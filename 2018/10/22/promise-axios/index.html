<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="biubiu的博客">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        promise/axios/async/await - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i>  </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <span>biubiu</span>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#axios-promise-async-await"><span class="toc-text">axios/promise/async/await</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#promise"><span class="toc-text">promise</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#axios"><span class="toc-text">axios</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#特点"><span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用"><span class="toc-text">使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#请求"><span class="toc-text">请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#传参"><span class="toc-text">传参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常用"><span class="toc-text">常用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拦截器"><span class="toc-text">拦截器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async-await"><span class="toc-text">async/await</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#语法"><span class="toc-text">语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#async-函数返回一个-Promise-对象"><span class="toc-text">async 函数返回一个 Promise 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#await"><span class="toc-text">await</span></a></li></ol></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i>  </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        promise/axios/async/await
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2018-10-22 17:36:10</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#vue" title="vue">vue</a>
        <span>/</span>
        
        <a class="tag" href="/tags/#javascript" title="javascript">javascript</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <h1 id="axios-promise-async-await"><a href="#axios-promise-async-await" class="headerlink" title="axios/promise/async/await"></a>axios/promise/async/await</h1><p>这里整理axios时，把牵扯到的基础promise学习了，更深一步的以后再深入。axios跨域的问题等之后再整理，这篇仅仅是一些简单的基础</p>
<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p>用法：可以将异步操作以同步操作的流程表达处理，避免层层嵌套回调函数<br>promise对象有三种状态，对象的状态不受外界影响</p>
<ul>
<li>pending 进行中</li>
<li>fulfilled 已成功</li>
<li>rejected 已失败</li>
</ul>
<p>并且一旦状态改变，就不会再变，任何时候都可以得到这个结果,这时称为resolved(已定型)。状态改变只有两种可能</p>
<ul>
<li>pending到fulfilled</li>
<li>pending到rejected</li>
</ul>
<p>Promise实例生成以后，then方法有2个参数，第一个函数接收resolved状态的执行，第二个参数接收reject状态的执行。且then的执行结果也会返回一个Promise对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// success,resolved时调用</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// failure rejected时调用</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p>基于promise用于浏览器和node.js的http客户端</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>支持浏览器和node.js</li>
<li>支持promise</li>
<li>能拦截请求和响应</li>
<li>能转换请求和响应数据</li>
<li>能取消请求</li>
<li>自动转换JSON数据</li>
<li>浏览器端支持防止CSRF(跨站请求伪造)</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import axios from &apos;axios&apos;;</span><br></pre></td></tr></table></figure>
<h4 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h4><p>get请求<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.get(url)</span><br><span class="line">.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">error</span>=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure></p>
<p>.then访问成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//打印的是object对象</span><br><span class="line">//data，status，statusText，headers，comfig</span><br><span class="line">XXXX.then(res=&gt;&#123;console.log(res)&#125;)</span><br><span class="line">//打印的是promise对象</span><br><span class="line">XXXX.then()</span><br></pre></td></tr></table></figure></p>
<p>.catch捕获错误</p>
<h4 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.get(url,&#123;params:&#123;&#125;&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h4><p>配置全局默认路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.baseURL =&apos;http://localhost:3000&apos;;</span><br></pre></td></tr></table></figure></p>
<h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>在请求或者返回被then或者catch处理之前对它们进行拦截<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 添加请求拦截器</span><br><span class="line">axios.interceptors.request.use(function (config) &#123;</span><br><span class="line">    // 在发送请求之前做些什么</span><br><span class="line">    return config;</span><br><span class="line">  &#125;, function (error) &#123;</span><br><span class="line">    // 对请求错误做些什么</span><br><span class="line">    return Promise.reject(error);</span><br><span class="line">  &#125;);</span><br><span class="line">// 添加响应拦截器</span><br><span class="line">axios.interceptors.response.use(function (response) &#123;</span><br><span class="line">    // 对响应数据做点什么</span><br><span class="line">    return response;</span><br><span class="line">  &#125;, function (error) &#123;</span><br><span class="line">    // 对响应错误做点什么</span><br><span class="line">    return Promise.reject(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>ES7 提出的async 函数，终于让 JavaScript 对于异步操作有了终极解决方案。<br>async作为一个关键字放到函数前面，表示函数是一个异步函数，异步函数也就意味着该函数的执行不会阻塞后面代码的执行。</p>
<ul>
<li>内置执行器。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，调用方式跟普通函数的调用一样</li>
<li>返回值是 Promise。async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用</li>
<li>写异步代码就像写同步代码一样了，不用不断的回调了。</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="async-函数返回一个-Promise-对象"><a href="#async-函数返回一个-Promise-对象" class="headerlink" title="async 函数返回一个 Promise 对象"></a>async 函数返回一个 Promise 对象</h3><p>async 函数内部 return 返回的值是个Promise 对象。当调用该函数时，内部会调用Promise.solve() 方法把它转化成一个promise 对象作为返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async function timeout() &#123;</span><br><span class="line">    return &apos;hello world&apos;</span><br><span class="line">&#125;</span><br><span class="line">console.log(timeout());</span><br><span class="line">console.log(&apos;虽然在后面，但是我先执行&apos;);</span><br><span class="line">//输出</span><br><span class="line">//Promise&#123;&#125;</span><br><span class="line">//虽然在后面，但是我先执行</span><br></pre></td></tr></table></figure></p>
<p>async 函数内部 return 返回的值。会成为 then 方法回调函数的参数。只有当 async 函数内部的异步操作都执行完，才会执行 then 方法的回调。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  async function timeout() &#123;</span><br><span class="line">    return &apos;hello world&apos;</span><br><span class="line">  &#125;</span><br><span class="line">  timeout().then(result =&gt; &#123;</span><br><span class="line">    console.log(result);</span><br><span class="line">  &#125;)</span><br><span class="line">  console.log(&apos;虽然在后面，但是我先执行&apos;);</span><br><span class="line">  //输出</span><br><span class="line">  //虽然在后面，但是我先执行</span><br><span class="line">  //hello world</span><br></pre></td></tr></table></figure></p>
<p>如果 async 函数内部抛出异常，则会导致返回的 Promise 对象状态变为 reject 状态。抛出的错误而会被 catch 方法回调函数接收到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async function e()&#123;</span><br><span class="line">    throw new Error(&apos;error&apos;);</span><br><span class="line">&#125;</span><br><span class="line">e().then(v =&gt; console.log(v))</span><br><span class="line">.catch( e =&gt; console.log(e));</span><br></pre></td></tr></table></figure></p>
<h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><p> await 后面放置的就是返回promise对象的一个表达式。await 表示等一下，先执行await后面的代码，等后面的promise对象执行完毕，再继续像下执行。</p>
<hr>
<p> 正常情况下，await 命令后面跟着的是 Promise，如果不是的话，也会被转换成一个 立即 resolve 的 Promise<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> async function  f() &#123;</span><br><span class="line">    return await 1</span><br><span class="line">&#125;;</span><br><span class="line">f().then( (v) =&gt; console.log(v)) // 1</span><br></pre></td></tr></table></figure></p>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>
    </div>
</div>
    </div>
</div>


<!--<footer class="footer">-->
    <!--<ul class="list-inline text-center">-->
        <!---->
        <!---->

        <!---->

        <!---->

        <!---->

        <!---->

    <!--</ul>-->
    <!---->
    <!--<p>-->
        <!--<span id="busuanzi_container_site_pv">-->
            <!--<span id="busuanzi_value_site_pv"></span>PV-->
        <!--</span>-->
        <!--<span id="busuanzi_container_site_uv">-->
            <!--<span id="busuanzi_value_site_uv"></span>UV-->
        <!--</span>-->
        <!--Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>-->
<!--</footer>-->




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.xml"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


</html>
