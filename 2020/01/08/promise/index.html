<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="biubiu的博客">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        Promise - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i>  </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <span>biubiu</span>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise"><span class="toc-text">Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#预备知识"><span class="toc-text">预备知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-函数对象与实例对象"><span class="toc-text">1.函数对象与实例对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-两种类型的回调函数"><span class="toc-text">2.两种类型的回调函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-error处理"><span class="toc-text">3.error处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise的理解和使用"><span class="toc-text">Promise的理解和使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async与await"><span class="toc-text">async与await</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-async-函数"><span class="toc-text">1.async 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-await-表达式"><span class="toc-text">2.await 表达式</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i>  </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Promise
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2020-01-08 17:36:10</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#学习笔记" title="学习笔记">学习笔记</a>
        <span>/</span>
        
        <a class="tag" href="/tags/#javascript" title="javascript">javascript</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        <p> 这里记录了学习promise的笔记，如果有更深刻的理解会不断更新。</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><h4 id="1-函数对象与实例对象"><a href="#1-函数对象与实例对象" class="headerlink" title="1.函数对象与实例对象"></a>1.函数对象与实例对象</h4><p>函数对象：将函数作为对象使用<br>实例对象：new函数产生的对象</p>
<blockquote>
<p>括号左边是函数，点左边是对象</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Fn</span></span>()&#123; //Fn函数</span><br><span class="line">&#125;</span><br><span class="line">const fn = new Fn() //这里的Fn是构造函数，fn是实例对象（new返回的，简称对象）</span><br><span class="line">Fn.prototype  //Fn本身是个函数，但是使用了XX.XXX(使用了.)，把该函数作为对象来使用，所以这里的Fn是函数对象</span><br></pre></td></tr></table></figure>
<h4 id="2-两种类型的回调函数"><a href="#2-两种类型的回调函数" class="headerlink" title="2.两种类型的回调函数"></a>2.两种类型的回调函数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*-----------同步回调函数--------------*/</span><br><span class="line">const arr = [1,3,5]</span><br><span class="line">arr.forEach(item =&gt;&#123;  //遍历回调，同步回调函数，一上来就执行，不会放入队列</span><br><span class="line"> console.log(item)</span><br><span class="line">&#125;)</span><br><span class="line">//forEach是一个函数，回调函数也是一个函数。说明该回调函数是同步回调函数，等完全执行完毕之后才执行最后一个打印语句</span><br><span class="line">console.log(<span class="string">"forEach()执行完毕之后"</span>)</span><br><span class="line">//输出</span><br><span class="line">//1，3，5 forEach()执行完毕之后</span><br><span class="line"></span><br><span class="line">/*-----------异步回调函数--------------*/</span><br><span class="line">setTimeout(()=&gt;&#123;//异步回调函数，会放入队列中将来执行</span><br><span class="line"> console.log(<span class="string">"timeout callback()"</span>)</span><br><span class="line">&#125;,0)</span><br><span class="line">console.log(<span class="string">"setTimeout()之后"</span>)</span><br><span class="line">//输出</span><br><span class="line">//setTimeout()之后 timeout callback()</span><br></pre></td></tr></table></figure>
<p><strong>同步回调</strong></p>
<p>理解：立即执行，完全执行完了才结束，不会放入回调队列中<br>例子：数组遍历相关的回调函数 /promise的excutor函数</p>
<p><strong>异步回调</strong></p>
<p>理解：不会立即执行，会放入回调队列中来执行<br>例子：定时器回调 /ajax回调 /promise的成功与失败的回调</p>
<h4 id="3-error处理"><a href="#3-error处理" class="headerlink" title="3.error处理"></a>3.error处理</h4><p><strong>错误类型</strong></p>
<p>Error:所有错误的父类型<br>子类型(常见的)：<br>ReferenceError: 引入错误，引用的变量不存在<br>TypeError: 数据类型不正确的错误<br>RangeError：数据值不在其所允许的范围内。<br>SyntaxError：语法错误</p>
<p><strong>错误处理</strong></p>
<p>若没有捕获error，后续的代码是不会执行的<br>捕获错误:try{}catch(error){}<br>抛出错误:throw error()</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//抛出错误，自己定义错误</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">something</span></span>()&#123;</span><br><span class="line"><span class="keyword">if</span>(Date.now()%2 ===1)&#123;</span><br><span class="line">  console.log(<span class="string">"当前时间为奇数,可以执行任务"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">//自己定义时间为偶数时为错误, 抛出的错误由调用来处理比如：打印，显示消息框等</span><br><span class="line">//  throw new Error(里面为传出的message) 固定格式</span><br><span class="line">  throw new Error(<span class="string">'当前时间为偶数，无法执行任务'</span>)</span><br><span class="line">&#125;</span><br><span class="line">try&#123;</span><br><span class="line">  something&#123;&#125;</span><br><span class="line">&#125; catch(error)&#123;</span><br><span class="line">//error下面两个属性message与stack</span><br><span class="line">console.log(error.message)//错误相关信息</span><br><span class="line">console.log(error.stack)//函数调用栈记录信息</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Promise的理解和使用"><a href="#Promise的理解和使用" class="headerlink" title="Promise的理解和使用"></a>Promise的理解和使用</h3><p>Promise是JS中进行异步编程的新的解决方案（旧的是纯回调的方式）<br>从语法来说：Promise是一个构造函数<br>从功能上说：Promise对象用来封装一个异步操作并可以获取其结果</p>
<p><strong>Promise的状态</strong></p>
<ol>
<li>pending变为resolved（成功）</li>
<li>pending变为rejected (失败)</li>
</ol>
<p>说明：只有这两种变化，且一个Promise对象只能改变一次。无论是成功还是失败，都会有一个结果数据。成功的结果数据一般称为value，失败的结果数据一般称为reason</p>
<p>   <img src="/img/软件超市/软件超市项目后台管理界面开发流程4.png" width="50%"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//1.创建一个新的promise对象,里面传一个回调函数</span><br><span class="line">const p = new Promise((resolve,reject)=&gt;&#123; //执行器函数 同步回调</span><br><span class="line">//2.执行异步操作</span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">const time = Date.now() //如果当前时间是偶数代表成功，否则代表失败</span><br><span class="line"><span class="keyword">if</span>(time%2 ==0)&#123;</span><br><span class="line">//3.1 如果成功了，调用resolve(value)</span><br><span class="line">  resolve(<span class="string">"成功的数据,time="</span>+time)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">//3.2 如果失败了，调用reject（reason）</span><br><span class="line"> reject(<span class="string">"成功的数据,time="</span>+time)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,1000);</span><br><span class="line">&#125;)</span><br><span class="line">p.then(</span><br><span class="line"> value =&gt;&#123;</span><br><span class="line"> //接收得到成功的value数据  onResolved</span><br><span class="line">   console.log(<span class="string">"成功的回调"</span>,value)</span><br><span class="line"> &#125;,</span><br><span class="line"> reason =&gt; &#123;</span><br><span class="line"> //接收得到失败的reason数据 onRejected</span><br><span class="line">    console.log(<span class="string">"失败的回调"</span>,reason)</span><br><span class="line"> &#125;</span><br><span class="line">)</span><br><span class="line">//输出 成功的回调 成功的数据,time=XXXX</span><br></pre></td></tr></table></figure>
<p><strong>优势</strong></p>
<ol>
<li><p>指令回调函数的方式更加灵活：旧的，必须在启动异步任务前指定;promise：启动异步任务 =&gt; 返回peomise对象 =&gt; 给promise对象绑定回调函数(甚至可以在异步执行之后才指定他的回调函数)</p>
</li>
<li><p>支持链式调用，可以解决回调地狱问题（回调函数嵌套调用，不便于阅读/不便于异常）。</p>
</li>
</ol>
<p>简便写法，Promise还有一些对象方法，这里就不进行记录了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">  resolve(1)</span><br><span class="line">&#125;)</span><br><span class="line">const p2 = Promise.reject(2)</span><br><span class="line">p2.catch(reason=&gt;&#123;console.log(reason)&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>几个关键问题</strong></p>
<p>1.如何改变promise的状态？<br>（1）resolve(value):如果当前是pending就会变为resolved<br>（2）reject（reason）：如果当前是pending就会变为rejected<br>（3）抛出异常：如果当前是pending就会被成rejected <code>throw new Error(&quot;出错了&quot;)</code> reason值是你抛出的东西</p>
<p>2.一个promise指定多个成功/失败的回调函数，都会调用吗？<br>当promise改变为对应状态时会调用</p>
<p>3.改变promise状态和指定回调函数谁先执行。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line"> setTimeout(()&gt;&#123;</span><br><span class="line">  resolve(1)//后改变的状态，同时指定数据，异步执行回调函数</span><br><span class="line"> &#125;,1000);</span><br><span class="line">&#125;).then(//先指定回调函数，保存当前指定的回调函数</span><br><span class="line">value=&gt;&#123;&#125;,reason=&gt;&#123;&#125;</span><br><span class="line">)</span><br><span class="line">/*---------先改状态后指定回调函数------------*/</span><br><span class="line">new Promise((resolve,reject)=&gt;&#123; //同步回调</span><br><span class="line">  resolve(1)//先改变的状态，同时指定数据</span><br><span class="line">);</span><br><span class="line">&#125;).then(//异步回调</span><br><span class="line">value=&gt;&#123;&#125;,reason=&gt;&#123;&#125;//后指定回调函数，异步执行回调函数</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>4.promise.then()返回的新的promise的结果状态由什么决定</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">  //1.resolve(1)</span><br><span class="line">  //2.reject(1)</span><br><span class="line">);</span><br><span class="line">&#125;).<span class="keyword">then</span>(</span><br><span class="line">value=&gt;&#123;</span><br><span class="line"> console.log(<span class="string">'onResolved1()'</span>,value)</span><br><span class="line"> //3.return 2</span><br><span class="line"> //4.return Promise.resolve(3)</span><br><span class="line"> //5.return Promise.reject(4)</span><br><span class="line"> //6 throw 5</span><br><span class="line">&#125;,reason=&gt;&#123;</span><br><span class="line"> console.log(<span class="string">'onRejected1()'</span>,reason)</span><br><span class="line">&#125;</span><br><span class="line">).<span class="keyword">then</span>(</span><br><span class="line">value=&gt;&#123;</span><br><span class="line"> console.log(<span class="string">'onResolved2()'</span>,value)</span><br><span class="line">&#125;,reason=&gt;&#123;</span><br><span class="line"> console.log(<span class="string">'onRejected2()'</span>,reason)</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">//1.输出onResolved1() 1 onResolved2() undefined</span><br><span class="line">//2.输出onRejected1() 1  onResolved2() undefined （ 其余情况结合1.3 1.4 1.5 1.6 ）</span><br><span class="line">//1.3 输出onResolved1() 1 onResolved2() 2</span><br><span class="line">//1.4 输出onResolved1() 1 onResolved2() 3</span><br><span class="line">//1.5 输出onResolved1() 1 onRejected2() 4</span><br><span class="line">//1.6 输出onResolved1() 1 onRejected2() 5</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>promise异常传透和中止</li>
</ol>
<p>当使用promise的then链式调用时，可以在最后指定失败的回调，因为没有处理异常相当于 <code>reason =&gt; {throw reason}</code>。会一层一层往下寻找异常处理（知道找到）。</p>
<p>当使用promise的then链式调用时，若想中断promise链，可一返回<code>new Promise(()=&gt;{})</code>返回一个处于pending的promise。</p>
<blockquote>
<p>自定义promise链接：<a href="https://github.com/biubiuins/promise-/tree/master" target="_blank" rel="noopener">https://github.com/biubiuins/promise-/tree/master</a></p>
</blockquote>
<h2 id="async与await"><a href="#async与await" class="headerlink" title="async与await"></a>async与await</h2><h3 id="1-async-函数"><a href="#1-async-函数" class="headerlink" title="1.async 函数"></a>1.async 函数</h3><p>async是’异步’的简写，用于申明这个函数是异步的。<br>函数的返回值为Promise对象，promise对象的结果由async函数执行的返回值决定。</p>
<h3 id="2-await-表达式"><a href="#2-await-表达式" class="headerlink" title="2.await 表达式"></a>2.await 表达式</h3><p>await相当于then的语法糖。<br>当await后面的表达式为promise，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，得到的结果就是promise成功的value。如果右侧表达不是promise，得到的结果就是它本身。</p>
<p><strong>注意：</strong></p>
<ul>
<li>await必须放在async函数里面</li>
<li>await只能得到成功的结果，失败的结果需用try-catch</li>
<li>try catch只能捕获同步代码，不能捕获异步代码，在async函数内，使用await可以捕获异步代码，这里实际上是异步代码变成了同步代码。</li>
</ul>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>
    </div>
</div>
    </div>
</div>


<!--<footer class="footer">-->
    <!--<ul class="list-inline text-center">-->
        <!---->
        <!---->

        <!---->

        <!---->

        <!---->

        <!---->

    <!--</ul>-->
    <!---->
    <!--<p>-->
        <!--<span id="busuanzi_container_site_pv">-->
            <!--<span id="busuanzi_value_site_pv"></span>PV-->
        <!--</span>-->
        <!--<span id="busuanzi_container_site_uv">-->
            <!--<span id="busuanzi_value_site_uv"></span>UV-->
        <!--</span>-->
        <!--Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>-->
<!--</footer>-->




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.xml"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


</html>
