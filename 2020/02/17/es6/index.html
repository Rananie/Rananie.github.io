<!DOCTYPE html>
<html>
  
<head>
  <meta charset="utf-8">
  <meta name="author" content="Ranan" />
  
  
  <title>es5/es6/es7 | Ranan的博客</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="学习笔记,Javascript," />
  

  
  <meta name="description" content="Ranan的博客">

  

  

  

  

  

  <script>
  // theme-ad's config script
  // it can be used in every script
  
  window.AD_CONFIG = {
    leancloud: {"appid":"Hyq9wkH495DgNHWhDQCOfQSp-gzGzoHsz","appkey":"WaR7nrzhliHj9aVwdQzkdlGd","comment":false,"count":false},
    welcome: {"enable":false,"interval":30},
    start_time: "2018-02-10",
    passwords: ["efe07af7441da2b69c4a41e42e73be4db47f66010a56900788a458354a7373ec", ],
    is_post: true,
    lock: false,
    author: "Ranan",
    share: {"twitter":false,"facebook":false,"weibo":false,"qq":false,"wechat":false},
    mathjax: false,
    page_type: "",
    root: "/"
  };
</script>

  <script src="/vendor/sha256.min.js"></script>
<script src="/js/auth.js"></script>
<script src="/js/index.js"></script>
<script src="/vendor/qrcode.min.js"></script>

  
    <link rel="icon" href="/images/favicon.ico">
    <link rel="apple-touch-icon" href="/images/touch-icon.png">
  

  <link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="stylesheet" href="/css/index.css">
<link rel="stylesheet" href="/styles/components/highlight/highlight.css">

  
</head>
  <body>
    <header class="site-header">
  <div class="site-header-brand">
    
      <span class="site-header-brand-title">
        <a href="/">Ranan</a>
      </span>
    
    
      <span class="site-header-brand-motto"> | 不能放弃思考</span>
    
  </div>
  <div class="site-header-right">
    <nav class="site-header-navigation">
      
        <a href="/" target="_self">首页</a>
      
        <a href="/archives/" target="_self">归档</a>
      
        <a href="/tags/" target="_self">标签</a>
      
        <a href="/categories/" target="_self">分类</a>
      
        <a href="/about/" target="_self">关于</a>
      
    </nav>
    <div class="site-header-btn">
      
        <a href="https://biubiuins.github.io/" target="_blank" id="site-github">
          <i class="fa fa-github-alt"></i>
        </a>
      
      <a href="javascript:void(0);" id="site-search">
        <i class="fa fa-search"></i>
      </a>
      <a href="javascript:void(0);" id="site-nav-btn">
        <i class="fa fa-ellipsis-v"></i>
      </a>
    </div>
  </div>
</header>
<nav class="table-content" id="site-nav">
  <div class="table-content-title">
    <span>导航</span>
  </div>
  <div class="table-content-main">
    <ol class="toc">
      
        <li class="toc-item">
          <a href="/" target="_self">
            首页
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/archives/" target="_self">
            归档
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/tags/" target="_self">
            标签
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/categories/" target="_self">
            分类
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/about/" target="_self">
            关于
          </a>
        </li>
      
    </ol>
  </div>
</nav>
<div id="site-process"></div>
    <main>
      
  <div class="passage">
  <div class="passage-meta">
    <span>
      <i class="fa fa-calendar"></i>2020-02-17
    </span>
    
      <span>
        | <a href="/categories/学习笔记/"><i class="fa fa-bookmark"></i>学习笔记</a>
      </span>
    
    
      <span>
        | <i class="fa fa-unlock-alt"></i>UNLOCK
      </span>
    
  </div>
  <h1 class="passage-title">
    es5/es6/es7
  </h1>
  
  <article class="passage-article">
    <h2 id="let-const"><a href="#let-const" class="headerlink" title="let/const"></a>let/const</h2><p>特点:</p>
<ul>
<li>不能重复定义</li>
<li>在块级作用域内有效</li>
<li>不会预处理，不存在变量提升</li>
<li>const不可以被修改，声明时必须赋值</li>
</ul>
<p>预处理：声明<code>var</code>后的变量但并不赋值(undefined)，声明<code>function</code>。因此使用let/const定义的变量在没声明前是无法使用的。</p>
<p>在循环使用中常用。如下述代码，结果会全部输出2，原因是：点击事件是回调函数进入队列，等同步执行的代码执行完毕之后，再执行。以前常用的解决办法是使用闭包。es6中的let也可以解决这个问题，因为let有自己的块级作用域，使用i值的时候，仅当次循环有用。</p>
<pre><code>//html
  &lt;button&gt;测试1&lt;/button&gt;
  &lt;button&gt;测试2&lt;/button&gt;
  &lt;button&gt;测试3&lt;/button&gt;
//js
   let btns = document.getElementsByTagName(&quot;button&quot;);
   for (var i = 0;i&lt;btns.length;i++) {
   var btn = btns[i];
    btn.onclick =function () {
      alert(i)
        }
      }
//js 闭包解决办法
    let btns = document.getElementsByTagName(&quot;button&quot;);
     for (var i = 0;i&lt;btns.length;i++) {
     var btn = btns[i];
     (function (i) {
      btn.onclick =function () {
      alert(i)
        }
       })(i)
       }
</code></pre><p>还有一点是let/const不属于顶层全局变量，不用担心污染全局的window对象。</p>
<pre><code>let a = 0
console.log(window.a)//undefined
var b = 1
console.log(window.b)//1
</code></pre><h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><p>理解：从对象或数组中提取数据，并赋值给变量(多个)。<br>常用：对象的解构赋值。(后台返回的数据进行利用)</p>
<p>例：交换对象,解构的目标是数组，所以以数组的形式来接收。</p>
<pre><code>let a = 1
let b = 2
[a,b] = [b,a]
//a=2 , b =1
</code></pre><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>作用：简化字符串的拼接<br>使用：模板字符串必须用<code></code>包含，变化的部分使用${xxx}定义</p>
<h2 id="对象属性-方法简写"><a href="#对象属性-方法简写" class="headerlink" title="对象属性/方法简写"></a>对象属性/方法简写</h2><p>对象属性简写：当对象的属性和值相同时，省略属性名</p>
<p>注意点：</p>
<ul>
<li>省略的是属性名而不是值</li>
<li>必须是一个变量</li>
</ul>
<p>方法的简写：当对象的属性值是一个函数(即是一个方法)，可以使用简写形式。</p>
<pre><code>//es5
let obj ={
 func:function(){}
 }
}

//es6
let obj2={
 func(){}  //不太常用
 func:()=&gt;{} //常用箭头函数
}

</code></pre><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>用处：常用在回调函数</p>
<pre><code>let a = ()=&gt;{ ... }
</code></pre><p>形参</p>
<ul>
<li>只有一个形参的时候，()可以省略</li>
<li>其余时候，()不能省略</li>
</ul>
<p>函数体</p>
<ul>
<li>函数体内只有一条语句或者表达式，{}可省略，省略后自动return</li>
<li>其余情况不可以省略，并且需要返回值时，需要加上return</li>
</ul>
<p>注意：由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</p>
<pre><code>//报错
let getTempItem = id =&gt; { id, name: &quot;Temp&quot; };
// 不报错
let getTempItem = id =&gt; ({ id, name: &quot;Temp&quot; });
</code></pre><p>特点：</p>
<ul>
<li>箭头函数没有arguments，但是如果在箭头函数需要参数时，可以使用rest运算符来取代arguments</li>
<li>箭头函数没有prototype属性，不能用作构造函数（不能用new关键字调用）</li>
<li><p>箭头函数没有自己的this，箭头函数的this，不是调用的时候决定的(一般函数是由调用时决定)，而是在定义的时候所处在的对象就是他的this</p>
<pre><code> let obj = {
 name:箭头函数
 getName(){
 btn2.onclick = ()=&gt;{
 console.log(this)
 }
 }
 }
 obj.getName()

 //输出obj

    let obj = {
    name:箭头函数
    getName:()=&gt;{
    btn2.onclick = ()=&gt;{
    console.log(this)
    }
    }
    }
    obj.getName()
 //输出window
</code></pre></li>
</ul>
<p><strong>理解</strong></p>
<ul>
<li>如果箭头函数外面有函数，则箭头函数的this同外层函数的this一样。</li>
<li>若外层没有函数，指向window。</li>
</ul>
<p>因此，箭头函数替代了以前需要显式的声明一个变量保存this的操作，使得代码更加的简洁。<br>还有一个好处在数组的迭代中使用箭头函数更加简洁，并且省略了return关键字。</p>
<pre><code>let arr = [1,2,3]
arr.filter (item=&gt; item === 2)//[2]
arr.map(item =&gt; item*2 ) //[2,4,6]
arr.reduce((acc,cur) = acc+cur) //6
</code></pre><p>注意:不要在可能改变this指向的函数中使用箭头函数，类似Vue中的methods,computed中的方法,生命周期函数，Vue将这些函数的this绑定了当前组件的vm实例，如果使用箭头函数会强行改变this，因为箭头函数优先级最高（无法再使用call,apply,bind改变指向）</p>
<h2 id="三点运算符"><a href="#三点运算符" class="headerlink" title="三点运算符"></a>三点运算符</h2><p><code>...</code></p>
<p>剩余运算符：用来代替arguments，但比arguments灵活。</p>
<p>补充:arguments.callee()方法的意思是：调用函数本身。</p>
<pre><code>function foo(...value){ //收集传过来的2，65两个元素
console.log(value)//输出[2,65]是一个真数组
}
function foo(value){
console.log(arguments)//2,65是一个伪数组
}
foo(2,65)
</code></pre><p>扩展运算符：只要含有iterator接口的数据结构都可以使用扩展运算符</p>
<blockquote>
<p>   扩展运算符可以和数组的解构赋值一起使用，但是必须放在最后一个，因为剩余/扩展运算符的原理其实是利用了数组的迭代器，它会消耗3个点后面的数组的所有迭代器，读取所有迭代器生成对象的value属性，剩余/扩展运算符后不能在有解构赋值，因为剩余/扩展运算符已经消耗了所有迭代器，而数组的解构赋值也是消耗迭代器，但是这个时候已经没有迭代器了，所以会报错</p>
</blockquote>
<pre><code>let [first,...arr]=[1,2,3,4,5]//不会报错
let[...arr,last] = [1,2,3,4,5] //报错
</code></pre><p><strong>剩余运算符和扩展运算符的区别就是，剩余运算符会收集这些集合，放到右边的数组中，扩展运算符是将右边的数组拆分成元素的集合，它们是相反的</strong></p>
<h2 id="形参默认值"><a href="#形参默认值" class="headerlink" title="形参默认值"></a>形参默认值</h2><p>在定义函数时可以定义形参的默认值，当不传入参数的时候默认使用形参里的默认值</p>
<pre><code>//定义形参默认值
    function add(a=0,b=1) {
        return a+b
    }
    console.log(add());
    //输出1
</code></pre><h2 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h2><p>Promise是JS中进行异步编程的新的解决方案，之前是纯回调的方法。</p>
<p>回调函数的一些缺点:<br>1.多重嵌套，导致回调地狱<br>    Promise引入了链式调用的概念，每个then方法同样也是一个promise，所以可以链式调用下去。其次将异步操作以同步的流程表达出来，更方便阅读。<br>2.不清楚回调是否都是异步调用的（可以同步调用ajax，在收到响应前会阻塞整个线程，会陷入假死状态，非常不推荐）<br>3.第三方库可能没有提供错误处理<br>    Promise在异步请求发送错误的时候，即使没有捕获错误，也不会阻塞主线程的代码</p>
<p>更深入的内容，在之前的博客中<a href="https://biubiuins.github.io/2020/01/08/promise/" target="_blank" rel="noopener">Promise学习笔记</a></p>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>Symbol是ES6中添加的新的数据类型(原来的有：String，Number,Boolean,Object,Null(空对象指针),Undefined(声明的变量未被初始化时))</p>
<p>特点:</p>
<ul>
<li>Symbol属性对应的值是唯一的，解决命名冲突问题。(类似id)</li>
<li>Symbol值不能与其他数据进行计算，包括同字符串拼接</li>
<li>for in/for of遍历时不会遍历symbol属性</li>
</ul>
<pre><code>//创建Symbol属性值
let symbol = Symbol();
//let symbol = Symbol(&#39;传一个标识&#39;);
console.log(symbol) //输出Symbol
//Symbol(&#39;传一个标识&#39;)
let obj ={
name:&quot;ko&quot;,age:48
}
obj[symbol]=&quot;男&quot;
</code></pre><p>1.当symbol作为对象的属性时，用XX[Symbol]形式，不用XX.Symbol形式。<br>2.可以定义常量<br>3.除了自己定义使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部的使用方法。比如<code>Symbol.iterator</code>属性</p>
<h2 id="iterator迭代器"><a href="#iterator迭代器" class="headerlink" title="iterator迭代器"></a>iterator迭代器</h2><p>概念:iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制。iterator接口是解构赋值，三点运算符，生成器，<code>for-of</code>循环的基础，主要供<code>for-of</code>消费。</p>
<p>工作原理:<br>1.创建一个指针对象(遍历器对、iterator迭代器)，指向数据结构的起始位置。<br>2.第一次调用next方法，指针自动指向数据结构的第一个成员<br>3.接下来不断调用next方法，直到指向最后一个成员</p>
<p>注意：每次调用next方法返回的是一个包含value和done的对象{value:当前成员的值，done：布尔值}其中done对用的布尔值表示当前的数据的结构是否遍历结束。当遍历结束的时候返回的value值是undefined，done值为true</p>
<ul>
<li>可迭代的数据结构会有一个[Symbol.iterator]方法,</li>
<li>[Symbol.iterator]执行后返回一个iterator对象</li>
</ul>
<p>默认具有iterator接口的数据结构有以下几个，注意普通对象默认是没有iterator接口的（可以自己创建iterator接口让普通对象也可以迭代）</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray（类数组）</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象</li>
</ul>
<p>自定义部署iterator接口</p>
<pre><code>let targetData = {
 [Symbol.iterator]:function(){
 let nextIndex = 0 //记录指针的位置
 return{//遍历器对象
 next:function(){
 return nextIndex &lt; this.length?{value:this[nextIndex++],done:false}:{value:undefined,done:true}}
 }
 }
 }
}
</code></pre><h3 id="for-of"><a href="#for-of" class="headerlink" title="for..of"></a>for..of</h3><p>以前我们遍历数组中的元素的时，最开始使用的是for</p>
<pre><code>let arr = [1,2,3]
for(let i = 0;i&lt;arr.length;i++){
console.log(arr[i])
//输出1，2，3
}
</code></pre><p>自ES5之后，可以使用<code>forEach</code></p>
<pre><code>arr.forEach(function (value) {
    console.log(value);
    //输出1，2，3
});
</code></pre><p>但是<code>foeEach</code>有两个缺点：<br>1.不能使用<code>break</code>语句中断循环<br>2.不能使用<code>return</code>语句返回到外层函数</p>
<p>ES6增加了<code>for-of</code>循坏，是现在简洁、最直接的遍历数组元素的语法。<code>for-in</code>不仅仅可以遍历数组，<strong>具有iterator接口的，都可以使用<code>for-of</code>进行遍历</strong></p>
<pre><code>for (var value of arr) {
      console.log(value); // 1,2,3
}
</code></pre><p>与<code>for-in</code>的区别：<br>1.for-in 获取的是对象的键名<br>2.for-in会遍历对象的整个原型链,性能非常差不推荐使用,</p>
<h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><p>概念：ES6提供的解决异步编程的方案之一。</p>
<p>特点：<br>1.<code>function函数名*</code><br>2.内部用yield表达式来定义不同的状态<br>3.其返回值是一个Iterator迭代器（指针对象）</p>
<p>比如某个事物只有三种状态（状态A，状态B，状态C），而这三种状态的变化是 状态A =&gt; 状态B =&gt; 状态C =&gt; 状态A ，这就是状态机。Generator特别适用于处理这种状态机。</p>
<pre><code class="bash">// A，B，C三种状态循环
function* state(){
    while(1){
        yield &#39;A&#39;;
        yield &#39;B&#39;;
        yield &#39;C&#39;;
    }
}
let status = state();//返回的是指针对象
//碰到yield返回
console.log(status.next()); // 先暂停到A，后面的代码不执行，返回{value: &quot;A&quot;, done: false}
console.log(status.next()); // 执行下一条指令，暂停到B，返回{value: &quot;B&quot;, done: false}
console.log(status.next()); // {value: &quot;C&quot;, done: false}
console.log(status.next()); // {value: &quot;A&quot;, done: false}
console.log(status.next()); // {value: &quot;B&quot;, done: false}
</code></pre>
<p>Iterator迭代器遍历结束时，返回的是：{value: undefined, done: true},Generator函数可以使用return来改变最后的返回值</p>
<p>next传的参数可以作为启动yield(默认返回undefined)的返回值</p>
<pre><code>function* state{
let result = yield &#39;hello&#39;
console.log(result)//输出aaa
}
state.next(&quot;aaa&quot;)
</code></pre><h2 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h2><p>本质:Generator语法糖，async取代Generator函数的星号*.await取代的是yield</p>
<p>ES7的async/await进一步的优化Promise的写法，async函数始终返回一个Promise，await可以实现一个”等待”的功能，async/await被称为异步编程的终极解决方案，即用同步的形式书写异步代码，并且能够更优雅的实现异步代码顺序执行。</p>
<p>补充一种更高级的写法。</p>
<pre><code>new Promise(resolve=&gt;{
   setTimeout(()=&gt;{
   resolve() //第一个参数为函数，目的在与执行resolve
   },2000)

   //更高级的写法
   setTimeout(resolve,2000)
})
</code></pre><p>更深入的内容，在之前的博客中<a href="https://biubiuins.github.io/2020/01/08/promise/" target="_blank" rel="noopener">Promise学习笔记</a></p>
<h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><pre><code>//定义一个人物的类
class Person{
//类的构造方法
 constructor(){}
}
</code></pre><p><strong>注意</strong>类里面的方法，用es6简写形式不加<code>function</code></p>
<pre><code>console.log(typeof Person);//function
console.log(Person===Person.prototype.constructor);//true
</code></pre><p>从上面的代码可以看出类实质上就是一个函数，可以任务ES6的类就是构造函数的另外一种写法。<br>实际上类的所有方法都定义在类的prototype属性上。<br>constructor内的属性可以称为实例属性（和前面说的实例成员一样）,constructor外声明的属性都是定义在原型上的，可以称为原型属性（即定义在class上)</p>
<p><strong>注意</strong>  <code>class</code>不存在变量提升，所以需要先定义再使用</p>
<h3 id="extends继承"><a href="#extends继承" class="headerlink" title="extends继承"></a>extends继承</h3><p>ES5的继承</p>
<pre><code>//父构造函数 this指向父构造函数的对象实例
function Father(name,age){
    this.name = name;
    this.age = age;
}
Father.prototype.money= ()=&gt;{
    console.log(&#39;父亲要上班&#39;);
}
//子构造函数 this指向子构造函数的对象实例
function  Son(name,age) {
  //把指向父构造函数的对象实例的this改变成指向子构造函数的对象实例的this
    Father.call(this,name,age)
}
//让Son的原型对象指向Father的实例对象，那么就可以访问到Father实例对象上的方法
//这个new Father()是一个原型对象，相当于{}，这样写会覆盖掉Son的原型对象的constructor
Son.prototype = new Father();
//所以还需要constructor指回原来的构造函数
Son.prototype.constructor = Son
</code></pre><p>ES6的extends继承</p>
<pre><code>class Son extends Father{
constructor(name,age){//继承时注意写参数
  super(name,age)// 调用父类的构造方法，这里也要注意参数
}
}
</code></pre><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>不同于普通在类中定义的会被实例继承的方法。在方法前加上static关键字。就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。（静态属性差不多的意思）</p>
<pre><code>class  {
  static classMethod() {
    return &#39;hello&#39;;
  }
}
//Foo.classMethod()使用
</code></pre><h2 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h2><h3 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><h4 id="String-includes-str"><a href="#String-includes-str" class="headerlink" title="String.includes(str)"></a>String.includes(str)</h4><p>判断是否包含指定的字符串<br>返回值：包含true,不包含false</p>
<h4 id="String-startsWith-str"><a href="#String-startsWith-str" class="headerlink" title="String.startsWith(str)"></a>String.startsWith(str)</h4><p>判断是否以指定字符串开头<br>返回值：是true,否false</p>
<h4 id="String-endsWith-str"><a href="#String-endsWith-str" class="headerlink" title="String.endsWith(str)"></a>String.endsWith(str)</h4><p>判断是否以指定字符串结尾<br>返回值：是true,否false</p>
<h4 id="String-repeat-count"><a href="#String-repeat-count" class="headerlink" title="String.repeat(count)"></a>String.repeat(count)</h4><p>指定目标字符串重复的次数<br>返回值:重复后的字符串</p>
<h3 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h3><h4 id="进制表示法"><a href="#进制表示法" class="headerlink" title="进制表示法"></a>进制表示法</h4><p>二进制用0b，八进制用0o</p>
<pre><code>console.log(0b1010);//输出10
</code></pre><h4 id="Number-isFinite-i"><a href="#Number-isFinite-i" class="headerlink" title="Number.isFinite(i)"></a>Number.isFinite(i)</h4><p>判断i是否有限大的数<br>返回值：是true,否false</p>
<pre><code>Number.isFinite(Infinity)//false
</code></pre><h4 id="Number-isNaN-i"><a href="#Number-isNaN-i" class="headerlink" title="Number.isNaN(i)"></a>Number.isNaN(i)</h4><p>判断i是否NaN<br>返回值：是true,否false</p>
<h4 id="Number-isInteger-i"><a href="#Number-isInteger-i" class="headerlink" title="Number.isInteger(i)"></a>Number.isInteger(i)</h4><p>判断i是否整数<br>返回值：是true,否false</p>
<pre><code>Number.isInteger(120.0)//true
</code></pre><h4 id="Number-parseInt-str"><a href="#Number-parseInt-str" class="headerlink" title="Number.parseInt(str)"></a>Number.parseInt(str)</h4><p>将字符串转换为对应的数值<br>返回值：对应的数值</p>
<h4 id="Math-trunc-i"><a href="#Math-trunc-i" class="headerlink" title="Math.trunc(i)"></a>Math.trunc(i)</h4><p>直接i的去除小数部分<br>返回值:整数部分</p>
<h3 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h3><h4 id="Array-from-v"><a href="#Array-from-v" class="headerlink" title="Array.from(v)"></a>Array.from(v)</h4><p>把v的伪数组(字符串也可)转换为真数组<br>类数组(伪数组)最基本的要求就是具有length属性的对象,该类数组对象的属性名必须为数值型或字符串型的数字。</p>
<pre><code>let arrayLike = {
    0: &#39;tom&#39;,
    1: &#39;65&#39;,
    2: &#39;男&#39;,
    3: [&#39;jane&#39;,&#39;john&#39;,&#39;Mary&#39;],
    &#39;length&#39;: 4
}
let arr = Array.from(arrayLike)
console.log(arr) // [&#39;tom&#39;,&#39;65&#39;,&#39;男&#39;,[&#39;jane&#39;,&#39;john&#39;,&#39;Mary&#39;]]
</code></pre><p>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。如下：</p>
<pre><code>  let arr = [1,2,2,2,3,4,5]
    let set = new Set(arr)
    console.log(Array.from(set, item =&gt; item + 1)) // [2,3,4,5,6]
</code></pre><h4 id="Array-of-v1-v2-v3"><a href="#Array-of-v1-v2-v3" class="headerlink" title="Array.of(v1,v2,v3)"></a>Array.of(v1,v2,v3)</h4><p>将v1，v2..等元素转换成数组</p>
<h4 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h4><p>找到第一个满足条件返回true的元素</p>
<pre><code>let arr = [2,4,6]
console.log(arr.find((value, index) =&gt; value &gt; 4));
//输出6
</code></pre><h4 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex()"></a>findIndex()</h4><p>找到第一个满足条件返回true的元素下标</p>
<pre><code>let arr = [2,4,6]
console.log(arr.findIndex((value, index) =&gt; value &gt; 4));
//输出2
</code></pre><h3 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h3><p><a href="9https://biubiuins.github.io/2020/02/19/%E6%8B%B7%E8%B4%9D/" target="_blank" rel="noopener">笔记</a></p>
<h3 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h3><p><strong><strong>proto</strong>隐式原型可直接操作</strong></p>
<pre><code>    let obj3={
    }
    let obj4 = {name:&quot;xx&quot;}
    obj3.__proto__ = obj4
</code></pre><h4 id="Object-is-v1-v2"><a href="#Object-is-v1-v2" class="headerlink" title="Object.is(v1,v2)"></a>Object.is(v1,v2)</h4><p>判断对象v1与v2是否完全相等。</p>
<pre><code>console.log(0 === -0)  //true
console.log(NaN == NaN)//false NaN与任何数都不相等
console.log(Object.is(0,-0)) //false
console.log(Object.is(NaN,NaN))//true
</code></pre><p>由上面代码可知该方式是以字符串是否相等来判断的</p>
<h4 id="Object-assign-target-source1-source2"><a href="#Object-assign-target-source1-source2" class="headerlink" title="Object.assign(target,source1,source2..)"></a>Object.assign(target,source1,source2..)</h4><p>这个Object静态方法允许我们进行多个对象的合并，遍历需要合并给target的对象（仅可枚举属性），用等号进行赋值(这里可能有深浅拷贝的问题)</p>
<p><strong>注意</strong>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>
<pre><code>const target = { a: 1, b: 1 };
const source1 = { b: 2, c: 2 };
const source2 = { c: 3 };
Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}
</code></pre><p><strong>常见用途</strong></p>
<p>1.<a href="https://biubiuins.github.io/2020/02/19/%E6%8B%B7%E8%B4%9D/" target="_blank" rel="noopener">关于拷贝的用法</a><br>2.为属性指定默认值</p>
<pre><code>```
const DEFAULTS = {
  logLevel: 0,
  outputFormat: &#39;html&#39;
};
//options对象是用户提供的参数。
function processContent(options) {
  options = Object.assign({}, DEFAULTS, options);
  console.log(options);
  // ...
}
```
</code></pre><h2 id="Set-Map容器"><a href="#Set-Map容器" class="headerlink" title="Set/Map容器"></a>Set/Map容器</h2><p>Set容器：无序不可重复的多个value的集合体</p>
<ul>
<li>new Set(array)创建方法</li>
<li>add(value)添加方法</li>
<li>delete(value)删除方法</li>
<li>has(value)判断是否存在方法</li>
<li>clear()清空方法</li>
</ul>
<pre><code>let set = new Set([1,3,2,2])
console.log(set);//输出唯一出现的值

//add(value)添加方法
set.add(7)
console.log(set.size,set)//set.size相当于数组的length。

</code></pre><p>遍历：可以使用Set实例对象的keys()，values()，entries()方法进行遍历。<br>由于Set的键名和键值是同一个值，它的每一个元素的key和value是相同的，所有keys()和values()的返回值是相同的，entries()返回的元素中的key和value是相同的。</p>
<pre><code>  let set = new Set([4, 5, &#39;hello&#39;])
    for(let item of set.keys()) {
        console.log(item) //输出4，5，hello
    }

    for(let item of set.values()) {
        console.log(item) // 输出4，5，hello
    }

    for(let item of set.entries()) {
        console.log(item) //[4,4],[5,5],[&#39;hello&#39;,&#39;hello&#39;]
    }
</code></pre><p><strong>数组去重(常用)</strong></p>
<pre><code>let array = [0,1,1,2,2,5,5,66,99,65,65];
console.log(Array.from(new Set(array))); //Array(7) [0, 1, 2, 5, 66, 99, 65]
console.log([...new Set(array)]); //Array(7) [0, 1, 2, 5, 66, 99, 65]
</code></pre><p>Map容器:Map是一组键值对(key-value，只取前两个元素。)的结构,key不重复</p>
<pre><code>let a = new Map([[&#39;Michael&#39;, 95],[&quot;Bot&quot;,99]]
m.set(&#39;Adam&#39;, 67); //添加新的key-value
m.has(&#39;Adam&#39;);//是否存在key&quot;Adam&quot;  true
m.get(&#39;Adam&#39;); //获得key为Adam的value  67
m.delete(&#39;Adam&#39;);//删除key&quot;Adam&quot;
m.clear() //清空Map容器
</code></pre><p>一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉。</p>
<h2 id="ES7-16年发布"><a href="#ES7-16年发布" class="headerlink" title="ES7(16年发布)"></a>ES7(16年发布)</h2><h3 id="指数运算符-幂"><a href="#指数运算符-幂" class="headerlink" title="指数运算符(幂)**"></a>指数运算符(幂)**</h3><pre><code>  console.log(3 ** 3);
  //3的3次方=27
</code></pre><h3 id="Array-prototype-includes-value"><a href="#Array-prototype-includes-value" class="headerlink" title="Array.prototype.includes(value)"></a>Array.prototype.includes(value)</h3><p>字符串与数组都有includes方法，判断数组中是否包含指定的value</p>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>Proxy也就是在目标对象之前设置一层拦截，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p>
<p>Proxy的作用</p>
<ul>
<li>拦截和监视外部对对象的访问</li>
<li>降低函数或类的复杂度</li>
<li>在复杂操作前对操作进行校验或对所需资源进行管理</li>
</ul>
<p>语法：new Proxy(target,handler)</p>
<ul>
<li>target就是被设置一层拦截的对象，可以是任何类型的对象(包括原生数组，函数，甚至另一个代理)</li>
<li>handler是一个对象，用来定制拦截行为</li>
</ul>
<p><strong>Proxy一般和Reflect配套使用,前者拦截对象,后者返回拦截的结果,Proxy上有的的拦截方法Reflect都有</strong></p>
<p><img src="/img/js/Proxy.png" width="50%"></p>
<p>1.set/get方法</p>
<p>set方法接收两个常用参数</p>
<ul>
<li>target：得到的目标值</li>
<li>key：目标的key值，相当于对象的属性</li>
</ul>
<p>set方法可以接收四个参数</p>
<ul>
<li>target:目标值。</li>
<li>key：目标的Key值。</li>
<li>value：要改变的值。</li>
<li>receiver：改变前的原始值。</li>
</ul>
<pre><code>
    let handler = {
        get:function (target,key) {
            if (target.hasOwnProperty(key)){
                return target[key]//key为属性名，target[key]为属性值
            }
            else{
                console.warn(`对不起，没有这个${key}`)
                return
            }
        },
        set:function (target,key,value) {
            console.log(&quot;set&quot;,target,key,value);
            target[key] =value //设置了p.a才打印1
        },
        //删除属性
        deleteProperty:function (target,key) {
            console.log(`删除${key}属性的${target[key]}值`);
            delete target[key]
        },
        // 拦截key in object操作
        has(target, key) {
            // 自定义限制：只暴露a属性
            if (key === &#39;a&#39;) {
                return target[key];
            } else {
                return false;
            }
        },

    }
    let p = new Proxy({},handler)
    p.a=1 //set {} a 1
    p.b=2
    console.log(&#39;b&#39; in p); // false,没有暴露
    console.log(&#39;a&#39; in p); //true
    //console.log(p.a);
    //delete p.b //删除了b属性的2值
    //console.log(p.b); //undefined
</code></pre><p>可以使用Proxy实现表单验证。</p>
<p>Object.defineProperty也可以实现数据拦截，Proxy有什么优势吗？<br>1.支持数组<br>数组的key是下标，对象的key是属性名</p>
<pre><code>    let arr = [1,2,3]
    let proxy = new Proxy(arr, {
        get (target, key, receiver) {
            console.log(&#39;get&#39;, key)
            return Reflect.get(target, key, receiver)
        },
        set (target, key, value, receiver) {
            console.log(&#39;set&#39;, key, value)
            return Reflect.set(target, key, value, receiver)
        }
    })
    proxy.push(4)
    // get push     (寻找 proxy.push 方法)
    // get length   (获取当前的 length)
    // set 3 4      (设置 proxy[3] = 4)
    // set length 4 (设置 proxy.length = 4)
</code></pre><p>2.Object.defineProperty()的升级版</p>
<p>外界对某个对象的访问，都必须经过这层拦截。因此它是针对整个对象，而不是对象的某个属性。</p>
<h2 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h2><h3 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h3><ul>
<li>JSON.stringify(obj/arr):js对象(数组)转换为json对象</li>
<li>JSON.parse(json):json对象(数组)转换为js对象(数组)</li>
</ul>
<h3 id="Object扩展"><a href="#Object扩展" class="headerlink" title="Object扩展"></a>Object扩展</h3><h4 id="Object-create-prototype-descriptors"><a href="#Object-create-prototype-descriptors" class="headerlink" title="Object.create(prototype,[descriptors])"></a>Object.create(prototype,[descriptors])</h4><p>作用：以指定对象为原型创建新的对象。为新的对象指定新的属性，并对属性进行描述</p>
<pre><code>let obj = {name:&quot;ranan&quot;,age:2}
//第一个参数指定原型，第二参数为实列添加属性
let obj1 = Object.create(obj,{sex:{
    value:&quot;女&quot;,//value指定值
    writable:true,//标识当前属性是否可以被删除，默认为false
    configurable:true,//表示当前属性是否可以被删除，默认为false
    enumerable:true,//标识当前属性是否能用for-in枚举，默认false
    }})
console.log(obj1);
</code></pre><p>克隆保持原型链</p>
<pre><code>function clone(origin) {
  //Object.getPrototypeOf方法返回指定对象的原型（内部[[Prototype]]属性的值）
  let originProto = Object.getPrototypeOf(origin);
  //Object.create方法创建一个新对象，originProto为原型创建新对象
  return Object.assign(Object.create(originProto), origin);
</code></pre><h4 id="Object-defineProperties-object-descriptors"><a href="#Object-defineProperties-object-descriptors" class="headerlink" title="Object.defineProperties(object,descriptors)"></a>Object.defineProperties(object,descriptors)</h4><p>作用:为指定的object对象扩展多个属性<br>一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。如果不指定configurable, writable, enumerable ，则这些属性默认值为false，如果不指定value, get, set，则这些属性默认值为undefined。</p>
<p>Object的defineProperty/defineProperties主要功能就是用来定义或修改这些内部属性,getOwnPropertyDescriptor/getOwnPropertyDescriptors就是获取这行内部属性的描述。</p>
<p>语法: Object.defineProperty(obj, prop, descriptor)</p>
<p>obj: 需要被操作的目标对象<br>prop: 目标对象需要定义或修改的属性的名称<br>descriptor: 将被定义或修改的属性的描述符</p>
<pre><code>var obj = new Object();

Object.defineProperty(obj, &#39;name&#39;, {
    configurable: false,
    writable: true,
    enumerable: true,
    value: &#39;张三&#39;
})

console.log(obj.name)  //张三
</code></pre><p>语法: Object.defineProperties(obj, props)</p>
<p>obj: 将要被添加属性或修改属性的对象<br>props: 该对象的一个或多个键值对定义了将要为对象添加或修改的属性的具体配置</p>
<p>方法直接在一个对象上定义一个或多个新的属性或修改现有属性，并返回该对象。</p>
<pre><code>var obj = new Object();
Object.defineProperties(obj, {
    name: {
        value: &#39;张三&#39;,
        configurable: false,
        writable: true,
        enumerable: true
    },
    age: {
        value: 18,
        configurable: true
    }
})

console.log(obj.name, obj.age) // 张三, 18
</code></pre><p>该方法的存储器属性(setter,getter)可以实现简单的数据双向绑定</p>
<pre><code>&lt;body&gt;

   &lt;input type=&quot;text&quot; id=&quot;input1&quot;&gt;


&lt;div&gt;
    上面输入的数据是
    &lt;span id=&quot;span&quot;&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;script&gt;

    let oInput1 = document.getElementById(&#39;input1&#39;);
    let oSpan = document.getElementById(&#39;span&#39;);
    let obj = {};
    Object.defineProperties(obj, {
    //惰性求值，get之后才有值
        val1: {
            configurable: true,//可修改
            get: function() {
                oInput1.value = 0;
                oSpan.innerHTML = 0;
                return 0
            },
            set: function(newValue) {
                oSpan.innerHTML = newValue
            }
        },

    })
    //设置默认值为0 调用get方法
    oInput1.value = obj.val1;
    oInput1.addEventListener(&#39;keyup&#39;, function() {
        //调用set方法
        obj.val1 = oInput1.value;
    }, false)
&lt;/script&gt;
</code></pre><h4 id="get-set-propertyName"><a href="#get-set-propertyName" class="headerlink" title="get/set propertyName(){}"></a>get/set propertyName(){}</h4><p>对象本身的两个方法，用法和上面的get/set一样</p>
<pre><code>let obj = {firstName:&quot;xx&quot;,lastName:&quot;xx&quot;, get fullName(){
return this.firstName+ this.lastName
}}
</code></pre><h3 id="Array扩展"><a href="#Array扩展" class="headerlink" title="Array扩展"></a>Array扩展</h3><h4 id="Array-prototype-indexOf-value-lastIndexOf-value"><a href="#Array-prototype-indexOf-value-lastIndexOf-value" class="headerlink" title="Array.prototype.indexOf(value)/lastIndexOf(value)"></a>Array.prototype.indexOf(value)/lastIndexOf(value)</h4><p>返回value在数组中出现的第一个下标和最后一下下标，没有出现则返回-1</p>
<p>应用场景：<br>两个方法结合判断下标是否相等，可以用来判断数组中唯一出现的值</p>
<h4 id="Array-prototype-forEach"><a href="#Array-prototype-forEach" class="headerlink" title="Array.prototype.forEach()"></a>Array.prototype.forEach()</h4><p>遍历数组,前面介绍for-of时介绍了此方法的用法，这里就不介绍了。</p>
<h4 id="Array-prototype-map"><a href="#Array-prototype-map" class="headerlink" title="Array.prototype.map()"></a>Array.prototype.map()</h4><p>遍历数组返回一个新的加工后之后的数组，不改变原数组的值</p>
<h4 id="Array-prototype-filter"><a href="#Array-prototype-filter" class="headerlink" title="Array.prototype.filter()"></a>Array.prototype.filter()</h4><p>遍历过滤出一个新的子数组，不改变原数组，返回条件为true的值</p>
<p><a href="https://biubiuins.github.io/2019/07/04/js%E7%9A%84%E9%81%8D%E5%8E%86/" target="_blank" rel="noopener">遍历方法的总结</a></p>
<h3 id="Function扩展"><a href="#Function扩展" class="headerlink" title="Function扩展"></a>Function扩展</h3><h4 id="bind-、call-、apple-的区别"><a href="#bind-、call-、apple-的区别" class="headerlink" title="bind()、call()、apple()的区别"></a>bind()、call()、apple()的区别</h4><ul>
<li>都能指定函数中的this</li>
<li>Array.prototype.call()/Array.prototype.apply()是立即调用函数，Array.prototype.bind()是将函数返回</li>
<li>Array.prototype.call(obj)/Array.prototype.bind()从第二个参数开始依次传，Array.prototype.apply(obj)第二个参数是数组，传入的数据放入数组中</li>
</ul>
<pre><code>let obj ={name:&quot;ranan&quot;}
function f(data,data2) {
    console.log(this);
    console.log(data + data2);
    return data+data2
}
f.call(obj,33,22) //{name:&quot;ranan&quot;} 55
f.apply(obj,[33,22])//{name:&quot;ranan&quot;} 55
let bar=f.bind(obj) //bind不调用函数
bar(33,22)//{name:&quot;ranan&quot;} 55

//上面也可以写成
f.bind(obj)(33,22)//{name:&quot;ranan&quot;} 55
</code></pre><h4 id="Function-prototype-bind-obj"><a href="#Function-prototype-bind-obj" class="headerlink" title="Function.prototype.bind(obj)"></a>Function.prototype.bind(obj)</h4><p>作用:将函数内的this绑定为obj，并将函数返回(并不调用)</p>
<ul>
<li>返回原函数的拷贝，我们称这个拷贝的函数为绑定函数。</li>
<li>将函数中的this固定为调用bind方法时的第一个参数，</li>
<li>绑定this之后，无论有哪个对象调用绑定函数，绑定函数中的this依旧之前绑定的第一个参数</li>
<li><p>如果绑定函数作为构造函数，已经捆绑的this会被忽略掉，this依然指向实例对象</p>
<pre><code>  function Person(name){
      this.name = name;
   }
  var bindPerson = Person.bind({name:&quot;绑定函数&quot;})
  new bindPerson(&quot;张三&quot;)          // Person {name: &quot;张三&quot;}
</code></pre><p>通常用于指定回调函数的this，因为apply与call会立即调用</p>
</li>
</ul>
<p><strong>使用场景</strong><br>保持上下文的方法</p>
<pre><code>var o={
    f: function () {
        var self=this;
        var fff=function() {
            console.log(this.value); // bind(this) 中 this 指向的是o，这里也可直接写成 bind(o)
        }.bind(this);
        fff();
    },
    value: &quot;Hello World!&quot;
};
o.f(); // Hello World！
</code></pre>
  </article>
  <aside class="table-content" id="site-toc">
  <div class="table-content-title">
    <i class="fa fa-arrow-right fa-lg" id="site-toc-hide-btn"></i>
    <span>目录</span>
  </div>
  <div class="table-content-main">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#let-const"><span class="toc-text">let/const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量的解构赋值"><span class="toc-text">变量的解构赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模板字符串"><span class="toc-text">模板字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象属性-方法简写"><span class="toc-text">对象属性/方法简写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#箭头函数"><span class="toc-text">箭头函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三点运算符"><span class="toc-text">三点运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#形参默认值"><span class="toc-text">形参默认值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise对象"><span class="toc-text">Promise对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Symbol"><span class="toc-text">Symbol</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iterator迭代器"><span class="toc-text">iterator迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#for-of"><span class="toc-text">for..of</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generator函数"><span class="toc-text">Generator函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async函数"><span class="toc-text">async函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class"><span class="toc-text">class</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#extends继承"><span class="toc-text">extends继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static"><span class="toc-text">static</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展方法"><span class="toc-text">扩展方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串扩展"><span class="toc-text">字符串扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#String-includes-str"><span class="toc-text">String.includes(str)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-startsWith-str"><span class="toc-text">String.startsWith(str)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-endsWith-str"><span class="toc-text">String.endsWith(str)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-repeat-count"><span class="toc-text">String.repeat(count)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数值扩展"><span class="toc-text">数值扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#进制表示法"><span class="toc-text">进制表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Number-isFinite-i"><span class="toc-text">Number.isFinite(i)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Number-isNaN-i"><span class="toc-text">Number.isNaN(i)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Number-isInteger-i"><span class="toc-text">Number.isInteger(i)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Number-parseInt-str"><span class="toc-text">Number.parseInt(str)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Math-trunc-i"><span class="toc-text">Math.trunc(i)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组扩展"><span class="toc-text">数组扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Array-from-v"><span class="toc-text">Array.from(v)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Array-of-v1-v2-v3"><span class="toc-text">Array.of(v1,v2,v3)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#find"><span class="toc-text">find()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#findIndex"><span class="toc-text">findIndex()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拷贝"><span class="toc-text">拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象扩展"><span class="toc-text">对象扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-is-v1-v2"><span class="toc-text">Object.is(v1,v2)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-assign-target-source1-source2"><span class="toc-text">Object.assign(target,source1,source2..)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set-Map容器"><span class="toc-text">Set/Map容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES7-16年发布"><span class="toc-text">ES7(16年发布)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#指数运算符-幂"><span class="toc-text">指数运算符(幂)**</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Array-prototype-includes-value"><span class="toc-text">Array.prototype.includes(value)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proxy"><span class="toc-text">Proxy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES5"><span class="toc-text">ES5</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON对象"><span class="toc-text">JSON对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object扩展"><span class="toc-text">Object扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-create-prototype-descriptors"><span class="toc-text">Object.create(prototype,[descriptors])</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-defineProperties-object-descriptors"><span class="toc-text">Object.defineProperties(object,descriptors)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get-set-propertyName"><span class="toc-text">get/set propertyName(){}</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Array扩展"><span class="toc-text">Array扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Array-prototype-indexOf-value-lastIndexOf-value"><span class="toc-text">Array.prototype.indexOf(value)/lastIndexOf(value)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Array-prototype-forEach"><span class="toc-text">Array.prototype.forEach()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Array-prototype-map"><span class="toc-text">Array.prototype.map()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Array-prototype-filter"><span class="toc-text">Array.prototype.filter()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Function扩展"><span class="toc-text">Function扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bind-、call-、apple-的区别"><span class="toc-text">bind()、call()、apple()的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Function-prototype-bind-obj"><span class="toc-text">Function.prototype.bind(obj)</span></a></li></ol></li></ol></li></ol>
  </div>
</aside>
  
  
    <div class="passage-tags">
     
      <a href="/tags/Javascript/"><i class="fa fa-tags"></i>Javascript</a>
    
    </div>
  
</div>

    </main>
    
    <div class="site-footer-wrapper">
  <footer class="site-footer">
    
    <!--<div class="site-footer-info">-->
      <!--<i class="fa fa-clock-o"></i> 本站已稳定运行<span id="site-time"></span>-->
    <!--</div>-->
    
    
      <div class="site-footer-info">
        <i class="fa fa-at"></i> Email: 981684424@qq.com
      </div>
    
    <div class="site-footer-info">
      <i class="fa fa-copyright"></i> 
      2019 <a href="https://github.com/dongyuanxin/theme-ad/" target="_blank">Theme-AD</a>.
      Created by <a href="https://godbmw.com/" target="_blank">GodBMW</a>.
      All rights reserved.
    </div>
  </footer>
</div>
    <div id="site-layer" style="display:none;">
  <div class="site-layer-content">
    <div class="site-layer-header">
      <span class="site-layer-header-title" id="site-layer-title"></span>
      <i class="fa fa-close" id="site-layer-close"></i>
    </div>
    <div class="site-layer-body" id="site-layer-container">
      <div class="site-layer-input" id="site-layer-search" style="display: none;">
        <div class="site-layer-input-choose">
          <a href="javascript:void(0);" title="Change Search Engine">Google</a>
        </div>
        <input type="text">
        <i class="fa fa-search"></i>
      </div>
      
      <div id="site-layer-welcome" style="display:none;"></div>
    </div>
  </div>
</div>
    

<div class="bottom-bar">
  <div class="bottom-bar-left">
    <a href="/2020/02/18/原型与原型链/" data-enable="true">
      <i class="fa fa-arrow-left"></i>
    </a>
    <a href="/2020/02/16/宏队列与微队列/" data-enable="true">
      <i class="fa fa-arrow-right"></i>
    </a>
  </div>
  <div class="bottom-bar-right">
    <a href="javascript:void(0);" data-enable="true" id="site-toc-show-btn">
      <i class="fa fa-bars"></i>
    </a>
    
    <a href="javascript:void(0);" id="site-toggle-share-btn">
      <i class="fa fa-share-alt"></i>
    </a>
    
    <a href="javascript:void(0);" id="back-top-btn">
      <i class="fa fa-chevron-up"></i>
    </a>
  </div>
</div>
    <div id="share-btn">
  
  
  
  
  
</div>
    





    
  </body>
</html>