<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="biubiu的博客">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        es5/es6/es7 - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i>  </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <span>biubiu</span>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#let-const"><span class="toc-text">let/const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量的解构赋值"><span class="toc-text">变量的解构赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模板字符串"><span class="toc-text">模板字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象属性-方法简写"><span class="toc-text">对象属性/方法简写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#箭头函数"><span class="toc-text">箭头函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三点运算符"><span class="toc-text">三点运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#形参默认值"><span class="toc-text">形参默认值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise对象"><span class="toc-text">Promise对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Symbol"><span class="toc-text">Symbol</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iterator迭代器"><span class="toc-text">iterator迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#for-of"><span class="toc-text">for..of</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generator函数"><span class="toc-text">Generator函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async函数"><span class="toc-text">async函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class"><span class="toc-text">class</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#extends继承"><span class="toc-text">extends继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static"><span class="toc-text">static</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展方法"><span class="toc-text">扩展方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串扩展"><span class="toc-text">字符串扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#String-includes-str"><span class="toc-text">String.includes(str)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-startsWith-str"><span class="toc-text">String.startsWith(str)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-endsWith-str"><span class="toc-text">String.endsWith(str)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-repeat-count"><span class="toc-text">String.repeat(count)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数值扩展"><span class="toc-text">数值扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#进制表示法"><span class="toc-text">进制表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Number-isFinite-i"><span class="toc-text">Number.isFinite(i)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Number-isNaN-i"><span class="toc-text">Number.isNaN(i)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Number-isInteger-i"><span class="toc-text">Number.isInteger(i)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Number-parseInt-str"><span class="toc-text">Number.parseInt(str)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Math-trunc-i"><span class="toc-text">Math.trunc(i)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组扩展"><span class="toc-text">数组扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Array-from-v"><span class="toc-text">Array.from(v)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Array-of-v1-v2-v3"><span class="toc-text">Array.of(v1,v2,v3)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#find"><span class="toc-text">find()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#findIndex"><span class="toc-text">findIndex()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拷贝"><span class="toc-text">拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象扩展"><span class="toc-text">对象扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-is-v1-v2"><span class="toc-text">Object.is(v1,v2)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-assign-target-source1-source2"><span class="toc-text">Object.assign(target,source1,source2..)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set-Map容器"><span class="toc-text">Set/Map容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES7-16年发布"><span class="toc-text">ES7(16年发布)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#指数运算符-幂"><span class="toc-text">指数运算符(幂)**</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Array-prototype-includes-value"><span class="toc-text">Array.prototype.includes(value)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proxy"><span class="toc-text">Proxy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES5"><span class="toc-text">ES5</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON对象"><span class="toc-text">JSON对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object扩展"><span class="toc-text">Object扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-create-prototype-descriptors"><span class="toc-text">Object.create(prototype,[descriptors])</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-defineProperties-object-descriptors"><span class="toc-text">Object.defineProperties(object,descriptors)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get-set-propertyName"><span class="toc-text">get/set propertyName(){}</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Array扩展"><span class="toc-text">Array扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Array-prototype-indexOf-value-lastIndexOf-value"><span class="toc-text">Array.prototype.indexOf(value)/lastIndexOf(value)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Array-prototype-forEach"><span class="toc-text">Array.prototype.forEach()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Array-prototype-map"><span class="toc-text">Array.prototype.map()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Array-prototype-filter"><span class="toc-text">Array.prototype.filter()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Function扩展"><span class="toc-text">Function扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bind-、call-、apple-的区别"><span class="toc-text">bind()、call()、apple()的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Function-prototype-bind-obj"><span class="toc-text">Function.prototype.bind(obj)</span></a></li></ol></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i>  </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        es5/es6/es7
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2020-02-17 12:51:14</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#学习笔记" title="学习笔记">学习笔记</a>
        <span>/</span>
        
        <a class="tag" href="/tags/#javascript" title="javascript">javascript</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        <h2 id="let-const"><a href="#let-const" class="headerlink" title="let/const"></a>let/const</h2><p>特点:</p>
<ul>
<li>不能重复定义</li>
<li>在块级作用域内有效</li>
<li>不会预处理，不存在变量提升</li>
<li>const不可以被修改，声明时必须赋值</li>
</ul>
<p>预处理：声明<code>var</code>后的变量但并不赋值(undefined)，声明<code>function</code>。因此使用let/const定义的变量在没声明前是无法使用的。</p>
<p>在循环使用中常用。如下述代码，结果会全部输出2，原因是：点击事件是回调函数进入队列，等同步执行的代码执行完毕之后，再执行。以前常用的解决办法是使用闭包。es6中的let也可以解决这个问题，因为let有自己的块级作用域，使用i值的时候，仅当次循环有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//html</span><br><span class="line">  &lt;button&gt;测试1&lt;/button&gt;</span><br><span class="line">  &lt;button&gt;测试2&lt;/button&gt;</span><br><span class="line">  &lt;button&gt;测试3&lt;/button&gt;</span><br><span class="line">//js</span><br><span class="line">   let btns = document.getElementsByTagName(&quot;button&quot;);</span><br><span class="line">   for (var i = 0;i&lt;btns.length;i++) &#123;</span><br><span class="line">   var btn = btns[i];</span><br><span class="line">    btn.onclick =function () &#123;</span><br><span class="line">      alert(i)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">//js 闭包解决办法</span><br><span class="line">    let btns = document.getElementsByTagName(&quot;button&quot;);</span><br><span class="line">     for (var i = 0;i&lt;btns.length;i++) &#123;</span><br><span class="line">     var btn = btns[i];</span><br><span class="line">     (function (i) &#123;</span><br><span class="line">      btn.onclick =function () &#123;</span><br><span class="line">      alert(i)</span><br><span class="line">        &#125;</span><br><span class="line">       &#125;)(i)</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>还有一点是let/const不属于顶层全局变量，不用担心污染全局的window对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = 0</span><br><span class="line">console.log(window.a)//undefined</span><br><span class="line">var b = 1</span><br><span class="line">console.log(window.b)//1</span><br></pre></td></tr></table></figure>
<h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><p>理解：从对象或数组中提取数据，并赋值给变量(多个)。<br>常用：对象的解构赋值。(后台返回的数据进行利用)</p>
<p>例：交换对象,解构的目标是数组，所以以数组的形式来接收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = 1</span><br><span class="line">let b = 2</span><br><span class="line">[a,b] = [b,a]</span><br><span class="line">//a=2 , b =1</span><br></pre></td></tr></table></figure>
<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>作用：简化字符串的拼接<br>使用：模板字符串必须用<code></code>包含，变化的部分使用${xxx}定义</p>
<h2 id="对象属性-方法简写"><a href="#对象属性-方法简写" class="headerlink" title="对象属性/方法简写"></a>对象属性/方法简写</h2><p>对象属性简写：当对象的属性和值相同时，省略属性名</p>
<p>注意点：</p>
<ul>
<li>省略的是属性名而不是值</li>
<li>必须是一个变量</li>
</ul>
<p>方法的简写：当对象的属性值是一个函数(即是一个方法)，可以使用简写形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//es5</span><br><span class="line">let obj =&#123;</span><br><span class="line"> func:function()&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//es6</span><br><span class="line">let obj2=&#123;</span><br><span class="line"> func()&#123;&#125;  //不太常用</span><br><span class="line"> func:()=&gt;&#123;&#125; //常用箭头函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>用处：常用在回调函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let a = ()=&gt;&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>形参</p>
<ul>
<li>只有一个形参的时候，()可以省略</li>
<li>其余时候，()不能省略</li>
</ul>
<p>函数体</p>
<ul>
<li>函数体内只有一条语句或者表达式，{}可省略，省略后自动return</li>
<li>其余情况不可以省略，并且需要返回值时，需要加上return</li>
</ul>
<p>注意：由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//报错</span><br><span class="line">let getTempItem = id =&gt; &#123; id, name: &quot;Temp&quot; &#125;;</span><br><span class="line">// 不报错</span><br><span class="line">let getTempItem = id =&gt; (&#123; id, name: &quot;Temp&quot; &#125;);</span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ul>
<li>箭头函数没有arguments，但是如果在箭头函数需要参数时，可以使用rest运算符来取代arguments</li>
<li>箭头函数没有prototype属性，不能用作构造函数（不能用new关键字调用）</li>
<li><p>箭头函数没有自己的this，箭头函数的this，不是调用的时候决定的(一般函数是由调用时决定)，而是在定义的时候所处在的对象就是他的this</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">name:箭头函数</span><br><span class="line">getName()&#123;</span><br><span class="line">btn2.onclick = ()=&gt;&#123;</span><br><span class="line">console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.getName()</span><br><span class="line"></span><br><span class="line">//输出obj</span><br><span class="line"></span><br><span class="line">   let obj = &#123;</span><br><span class="line">   name:箭头函数</span><br><span class="line">   getName:()=&gt;&#123;</span><br><span class="line">   btn2.onclick = ()=&gt;&#123;</span><br><span class="line">   console.log(this)</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   obj.getName()</span><br><span class="line">//输出window</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>理解</strong></p>
<ul>
<li>如果箭头函数外面有函数，则箭头函数的this同外层函数的this一样。</li>
<li>若外层没有函数，指向window。</li>
</ul>
<p>因此，箭头函数替代了以前需要显式的声明一个变量保存this的操作，使得代码更加的简洁。<br>还有一个好处在数组的迭代中使用箭头函数更加简洁，并且省略了return关键字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3]</span><br><span class="line">arr.filter (item=&gt; item === 2)//[2]</span><br><span class="line">arr.map(item =&gt; item*2 ) //[2,4,6]</span><br><span class="line">arr.reduce((acc,cur) = acc+cur) //6</span><br></pre></td></tr></table></figure>
<p>注意:不要在可能改变this指向的函数中使用箭头函数，类似Vue中的methods,computed中的方法,生命周期函数，Vue将这些函数的this绑定了当前组件的vm实例，如果使用箭头函数会强行改变this，因为箭头函数优先级最高（无法再使用call,apply,bind改变指向）</p>
<h2 id="三点运算符"><a href="#三点运算符" class="headerlink" title="三点运算符"></a>三点运算符</h2><p><code>...</code></p>
<p>剩余运算符：用来代替arguments，但比arguments灵活。</p>
<p>补充:arguments.callee()方法的意思是：调用函数本身。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo(...value)&#123; //收集传过来的2，65两个元素</span><br><span class="line">console.log(value)//输出[2,65]是一个真数组</span><br><span class="line">&#125;</span><br><span class="line">function foo(value)&#123;</span><br><span class="line">console.log(arguments)//2,65是一个伪数组</span><br><span class="line">&#125;</span><br><span class="line">foo(2,65)</span><br></pre></td></tr></table></figure>
<p>扩展运算符：只要含有iterator接口的数据结构都可以使用扩展运算符</p>
<blockquote>
<p>   扩展运算符可以和数组的解构赋值一起使用，但是必须放在最后一个，因为剩余/扩展运算符的原理其实是利用了数组的迭代器，它会消耗3个点后面的数组的所有迭代器，读取所有迭代器生成对象的value属性，剩余/扩展运算符后不能在有解构赋值，因为剩余/扩展运算符已经消耗了所有迭代器，而数组的解构赋值也是消耗迭代器，但是这个时候已经没有迭代器了，所以会报错</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let [first,...arr]=[1,2,3,4,5]//不会报错</span><br><span class="line">let[...arr,last] = [1,2,3,4,5] //报错</span><br></pre></td></tr></table></figure>
<p><strong>剩余运算符和扩展运算符的区别就是，剩余运算符会收集这些集合，放到右边的数组中，扩展运算符是将右边的数组拆分成元素的集合，它们是相反的</strong></p>
<h2 id="形参默认值"><a href="#形参默认值" class="headerlink" title="形参默认值"></a>形参默认值</h2><p>在定义函数时可以定义形参的默认值，当不传入参数的时候默认使用形参里的默认值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//定义形参默认值</span><br><span class="line">    function add(a=0,b=1) &#123;</span><br><span class="line">        return a+b</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(add());</span><br><span class="line">    //输出1</span><br></pre></td></tr></table></figure></p>
<h2 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h2><p>Promise是JS中进行异步编程的新的解决方案，之前是纯回调的方法。</p>
<p>回调函数的一些缺点:<br>1.多重嵌套，导致回调地狱<br>    Promise引入了链式调用的概念，每个then方法同样也是一个promise，所以可以链式调用下去。其次将异步操作以同步的流程表达出来，更方便阅读。<br>2.不清楚回调是否都是异步调用的（可以同步调用ajax，在收到响应前会阻塞整个线程，会陷入假死状态，非常不推荐）<br>3.第三方库可能没有提供错误处理<br>    Promise在异步请求发送错误的时候，即使没有捕获错误，也不会阻塞主线程的代码</p>
<p>更深入的内容，在之前的博客中<a href="https://biubiuins.github.io/2020/01/08/promise/" target="_blank" rel="noopener">Promise学习笔记</a></p>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>Symbol是ES6中添加的新的数据类型(原来的有：String，Number,Boolean,Object,Null(空对象指针),Undefined(声明的变量未被初始化时))</p>
<p>特点:</p>
<ul>
<li>Symbol属性对应的值是唯一的，解决命名冲突问题。(类似id)</li>
<li>Symbol值不能与其他数据进行计算，包括同字符串拼接</li>
<li>for in/for of遍历时不会遍历symbol属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//创建Symbol属性值</span><br><span class="line">let symbol = Symbol();</span><br><span class="line">//let symbol = Symbol(&apos;传一个标识&apos;);</span><br><span class="line">console.log(symbol) //输出Symbol</span><br><span class="line">//Symbol(&apos;传一个标识&apos;)</span><br><span class="line">let obj =&#123;</span><br><span class="line">name:&quot;ko&quot;,age:48</span><br><span class="line">&#125;</span><br><span class="line">obj[symbol]=&quot;男&quot;</span><br></pre></td></tr></table></figure>
<p>1.当symbol作为对象的属性时，用XX[Symbol]形式，不用XX.Symbol形式。<br>2.可以定义常量<br>3.除了自己定义使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部的使用方法。比如<code>Symbol.iterator</code>属性</p>
<h2 id="iterator迭代器"><a href="#iterator迭代器" class="headerlink" title="iterator迭代器"></a>iterator迭代器</h2><p>概念:iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制。iterator接口是解构赋值，三点运算符，生成器，<code>for-of</code>循环的基础，主要供<code>for-of</code>消费。</p>
<p>工作原理:<br>1.创建一个指针对象(遍历器对、iterator迭代器)，指向数据结构的起始位置。<br>2.第一次调用next方法，指针自动指向数据结构的第一个成员<br>3.接下来不断调用next方法，直到指向最后一个成员</p>
<p>注意：每次调用next方法返回的是一个包含value和done的对象{value:当前成员的值，done：布尔值}其中done对用的布尔值表示当前的数据的结构是否遍历结束。当遍历结束的时候返回的value值是undefined，done值为true</p>
<ul>
<li>可迭代的数据结构会有一个[Symbol.iterator]方法,</li>
<li>[Symbol.iterator]执行后返回一个iterator对象</li>
</ul>
<p>默认具有iterator接口的数据结构有以下几个，注意普通对象默认是没有iterator接口的（可以自己创建iterator接口让普通对象也可以迭代）</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray（类数组）</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象</li>
</ul>
<p>自定义部署iterator接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let targetData = &#123;</span><br><span class="line"> [Symbol.iterator]:function()&#123;</span><br><span class="line"> let nextIndex = 0 //记录指针的位置</span><br><span class="line"> return&#123;//遍历器对象</span><br><span class="line"> next:function()&#123;</span><br><span class="line"> return nextIndex &lt; this.length?&#123;value:this[nextIndex++],done:false&#125;:&#123;value:undefined,done:true&#125;&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="for-of"><a href="#for-of" class="headerlink" title="for..of"></a>for..of</h3><p>以前我们遍历数组中的元素的时，最开始使用的是for</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3]</span><br><span class="line">for(let i = 0;i&lt;arr.length;i++)&#123;</span><br><span class="line">console.log(arr[i])</span><br><span class="line">//输出1，2，3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自ES5之后，可以使用<code>forEach</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(function (value) &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">    //输出1，2，3</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>但是<code>foeEach</code>有两个缺点：<br>1.不能使用<code>break</code>语句中断循环<br>2.不能使用<code>return</code>语句返回到外层函数</p>
<p>ES6增加了<code>for-of</code>循坏，是现在简洁、最直接的遍历数组元素的语法。<code>for-in</code>不仅仅可以遍历数组，<strong>具有iterator接口的，都可以使用<code>for-of</code>进行遍历</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var value of arr) &#123;</span><br><span class="line">      console.log(value); // 1,2,3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与<code>for-in</code>的区别：<br>1.for-in 获取的是对象的键名<br>2.for-in会遍历对象的整个原型链,性能非常差不推荐使用,</p>
<h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><p>概念：ES6提供的解决异步编程的方案之一。</p>
<p>特点：<br>1.<code>function函数名*</code><br>2.内部用yield表达式来定义不同的状态<br>3.其返回值是一个Iterator迭代器（指针对象）</p>
<p>比如某个事物只有三种状态（状态A，状态B，状态C），而这三种状态的变化是 状态A =&gt; 状态B =&gt; 状态C =&gt; 状态A ，这就是状态机。Generator特别适用于处理这种状态机。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// A，B，C三种状态循环</span><br><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">state</span></span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(1)&#123;</span><br><span class="line">        yield <span class="string">'A'</span>;</span><br><span class="line">        yield <span class="string">'B'</span>;</span><br><span class="line">        yield <span class="string">'C'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> status = state();//返回的是指针对象</span><br><span class="line">//碰到yield返回</span><br><span class="line">console.log(status.next()); // 先暂停到A，后面的代码不执行，返回&#123;value: <span class="string">"A"</span>, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">console.log(status.next()); // 执行下一条指令，暂停到B，返回&#123;value: <span class="string">"B"</span>, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">console.log(status.next()); // &#123;value: <span class="string">"C"</span>, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">console.log(status.next()); // &#123;value: <span class="string">"A"</span>, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">console.log(status.next()); // &#123;value: <span class="string">"B"</span>, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure>
<p>Iterator迭代器遍历结束时，返回的是：{value: undefined, done: true},Generator函数可以使用return来改变最后的返回值</p>
<p>next传的参数可以作为启动yield(默认返回undefined)的返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function* state&#123;</span><br><span class="line">let result = yield &apos;hello&apos;</span><br><span class="line">console.log(result)//输出aaa</span><br><span class="line">&#125;</span><br><span class="line">state.next(&quot;aaa&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h2><p>本质:Generator语法糖，async取代Generator函数的星号*.await取代的是yield</p>
<p>ES7的async/await进一步的优化Promise的写法，async函数始终返回一个Promise，await可以实现一个”等待”的功能，async/await被称为异步编程的终极解决方案，即用同步的形式书写异步代码，并且能够更优雅的实现异步代码顺序执行。</p>
<p>补充一种更高级的写法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Promise(resolve=&gt;&#123;</span><br><span class="line">   setTimeout(()=&gt;&#123;</span><br><span class="line">   resolve() //第一个参数为函数，目的在与执行resolve</span><br><span class="line">   &#125;,2000)</span><br><span class="line"></span><br><span class="line">   //更高级的写法</span><br><span class="line">   setTimeout(resolve,2000)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>更深入的内容，在之前的博客中<a href="https://biubiuins.github.io/2020/01/08/promise/" target="_blank" rel="noopener">Promise学习笔记</a></p>
<h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//定义一个人物的类</span><br><span class="line">class Person&#123;</span><br><span class="line">//类的构造方法</span><br><span class="line"> constructor()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>类里面的方法，用es6简写形式不加<code>function</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(typeof Person);//function</span><br><span class="line">console.log(Person===Person.prototype.constructor);//true</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出类实质上就是一个函数，可以任务ES6的类就是构造函数的另外一种写法。<br>实际上类的所有方法都定义在类的prototype属性上。<br>constructor内的属性可以称为实例属性（和前面说的实例成员一样）,constructor外声明的属性都是定义在原型上的，可以称为原型属性（即定义在class上)</p>
<p><strong>注意</strong>  <code>class</code>不存在变量提升，所以需要先定义再使用</p>
<h3 id="extends继承"><a href="#extends继承" class="headerlink" title="extends继承"></a>extends继承</h3><p>ES5的继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//父构造函数 this指向父构造函数的对象实例</span><br><span class="line">function Father(name,age)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.money= ()=&gt;&#123;</span><br><span class="line">    console.log(&apos;父亲要上班&apos;);</span><br><span class="line">&#125;</span><br><span class="line">//子构造函数 this指向子构造函数的对象实例</span><br><span class="line">function  Son(name,age) &#123;</span><br><span class="line">  //把指向父构造函数的对象实例的this改变成指向子构造函数的对象实例的this</span><br><span class="line">    Father.call(this,name,age)</span><br><span class="line">&#125;</span><br><span class="line">//让Son的原型对象指向Father的实例对象，那么就可以访问到Father实例对象上的方法</span><br><span class="line">//这个new Father()是一个原型对象，相当于&#123;&#125;，这样写会覆盖掉Son的原型对象的constructor</span><br><span class="line">Son.prototype = new Father();</span><br><span class="line">//所以还需要constructor指回原来的构造函数</span><br><span class="line">Son.prototype.constructor = Son</span><br></pre></td></tr></table></figure>
<p>ES6的extends继承<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Son extends Father&#123;</span><br><span class="line">constructor(name,age)&#123;//继承时注意写参数</span><br><span class="line">  super(name,age)// 调用父类的构造方法，这里也要注意参数</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>不同于普通在类中定义的会被实例继承的方法。在方法前加上static关键字。就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。（静态属性差不多的意思）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class  &#123;</span><br><span class="line">  static classMethod() &#123;</span><br><span class="line">    return &apos;hello&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//Foo.classMethod()使用</span><br></pre></td></tr></table></figure>
<h2 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h2><h3 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><h4 id="String-includes-str"><a href="#String-includes-str" class="headerlink" title="String.includes(str)"></a>String.includes(str)</h4><p>判断是否包含指定的字符串<br>返回值：包含true,不包含false</p>
<h4 id="String-startsWith-str"><a href="#String-startsWith-str" class="headerlink" title="String.startsWith(str)"></a>String.startsWith(str)</h4><p>判断是否以指定字符串开头<br>返回值：是true,否false</p>
<h4 id="String-endsWith-str"><a href="#String-endsWith-str" class="headerlink" title="String.endsWith(str)"></a>String.endsWith(str)</h4><p>判断是否以指定字符串结尾<br>返回值：是true,否false</p>
<h4 id="String-repeat-count"><a href="#String-repeat-count" class="headerlink" title="String.repeat(count)"></a>String.repeat(count)</h4><p>指定目标字符串重复的次数<br>返回值:重复后的字符串</p>
<h3 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h3><h4 id="进制表示法"><a href="#进制表示法" class="headerlink" title="进制表示法"></a>进制表示法</h4><p>二进制用0b，八进制用0o</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(0b1010);//输出10</span><br></pre></td></tr></table></figure>
<h4 id="Number-isFinite-i"><a href="#Number-isFinite-i" class="headerlink" title="Number.isFinite(i)"></a>Number.isFinite(i)</h4><p>判断i是否有限大的数<br>返回值：是true,否false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number.isFinite(Infinity)//false</span><br></pre></td></tr></table></figure>
<h4 id="Number-isNaN-i"><a href="#Number-isNaN-i" class="headerlink" title="Number.isNaN(i)"></a>Number.isNaN(i)</h4><p>判断i是否NaN<br>返回值：是true,否false</p>
<h4 id="Number-isInteger-i"><a href="#Number-isInteger-i" class="headerlink" title="Number.isInteger(i)"></a>Number.isInteger(i)</h4><p>判断i是否整数<br>返回值：是true,否false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number.isInteger(120.0)//true</span><br></pre></td></tr></table></figure>
<h4 id="Number-parseInt-str"><a href="#Number-parseInt-str" class="headerlink" title="Number.parseInt(str)"></a>Number.parseInt(str)</h4><p>将字符串转换为对应的数值<br>返回值：对应的数值</p>
<h4 id="Math-trunc-i"><a href="#Math-trunc-i" class="headerlink" title="Math.trunc(i)"></a>Math.trunc(i)</h4><p>直接i的去除小数部分<br>返回值:整数部分</p>
<h3 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h3><h4 id="Array-from-v"><a href="#Array-from-v" class="headerlink" title="Array.from(v)"></a>Array.from(v)</h4><p>把v的伪数组(字符串也可)转换为真数组<br>类数组(伪数组)最基本的要求就是具有length属性的对象,该类数组对象的属性名必须为数值型或字符串型的数字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let arrayLike = &#123;</span><br><span class="line">    0: &apos;tom&apos;,</span><br><span class="line">    1: &apos;65&apos;,</span><br><span class="line">    2: &apos;男&apos;,</span><br><span class="line">    3: [&apos;jane&apos;,&apos;john&apos;,&apos;Mary&apos;],</span><br><span class="line">    &apos;length&apos;: 4</span><br><span class="line">&#125;</span><br><span class="line">let arr = Array.from(arrayLike)</span><br><span class="line">console.log(arr) // [&apos;tom&apos;,&apos;65&apos;,&apos;男&apos;,[&apos;jane&apos;,&apos;john&apos;,&apos;Mary&apos;]]</span><br></pre></td></tr></table></figure>
<p>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,2,2,3,4,5]</span><br><span class="line">  let set = new Set(arr)</span><br><span class="line">  console.log(Array.from(set, item =&gt; item + 1)) // [2,3,4,5,6]</span><br></pre></td></tr></table></figure>
<h4 id="Array-of-v1-v2-v3"><a href="#Array-of-v1-v2-v3" class="headerlink" title="Array.of(v1,v2,v3)"></a>Array.of(v1,v2,v3)</h4><p>将v1，v2..等元素转换成数组</p>
<h4 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h4><p>找到第一个满足条件返回true的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [2,4,6]</span><br><span class="line">console.log(arr.find((value, index) =&gt; value &gt; 4));</span><br><span class="line">//输出6</span><br></pre></td></tr></table></figure>
<h4 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex()"></a>findIndex()</h4><p>找到第一个满足条件返回true的元素下标<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [2,4,6]</span><br><span class="line">console.log(arr.findIndex((value, index) =&gt; value &gt; 4));</span><br><span class="line">//输出2</span><br></pre></td></tr></table></figure></p>
<h3 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h3><p><a href="9https://biubiuins.github.io/2020/02/19/%E6%8B%B7%E8%B4%9D/" target="_blank" rel="noopener">笔记</a></p>
<h3 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h3><p><strong><strong>proto</strong>隐式原型可直接操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let obj3=&#123;</span><br><span class="line">&#125;</span><br><span class="line">let obj4 = &#123;name:&quot;xx&quot;&#125;</span><br><span class="line">obj3.__proto__ = obj4</span><br></pre></td></tr></table></figure>
<h4 id="Object-is-v1-v2"><a href="#Object-is-v1-v2" class="headerlink" title="Object.is(v1,v2)"></a>Object.is(v1,v2)</h4><p>判断对象v1与v2是否完全相等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(0 === -0)  //true</span><br><span class="line">console.log(NaN == NaN)//false NaN与任何数都不相等</span><br><span class="line">console.log(Object.is(0,-0)) //false</span><br><span class="line">console.log(Object.is(NaN,NaN))//true</span><br></pre></td></tr></table></figure>
<p>由上面代码可知该方式是以字符串是否相等来判断的</p>
<h4 id="Object-assign-target-source1-source2"><a href="#Object-assign-target-source1-source2" class="headerlink" title="Object.assign(target,source1,source2..)"></a>Object.assign(target,source1,source2..)</h4><p>这个Object静态方法允许我们进行多个对象的合并，遍历需要合并给target的对象（仅可枚举属性），用等号进行赋值(这里可能有深浅拷贝的问题)</p>
<p><strong>注意</strong>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const target = &#123; a: 1, b: 1 &#125;;</span><br><span class="line">const source1 = &#123; b: 2, c: 2 &#125;;</span><br><span class="line">const source2 = &#123; c: 3 &#125;;</span><br><span class="line">Object.assign(target, source1, source2);</span><br><span class="line">target // &#123;a:1, b:2, c:3&#125;</span><br></pre></td></tr></table></figure>
<p><strong>常见用途</strong></p>
<p>1.<a href="https://biubiuins.github.io/2020/02/19/%E6%8B%B7%E8%B4%9D/" target="_blank" rel="noopener">关于拷贝的用法</a><br>2.为属性指定默认值<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const DEFAULTS = &#123;</span><br><span class="line">  logLevel: 0,</span><br><span class="line">  outputFormat: &apos;html&apos;</span><br><span class="line">&#125;;</span><br><span class="line">//options对象是用户提供的参数。</span><br><span class="line">function processContent(options) &#123;</span><br><span class="line">  options = Object.assign(&#123;&#125;, DEFAULTS, options);</span><br><span class="line">  console.log(options);</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Set-Map容器"><a href="#Set-Map容器" class="headerlink" title="Set/Map容器"></a>Set/Map容器</h2><p>Set容器：无序不可重复的多个value的集合体</p>
<ul>
<li>new Set(array)创建方法</li>
<li>add(value)添加方法</li>
<li>delete(value)删除方法</li>
<li>has(value)判断是否存在方法</li>
<li>clear()清空方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([1,3,2,2])</span><br><span class="line">console.log(set);//输出唯一出现的值</span><br><span class="line"></span><br><span class="line">//add(value)添加方法</span><br><span class="line">set.add(7)</span><br><span class="line">console.log(set.size,set)//set.size相当于数组的length。</span><br></pre></td></tr></table></figure>
<p>遍历：可以使用Set实例对象的keys()，values()，entries()方法进行遍历。<br>由于Set的键名和键值是同一个值，它的每一个元素的key和value是相同的，所有keys()和values()的返回值是相同的，entries()返回的元素中的key和value是相同的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([4, 5, &apos;hello&apos;])</span><br><span class="line">  for(let item of set.keys()) &#123;</span><br><span class="line">      console.log(item) //输出4，5，hello</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for(let item of set.values()) &#123;</span><br><span class="line">      console.log(item) // 输出4，5，hello</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for(let item of set.entries()) &#123;</span><br><span class="line">      console.log(item) //[4,4],[5,5],[&apos;hello&apos;,&apos;hello&apos;]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>数组去重(常用)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let array = [0,1,1,2,2,5,5,66,99,65,65];</span><br><span class="line">console.log(Array.from(new Set(array))); //Array(7) [0, 1, 2, 5, 66, 99, 65]</span><br><span class="line">console.log([...new Set(array)]); //Array(7) [0, 1, 2, 5, 66, 99, 65]</span><br></pre></td></tr></table></figure>
<p>Map容器:Map是一组键值对(key-value，只取前两个元素。)的结构,key不重复</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a = new Map([[&apos;Michael&apos;, 95],[&quot;Bot&quot;,99]]</span><br><span class="line">m.set(&apos;Adam&apos;, 67); //添加新的key-value</span><br><span class="line">m.has(&apos;Adam&apos;);//是否存在key&quot;Adam&quot;  true</span><br><span class="line">m.get(&apos;Adam&apos;); //获得key为Adam的value  67</span><br><span class="line">m.delete(&apos;Adam&apos;);//删除key&quot;Adam&quot;</span><br><span class="line">m.clear() //清空Map容器</span><br></pre></td></tr></table></figure>
<p>一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉。</p>
<h2 id="ES7-16年发布"><a href="#ES7-16年发布" class="headerlink" title="ES7(16年发布)"></a>ES7(16年发布)</h2><h3 id="指数运算符-幂"><a href="#指数运算符-幂" class="headerlink" title="指数运算符(幂)**"></a>指数运算符(幂)**</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(3 ** 3);</span><br><span class="line">//3的3次方=27</span><br></pre></td></tr></table></figure>
<h3 id="Array-prototype-includes-value"><a href="#Array-prototype-includes-value" class="headerlink" title="Array.prototype.includes(value)"></a>Array.prototype.includes(value)</h3><p>字符串与数组都有includes方法，判断数组中是否包含指定的value</p>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>Proxy也就是在目标对象之前设置一层拦截，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p>
<p>Proxy的作用</p>
<ul>
<li>拦截和监视外部对对象的访问</li>
<li>降低函数或类的复杂度</li>
<li>在复杂操作前对操作进行校验或对所需资源进行管理</li>
</ul>
<p>语法：new Proxy(target,handler)</p>
<ul>
<li>target就是被设置一层拦截的对象，可以是任何类型的对象(包括原生数组，函数，甚至另一个代理)</li>
<li>handler是一个对象，用来定制拦截行为</li>
</ul>
<p><strong>Proxy一般和Reflect配套使用,前者拦截对象,后者返回拦截的结果,Proxy上有的的拦截方法Reflect都有</strong></p>
<p><img src="/img/js/Proxy.png" width="50%"></p>
<p>1.set/get方法</p>
<p>set方法接收两个常用参数</p>
<ul>
<li>target：得到的目标值</li>
<li>key：目标的key值，相当于对象的属性</li>
</ul>
<p>set方法可以接收四个参数</p>
<ul>
<li>target:目标值。</li>
<li>key：目标的Key值。</li>
<li>value：要改变的值。</li>
<li>receiver：改变前的原始值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let handler = &#123;</span><br><span class="line">    get:function (target,key) &#123;</span><br><span class="line">        if (target.hasOwnProperty(key))&#123;</span><br><span class="line">            return target[key]//key为属性名，target[key]为属性值</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            console.warn(`对不起，没有这个$&#123;key&#125;`)</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    set:function (target,key,value) &#123;</span><br><span class="line">        console.log(&quot;set&quot;,target,key,value);</span><br><span class="line">        target[key] =value //设置了p.a才打印1</span><br><span class="line">    &#125;,</span><br><span class="line">    //删除属性</span><br><span class="line">    deleteProperty:function (target,key) &#123;</span><br><span class="line">        console.log(`删除$&#123;key&#125;属性的$&#123;target[key]&#125;值`);</span><br><span class="line">        delete target[key]</span><br><span class="line">    &#125;,</span><br><span class="line">    // 拦截key in object操作</span><br><span class="line">    has(target, key) &#123;</span><br><span class="line">        // 自定义限制：只暴露a属性</span><br><span class="line">        if (key === &apos;a&apos;) &#123;</span><br><span class="line">            return target[key];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">let p = new Proxy(&#123;&#125;,handler)</span><br><span class="line">p.a=1 //set &#123;&#125; a 1</span><br><span class="line">p.b=2</span><br><span class="line">console.log(&apos;b&apos; in p); // false,没有暴露</span><br><span class="line">console.log(&apos;a&apos; in p); //true</span><br><span class="line">//console.log(p.a);</span><br><span class="line">//delete p.b //删除了b属性的2值</span><br><span class="line">//console.log(p.b); //undefined</span><br></pre></td></tr></table></figure>
<p>可以使用Proxy实现表单验证。</p>
<p>Object.defineProperty也可以实现数据拦截，Proxy有什么优势吗？<br>1.支持数组<br>数组的key是下标，对象的key是属性名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3]</span><br><span class="line">let proxy = new Proxy(arr, &#123;</span><br><span class="line">    get (target, key, receiver) &#123;</span><br><span class="line">        console.log(&apos;get&apos;, key)</span><br><span class="line">        return Reflect.get(target, key, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    set (target, key, value, receiver) &#123;</span><br><span class="line">        console.log(&apos;set&apos;, key, value)</span><br><span class="line">        return Reflect.set(target, key, value, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.push(4)</span><br><span class="line">// get push     (寻找 proxy.push 方法)</span><br><span class="line">// get length   (获取当前的 length)</span><br><span class="line">// set 3 4      (设置 proxy[3] = 4)</span><br><span class="line">// set length 4 (设置 proxy.length = 4)</span><br></pre></td></tr></table></figure></p>
<p>2.Object.defineProperty()的升级版</p>
<p>外界对某个对象的访问，都必须经过这层拦截。因此它是针对整个对象，而不是对象的某个属性。</p>
<h2 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h2><h3 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h3><ul>
<li>JSON.stringify(obj/arr):js对象(数组)转换为json对象</li>
<li>JSON.parse(json):json对象(数组)转换为js对象(数组)</li>
</ul>
<h3 id="Object扩展"><a href="#Object扩展" class="headerlink" title="Object扩展"></a>Object扩展</h3><h4 id="Object-create-prototype-descriptors"><a href="#Object-create-prototype-descriptors" class="headerlink" title="Object.create(prototype,[descriptors])"></a>Object.create(prototype,[descriptors])</h4><p>作用：以指定对象为原型创建新的对象。为新的对象指定新的属性，并对属性进行描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;name:&quot;ranan&quot;,age:2&#125;</span><br><span class="line">//第一个参数指定原型，第二参数为实列添加属性</span><br><span class="line">let obj1 = Object.create(obj,&#123;sex:&#123;</span><br><span class="line">    value:&quot;女&quot;,//value指定值</span><br><span class="line">    writable:true,//标识当前属性是否可以被删除，默认为false</span><br><span class="line">    configurable:true,//表示当前属性是否可以被删除，默认为false</span><br><span class="line">    enumerable:true,//标识当前属性是否能用for-in枚举，默认false</span><br><span class="line">    &#125;&#125;)</span><br><span class="line">console.log(obj1);</span><br></pre></td></tr></table></figure>
<p>克隆保持原型链<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function clone(origin) &#123;</span><br><span class="line">  //Object.getPrototypeOf方法返回指定对象的原型（内部[[Prototype]]属性的值）</span><br><span class="line">  let originProto = Object.getPrototypeOf(origin);</span><br><span class="line">  //Object.create方法创建一个新对象，originProto为原型创建新对象</span><br><span class="line">  return Object.assign(Object.create(originProto), origin);</span><br></pre></td></tr></table></figure></p>
<h4 id="Object-defineProperties-object-descriptors"><a href="#Object-defineProperties-object-descriptors" class="headerlink" title="Object.defineProperties(object,descriptors)"></a>Object.defineProperties(object,descriptors)</h4><p>作用:为指定的object对象扩展多个属性<br>一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。如果不指定configurable, writable, enumerable ，则这些属性默认值为false，如果不指定value, get, set，则这些属性默认值为undefined。</p>
<p>Object的defineProperty/defineProperties主要功能就是用来定义或修改这些内部属性,getOwnPropertyDescriptor/getOwnPropertyDescriptors就是获取这行内部属性的描述。</p>
<p>语法: Object.defineProperty(obj, prop, descriptor)</p>
<p>obj: 需要被操作的目标对象<br>prop: 目标对象需要定义或修改的属性的名称<br>descriptor: 将被定义或修改的属性的描述符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object();</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj, &apos;name&apos;, &#123;</span><br><span class="line">    configurable: false,</span><br><span class="line">    writable: true,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    value: &apos;张三&apos;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(obj.name)  //张三</span><br></pre></td></tr></table></figure>
<p>语法: Object.defineProperties(obj, props)</p>
<p>obj: 将要被添加属性或修改属性的对象<br>props: 该对象的一个或多个键值对定义了将要为对象添加或修改的属性的具体配置</p>
<p>方法直接在一个对象上定义一个或多个新的属性或修改现有属性，并返回该对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object();</span><br><span class="line">Object.defineProperties(obj, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: &apos;张三&apos;,</span><br><span class="line">        configurable: false,</span><br><span class="line">        writable: true,</span><br><span class="line">        enumerable: true</span><br><span class="line">    &#125;,</span><br><span class="line">    age: &#123;</span><br><span class="line">        value: 18,</span><br><span class="line">        configurable: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(obj.name, obj.age) // 张三, 18</span><br></pre></td></tr></table></figure>
<p>该方法的存储器属性(setter,getter)可以实现简单的数据双向绑定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">   &lt;input type=&quot;text&quot; id=&quot;input1&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    上面输入的数据是</span><br><span class="line">    &lt;span id=&quot;span&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">    let oInput1 = document.getElementById(&apos;input1&apos;);</span><br><span class="line">    let oSpan = document.getElementById(&apos;span&apos;);</span><br><span class="line">    let obj = &#123;&#125;;</span><br><span class="line">    Object.defineProperties(obj, &#123;</span><br><span class="line">    //惰性求值，get之后才有值</span><br><span class="line">        val1: &#123;</span><br><span class="line">            configurable: true,//可修改</span><br><span class="line">            get: function() &#123;</span><br><span class="line">                oInput1.value = 0;</span><br><span class="line">                oSpan.innerHTML = 0;</span><br><span class="line">                return 0</span><br><span class="line">            &#125;,</span><br><span class="line">            set: function(newValue) &#123;</span><br><span class="line">                oSpan.innerHTML = newValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    //设置默认值为0 调用get方法</span><br><span class="line">    oInput1.value = obj.val1;</span><br><span class="line">    oInput1.addEventListener(&apos;keyup&apos;, function() &#123;</span><br><span class="line">        //调用set方法</span><br><span class="line">        obj.val1 = oInput1.value;</span><br><span class="line">    &#125;, false)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="get-set-propertyName"><a href="#get-set-propertyName" class="headerlink" title="get/set propertyName(){}"></a>get/set propertyName(){}</h4><p>对象本身的两个方法，用法和上面的get/set一样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;firstName:&quot;xx&quot;,lastName:&quot;xx&quot;, get fullName()&#123;</span><br><span class="line">return this.firstName+ this.lastName</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Array扩展"><a href="#Array扩展" class="headerlink" title="Array扩展"></a>Array扩展</h3><h4 id="Array-prototype-indexOf-value-lastIndexOf-value"><a href="#Array-prototype-indexOf-value-lastIndexOf-value" class="headerlink" title="Array.prototype.indexOf(value)/lastIndexOf(value)"></a>Array.prototype.indexOf(value)/lastIndexOf(value)</h4><p>返回value在数组中出现的第一个下标和最后一下下标，没有出现则返回-1</p>
<p>应用场景：<br>两个方法结合判断下标是否相等，可以用来判断数组中唯一出现的值</p>
<h4 id="Array-prototype-forEach"><a href="#Array-prototype-forEach" class="headerlink" title="Array.prototype.forEach()"></a>Array.prototype.forEach()</h4><p>遍历数组,前面介绍for-of时介绍了此方法的用法，这里就不介绍了。</p>
<h4 id="Array-prototype-map"><a href="#Array-prototype-map" class="headerlink" title="Array.prototype.map()"></a>Array.prototype.map()</h4><p>遍历数组返回一个新的加工后之后的数组，不改变原数组的值</p>
<h4 id="Array-prototype-filter"><a href="#Array-prototype-filter" class="headerlink" title="Array.prototype.filter()"></a>Array.prototype.filter()</h4><p>遍历过滤出一个新的子数组，不改变原数组，返回条件为true的值</p>
<p><a href="https://biubiuins.github.io/2019/07/04/js%E7%9A%84%E9%81%8D%E5%8E%86/" target="_blank" rel="noopener">遍历方法的总结</a></p>
<h3 id="Function扩展"><a href="#Function扩展" class="headerlink" title="Function扩展"></a>Function扩展</h3><h4 id="bind-、call-、apple-的区别"><a href="#bind-、call-、apple-的区别" class="headerlink" title="bind()、call()、apple()的区别"></a>bind()、call()、apple()的区别</h4><ul>
<li>都能指定函数中的this</li>
<li>Array.prototype.call()/Array.prototype.apply()是立即调用函数，Array.prototype.bind()是将函数返回</li>
<li>Array.prototype.call(obj)/Array.prototype.bind()从第二个参数开始依次传，Array.prototype.apply(obj)第二个参数是数组，传入的数据放入数组中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let obj =&#123;name:&quot;ranan&quot;&#125;</span><br><span class="line">function f(data,data2) &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">    console.log(data + data2);</span><br><span class="line">    return data+data2</span><br><span class="line">&#125;</span><br><span class="line">f.call(obj,33,22) //&#123;name:&quot;ranan&quot;&#125; 55</span><br><span class="line">f.apply(obj,[33,22])//&#123;name:&quot;ranan&quot;&#125; 55</span><br><span class="line">let bar=f.bind(obj) //bind不调用函数</span><br><span class="line">bar(33,22)//&#123;name:&quot;ranan&quot;&#125; 55</span><br><span class="line"></span><br><span class="line">//上面也可以写成</span><br><span class="line">f.bind(obj)(33,22)//&#123;name:&quot;ranan&quot;&#125; 55</span><br></pre></td></tr></table></figure>
<h4 id="Function-prototype-bind-obj"><a href="#Function-prototype-bind-obj" class="headerlink" title="Function.prototype.bind(obj)"></a>Function.prototype.bind(obj)</h4><p>作用:将函数内的this绑定为obj，并将函数返回(并不调用)</p>
<ul>
<li>返回原函数的拷贝，我们称这个拷贝的函数为绑定函数。</li>
<li>将函数中的this固定为调用bind方法时的第一个参数，</li>
<li>绑定this之后，无论有哪个对象调用绑定函数，绑定函数中的this依旧之前绑定的第一个参数</li>
<li><p>如果绑定函数作为构造函数，已经捆绑的this会被忽略掉，this依然指向实例对象</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line"> &#125;</span><br><span class="line">var bindPerson = Person.bind(&#123;name:&quot;绑定函数&quot;&#125;)</span><br><span class="line">new bindPerson(&quot;张三&quot;)          // Person &#123;name: &quot;张三&quot;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>通常用于指定回调函数的this，因为apply与call会立即调用</p>
<p><strong>使用场景</strong><br>保持上下文的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var o=&#123;</span><br><span class="line">    f: function () &#123;</span><br><span class="line">        var self=this;</span><br><span class="line">        var fff=function() &#123;</span><br><span class="line">            console.log(this.value); // bind(this) 中 this 指向的是o，这里也可直接写成 bind(o)</span><br><span class="line">        &#125;.bind(this);</span><br><span class="line">        fff();</span><br><span class="line">    &#125;,</span><br><span class="line">    value: &quot;Hello World!&quot;</span><br><span class="line">&#125;;</span><br><span class="line">o.f(); // Hello World！</span><br></pre></td></tr></table></figure>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>
    </div>
</div>
    </div>
</div>


<!--<footer class="footer">-->
    <!--<ul class="list-inline text-center">-->
        <!---->
        <!---->

        <!---->

        <!---->

        <!---->

        <!---->

    <!--</ul>-->
    <!---->
    <!--<p>-->
        <!--<span id="busuanzi_container_site_pv">-->
            <!--<span id="busuanzi_value_site_pv"></span>PV-->
        <!--</span>-->
        <!--<span id="busuanzi_container_site_uv">-->
            <!--<span id="busuanzi_value_site_uv"></span>UV-->
        <!--</span>-->
        <!--Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>-->
<!--</footer>-->




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.xml"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


</html>
