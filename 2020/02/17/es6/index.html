<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="biubiu的博客">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        es6 - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i>  </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <span>biubiu</span>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>HOME</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>TAGS</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>ARCHIVES</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>ABOUT</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>SEARCH</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#let-const"><span class="toc-text">let/const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量的解构赋值"><span class="toc-text">变量的解构赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模板字符串"><span class="toc-text">模板字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象属性-方法简写"><span class="toc-text">对象属性/方法简写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#箭头函数"><span class="toc-text">箭头函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三点运算符"><span class="toc-text">三点运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#形参默认值"><span class="toc-text">形参默认值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise对象"><span class="toc-text">Promise对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Symbol"><span class="toc-text">Symbol</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iterator迭代器"><span class="toc-text">iterator迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#for-of"><span class="toc-text">for..of</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generator函数"><span class="toc-text">Generator函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async函数"><span class="toc-text">async函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class"><span class="toc-text">class</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">search</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i>  </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        es6
    </div>

    <div class="post-meta">
        <span class="attr">Post：<span>2020-02-17 12:51:14</span></span>
        
        <span class="attr">Tags：/
        
        <a class="tag" href="/tags/#学习笔记" title="学习笔记">学习笔记</a>
        <span>/</span>
        
        <a class="tag" href="/tags/#javascript" title="javascript">javascript</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">Visit：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        <h2 id="let-const"><a href="#let-const" class="headerlink" title="let/const"></a>let/const</h2><p>特点:</p>
<ul>
<li>不能重复定义</li>
<li>在块级作用域内有效</li>
<li>不会预处理，不存在变量提升</li>
<li>const不可以被修改，声明时必须赋值</li>
</ul>
<p>预处理：声明<code>var</code>后的变量但并不赋值(undefined)，声明<code>function</code>。因此使用let/const定义的变量在没声明前是无法使用的。</p>
<p>在循环使用中常用。如下述代码，结果会全部输出2，原因是：点击事件是回调函数进入队列，等同步执行的代码执行完毕之后，再执行。以前常用的解决办法是使用闭包。es6中的let也可以解决这个问题，因为let有自己的块级作用域，使用i值的时候，仅当次循环有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//html</span><br><span class="line">  &lt;button&gt;测试1&lt;/button&gt;</span><br><span class="line">  &lt;button&gt;测试2&lt;/button&gt;</span><br><span class="line">  &lt;button&gt;测试3&lt;/button&gt;</span><br><span class="line">//js</span><br><span class="line">   let btns = document.getElementsByTagName(&quot;button&quot;);</span><br><span class="line">   for (var i = 0;i&lt;btns.length;i++) &#123;</span><br><span class="line">   var btn = btns[i];</span><br><span class="line">    btn.onclick =function () &#123;</span><br><span class="line">      alert(i)</span><br><span class="line">        &#125;</span><br><span class="line">//js 闭包解决办法</span><br><span class="line">    let btns = document.getElementsByTagName(&quot;button&quot;);</span><br><span class="line">     for (var i = 0;i&lt;btns.length;i++) &#123;</span><br><span class="line">     var btn = btns[i];</span><br><span class="line">     (function (i) &#123;</span><br><span class="line">      btn.onclick =function () &#123;</span><br><span class="line">      alert(i)</span><br><span class="line">        &#125;</span><br><span class="line">       &#125;)(i)</span><br></pre></td></tr></table></figure>
<p>还有一点是let/const不属于顶层全局变量，不用担心污染全局的window对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = 0</span><br><span class="line">console.log(window.a)//undefined</span><br><span class="line">var b = 1</span><br><span class="line">console.log(window.b)//1</span><br></pre></td></tr></table></figure>
<h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><p>理解：从对象或数组中提取数据，并赋值给变量(多个)。<br>常用：对象的解构赋值。(后台返回的数据进行利用)</p>
<p>例：交换对象,解构的目标是数组，所以以数组的形式来接收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = 1</span><br><span class="line">let b = 2</span><br><span class="line">[a,b] = [b,a]</span><br><span class="line">//a=2 , b =1</span><br></pre></td></tr></table></figure>
<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>作用：简化字符串的拼接<br>使用：模板字符串必须用<code></code>包含，变化的部分使用${xxx}定义</p>
<h2 id="对象属性-方法简写"><a href="#对象属性-方法简写" class="headerlink" title="对象属性/方法简写"></a>对象属性/方法简写</h2><p>对象属性简写：当对象的属性和值相同时，省略属性名</p>
<p>注意点：</p>
<ul>
<li>省略的是属性名而不是值</li>
<li>必须是一个变量</li>
</ul>
<p>方法的简写：当对象的属性值是一个函数(即是一个方法)，可以使用简写形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//es5</span><br><span class="line">let obj =&#123;</span><br><span class="line"> func:function()&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//es6</span><br><span class="line">let obj2=&#123;</span><br><span class="line"> func()&#123;&#125;  //不太常用</span><br><span class="line"> func:()=&gt;&#123;&#125; //常用箭头函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>用处：常用在回调函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let a = ()=&gt;&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>形参</p>
<ul>
<li>只有一个形参的时候，()可以省略</li>
<li>其余时候，()不能省略</li>
</ul>
<p>函数体</p>
<ul>
<li>函数体内只有一条语句或者表达式，{}可省略，省略后自动return</li>
<li>其余情况不可以省略，并且需要返回值时，需要加上return</li>
</ul>
<p>注意：由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//报错</span><br><span class="line">let getTempItem = id =&gt; &#123; id, name: &quot;Temp&quot; &#125;;</span><br><span class="line">// 不报错</span><br><span class="line">let getTempItem = id =&gt; (&#123; id, name: &quot;Temp&quot; &#125;);</span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ul>
<li>箭头函数没有arguments，但是如果在箭头函数需要参数时，可以使用rest运算符来取代arguments</li>
<li>箭头函数没有prototype属性，不能用作构造函数（不能用new关键字调用）</li>
<li><p>箭头函数没有自己的this，箭头函数的this，不是调用的时候决定的(一般函数是由调用时决定)，而是在定义的时候所处在的对象就是他的this</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">name:箭头函数</span><br><span class="line">getName()&#123;</span><br><span class="line">btn2.onclick = ()=&gt;&#123;</span><br><span class="line">console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.getName()</span><br><span class="line"></span><br><span class="line">//输出obj</span><br><span class="line"></span><br><span class="line">   let obj = &#123;</span><br><span class="line">   name:箭头函数</span><br><span class="line">   getName:()=&gt;&#123;</span><br><span class="line">   btn2.onclick = ()=&gt;&#123;</span><br><span class="line">   console.log(this)</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   obj.getName()</span><br><span class="line">//输出window</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>理解</strong></p>
<ul>
<li>如果箭头函数外面有函数，则箭头函数的this同外层函数的this一样。</li>
<li>若外层没有函数，指向window。</li>
</ul>
<p>因此，箭头函数替代了以前需要显式的声明一个变量保存this的操作，使得代码更加的简洁。<br>还有一个好处在数组的迭代中使用箭头函数更加简洁，并且省略了return关键字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3]</span><br><span class="line">arr.filter (item=&gt; item === 2)//[2]</span><br><span class="line">arr.map(item =&gt; item*2 ) //[2,4,6]</span><br><span class="line">arr.reduce((acc,cur) = acc+cur) //6</span><br></pre></td></tr></table></figure>
<p>注意:不要在可能改变this指向的函数中使用箭头函数，类似Vue中的methods,computed中的方法,生命周期函数，Vue将这些函数的this绑定了当前组件的vm实例，如果使用箭头函数会强行改变this，因为箭头函数优先级最高（无法再使用call,apply,bind改变指向）</p>
<h2 id="三点运算符"><a href="#三点运算符" class="headerlink" title="三点运算符"></a>三点运算符</h2><p><code>...</code></p>
<p>剩余运算符：用来代替arguments，但比arguments灵活。</p>
<p>补充:arguments.callee()方法的意思是：调用函数本身。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo(...value)&#123; //收集传过来的2，65两个元素</span><br><span class="line">console.log(value)//输出[2,65]是一个真数组</span><br><span class="line">&#125;</span><br><span class="line">function foo(value)&#123;</span><br><span class="line">console.log(arguments)//2,65是一个伪数组</span><br><span class="line">&#125;</span><br><span class="line">foo(2,65)</span><br></pre></td></tr></table></figure>
<p>扩展运算符：只要含有iterator接口的数据结构都可以使用扩展运算符</p>
<blockquote>
<p>   扩展运算符可以和数组的解构赋值一起使用，但是必须放在最后一个，因为剩余/扩展运算符的原理其实是利用了数组的迭代器，它会消耗3个点后面的数组的所有迭代器，读取所有迭代器生成对象的value属性，剩余/扩展运算符后不能在有解构赋值，因为剩余/扩展运算符已经消耗了所有迭代器，而数组的解构赋值也是消耗迭代器，但是这个时候已经没有迭代器了，所以会报错</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let [first,...arr]=[1,2,3,4,5]//不会报错</span><br><span class="line">let[...arr,last] = [1,2,3,4,5] //报错</span><br></pre></td></tr></table></figure>
<p><strong>剩余运算符和扩展运算符的区别就是，剩余运算符会收集这些集合，放到右边的数组中，扩展运算符是将右边的数组拆分成元素的集合，它们是相反的</strong></p>
<h2 id="形参默认值"><a href="#形参默认值" class="headerlink" title="形参默认值"></a>形参默认值</h2><p>在定义函数时可以定义形参的默认值，当不传入参数的时候默认使用形参里的默认值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//定义形参默认值</span><br><span class="line">    function add(a=0,b=1) &#123;</span><br><span class="line">        return a+b</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(add());</span><br><span class="line">    //输出1</span><br></pre></td></tr></table></figure></p>
<h2 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h2><p>Promise是JS中进行异步编程的新的解决方案，之前是纯回调的方法。</p>
<p>回调函数的一些缺点:<br>1.多重嵌套，导致回调地狱<br>    Promise引入了链式调用的概念，每个then方法同样也是一个promise，所以可以链式调用下去。其次将异步操作以同步的流程表达出来，更方便阅读。<br>2.不清楚回调是否都是异步调用的（可以同步调用ajax，在收到响应前会阻塞整个线程，会陷入假死状态，非常不推荐）<br>3.第三方库可能没有提供错误处理<br>    Promise在异步请求发送错误的时候，即使没有捕获错误，也不会阻塞主线程的代码</p>
<p>更深入的内容，在之前的博客中<a href="https://biubiuins.github.io/2020/01/08/promise/" target="_blank" rel="noopener">Promise学习笔记</a></p>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>Symbol是ES6中添加的新的数据类型(原来的有：String，Number,Boolean,Object,Null(空对象指针),Undefined(声明的变量未被初始化时))</p>
<p>特点:</p>
<ul>
<li>Symbol属性对应的值是唯一的，解决命名冲突问题。(类似id)</li>
<li>Symbol值不能与其他数据进行计算，包括同字符串拼接</li>
<li>for in/for of遍历时不会遍历symbol属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//创建Symbol属性值</span><br><span class="line">let symbol = Symbol();</span><br><span class="line">//let symbol = Symbol(&apos;传一个标识&apos;);</span><br><span class="line">console.log(symbol) //输出Symbol</span><br><span class="line">//Symbol(&apos;传一个标识&apos;)</span><br><span class="line">let obj =&#123;</span><br><span class="line">name:&quot;ko&quot;,age:48</span><br><span class="line">&#125;</span><br><span class="line">obj[symbol]=&quot;男&quot;</span><br></pre></td></tr></table></figure>
<p>1.当symbol作为对象的属性时，用XX[Symbol]形式，不用XX.Symbol形式。<br>2.可以定义常量<br>3.除了自己定义使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部的使用方法。比如<code>Symbol.iterator</code>属性</p>
<h2 id="iterator迭代器"><a href="#iterator迭代器" class="headerlink" title="iterator迭代器"></a>iterator迭代器</h2><p>概念:iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制。iterator接口是解构赋值，三点运算符，生成器，<code>for-of</code>循环的基础，主要供<code>for-of</code>消费。</p>
<p>工作原理:<br>1.创建一个指针对象(遍历器对、iterator迭代器)，指向数据结构的起始位置。<br>2.第一次调用next方法，指针自动指向数据结构的第一个成员<br>3.接下来不断调用next方法，直到指向最后一个成员</p>
<p>注意：每次调用next方法返回的是一个包含value和done的对象{value:当前成员的值，done：布尔值}其中done对用的布尔值表示当前的数据的结构是否遍历结束。当遍历结束的时候返回的value值是undefined，done值为true</p>
<ul>
<li>可迭代的数据结构会有一个[Symbol.iterator]方法,</li>
<li>[Symbol.iterator]执行后返回一个iterator对象</li>
</ul>
<p>默认具有iterator接口的数据结构有以下几个，注意普通对象默认是没有iterator接口的（可以自己创建iterator接口让普通对象也可以迭代）</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray（类数组）</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象</li>
</ul>
<p>自定义部署iterator接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let targetData = &#123;</span><br><span class="line"> [Symbol.iterator]:function()&#123;</span><br><span class="line"> let nextIndex = 0 //记录指针的位置</span><br><span class="line"> return&#123;//遍历器对象</span><br><span class="line"> next:function()&#123;</span><br><span class="line"> return nextIndex &lt; this.length?&#123;value:this[nextIndex++],done:false&#125;:&#123;value:undefined,done:true&#125;&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="for-of"><a href="#for-of" class="headerlink" title="for..of"></a>for..of</h3><p>以前我们遍历数组中的元素的时，最开始使用的是for</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3]</span><br><span class="line">for(let i = 0;i&lt;arr.length;i++)&#123;</span><br><span class="line">console.log(arr[i])</span><br><span class="line">//输出1，2，3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自ES5之后，可以使用<code>forEach</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(function (value) &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">    //输出1，2，3</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>但是<code>foeEach</code>有两个缺点：<br>1.不能使用<code>break</code>语句中断循环<br>2.不能使用<code>return</code>语句返回到外层函数</p>
<p>ES6增加了<code>for-of</code>循坏，是现在简洁、最直接的遍历数组元素的语法。<code>for-in</code>不仅仅可以遍历数组，<strong>具有iterator接口的，都可以使用<code>for-of</code>进行遍历</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var value of arr) &#123;</span><br><span class="line">      console.log(value); // 1,2,3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与<code>for-in</code>的区别：<br>1.for-in 获取的是对象的键名<br>2.for-in会遍历对象的整个原型链,性能非常差不推荐使用,</p>
<h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><p>概念：ES6提供的解决异步编程的方案之一。</p>
<p>特点：<br>1.<code>function函数名*</code><br>2.内部用yield表达式来定义不同的状态<br>3.其返回值是一个Iterator迭代器（指针对象）</p>
<p>比如某个事物只有三种状态（状态A，状态B，状态C），而这三种状态的变化是 状态A =&gt; 状态B =&gt; 状态C =&gt; 状态A ，这就是状态机。Generator特别适用于处理这种状态机。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// A，B，C三种状态循环</span><br><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">state</span></span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(1)&#123;</span><br><span class="line">        yield <span class="string">'A'</span>;</span><br><span class="line">        yield <span class="string">'B'</span>;</span><br><span class="line">        yield <span class="string">'C'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> status = state();//返回的是指针对象</span><br><span class="line">//碰到yield返回</span><br><span class="line">console.log(status.next()); // 先暂停到A，后面的代码不执行，返回&#123;value: <span class="string">"A"</span>, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">console.log(status.next()); // 执行下一条指令，暂停到B，返回&#123;value: <span class="string">"B"</span>, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">console.log(status.next()); // &#123;value: <span class="string">"C"</span>, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">console.log(status.next()); // &#123;value: <span class="string">"A"</span>, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">console.log(status.next()); // &#123;value: <span class="string">"B"</span>, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure>
<p>Iterator迭代器遍历结束时，返回的是：{value: undefined, done: true},Generator函数可以使用return来改变最后的返回值</p>
<p>next传的参数可以作为启动yield(默认返回undefined)的返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function* state&#123;</span><br><span class="line">let result = yield &apos;hello&apos;</span><br><span class="line">console.log(result)//输出aaa</span><br><span class="line">&#125;</span><br><span class="line">state.next(&quot;aaa&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h2><p>本质:Generator语法糖，async取代Generator函数的星号*.await取代的是yield</p>
<p>ES7的async/await进一步的优化Promise的写法，async函数始终返回一个Promise，await可以实现一个”等待”的功能，async/await被称为异步编程的终极解决方案，即用同步的形式书写异步代码，并且能够更优雅的实现异步代码顺序执行。</p>
<p>补充一种更高级的写法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Promise(resolve=&gt;&#123;</span><br><span class="line">   setTimeout(()=&gt;&#123;</span><br><span class="line">   resolve() //第一个参数为函数，目的在与执行resolve</span><br><span class="line">   &#125;,2000)</span><br><span class="line"></span><br><span class="line">   //更高级的写法</span><br><span class="line">   setTimeout(resolve,2000)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>更深入的内容，在之前的博客中<a href="https://biubiuins.github.io/2020/01/08/promise/" target="_blank" rel="noopener">Promise学习笔记</a></p>
<h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2>
        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>
    </div>
</div>
    </div>
</div>


<!--<footer class="footer">-->
    <!--<ul class="list-inline text-center">-->
        <!---->
        <!---->

        <!---->

        <!---->

        <!---->

        <!---->

    <!--</ul>-->
    <!---->
    <!--<p>-->
        <!--<span id="busuanzi_container_site_pv">-->
            <!--<span id="busuanzi_value_site_pv"></span>PV-->
        <!--</span>-->
        <!--<span id="busuanzi_container_site_uv">-->
            <!--<span id="busuanzi_value_site_uv"></span>UV-->
        <!--</span>-->
        <!--Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>-->
<!--</footer>-->




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.xml"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


</html>
