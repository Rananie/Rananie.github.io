<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="biubiu的博客">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        拷贝 - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i>  </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <span>biubiu</span>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>HOME</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>TAGS</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>ARCHIVES</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>ABOUT</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>SEARCH</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#深拷贝浅拷贝"><span class="toc-text">深拷贝浅拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拷贝数据的方法"><span class="toc-text">拷贝数据的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何实现深拷贝？"><span class="toc-text">如何实现深拷贝？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何判断数据类型"><span class="toc-text">如何判断数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最终实现"><span class="toc-text">最终实现</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">search</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i>  </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        拷贝
    </div>

    <div class="post-meta">
        <span class="attr">Post：<span>2020-02-19 19:46:18</span></span>
        
        <span class="attr">Tags：/
        
        <a class="tag" href="/tags/#学习笔记" title="学习笔记">学习笔记</a>
        <span>/</span>
        
        <a class="tag" href="/tags/#javascript" title="javascript">javascript</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">Visit：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        <h2 id="深拷贝浅拷贝"><a href="#深拷贝浅拷贝" class="headerlink" title="深拷贝浅拷贝"></a>深拷贝浅拷贝</h2><p>深浅拷贝只是针对引用数据类型。</p>
<p><strong>js的数据类型</strong></p>
<p>基本数据类型： undefined、null、Boolean、Number、String和Symbol(ES6)<br>引用数据类型： Object(Array, Date, RegExp, Function)</p>
<p>浅拷贝：修改拷贝以后的数据会影响原数据，拷贝的引用。使得原数据不安全。<br>深拷贝：修改拷贝以后的数据不会影响原数据，拷贝的时候生成新数据。</p>
<h2 id="拷贝数据的方法"><a href="#拷贝数据的方法" class="headerlink" title="拷贝数据的方法"></a>拷贝数据的方法</h2><p>1.引用类型直接赋值是浅拷贝<br>2.Object.assign()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    a: &#123;</span><br><span class="line">        a1: &apos;a1&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    b: &apos;b&apos;</span><br><span class="line">&#125;</span><br><span class="line">let ass = Object.assign(&#123;&#125;, obj);</span><br><span class="line">ass.a.a1 = &apos;aaa&apos;;</span><br><span class="line">ass.b=&quot;c&quot;</span><br><span class="line">console.log(obj);</span><br><span class="line">/*</span><br><span class="line">输出：a:&#123;a1:&quot;aaa&quot;&#125;,</span><br><span class="line">      b:&quot;b&quot;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>说明: Obejct.assign()只能对一层进行深拷贝,如果拷贝的层数超过了一层的话，那么就会进行浅拷贝。</p>
<p>这种克隆方式，只能克隆原始对象自身的值，不能克隆它的继承值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function clone(origin) &#123;</span><br><span class="line">  return Object.assign(&#123;&#125;, origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要保持继承链。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function clone(origin) &#123;</span><br><span class="line">  //Object.getPrototypeOf方法返回指定对象的原型（内部[[Prototype]]属性的值）</span><br><span class="line">  let originProto = Object.getPrototypeOf(origin);</span><br><span class="line">  //Object.create方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。</span><br><span class="line">  return Object.assign(Object.create(originProto), origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.三点运算符<br>对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    a: &#123;</span><br><span class="line">        a1: &apos;a1&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    b: &apos;b&apos;</span><br><span class="line">&#125;</span><br><span class="line">let ass = &#123;...obj&#125;;</span><br><span class="line">ass.a.a1 = &apos;aaa&apos;;</span><br><span class="line">ass.b = &apos;bbb&apos;</span><br><span class="line">console.log(obj);</span><br><span class="line"> /*</span><br><span class="line">    输出：a:&#123;a1:&quot;aaa&quot;&#125;,</span><br><span class="line">          b:&quot;b&quot;</span><br><span class="line">    */</span><br></pre></td></tr></table></figure></p>
<p>说明:扩展运算符只能对一层进行深拷贝,如果拷贝的层数超过了一层的话，那么就会进行浅拷贝。</p>
<p>Object.assign(）和展开原算符对于深浅拷贝的结果是一样。</p>
<p>4.Array.prototype.concat()</p>
<p>concat() 方法用于连接两个或多个数组。<br>该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> let arr= [1,3,&#123;name:&apos;ran&apos;&#125;]</span><br><span class="line">   let arr2 = arr.concat()</span><br><span class="line">// arr2[1]=55  //输出[1，3，&#123;name:&apos;ran&apos;&#125;]</span><br><span class="line"> arr2[3].name = &apos;ke&apos;</span><br><span class="line"> console.log(arr);</span><br><span class="line"> //输出 [1,3,&#123;name:&apos;ke&apos;&#125;]</span><br></pre></td></tr></table></figure>
<p>遍历arr数组时得到arr数组的元素，把该元素赋值给arr2对应的位置，当遍历的元素是对象时，因为对象的赋值浅拷贝，所有会改变原来的值。</p>
<p>5.Array.prototype.slice(startindex,endindex)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr= [1,3,&#123;name:&apos;ran&apos;&#125;]</span><br><span class="line">let arr2 = arr.slice()</span><br><span class="line">arr2[1]=55</span><br><span class="line">arr2[2].name = &apos;ke&apos;</span><br><span class="line">console.log(arr); // 输出[1,3,&#123;name:&apos;ke&apos;&#125;]</span><br></pre></td></tr></table></figure>
<p>因此，slice和concat这两个方法，仅适用于对不包含引用对象的一维数组的深拷贝</p>
<p>6.JSON.parse(JSON.stringify()) 深拷贝</p>
<p>JSON.stringify()：将JavaScript对象转换为JSON字符串<br>JSON.parse()：可以将JSON字符串转为一个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr= [1,3,&#123;name:&apos;ran&apos;&#125;]</span><br><span class="line">  let arr2 = JSON.parse(JSON.stringify(arr))//在JSON.stringify()完成后，对象就转为了字符串，也就可以说实实在在的复制了一个值，不存在引用之说</span><br><span class="line">  arr2[1]=55</span><br><span class="line">  arr2[2].name = &apos;ke&apos;</span><br><span class="line">  console.log(arr);//输出[1,3,&#123;name:&apos;ran&apos;&#125;]</span><br></pre></td></tr></table></figure>
<p>缺点：拷贝有些对象会被忽略(undefined,symbol,function)也有可能导致原型链缺失。</p>
<p><strong>补充1</strong></p>
<table><tr><td bgcolor="pink">判断数组是否包含某对象，或者判断对象是否相等。(这个特别有用)</td></tr></table>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//判断数组是否包含某对象</span><br><span class="line">let data = [</span><br><span class="line">    &#123;name:&apos;echo&apos;&#125;,</span><br><span class="line">    &#123;name:&apos;听风是风&apos;&#125;,</span><br><span class="line">    &#123;name:&apos;天子笑&apos;&#125;,</span><br><span class="line">    ],</span><br><span class="line">    val = &#123;name:&apos;天子笑&apos;&#125;;</span><br><span class="line">JSON.stringify(data).indexOf(JSON.stringify(val)) !== -1;//true</span><br><span class="line"></span><br><span class="line">//判断两数组/对象是否相等</span><br><span class="line">let a = [1,2,3],</span><br><span class="line">    b = [1,2,3];</span><br><span class="line">JSON.stringify(a) === JSON.stringify(b);//true</span><br></pre></td></tr></table></figure>
<p><strong>补充2</strong></p>
<p>localStorage/sessionStorage默认只能存储字符串，而实际开发中，我们往往需要存储的数据多为对象类型，那么这里我们就可以在存储时利用json.stringify()将对象转为字符串，而在取缓存时，只需配合json.parse()转回对象即可</p>
<p><strong>补充3</strong><br>JSON.stringify()与toString()的区别，这两者虽然都可以将目标值转为字符串，但本质上还是有区别的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3];</span><br><span class="line">JSON.stringify(arr);//&apos;[1,2,3]&apos;</span><br><span class="line">arr.toString();//1,2,3</span><br></pre></td></tr></table></figure>
<p>JSON.stringify更对用于对象，toString()更对用于数组</p>
<p><a href="https://www.cnblogs.com/echolun/p/9631836.html" target="_blank" rel="noopener">参考文章</a></p>
<h2 id="如何实现深拷贝？"><a href="#如何实现深拷贝？" class="headerlink" title="如何实现深拷贝？"></a>如何实现深拷贝？</h2><p>拷贝的数据里面不能有引用类型。如果有，只要拿到的是基本数据类型，然后再去赋值，就可以实现深拷贝</p>
<h3 id="如何判断数据类型"><a href="#如何判断数据类型" class="headerlink" title="如何判断数据类型"></a>如何判断数据类型</h3><p><code>typeof</code>返回的数据类型:String,Number,Boolean,Undefined,Object(Array,null也是),Function，不能准确的确定数据的类型。</p>
<p><strong>1</strong> Object.prototype.toString.call()</p>
<p><code>Object.prototype.toString.call()</code>可以区分各种类型，但它无法区分自定义对象类型，自定义类型可以采用instanceof区分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.prototype.toString.call(&quot;jerry&quot;));//[object String]</span><br><span class="line">console.log(Object.prototype.toString.call(12));//[object Number]</span><br><span class="line">console.log(Object.prototype.toString.call(true));//[object Boolean]</span><br><span class="line">console.log(Object.prototype.toString.call(undefined));//[object Undefined]</span><br><span class="line">console.log(Object.prototype.toString.call(null));//[object Null]</span><br><span class="line">console.log(Object.prototype.toString.call(&#123;name: &quot;jerry&quot;&#125;));//[object Object]</span><br><span class="line">console.log(Object.prototype.toString.call(function()&#123;&#125;));//[object Function]</span><br><span class="line">console.log(Object.prototype.toString.call([]));//[object Array]</span><br><span class="line">console.log(Object.prototype.toString.call(new Date));//[object Date]</span><br><span class="line">console.log(Object.prototype.toString.call(/\d/));//[object RegExp]</span><br><span class="line">function Person()&#123;&#125;;</span><br><span class="line">console.log(Object.prototype.toString.call(new Person));//[object Object]</span><br></pre></td></tr></table></figure>
<p>那么为什么<code>Object.prototype.toString.call()</code>可以区分？</p>
<p>toString方法返回反映这个对象的字符串（除了null和undefined之外）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#123;name:&quot;张三&quot;&#125;.toString());//[object Object]</span><br><span class="line">console.log([1,2].toString());//1,2</span><br><span class="line">console.log(typeof [1,2].toString())//String</span><br></pre></td></tr></table></figure>
<p>obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？</p>
<p>因为toString为Object的原型方法，而Array ，function等类型作为Object的实例重写了toString方法，调用toString方法时，优先调用的是重写之后的toString方法，所以要使用Object原型上的toString才可以反映对象的具体类型。</p>
<p><a href="https://www.cnblogs.com/cangqinglang/p/9143308.html" target="_blank" rel="noopener">参考文章</a></p>
<p><strong>2</strong> 获取标识类</p>
<p>Object.prototype.toString.call()返回的是字符串类型的[object xxx],但是我们只需要后面的标识数据类型的xxx，可以使用Array的slice方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let data = [1,3]</span><br><span class="line">//slice包含开始的位置，不包含结束的位置，结束位置为-1</span><br><span class="line">console.log(Object.prototype.toString.call(data).slice(8,-1));//Array</span><br></pre></td></tr></table></figure>
<h3 id="最终实现"><a href="#最终实现" class="headerlink" title="最终实现"></a>最终实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//检测数据类型的功能函数</span><br><span class="line">function checkedType(target) &#123;</span><br><span class="line"> return Object.prototype.toString.call(target).slice(8,-1)</span><br><span class="line">&#125;</span><br><span class="line">//实现深度克隆 数组/对象</span><br><span class="line">function  clone(target) &#123;</span><br><span class="line">  let result,targetType=checkedType(target)</span><br><span class="line"></span><br><span class="line">    switch (targetType) &#123;</span><br><span class="line">    case &apos;Object&apos;:</span><br><span class="line">        result = &#123;&#125;;</span><br><span class="line">        break;</span><br><span class="line">    case &apos;Array&apos;:</span><br><span class="line">        result = []</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        return target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  //遍历，基本数据类型的赋值</span><br><span class="line">    for (let i in target)&#123;</span><br><span class="line">      //获取数据结构的每一项值</span><br><span class="line">      let value = target[i]</span><br><span class="line">      //判断目标结构里的每一值是否存在对象/数组</span><br><span class="line">       if (checkedType(value) === &apos;Object&apos; || checkedType(value) === &apos;Array&apos;)&#123;</span><br><span class="line">        //继续遍历获取到的value</span><br><span class="line">           result[i] = clone(value)</span><br><span class="line">       &#125;else &#123; //获取到的value值是基本的数据类型或者函数</span><br><span class="line">           result[i] = value</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>
    </div>
</div>
    </div>
</div>


<!--<footer class="footer">-->
    <!--<ul class="list-inline text-center">-->
        <!---->
        <!---->

        <!---->

        <!---->

        <!---->

        <!---->

    <!--</ul>-->
    <!---->
    <!--<p>-->
        <!--<span id="busuanzi_container_site_pv">-->
            <!--<span id="busuanzi_value_site_pv"></span>PV-->
        <!--</span>-->
        <!--<span id="busuanzi_container_site_uv">-->
            <!--<span id="busuanzi_value_site_uv"></span>UV-->
        <!--</span>-->
        <!--Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>-->
<!--</footer>-->




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.xml"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


</html>
