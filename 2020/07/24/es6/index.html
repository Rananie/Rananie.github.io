<!DOCTYPE html>
<html>
  
<head>
  <meta charset="utf-8">
  <meta name="author" content="Ranan" />
  
  
  <title>es6(含之后的版本) | Ranan的博客</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="前端,JavaScript,JavaScript," />
  

  
  <meta name="description" content="Ranan的博客">

  

  

  

  

  

  <script>
  // theme-ad's config script
  // it can be used in every script
  
  window.AD_CONFIG = {
    leancloud: {"appid":"Hyq9wkH495DgNHWhDQCOfQSp-gzGzoHsz","appkey":"WaR7nrzhliHj9aVwdQzkdlGd","comment":false,"count":false},
    welcome: {"enable":false,"interval":30},
    start_time: "2018-02-10",
    passwords: ["efe07af7441da2b69c4a41e42e73be4db47f66010a56900788a458354a7373ec", ],
    is_post: true,
    lock: false,
    author: "Ranan",
    share: {"twitter":false,"facebook":false,"weibo":false,"qq":false,"wechat":false},
    mathjax: false,
    page_type: "",
    root: "/"
  };
</script>

  <script src="/vendor/sha256.min.js"></script>
<script src="/js/auth.js"></script>
<script src="/js/index.js"></script>
<script src="/vendor/qrcode.min.js"></script>

  
    <link rel="icon" href="/images/favicon.ico">
    <link rel="apple-touch-icon" href="/images/touch-icon.png">
  

  <link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="stylesheet" href="/css/index.css">
<link rel="stylesheet" href="/styles/components/highlight/highlight.css">

  
</head>
  <body>
    <header class="site-header">
  <div class="site-header-brand">
    
      <span class="site-header-brand-title">
        <a href="/">Ranan</a>
      </span>
    
    
      <span class="site-header-brand-motto"> | 不能放弃思考</span>
    
  </div>
  <div class="site-header-right">
    <nav class="site-header-navigation">
      
        <a href="/" target="_self">首页</a>
      
        <a href="/archives/" target="_self">归档</a>
      
        <a href="/tags/" target="_self">标签</a>
      
        <a href="/categories/" target="_self">分类</a>
      
        <a href="/about/" target="_self">关于</a>
      
    </nav>
    <div class="site-header-btn">
      
        <a href="https://biubiuins.github.io/" target="_blank" id="site-github">
          <i class="fa fa-github-alt"></i>
        </a>
      
      <a href="javascript:void(0);" id="site-search">
        <i class="fa fa-search"></i>
      </a>
      <a href="javascript:void(0);" id="site-nav-btn">
        <i class="fa fa-ellipsis-v"></i>
      </a>
    </div>
  </div>
</header>
<nav class="table-content" id="site-nav">
  <div class="table-content-title">
    <span>导航</span>
  </div>
  <div class="table-content-main">
    <ol class="toc">
      
        <li class="toc-item">
          <a href="/" target="_self">
            首页
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/archives/" target="_self">
            归档
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/tags/" target="_self">
            标签
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/categories/" target="_self">
            分类
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/about/" target="_self">
            关于
          </a>
        </li>
      
    </ol>
  </div>
</nav>
<div id="site-process"></div>
    <main>
      
  <div class="passage">
  <div class="passage-meta">
    <span>
      <i class="fa fa-calendar"></i>2020-07-24
    </span>
    
      <span>
        | <a href="/categories/前端/"><i class="fa fa-bookmark"></i>前端</a>
      </span>
    
    
      <span>
        | <i class="fa fa-unlock-alt"></i>UNLOCK
      </span>
    
  </div>
  <h1 class="passage-title">
    es6(含之后的版本)
  </h1>
  
  <article class="passage-article">
    <h2 id="let-const"><a href="#let-const" class="headerlink" title="let/const"></a>let/const</h2><p>特点:</p>
<ul>
<li>不能重复定义</li>
<li>在块级作用域内有效,不影响作用域链</li>
<li>不存在变量提升</li>
<li>const不可以被修改，声明时必须赋值</li>
</ul>
<p>补充:<br>1.新增块级作用域：if、else\while、for后面的{}或者直接的{}<br>2.数组和对象常量的元素是可以修改的，因为常量地址是没有变化的。</p>
<p>变量的声明提前:使用var关键字声明的变量。会在所有的代码执行前被声明（但是不会赋值）<br>函数的声明提前：使用function 函数名{}声明的函数会在所有的代码执行前就被创建</p>
<p>使用let/const定义的变量在没声明前是无法使用的。</p>
<p>在循环使用中常用。如下述代码，结果会全部输出2，原因是：点击事件是回调函数进入队列，等同步执行的代码执行完毕之后，再执行,i是全局变量，此时的i已经是最后一次循环之后的i了。es6中的let也可以解决这个问题，因为let有自己的块级作用域，使用i值的时候，仅当次循环有用。</p>
<pre><code>//html
  &lt;button&gt;测试1&lt;/button&gt;
  &lt;button&gt;测试2&lt;/button&gt;
  &lt;button&gt;测试3&lt;/button&gt;
//js
   let btns = document.getElementsByTagName(&quot;button&quot;);
   for (var i = 0;i&lt;btns.length;i++) {
   var btn = btns[i];
    btn.onclick =function () {
      alert(i)
        }
      }
  //执行回调时此时的i已经是最后一次循环之后的i了    
 //{var i = 0} {var i = 1}   {var i = 2}          
</code></pre><p>还有一点是let/const<strong>不属于顶层全局变量</strong>，不用担心污染全局的window对象。</p>
<pre><code>let a = 0
console.log(window.a)//undefined
var b = 1
console.log(window.b)//1
</code></pre><h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><p>理解：从对象或数组中提取数据，并赋值给变量(多个)。<br>常用：函数形参对象的解构赋值。</p>
<p>例：交换对象,解构的目标是数组，所以以数组的形式来接收。</p>
<pre><code>let a = 1
let b = 2
[a,b] = [b,a]
//a=2 , b =1
</code></pre><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>作用：简化字符串的拼接<br>使用：模板字符串必须用<code></code>包含，变化的部分使用${xxx}定义</p>
<h2 id="对象属性-方法简写"><a href="#对象属性-方法简写" class="headerlink" title="对象属性/方法简写"></a>对象属性/方法简写</h2><p>对象属性简写：当对象的属性和值相同时，省略属性名</p>
<ul>
<li>省略的是属性名而不是值</li>
<li>必须是一个变量</li>
</ul>
<p>方法的简写：当对象的属性是一个方法，可以使用简写形式。</p>
<pre><code>//es5
let obj ={
 func:function(){}
 }
}

//es6
let obj2={
 func(){}  //不太常用
 func:()=&gt;{} //常用箭头函数
}

</code></pre><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p><a href="https://biubiuins.github.io/2020/07/24/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/" target="_blank" rel="noopener">箭头函数</a></p>
<h2 id="形参默认值"><a href="#形参默认值" class="headerlink" title="形参默认值"></a>形参默认值</h2><p>在定义函数时可以定义形参的默认值，当不传入参数的时候默认使用形参里的默认值。一般有默认值的形参放在最后。</p>
<pre><code>//定义形参默认值
function add(a=0,b=1) {
        return a+b
}
console.log(add());
//输出1
</code></pre><h2 id="…"><a href="#…" class="headerlink" title="…"></a>…</h2><p>rest参数<code>...</code> 把<strong>实参</strong>封装成数组，rest参数中的变量代表一个数组。主要用于形参，且rest参数之后不能有其他参数。<br>在ES9中，封装成对象也可以了。</p>
<p>剩余运算符：用来代替arguments，比arguments灵活。</p>
<p>补充:arguments.callee()方法的意思是：调用函数本身。</p>
<pre><code>function foo(...value){ //收集传过来的2，65两个元素
console.log(value)//输出[2,65]是一个真数组
}
function foo(value){
console.log(arguments)//2,65是一个伪数组
}
foo(2,65)
</code></pre><p>扩展运算符<code>...</code>将<strong>数组转换为逗号分割的参数序列</strong>，常用于函数调用<br>ES9中也可以将对象转换为逗号分割的参数序列。</p>
<blockquote>
<p>扩展运算符可以和数组的解构赋值一起使用，但是必须放在最后一个，因为剩余/扩展运算符的原理其实是利用了数组的迭代器，它会消耗3个点后面的数组的所有迭代器，读取所有迭代器生成对象的value属性，剩余/扩展运算符后不能在有解构赋值，因为剩余/扩展运算符已经消耗了所有迭代器，而数组的解构赋值也是消耗迭代器，但是这个时候已经没有迭代器了，所以会报错</p>
</blockquote>
<pre><code>let [first,...arr]=[1,2,3,4,5]//不会报错
let[...arr,last] = [1,2,3,4,5] //报错
</code></pre><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>Symbol主要用于解决ES5的对象属性名都是字符串，容易造成属性名的冲突问题。是一种类似于字符串的数据类型。</p>
<p>Symbol是ES6中添加的新的数据类型(原来的有：String，Number,Boolean,Object,Null(空对象指针),Undefined(声明的变量未被初始化时))</p>
<p>特点:</p>
<ul>
<li>Symbol的值是唯一的，解决命名冲突问题。(类似id)</li>
<li>Symbol值不能与其他数据进行计算，包括同字符串拼接</li>
<li>Symbol可以转化为布尔值</li>
<li>Symbol定义的对象属性不能用for/in 循环遍历，可以使用Reflect.ownKeys来获取对象的所有键名。</li>
</ul>
<pre><code>//创建Symbol，通过Symbol函数创建 
let symbol = Symbol();
console.log(symbol) //输出Symbol
//Symbol(&#39;对实例的描述&#39;),Symbol是唯一的与如何描述实例无关
//对实例进行描述，主要是用于控制台输出时容易区分
let s1 = Symbol(&quot;a&quot;)
let s2 = Symbol(&quot;a&quot;)
console.log(s1===s2) //false

//Symbol.for 创建
let s3 = Symbol.for(&quot;b&quot;)
let s4 = Symbol.for(&quot;b&quot;)
console.log(s3===s4) //true
</code></pre><p>symbol的作用场景就是给对象添加属性/方法</p>
<p>1.当symbol作为对象的属性时，用[Symbol]形式，不用XX.Symbol形式。并且在定义的时候也需要加中括号<br>2.除了自己定义使用的Symbol值以外，ES6还提供了11个内置的Symbol方法，比如<code>Symbol.iterator</code>属性</p>
<p><strong>Symbol.prototype.description</strong></p>
<p>获取创建symbol实例时对其的描述。</p>
<h2 id="iterator迭代器"><a href="#iterator迭代器" class="headerlink" title="iterator迭代器"></a>iterator迭代器</h2><p><a href="https://biubiuins.github.io/2020/07/26/%E8%BF%AD%E4%BB%A3%E5%99%A8/" target="_blank" rel="noopener">iterator迭代器</a></p>
<h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><p>概念：ES6提供的解决异步编程的方案之一。</p>
<p>特点：<br>1.写法:<code>function函数名*</code><br>2.内部用yield表达式来定义不同的状态<br>3.其返回值是一个Iterator迭代器（指针对象）<br>4.通过调用返回值的next()方法执行函数内部语句</p>
<p>比如某个事物只有三种状态（状态A，状态B，状态C），而这三种状态的变化是 状态A =&gt; 状态B =&gt; 状态C =&gt; 状态A ，这就是状态机。Generator特别适用于处理这种状态机。</p>
<pre><code class="bash">// A，B，C三种状态循环
function* state(){
    while(1){
        yield &#39;A&#39;;
        yield &#39;B&#39;;
        yield &#39;C&#39;;
    }
}  
let status = state();//返回的是指针对象,迭代器对象
//碰到yield返回
console.log(status.next()); // 先暂停到A，后面的代码不执行，返回{value: &quot;A&quot;, done: false}
console.log(status.next()); // 执行下一条指令，暂停到B，返回{value: &quot;B&quot;, done: false}
console.log(status.next()); // {value: &quot;C&quot;, done: false}
console.log(status.next()); // {value: &quot;A&quot;, done: false}
console.log(status.next()); // {value: &quot;B&quot;, done: false}

function* state(){
        yield &#39;A&#39;;
        yield &#39;B&#39;;
        yield &#39;C&#39;;
} 

for(let v of gen(){
 console.log(v) //输出A,B,C
})
</code></pre>
<p>Iterator迭代器遍历结束时，返回的是：{value: undefined, done: true},Generator函数可以使用return来改变最后的返回值</p>
<p>next传的参数可以作为yield语句(默认返回undefined)的返回值。<br>第一个next表示启动，第二个next对应的才是第一个yieId语句。</p>
<pre><code>function * state(){
    let result = yield &#39;hello&#39;
    console.log(result)//输出xxx
    }
    let iterator = state()
    iterator.next(&quot;aaa&quot;)
    iterator.next(&quot;xxx&quot;)
</code></pre><p><strong>实例</strong>如何实现异步</p>
<pre><code>//需求:1s 输出111，2s后输出 222，3s输出 333

//定时器方法
setTimeout(() =&gt; {
    console.log(111);
    setTimeout(() =&gt; {
        console.log(222);
        setTimeout(() =&gt; {
            console.log(333);
        }, 3000)
    }, 2000)
}, 1000)

//使用生成器函数
function one(){
    setTimeout(()=&gt;{
        console.log(111);
        iterator.next();
    },1000)
}

function two(){
    setTimeout(()=&gt;{
        console.log(111);
        iterator.next()
    },2000)
}

function three(){
    setTimeout(()=&gt;{
        console.log(111);
        iterator.next()
    },3000)
}

function * gen(){
    yield one();
    yield two();
    yield three();
}
//调用生成器函数
let iterator = gen()
</code></pre><h2 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h2><p>Promise是JS中进行异步编程的新的解决方案，之前是纯回调的方法。</p>
<p>回调函数的一些缺点:<br>1.多重嵌套，导致回调地狱<br>    Promise引入了链式调用的概念，每个then方法同样也是一个promise，所以可以链式调用下去。其次将异步操作以同步的流程表达出来，更方便阅读。<br>2.不清楚回调是否都是异步调用的（可以同步调用ajax，在收到响应前会阻塞整个线程，会陷入假死状态，非常不推荐）<br>3.第三方库可能没有提供错误处理<br>    Promise在异步请求发送错误的时候，即使没有捕获错误，也不会阻塞主线程的代码</p>
<p>更深入的内容，在之前的博客中<a href="https://biubiuins.github.io/2020/01/08/promise/" target="_blank" rel="noopener">Promise学习笔记</a></p>
<h2 id="Set-Map容器"><a href="#Set-Map容器" class="headerlink" title="Set/Map容器"></a>Set/Map容器</h2><p>Set容器：无序不可重复的多个value的集合体,<strong>类似数组</strong>但成员唯一，集合实现了iterator接口。</p>
<ul>
<li>new Set(array)创建方法</li>
<li>add(value)添加方法</li>
<li>delete(value)删除方法</li>
<li>has(value)判断是否存在方法</li>
<li>clear()清空方法</li>
</ul>
<pre><code>let set = new Set([1,3,2,2])
console.log(set);//输出唯一出现的值

//add(value)添加方法
set.add(7)
console.log(set.size,set)//set.size相当于数组的length
</code></pre><p><strong>遍历</strong><br>可以使用Set/Map<strong>实例对象</strong>的keys()，values()，entries()方法进行遍历。<br>由于Set的键名和键值是同一个值，它的每一个元素的key和value是相同的，所有keys()和values()的返回值是相同的，entries()返回的元素中的key和value是相同的。</p>
<pre><code>  let set = new Set([4, 5, &#39;hello&#39;])
    for(let item of set.keys()) {
        console.log(item) //输出4，5，hello
    }

    for(let item of set.values()) {
        console.log(item) // 输出4，5，hello
    }

    for(let item of set.entries()) {
        console.log(item) //[4,4],[5,5],[&#39;hello&#39;,&#39;hello&#39;]
    }
</code></pre><p>Map容器:Map是一组键值对(key-value，只取前两个元素。)的结构,key不重复。</p>
<pre><code>let a = new Map()
m.set(&#39;Adam&#39;, 67); //添加新的key-value
m.has(&#39;Adam&#39;);//是否存在key&quot;Adam&quot;  true
m.get(&#39;Adam&#39;); //获得key为Adam的value  67
m.delete(&#39;Adam&#39;);//删除key&quot;Adam&quot;
m.clear() //清空Map容器
</code></pre><p>一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉。</p>
<h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p><a href="https://biubiuins.github.io/2020/07/26/class%E7%B1%BB/" target="_blank" rel="noopener">class类</a></p>
<h2 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h2><p>Number.EPSILON 属性的值表示JavaScript里面的最小值</p>
<p><strong>进制表示法</strong><br>二进制用0b，八进制用0o</p>
<pre><code>console.log(0b1010);//输出10
</code></pre><p><strong>Number.isFinite(i)</strong></p>
<p>判断i是否有限大的数<br>返回值：是true,否false</p>
<pre><code>Number.isFinite(Infinity)//false
</code></pre><p><strong>Number.isNaN(i)</strong></p>
<p>判断i是否NaN<br>返回值：是true,否false</p>
<p><strong>Number.isInteger(i)</strong></p>
<p>判断i是否整数<br>返回值：是true,否false</p>
<pre><code>Number.isInteger(120.0)//true
</code></pre><p><strong>Number.parseInt(str)</strong></p>
<p>将字符串转换为对应的数值<br>返回值：对应的数值</p>
<p><strong>Math.trunc(i)</strong></p>
<p>直接i的去除小数部分<br>返回值:整数部分</p>
<p><strong>Math.sign(i)</strong></p>
<p>判断i是正数、负数、还是零</p>
<p><strong>指数运算符(幂)</strong></p>
<pre><code>  console.log(3 ** 3);
  //3的3次方=27
</code></pre><p><strong>BigInt</strong></p>
<p>在普通数据后面加上n，数据类型是大整型。用于很大的数值运算，只能大整型与大整型运算。</p>
<pre><code>//创建大整型
let n = 521n
//正数转化成大整型
let n = 123
console.log(BigInt(n)) //输出123n

</code></pre><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>模块功能主要由两个命令构成<br>export 命令用于规定模块的对外接口<br>import 命令用于输入其他模块提供的功能</p>
<pre><code>//分别暴露
export let name = &quot;ranan&quot;
export let fun = function(){}
//统一暴露
export {name,fun}
//默认暴露
export default {
   name : &quot;ranan&quot; ,
   fun : function(){}
}

//通用导入的方式 as 别名 from 地址
import * as data from &quot;path&quot; 
//如果是默认暴露方式，使用时应该是
data.default.fun()
//解构赋值形式,如果重复了可以使用as别名
import {name,fun} from &quot;path&quot;
import {name as na,function} from &quot;path&quot;
//默认暴露的写法，必须要写别名
import {default as data} from &quot;path&quot; 
//简便形式 针对默认暴露
import data from &quot;path&quot;
console.log(data) //输出{name : &quot;ranan&quot; ,fun : functio(){}}
</code></pre><p><strong>动态import加载</strong></p>
<p>实现懒加载/按需加载,使用import()函数，返回值是promise对象,pormise返回的成功值就是暴露的对象。</p>
<pre><code>import(path).then(data =&gt; data.xx)
</code></pre><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>Proxy也就是在目标对象之前设置一层拦截，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p>
<p>Proxy的作用</p>
<ul>
<li>拦截和监视外部对对象的访问</li>
<li>降低函数或类的复杂度</li>
<li>在复杂操作前对操作进行校验或对所需资源进行管理</li>
</ul>
<p>语法：new Proxy(target,handler)</p>
<ul>
<li>target就是被设置一层拦截的对象，可以是任何类型的对象(包括原生数组，函数，甚至另一个代理)</li>
<li>handler是一个对象，用来定制拦截行为</li>
</ul>
<p><strong>Proxy一般和Reflect配套使用,前者拦截对象,后者返回拦截的结果,Proxy上有的的拦截方法Reflect都有</strong></p>
<p><img src="/img/js/Proxy.png" width="50%"></p>
<p>1.set/get方法</p>
<p>set方法接收两个常用参数</p>
<ul>
<li>target：得到的目标值</li>
<li>key：目标的key值，相当于对象的属性</li>
</ul>
<p>set方法可以接收四个参数</p>
<ul>
<li>target:目标值。</li>
<li>key：目标的Key值。</li>
<li>value：要改变的值。</li>
<li>receiver：改变前的原始值。</li>
</ul>
<pre><code>
    let handler = {
        get:function (target,key) {
            if (target.hasOwnProperty(key)){
                return target[key]//key为属性名，target[key]为属性值
            }
            else{
                console.warn(`对不起，没有这个${key}`)
                return
            }
        },
        set:function (target,key,value) {
            console.log(&quot;set&quot;,target,key,value);
            target[key] =value //设置了p.a才打印1
        },
        //删除属性
        deleteProperty:function (target,key) {
            console.log(`删除${key}属性的${target[key]}值`);
            delete target[key]
        },
        // 拦截key in object操作
        has(target, key) {
            // 自定义限制：只暴露a属性
            if (key === &#39;a&#39;) {
                return target[key];
            } else {
                return false;
            }
        },

    }
    let p = new Proxy({},handler)
    p.a=1 //set {} a 1
    p.b=2
    console.log(&#39;b&#39; in p); // false,没有暴露
    console.log(&#39;a&#39; in p); //true
    //console.log(p.a);
    //delete p.b //删除了b属性的2值
    //console.log(p.b); //undefined
</code></pre><p>可以使用Proxy实现表单验证。</p>
<p>Object.defineProperty也可以实现数据拦截，Proxy有什么优势吗？<br>1.支持数组<br>数组的key是下标，对象的key是属性名</p>
<pre><code>    let arr = [1,2,3]
    let proxy = new Proxy(arr, {
        get (target, key, receiver) {
            console.log(&#39;get&#39;, key)
            return Reflect.get(target, key, receiver)
        },
        set (target, key, value, receiver) {
            console.log(&#39;set&#39;, key, value)
            return Reflect.set(target, key, value, receiver)
        }
    })
    proxy.push(4)
    // get push     (寻找 proxy.push 方法)
    // get length   (获取当前的 length)
    // set 3 4      (设置 proxy[3] = 4)
    // set length 4 (设置 proxy.length = 4)
</code></pre><p>2.Object.defineProperty()的升级版</p>
<p>外界对某个对象的访问，都必须经过这层拦截。因此它是针对整个对象，而不是对象的某个属性。</p>
<h2 id="可选链操作符"><a href="#可选链操作符" class="headerlink" title="可选链操作符"></a>可选链操作符</h2><p>可选链操作符<code>?.</code>允许读取一个被连接对象的深层次的属性的值而无需明确校验链条上每一个引用的有效性，类似<code>.</code>运算。<br><code>.</code>:如果对象链.上有数据为null或undefiend，操作符会抛出一个错误<br><code>?.</code>:如果对象链上有数据为null或undefiend，操作符则会按照短路计算的方式进行处理，返回 undefined。</p>
<p>比如读取一个对象的深层属性</p>
<pre><code>const obj = {
  foo: {
    bar: {
      baz: 42,
      fun: ()=&gt;{}
    },
  },
};

// 不使用?.  需要层层判断防止报错
let baz = obj &amp;&amp; obj.foo &amp;&amp; obj.foo.bar &amp;&amp; obj.foo.bar.baz;

// 使用?.  不需要层层判断
let baz = obj?.foo?.bar?.baz; // 结果：42
</code></pre><h2 id="绝对全局对象globalThis"><a href="#绝对全局对象globalThis" class="headerlink" title="绝对全局对象globalThis"></a>绝对全局对象globalThis</h2><p>不管是浏览器还是nodejs还是其他环境，<code>globalThis</code>永远表示全局对象，比如浏览器环境表示window，nodejs下表示global</p>

  </article>
  <aside class="table-content" id="site-toc">
  <div class="table-content-title">
    <i class="fa fa-arrow-right fa-lg" id="site-toc-hide-btn"></i>
    <span>目录</span>
  </div>
  <div class="table-content-main">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#let-const"><span class="toc-text">let/const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量的解构赋值"><span class="toc-text">变量的解构赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模板字符串"><span class="toc-text">模板字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象属性-方法简写"><span class="toc-text">对象属性/方法简写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#箭头函数"><span class="toc-text">箭头函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#形参默认值"><span class="toc-text">形参默认值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#…"><span class="toc-text">…</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Symbol"><span class="toc-text">Symbol</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iterator迭代器"><span class="toc-text">iterator迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generator函数"><span class="toc-text">Generator函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise对象"><span class="toc-text">Promise对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set-Map容器"><span class="toc-text">Set/Map容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class"><span class="toc-text">class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数值扩展"><span class="toc-text">数值扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模块化"><span class="toc-text">模块化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proxy"><span class="toc-text">Proxy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可选链操作符"><span class="toc-text">可选链操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#绝对全局对象globalThis"><span class="toc-text">绝对全局对象globalThis</span></a></li></ol>
  </div>
</aside>
  
  
    <div class="passage-tags">
     
      <a href="/tags/JavaScript/"><i class="fa fa-tags"></i>JavaScript</a>
    
    </div>
  
</div>

    </main>
    
    <div class="site-footer-wrapper">
  <footer class="site-footer">
    
    <!--<div class="site-footer-info">-->
      <!--<i class="fa fa-clock-o"></i> 本站已稳定运行<span id="site-time"></span>-->
    <!--</div>-->
    
    
      <div class="site-footer-info">
        <i class="fa fa-at"></i> Email: 981684424@qq.com
      </div>
    
    <div class="site-footer-info">
      <i class="fa fa-copyright"></i> 
      2019 <a href="https://github.com/dongyuanxin/theme-ad/" target="_blank">Theme-AD</a>.
      Created by <a href="https://godbmw.com/" target="_blank">GodBMW</a>.
      All rights reserved.
    </div>
  </footer>
</div>
    <div id="site-layer" style="display:none;">
  <div class="site-layer-content">
    <div class="site-layer-header">
      <span class="site-layer-header-title" id="site-layer-title"></span>
      <i class="fa fa-close" id="site-layer-close"></i>
    </div>
    <div class="site-layer-body" id="site-layer-container">
      <div class="site-layer-input" id="site-layer-search" style="display: none;">
        <div class="site-layer-input-choose">
          <a href="javascript:void(0);" title="Change Search Engine">Google</a>
        </div>
        <input type="text">
        <i class="fa fa-search"></i>
      </div>
      
      <div id="site-layer-welcome" style="display:none;"></div>
    </div>
  </div>
</div>
    

<div class="bottom-bar">
  <div class="bottom-bar-left">
    <a href="/2020/07/24/箭头函数/" data-enable="true">
      <i class="fa fa-arrow-left"></i>
    </a>
    <a href="/2020/07/22/JavaScript高级/" data-enable="true">
      <i class="fa fa-arrow-right"></i>
    </a>
  </div>
  <div class="bottom-bar-right">
    <a href="javascript:void(0);" data-enable="true" id="site-toc-show-btn">
      <i class="fa fa-bars"></i>
    </a>
    
    <a href="javascript:void(0);" id="site-toggle-share-btn">
      <i class="fa fa-share-alt"></i>
    </a>
    
    <a href="javascript:void(0);" id="back-top-btn">
      <i class="fa fa-chevron-up"></i>
    </a>
  </div>
</div>
    <div id="share-btn">
  
  
  
  
  
</div>
    





    
  </body>
</html>