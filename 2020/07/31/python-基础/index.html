<!DOCTYPE html>
<html>
  
<head>
  <meta charset="utf-8">
  <meta name="author" content="Ranan" />
  
  
  <title>python基础 | Ranan的博客</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="python,python," />
  

  
  <meta name="description" content="Ranan的博客">

  

  

  

  

  

  <script>
  // theme-ad's config script
  // it can be used in every script
  
  window.AD_CONFIG = {
    leancloud: {"appid":"Hyq9wkH495DgNHWhDQCOfQSp-gzGzoHsz","appkey":"WaR7nrzhliHj9aVwdQzkdlGd","comment":false,"count":false},
    welcome: {"enable":false,"interval":30},
    start_time: "2018-02-10",
    passwords: ["efe07af7441da2b69c4a41e42e73be4db47f66010a56900788a458354a7373ec", ],
    is_post: true,
    lock: false,
    author: "Ranan",
    share: {"twitter":false,"facebook":false,"weibo":false,"qq":false,"wechat":false},
    mathjax: false,
    page_type: "",
    root: "/"
  };
</script>

  <script src="/vendor/sha256.min.js"></script>
<script src="/js/auth.js"></script>
<script src="/js/index.js"></script>
<script src="/vendor/qrcode.min.js"></script>

  
    <link rel="icon" href="/images/favicon.ico">
    <link rel="apple-touch-icon" href="/images/touch-icon.png">
  

  <link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="stylesheet" href="/css/index.css">
<link rel="stylesheet" href="/styles/components/highlight/highlight.css">

  
</head>
  <body>
    <header class="site-header">
  <div class="site-header-brand">
    
      <span class="site-header-brand-title">
        <a href="/">Ranan</a>
      </span>
    
    
      <span class="site-header-brand-motto"> | 不能放弃思考</span>
    
  </div>
  <div class="site-header-right">
    <nav class="site-header-navigation">
      
        <a href="/" target="_self">首页</a>
      
        <a href="/archives/" target="_self">归档</a>
      
        <a href="/tags/" target="_self">标签</a>
      
        <a href="/categories/" target="_self">分类</a>
      
        <a href="/about/" target="_self">关于</a>
      
    </nav>
    <div class="site-header-btn">
      
        <a href="https://biubiuins.github.io/" target="_blank" id="site-github">
          <i class="fa fa-github-alt"></i>
        </a>
      
      <a href="javascript:void(0);" id="site-search">
        <i class="fa fa-search"></i>
      </a>
      <a href="javascript:void(0);" id="site-nav-btn">
        <i class="fa fa-ellipsis-v"></i>
      </a>
    </div>
  </div>
</header>
<nav class="table-content" id="site-nav">
  <div class="table-content-title">
    <span>导航</span>
  </div>
  <div class="table-content-main">
    <ol class="toc">
      
        <li class="toc-item">
          <a href="/" target="_self">
            首页
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/archives/" target="_self">
            归档
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/tags/" target="_self">
            标签
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/categories/" target="_self">
            分类
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/about/" target="_self">
            关于
          </a>
        </li>
      
    </ol>
  </div>
</nav>
<div id="site-process"></div>
    <main>
      
  <div class="passage">
  <div class="passage-meta">
    <span>
      <i class="fa fa-calendar"></i>2020-07-31
    </span>
    
      <span>
        | <a href="/categories/python/"><i class="fa fa-bookmark"></i>python</a>
      </span>
    
    
      <span>
        | <i class="fa fa-unlock-alt"></i>UNLOCK
      </span>
    
  </div>
  <h1 class="passage-title">
    python基础
  </h1>
  
  <article class="passage-article">
    <h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>Python是解释型语言，用途有Web应用、爬虫程序、科学计算、自动化运维、大数据、云计算、人工智能等。</p>
<p>补充:解释型语言:不会在执行前对代码进行编译，而是在执行的同时一边执行一边编译。</p>
<p><strong>Python开发环境搭建</strong><br>开发环境搭建就是安装Python的解释器<br>安装解释器的同时会安装python开发工具IDLE，在IDLE中可以通过TAB键来查看代码的提示。交互模式写一行执行一行，并不适用于我们日常的开发。</p>
<p><strong>基本语言</strong><br>1.Python中严格区分大小写<br>2.Python中的每一行就是一条语句，每条语句以换行结束<br>3.Pyhton中每一行语句不要太长<br>4.一条语句可以分多行编写，以<code>\</code>结尾<br>5.Python是缩进严格的语言<br>6.注释符<code>#</code>，习惯上注释符后跟一个空格</p>
<p><strong>字面量和变量</strong><br>字面量表示的意思就是它的字面的值，在程序中可以直接使用，比如:1,2,’hello’<br>变量可以用来保存字面量</p>
<p>Python中使用变量，不需要声明，直接变量赋值，但不能使用没有赋值的变量。<br>Python是一个动态类型的语言，可以为变量赋任意类型的值。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><strong>数值</strong><br>Python数值分成了整数、浮点数、复数。<br>在python中所有的整数都是int类型，如果数字的长度过大，可以使用下划线作为分隔符，比如123456可以写成123_456</p>
<p>其他进制的整数<br>二进制0b  八进制0o 十六进制0x</p>
<p>在python中所有小数都是float类型，对浮点数进行运算时，可能得到一个不精确的结果。</p>
<p><strong>字符串</strong></p>
<p>大部分同JS类似。<br>1.用三重引号来表示JS中的模板字符串。<br>2.字符串不能和其他类型进行加法运算<br>3.在创建字符串时，可以在字符串中指定占位符,%s在字符串中表示任意字符<br>4.格式化字符串，可以通过在字符串引号外面添加f来创建一个格式化字符串,在格式化字符串中可以直接嵌入变量,该变量必须已经赋值。</p>
<pre><code># 表示用孙悟空替换%s
b = &#39;Hello %s&#39;%&#39;孙悟空&#39;
b = &#39;Hello %s 你好%s&#39;%(&#39;tom&#39;,&#39;孙悟空&#39;)

# 还可以限制位数，不够就补空格
b = &#39;Hello %2s&#39;%&#39;孙悟空&#39;

# 表示限制在3-5之间
b = &#39;Hello %3.5s&#39;%&#39;孙悟空&#39;

# %f 浮点数占位符,会四舍五入 
# %d 整数占位符，不会四舍五入
b = &#39;Hello %.5f&#39;%123.123

# 打印
print(&quot;a=&quot;,a)
print(&quot;a=%s&quot;%a)
print(f&#39;a={a}&#39;)

# 格式化字符串
c = f&#39;hello{a}&#39;
</code></pre><p><strong>字符串的复制</strong></p>
<p>字符串和数字相乘，则解释器会将字符串重复指定的次数并返回。</p>
<pre><code>a=&#39;abc&#39;
a= a*2
print(a) abcabc
</code></pre><p><strong>布尔值和空值</strong></p>
<p>True表真，False表假，注意开头大写，<strong>布尔值实际上也属于整型</strong>，True相当于1，False相当于0。</p>
<p>None空值专门表示不存在</p>
<p><strong>类型检查type</strong></p>
<p>type()用来检查值的类型，返回值为其类型</p>
<p><strong>对象object</strong></p>
<p><strong>一切皆对象</strong>,上面的数据类型都是对象，程序运行当中，所有的数据都是存储到内存中然后再运行，对象是内存中专门用来存储指定数据的一块区域，对象实际上就是一个存储数据的容器。</p>
<p>每个对象都要保存三种数据</p>
<ul>
<li>id 标识 通过id()来查看对象的id，在CPython中,id就是对象的内存地址，id一旦创建就不能改变。</li>
<li>type 类型 用来表示对象所属的类型，如int str float bool等，通过type()查看类型，Python是一门强类型语言，类型创建后不可以改变。</li>
<li>value 值  值就是对象中存储的数据，可变对象的值可以改变，不可变对象的值不可以改变。</li>
</ul>
<p>在python中，对象并没有直接存储到变量中，变量更像是给对象起的别名，变量中存储的是对象的id(地址)。</p>
<p><strong>变量中保存的对象id，只有在为变量重新赋值才会改变。</strong></p>
<p><strong>类型转换</strong>将一个类型的对象转换为其他对象，并不是改变对象本身的类型，而是根据当前对象的值创建一个新对象<br>int()  浮点数直接取整，整数字符串直接转整数，其他类型字符串报错，None也会报错。<br>float() float和int基本一致<br>str()/bool() 表空的都会转化成False</p>
<h2 id="运算符-操作符"><a href="#运算符-操作符" class="headerlink" title="运算符(操作符)"></a>运算符(操作符)</h2><p><strong>算术运算符</strong></p>
<p>两个不同类型不能进行加法<br>字符串和数字相乘，会对字符串指定重复次数<br><code>/</code>除法运算结果总会返回一个浮点类型<br><code>//</code>整除，只保留计算后的整数位。对浮点数运算时，结果也是浮点数即使是整除运算。</p>
<p><strong>关系运算符</strong></p>
<p>关系运算符用来比较两个<strong>值</strong>之间的关系，总会返回一个布尔值</p>
<p>可以对两个字符串进行大于/小于的运算，当对字符串进行逐位比较时，比较的是字符串的Unicode编码，比出大小后直接返回后面的字符串将不会进行比较了。</p>
<p><code>==</code>与<code>!=</code>比较的是对象的值<br><code>is</code>比较两个对象是否是同一个对象，比较的是ID<br><code>is not</code> 比较两个对象是否不是同一个对象，比较的是ID</p>
<p>逻辑运算符可以连着用,表示关系成立，以中间的数为基准比较</p>
<pre><code># 相当于 1&lt;2 and 2&lt;3 和中间数进行比较 Python独有
1&lt;2&lt;3
</code></pre><p><strong>逻辑运算符</strong></p>
<p>not 逻辑非  对非布尔值，非运算符会将其转换为布尔值，再取反<br>and 逻辑与  Python中的逻辑与和JS一样，也是短路的与，对非布尔值会先转化为布尔值运算，<strong>最终返回原值</strong><br>or 逻辑或   短路的或</p>
<pre><code># 与运算找false 2
1 and 2 
# 或运算找true 1 
1 or 2 
</code></pre><p><strong>条件运算符(三元运算符)</strong></p>
<p>语法: 语句1 if 条件表达式 else 语句2</p>
<p>条件运算符在执行时，先对条件表达式进行求值判断，执行相应语句并返回执行结果。</p>
<h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><p><strong>条件判断语句(if)</strong></p>
<p>语法: if 条件表达式 : 语句 </p>
<p>Python是通过<strong>缩进</strong>表达代码块的,Python代码中使用的缩进方式必须统一，要么全缩进要么全空格</p>
<p>依次判断找到表达式结果为True的，执行代码块，然后语句结束。所以if-elif中只有一个代码块被执行。</p>
<pre><code>    if True：
        # Tab缩进 或者 4个空格
        # end=&quot;&quot; 可以控制打印之后不换行
        print(123,end=&quot;&quot;)
    # else:
        # else的代码块
    elif 条件表达式 :
        # 代码块  
</code></pre><p><strong>input函数</strong></p>
<p>input()函数用来获取用户的输入，调用后程序会立即暂停，等待用户输入，点击回车程序才会继续向下执行。</p>
<p>输入的内容会作为返回值返回，返回值为字符串<br>参数为字符串，作为提示文字显示</p>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>while 条件表达式:<br>    代码块<br>else:<br>    代码块，仅跳出循环后执行一次</p>
<p><strong>break与continue</strong></p>
<p>break 可以用来立即退出循环语句,后面与循环一套的else<br>continue 可以退出本次循环，本次循环continue后面的语句将不会被执行，执行下一次循环，不会影响循环一套的else</p>
<p>pass 用于在判断或循环语句中占位</p>
<h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表(list)是Python中的一个对象，列表中可以保存多个有序的数据<br>列表存储的数据，称为元素<br>列表的索引可以是负数，如果是负数从后向前获取元素</p>
<p><strong>切片</strong></p>
<p>切片指从现有列表中，获取一个子列表，索引传<br>个值，起始位置包括，结束位置不包括。或者可以理解为从索引的左边切下。<br>语法: 列表[起始:结束]   列表[起始:结束:步长]<br>步长表示每次获取元素的间隔，默认值是1，不能是0但是可以是负数，负数则会从列表的后面像前面取<br>切片操作不会影响原来的列表，会返回一个新的列表<br>起始位置和结束位置的索引可以省略不写</p>
<p>通过切片来修改列表，进行赋值时，只能使用序列中元素的个数没有要求。<br>当设置了步长时，序列中元素的个数必须和切片中元素的个数一致。</p>
<pre><code># 列表的创建
my_list = [1,2,3]

# 列表的使用，通过索引使用
my_list[0:0] = [9] //[9 1 2 3]

# 删除元素
del list[0]

# 通过len()函数获取列表的长度,列表的最大索引+1
len(my_list)
</code></pre><p><strong>列表的方法</strong></p>
<p><strong>都是直接修改原列表</strong></p>
<p>插入：<br>s.append(value) 序列的最后添加value，不可以使用直接赋值的办法是因为索引超过最大值了会保存<br>s.insert(i,value) 想列表的指定位置插入一个元素，参数1要插入的位置，参数2插入的元素<br>s.extend(list) 使用新的序列来扩展当前序列，会将当前序列中的元素添加到当前列表中，相当于<code>+ =</code></p>
<p>删除:</p>
<p>s.clear() 清空序列<br>s.pop() 根据索引删除并返回指定元素<br>s.remove() 删除指定值的一个元素<br>s.reverse() 序列反转<br>s.sort() 用来对列表中的元素进行排序，默认升序排列，如果需要降序，则需要传递一个reverse = True作为参数</p>
<p><strong>range()函数</strong></p>
<p>range() 可以生成一个自然数序列,可以创建一个指定执行次数的for循环。</p>
<p>该函数需要三个参数<br>1.起始位置，可以省略，默认是1<br>2.结束位置<br>3.步长，可以省略，默认是1</p>
<pre><code>range(5) # 生成一个序列[0,1,2,3,4]
for i in range(30):
    print(i)
</code></pre><p><strong>列表的常用操作/序列通用操作</strong></p>
<p><code>+</code> 两个列表拼接为一个列表<br><code>*</code> 可以将列表重复指定的次数<br><code>in</code> 用来检查指定元素是否存在列表中，语法：元素 in 列表 ，返回布尔值<br><code>not in</code> 用来检查指定元素是否不在列表中</p>
<p>函数:<br>len(list) 获取列表中的元素个数<br>min(list) 获取列表中的最小值<br>max(list) 获取列表中的最大值</p>
<p>两个方法:方法和函数基本是一致的，只不过方法必须通过对象.方法()的形式调用<br>s.index() 获取指定元素在列表中的位置,如果列表中没有会报错，仅返回第一次出现的索引。第一次参数表示查找的元素，第二个参数表示查找的起始位置，第三个参数表示查找的结束位置<br>s.count() 统计指定元素在列表中出现的次数</p>
<h3 id="序列-sequence"><a href="#序列-sequence" class="headerlink" title="序列(sequence)"></a>序列(sequence)</h3><p>序列是Python中最基本的一种数据结构，数据结构指计算机中数据存储的方式</p>
<p>序列用于保存一组有序的数据，所有的数据在序列当中都有一个唯一的位置(索引)</p>
<p>序列的分类<br>    可变序列:序列中的元素可以改变<br>        列表(list)<br>    不可变序列:序列中的元素不可以改变<br>        字符串(str)<br>        元组(tuple)</p>
<p>可以通过<code>list()</code>函数将其他的序列转换为list</p>
<p>所有的序列都可以进行解包。</p>
<p><strong>遍历序列</strong></p>
<p><code>for-in</code>循环将序列中的所有元素取出来,每执行一次会将序列中的一个元素赋值给变量，变量指的是<strong>键值</strong>,这里是和JS不同的地方</p>
<p>for 变量 in 序列:<br>    代码块</p>
<h3 id="元组tuple"><a href="#元组tuple" class="headerlink" title="元组tuple"></a>元组tuple</h3><p>把元组当成是一个不可变的列表，一般当我们希望数据不改变时，就是用元组，其余情况都使用列表。</p>
<p>创建元组，使用小括号<code>()</code>，当元组不是空元组时，可以省略括号,<strong>至少有一个逗号</strong>(可以看成元组的信号)</p>
<p>元组的特殊用法类似JS的解构赋值，在对一个元组进行解包时，变量的数量必须和元组中的元素的数量一致，也可以在变量前面添加<code>*</code>,这样变量将会获取元组中所有的剩余元素，变量为一个列表</p>
<pre><code>my_tuple = 10,20,30,40
# 元组的解构赋值（解构）
a,b,c,d = my_tuple

# c=[30,40]
a,b,*c = my_tuple
</code></pre><h3 id="字典-dict"><a href="#字典-dict" class="headerlink" title="字典 dict"></a>字典 dict</h3><p>字典属于一种新的数据结构，称为映射。字典的作用和列表类似，都是用来存储对象的容器。</p>
<p>列表存储数据的性能很好，但是查询数据的性能很差</p>
<p>在字典中每一个元素都有一个唯一的名字(键名)，通过这个唯一的名字就可以快速的查找到指定的元素(键值)</p>
<p>字典的键是任意的不可变对象，一般为字符串，不可以重复，如果重复，后面的会替换前面的；值可以是任意对象。</p>
<pre><code># 创建字典,类似JSON格式
d = {&#39;age&#39;:18}
d[&#39;age&#39;]
</code></pre><p><strong>字典的操作</strong><br>函数:<br>dict() 来创建字典,这种方式 创建的字典，key都是字符串<br>    也可以将一个包含双值(仅两个值如’ab’)子序列的序列转换为字典。<br>len() 获取字典中键值对的个数<br>in 检查字典中是否包含指定的<strong>键</strong><br>not in 检查字典中是否不包含指定的<strong>键</strong></p>
<p>方法:<br>d.get(key[,default]) 根据键来获取字典中的值，如果键不存在，会返回None;通过[]来获取值时，如果键不存在，会抛出异常。<br>d.setdefault(key[,default]) 可以用来向字典中添加key-value，如果key存在，则返回key的值不会对字典做任何操作，如果key不存在，则向字典中添加这个key，并设置value<br>d.updata(other d) 将其他字典中的key-value添加到当前字典中<br>d.popitem() 随机删除字典中的一个键值对，一般都会删除最后一个键值对并以元组形式返回，删除空字典时报错<br>d.pop(key[,default]) 根据key删除字典中的key-value，返回值是删除的value。删除不存在的key会报错，如果指定了默认值就不会报错并直接返回默认值<br>d.clear() 用来清空字典<br><strong>copy()</strong><br>d.copy() 该方法用于对字典进行<strong>浅复制</strong></p>
<p>复制以后的对象和原对象是独立的，修改一个不会另外一个，浅复制仅是简单的复制对象内部的值，如果值是一个可变对象，这个可变对象不会被复制(会影响原来的值)</p>
<pre><code>d = dict(name=&#39;孙悟空&#39;,age=18)
# {&quot;name&quot;:&quot;孙悟空&quot;，&quot;age&quot;:18}
d = dict([(name,&#39;孙悟空&#39;),(age,18)])
# 获取字典中的值,注意引号,有引号为字符串，没有引号为变量，
d[&#39;name&#39;] = &quot;value&quot; # key存在修改，不存在添加

# 删除字典中的key-value，key不存在报错
del d[&#39;name&#39;]
</code></pre><p><strong>字典的遍历</strong><br>d.keys()该方法会返回字典的所有key的序列<br>d.values()该方法会返回字典的所有value的序列<br>d.items(k,v)该方法会返回字典中所有项的序列<code>[(k,v),(k,v)]</code></p>
<h3 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h3><p>集合和列表非常相似，类似JS的Set</p>
<p>不同点</p>
<pre><code>- 集合中只能存储不可变对象
- 集合中存储的对象是无序
- 集合中不能出现重复的元素
</code></pre><p>集合的创建使用<code>{}</code>或使用<code>set()</code>,创造空集合只能使用<code>set()</code>,使用<code>{}</code>默认是创建的字典。</p>
<p>set可以将序列和字典(的键)转换为集合，<strong>利用这点可以去重</strong>，</p>
<p>in 检查集合中的元素<br>len()来获取集合中元素的数量</p>
<p>s.add() 向集合中添加元素<br>s.update() 将一个集合/元组/字典(key<br>)中的元素添加到当前集合中<br>s.pop() 随机删除集合中的元素并返回<br>s.remove(value) 删除集合中的指定元素<br>s.clear()清空集合<br>s.copy() 对集合进行浅复制</p>
<p><strong>集合的运算</strong></p>
<pre><code># 在对集合做运算时，不会影响原来的集合，而是将运算结果返回
# 创建两个集合
s = {1,2,3,5,9}
s2 = {4,6,7,8,9}

# &amp; 交集运算
result = s &amp; s2

# | 并集运算
result = s | s2

# - 差集
result = s - s2

# ^ 异或集(除去交集的剩余部分，只在一个集合中出现的元素)
result = s ^ s2

# &lt;= 检查一个集合是否是另外一个集合的子集 
# &lt; 检查一个集合是否是另外一个集合的真子集
</code></pre><h2 id="函数-function"><a href="#函数-function" class="headerlink" title="函数 function"></a>函数 function</h2><p>函数也是一个对象<br>def 函数名([形参1=默认值,形参2]):<br>    代码块</p>
<p>位置参数:将对应位置的参数复制给对应位置的形参<br>关键字参数:通过参数名直接传递参数，可以不按照形参定义的顺序去传递<br>混合使用关键字和位置参数时，必须将位置参数写到前面</p>
<p>函数在调用时，解析器不会检查实参的类型，实参可以传递任意类型的对象</p>
<p>当传的参数是可变参数时，不想形参影响实参，传参可以通过<code>x.copy()</code>或<code>x[:]</code>传副本，这样形参和实参之间互不影响</p>
<p><strong>不定长参数</strong></p>
<p>在定义函数时，可以在形参前边加上<code>*</code>,这个形参将会获取到所有的实参，它会将所有的实参保存到一个<strong>元组</strong>,带<code>*</code>的参数后的所有的参数，必须以关键字参数的形式传递必须按形参顺序。</p>
<pre><code># 如果*后没跟变量，可以使用这种写法要求调用函数时必须使用关键字参数的形式传值
def fn(*,a,b,c):
    代码块
# * 形参只能接收位置参数，而不能接收关键字参数
def fn(*a):
    代码块
# **形参可以接收其他的关键字参数，将这些参数统一保存到字典中，字典的key就是参数的名字，字典value就是参数的值
# **只能有一个且写在参数的最后    
def fn(**a):
    代码块    
</code></pre><p><strong>参数的解包</strong><br>通过一个星号，对序列进行参数的解包。<br>通过两个星号，对字典进行参数的解包</p>
<pre><code>def fn(a,b,c):
    代码块
# 传递实参时，也可以在序列类型的参数前添加星号，这样会依次将序列中的元素作为参数传递。
# 序列中元素的个数必须和形参的个数一致
t = (10,20,30)
fn(*t)

d = {&#39;a&#39;:100,&#39;b&#39;:200,&#39;c&#39;:300}

# 通过**来对字典进行解包操作,相当于关键字参数，所以key要和参数名一致
fn(**d)
</code></pre><p><strong>help()</strong></p>
<p>help()是python的内置函数，通过help(函数对象)函数可以查询python中的函数的用法</p>
<p>文档字符串(doc str)<br>在定义函数时，可以在函数内部第一行用<code>&#39;&#39;&#39;文档字符串&#39;&#39;&#39;</code>编写文档字符串，文档字符串就是函数的说明，可以通过help()函数来查看函数的说明。</p>
<p><strong>作用域</strong></p>
<p>作用域分两种</p>
<ul>
<li><p>全局作用域:在程序执行时创建，在程序执行结束时销毁</p>
</li>
<li><p>函数作用域:在函数调用时创建，在调用结束时销毁，每调用一次就会产生一个新的函数作用域</p>
</li>
</ul>
<p>如果希望在函数内部修改全局变量，可以通过global关键字来声明变量，表示这个变量不是函数内部的而是全局的。</p>
<p><strong>命名空间</strong><br>命名空间指的是变量存储的位置，每一个变量都需要存储到指定的命名空间中。<br>每一个作用域都会有一个它对应的命名空间，命名空间实际上就是一个字典，是一个专门用来储存变量的字典。</p>
<p>locals() 用来获取当前作用域的命名空间，返回当前作用域的命名空间<br>globals() 用来获取全局命名空间</p>
<p><strong>递归</strong></p>
<p>基线条件,问题可以被分解为的最小问题，当满足基线条件时，递归就不在执行了<br>递归条件，将问题继续分解的条件</p>
<p><strong>函数式编程</strong></p>
<p>在Python中，函数是一等对象<br>一等对象一般特点：<br>1.对象是在运行时创建的<br>2.能赋值给变量或作为数据结构中的元素<br>3.能作为参数传递<br>4.能作为返回值返回</p>
<p>高阶函数至少符合以下两个特点的一个:<br>1.接收一个或多个函数作为参数<br>2.将函数作为返回值返回</p>
<p><strong>filer()函数</strong><br>可迭代结构中过滤出符合条件的元素，保存到新的序列中<br>参数:<br>1.函数，根据函数来过过滤课迭代结构(需要返回bool值)<br>2.需要过滤的可迭代结构<br>返回值：<br>过滤后的新可迭代的结构</p>
<p>这个的函数可以传匿名函数,也可以将匿名函数赋值给一个变量，这里的返回值直接返回不需要使用<code>return</code></p>
<p>语法:lambda 参数列表 : 返回值</p>
<p><strong>map()函数</strong></p>
<p>map()函数可以对可迭代对象中的所有元素做指定的操作，然后将其添加到一个新的对象中返回。<br>语法:map(函数,可迭代对象)</p>
<p><strong>sort()方法/sorted()函数</strong></p>
<p>sort()方法用来对列表中的元素进行排序，会影响原列表。<br>该方法是直接比较列表中元素的大小。</p>
<p>在sort()可以接收一个关键字参数key，key需要一个函数作为参数，当设置了函数作为 参数，每次都会以列表中的一个元素作为参数来调用函数，并且使用函数的返回值来比较元素的大小。<br>如:<code>l.sort(key=len)</code>利用列表元素的长度排序。<br>key = int 每个元素转换成int类型排序<br>key = string 每个元素转换成string类型排序</p>
<p>这种用法只在比较的时候转换，不影响原来列表的类型</p>
<p>sorted()可以对任意的序列进行排序,不会影响原来的序列，返回一个新的对象。<br>第一个参数为序列，第二个参数为key</p>
<p><strong>闭包</strong></p>
<p>将函数作为返回值返回</p>
<p>产生闭包的条件<br>1.函数嵌套<br>2.内部函数引用了外部函数的数据</p>
<p><strong>装饰器</strong></p>
<p>开闭原则，程序的设计要求开发对程序的扩展，要关闭对程序的修改</p>
<p>在希望不修改原函数的情况下，对函数进行扩展</p>
<p>只需要在现在的函数，创建一个新的函数，把原来的函数在新的函数中运行。这种方式要求每扩展一个函数就要手动创建一个新函数，为了避免麻烦，我们创建一个函数，让这个函数可以自动帮助我们生产函数</p>
<pre><code>def begin_end(old_function):
    &#39;&#39;&#39;
    用来对其他函数进行扩展，使其他函数可以在执行前打印开始执行，执行后打印执行结束
    参数：要扩展的函数对象
    &#39;&#39;&#39;
    # 打包
    def new_function(*args,**kwargs):
        print(&quot;开始执行&quot;)
        # 解包
        old_function(*args,**kwargs)
        print(&quot;执行结束&quot;)
    return new_function
</code></pre><p>像begin_end()这种函数就被称为装饰器，在开发中使用装饰器扩展函数的功能。<br>在定义函数时，可以通过@装饰器来指定装饰器，可以同时为一个函数指定多个装饰器，函数将会被由内到外的装饰</p>
<pre><code># 在函数前面@装饰器，表示下面的函数被该装饰器装饰
@begin_end
@装饰器2
def say_hello():
    代码块
# 执行的结果是被装饰器装饰后的结果  
say_hello()    
</code></pre><p><strong>可变对象</strong></p>
<p>列表、字典</p>
<p>变量中保存的对象id，只有在为变量重新赋值才会改变。<br>可变对象指的是对象的值可变<br>列表中的对象改变，该改变的是值，并没有重新给列表赋值</p>
<pre><code># 改对象
a[0] = 10
# 改变量
a = [1,2,3]
</code></pre><h2 id="对象Object"><a href="#对象Object" class="headerlink" title="对象Object"></a>对象Object</h2><p>对象由三部分组成<br>1.对象的标识，不可变(id)<br>2.对象的类型，不可变(type)<br>3.对象的值(value)</p>
<p><strong>面向对象</strong></p>
<p>面向对象的语言就是语言中的所有操作都是通过对象来进行的</p>
<h3 id="类class"><a href="#类class" class="headerlink" title="类class"></a>类class</h3><p><a href="https://biubiuins.github.io/2020/08/20/python-%E7%B1%BB/" target="_blank" rel="noopener">class</a></p>
<p><strong>isinstance()/issubclass()函数</strong></p>
<p>isinstance(mc,MyClass) 用来检查mc(第一个参数)是否是MyClass(第二个参数)的实例，返回布尔值<br>issubclass()用来检查第一个参数是否是第二个参数的子类</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>程序运行过程中产生的垃圾会影响到程序运行的运行性能，所以这些垃圾必须被及时清理。<br>在Python中有自动的垃圾回收机制，它会自动将这些没有被引用的对象删除，所以不用手动处理垃圾回收<br>程序结束之后，对象也会被自动回收</p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>在Python中一个py文件就是一个模块，模块名要符合标识符的规范。<br>语法: import 模块名  – 模块名为python文件的名字<br>可以引用同一个模块多次，但是模块的实例只会创建一次。<br>在每一个模块内部都有一个<strong>name</strong>属性，通过这个属性可以获取到模块的名字,<strong>name</strong>属性值为<strong>main</strong>的模块是主模块，一个程序中只会有一个主模块，主模块就是直接通过python执行的模块</p>
<p>模块中添加了_的变量，通过<code>import *</code>引入是看不见该变量的</p>
<pre><code># 给模块起别名
import test_module as test
print (test.__name__)  # 输出test_module
print (__name__)  # 输出__main__

# 访问模块中的变量:模块名.属性/方法()

# 引入模块中的部分内容
# 语法 from 模块名 import 变量,变量
from m import Person,test
# 引入模块中所有内容，一般不会使用
from m import * 


# 也可以为引入的变量使用别名
# 语法: from 模块名 import 变量名 as 别名


# 测试代码，当前文件为主模块的时候才需要执行
if __name__ == &#39;__main__&#39;:
    # 测试代码
</code></pre><p><strong>time模块</strong></p>
<p>time()可以用来获取当前的时间，返回的单位是秒</p>
<pre><code>from time import *
begin = time() 
</code></pre><p><strong>pprint模块</strong></p>
<p>pprint 模式给我们提供了一个方法pprint()该方法可以用来对打印的数据做简单的格式化。</p>
<h3 id="包package"><a href="#包package" class="headerlink" title="包package"></a>包package</h3><p>包也是一个模块，当我们模块中代码过多时，或者一个模块需要被分解为多个模块时，就需要使用包</p>
<p>普通的模块就是一个py文件，而包是一个文件夹。包中必须要一个<code>__init__.py</code>,在这个中可以包含有包的主要的内容</p>
<pre><code># 这个包里有很多模块，这里引入a.py ,b.py
form package_test import a,b
</code></pre><p><code>__pycache__</code>是模块的缓存文件，py代码在执行前，需要被解析器先转换为机器码，然后再执行，python会在编译一次以后，将转化后的机器码保存到缓存文件中</p>
<h3 id="python标准库"><a href="#python标准库" class="headerlink" title="python标准库"></a>python标准库</h3><p>sys模块，可以获取到python解析器的信息<br>os模块让我可以对操作系统进行访问</p>
<pre><code># 引入sys模块
import sys

# 获取执行代码时，命令行中包含的参数(指令后面紧跟的)
# 该属性是一个列表，列表保存了当前命令的所有参数
sys.argv

# 当前程序中引入的所有模块，modules是一个字典，key为模块名，value是模块对象
sys.modules

# 该属性是一个保存了模块的搜索路径的列表，有点类似环境变量path
sys.path

# 表示当前python运行的平台
sys.platform

# 用来退出程序
sys.exit(&quot;提示语句&quot;)

# 通过这个属性可以获取到系统的环境变量
os.environ
os.environ[&#39;path&#39;]

# 可以执行操作系统的命令
os.system(&quot;命令名&quot;)
# os.listdir(path=&quot;.&quot;)获取当前目录的目录结构,返回一个列表，列表中的每一个元素都是文件夹/文件名
r = os.listdir()
# os.getcwd()获取当前所在的目录
r = os.getcwd
</code></pre><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>Python是希望在出现异常时,我们可以编写代码来对异常进行处理，避免因为异常导致整个程序的终止。</p>
<p>try-except语句，try必须、except和finally至少有一个。</p>
<pre><code>try:
    代码块，可能出现错误的语句
except:
    代码块，出现错误以后的处理方式
else:
    代码块，没出错时要执行的语句
finally:
    代码块，该代码块总会执行
</code></pre><p><strong>异常的传播</strong></p>
<p>函数中出现异常时，如果函数中对异常进行了处理，异常将不会传播；如果函数中没有对异常进行处理，异常会传播到函数的调用处。<br>在异常传播时，实际上就是把异常对象抛给了调用处，如NameError类的对象专门用来处理变量错误的异常。</p>
<p><strong>异常对象</strong></p>
<p>如果except后不跟任何内容(默认Exception)，此时会捕获到所有的异常;如果except后跟着一个异常的类型，那么此时只会捕获该类型的异常<br>一个try后可能跟n个except,类似elif,可以跟n个但只执行一个except<br>Exception是所有异常类的父类，效果等于except后不跟任何内容<br>可以在异常类后面跟着一个as xx,此时xx就是异常对象</p>
<pre><code>try:
    print(c)
    print(10/0)
except NameError as err:
    print(&quot;出现NameError异常&quot;) 
except ZeroDivisionError:
    print(&quot;出现ZeroDivisionError异常&quot;)
finally:
    print(&quot;无论是否出现异常，该子句都会执行&quot;)
</code></pre><p><strong>抛出异常</strong></p>
<p>可以使用raise语句来抛出异常，raise语句后需要跟一个异常类或者异常类的实例。<br>也可以自定义异常类，主要创建一个类继承Exception就可</p>
<pre><code>class MyError(Exception):
    pass

def add(a,b):
    # 如果a和b中有负数，就向调用出抛出异常
    if a&lt;0 or b&lt;0
        # 抛出异常类
        raise Exception
        # 抛出异常类的实例
        raise MyError(&quot;两个参数中不能有负数&quot;)
    r = a + b
    return r
</code></pre>
  </article>
  <aside class="table-content" id="site-toc">
  <div class="table-content-title">
    <i class="fa fa-arrow-right fa-lg" id="site-toc-hide-btn"></i>
    <span>目录</span>
  </div>
  <div class="table-content-main">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#基础"><span class="toc-text">基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型"><span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运算符-操作符"><span class="toc-text">运算符(操作符)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#流程控制语句"><span class="toc-text">流程控制语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#循环语句"><span class="toc-text">循环语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#序列"><span class="toc-text">序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#列表"><span class="toc-text">列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#序列-sequence"><span class="toc-text">序列(sequence)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#元组tuple"><span class="toc-text">元组tuple</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字典-dict"><span class="toc-text">字典 dict</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集合set"><span class="toc-text">集合set</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数-function"><span class="toc-text">函数 function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象Object"><span class="toc-text">对象Object</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类class"><span class="toc-text">类class</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾回收"><span class="toc-text">垃圾回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模块"><span class="toc-text">模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#包package"><span class="toc-text">包package</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python标准库"><span class="toc-text">python标准库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异常"><span class="toc-text">异常</span></a></li></ol>
  </div>
</aside>
  
  
    <div class="passage-tags">
     
      <a href="/tags/python/"><i class="fa fa-tags"></i>python</a>
    
    </div>
  
</div>

    </main>
    
    <div class="site-footer-wrapper">
  <footer class="site-footer">
    
    <!--<div class="site-footer-info">-->
      <!--<i class="fa fa-clock-o"></i> 本站已稳定运行<span id="site-time"></span>-->
    <!--</div>-->
    
    
      <div class="site-footer-info">
        <i class="fa fa-at"></i> Email: 981684424@qq.com
      </div>
    
    <div class="site-footer-info">
      <i class="fa fa-copyright"></i> 
      2019 <a href="https://github.com/dongyuanxin/theme-ad/" target="_blank">Theme-AD</a>.
      Created by <a href="https://godbmw.com/" target="_blank">GodBMW</a>.
      All rights reserved.
    </div>
  </footer>
</div>
    <div id="site-layer" style="display:none;">
  <div class="site-layer-content">
    <div class="site-layer-header">
      <span class="site-layer-header-title" id="site-layer-title"></span>
      <i class="fa fa-close" id="site-layer-close"></i>
    </div>
    <div class="site-layer-body" id="site-layer-container">
      <div class="site-layer-input" id="site-layer-search" style="display: none;">
        <div class="site-layer-input-choose">
          <a href="javascript:void(0);" title="Change Search Engine">Google</a>
        </div>
        <input type="text">
        <i class="fa fa-search"></i>
      </div>
      
      <div id="site-layer-welcome" style="display:none;"></div>
    </div>
  </div>
</div>
    

<div class="bottom-bar">
  <div class="bottom-bar-left">
    <a href="/2020/08/06/vue组件通信/" data-enable="true">
      <i class="fa fa-arrow-left"></i>
    </a>
    <a href="/2020/07/31/vue基础/" data-enable="true">
      <i class="fa fa-arrow-right"></i>
    </a>
  </div>
  <div class="bottom-bar-right">
    <a href="javascript:void(0);" data-enable="true" id="site-toc-show-btn">
      <i class="fa fa-bars"></i>
    </a>
    
    <a href="javascript:void(0);" id="site-toggle-share-btn">
      <i class="fa fa-share-alt"></i>
    </a>
    
    <a href="javascript:void(0);" id="back-top-btn">
      <i class="fa fa-chevron-up"></i>
    </a>
  </div>
</div>
    <div id="share-btn">
  
  
  
  
  
</div>
    





    
  </body>
</html>