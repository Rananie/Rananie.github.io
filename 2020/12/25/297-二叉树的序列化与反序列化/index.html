<!DOCTYPE html>
<html>
  
<head>
  <meta charset="utf-8">
  <meta name="author" content="Ranan" />
  
  
  <title>297.二叉树的序列化与反序列化 | Ranan_blog</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="刷题笔记,Java," />
  

  
  <meta name="description" content="Ranan的博客">

  

  

  

  

  

  <script>
  // theme-ad's config script
  // it can be used in every script
  
  window.AD_CONFIG = {
    leancloud: {"appid":"Hyq9wkH495DgNHWhDQCOfQSp-gzGzoHsz","appkey":"WaR7nrzhliHj9aVwdQzkdlGd","comment":false,"count":false},
    welcome: {"enable":false,"interval":30},
    start_time: "2018-02-10",
    passwords: ["efe07af7441da2b69c4a41e42e73be4db47f66010a56900788a458354a7373ec", ],
    is_post: true,
    lock: false,
    author: "Ranan",
    share: {"twitter":false,"facebook":false,"weibo":false,"qq":false,"wechat":false},
    mathjax: false,
    page_type: "",
    root: "/"
  };
</script>

  <script src="/vendor/sha256.min.js"></script>
<script src="/js/auth.js"></script>
<script src="/js/index.js"></script>
<script src="/vendor/qrcode.min.js"></script>

  
    <link rel="icon" href="/images/favicon.ico">
    <link rel="apple-touch-icon" href="/images/touch-icon.png">
  

  <link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="stylesheet" href="/css/index.css">
<link rel="stylesheet" href="/styles/components/highlight/highlight.css">

  
</head>
  <body>
    <header class="site-header">
  <div class="site-header-brand">
    
      <span class="site-header-brand-title">
        <a href="/">Ranan</a>
      </span>
    
    
  </div>
  <div class="site-header-right">
    <nav class="site-header-navigation">
      
        <a href="/" target="_self">首页</a>
      
        <a href="/archives/" target="_self">归档</a>
      
        <a href="/tags/" target="_self">标签</a>
      
        <a href="/categories/" target="_self">分类</a>
      
        <a href="/about/" target="_self">关于</a>
      
    </nav>
    <div class="site-header-btn">
      
        <a href="https://github.com/Rananie" target="_blank" id="site-github">
          <i class="fa fa-github-alt"></i>
        </a>
      
      <a href="javascript:void(0);" id="site-search">
        <i class="fa fa-search"></i>
      </a>
      <a href="javascript:void(0);" id="site-nav-btn">
        <i class="fa fa-ellipsis-v"></i>
      </a>
    </div>
  </div>
</header>
<nav class="table-content" id="site-nav">
  <div class="table-content-title">
    <span>导航</span>
  </div>
  <div class="table-content-main">
    <ol class="toc">
      
        <li class="toc-item">
          <a href="/" target="_self">
            首页
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/archives/" target="_self">
            归档
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/tags/" target="_self">
            标签
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/categories/" target="_self">
            分类
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/about/" target="_self">
            关于
          </a>
        </li>
      
    </ol>
  </div>
</nav>
<div id="site-process"></div>
    <main>
      
  <div class="passage">
  <div class="passage-meta">
    <span>
      <i class="fa fa-calendar"></i>2020-12-25
    </span>
    
      <span>
        | <a href="/categories/刷题笔记/"><i class="fa fa-bookmark"></i>刷题笔记</a>
      </span>
    
    
      <span>
        | <i class="fa fa-unlock-alt"></i>UNLOCK
      </span>
    
  </div>
  <h1 class="passage-title">
    297.二叉树的序列化与反序列化
  </h1>
  
  <article class="passage-article">
    <p><strong>题目</strong></p>
<p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p><strong>思路</strong></p>
<p><strong>前序遍历</strong></p>
<p>反序列：如何使用由前序遍历生成的列表构造二叉树，结合前序遍历，列表的第一个元素就是节点元素。前序遍历序列化，再前序遍历反序列化。</p>
<pre><code class="Java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
      StringBuilder sb = new StringBuilder();
       serialize(root,sb);
       return sb.toString();
    } 
    void serialize(TreeNode root,StringBuilder sb){
        if(root == null){
            sb.append(&quot;null,&quot;);
            return;
        }
        sb.append(root.val+&quot;,&quot;);
        serialize(root.left,sb);
        serialize(root.right,sb);
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        //先将字符串转化成列表，问题就转换成如何根据列表构造二叉树
        LinkedList&lt;String&gt; nodes = new LinkedList&lt;&gt;();
        for(String s:data.split(&quot;,&quot;)){
            nodes.addLast(s);
        }
        return deserialize(nodes);
    }
    //通过辅助函数构造二叉树
    TreeNode deserialize(LinkedList&lt;String&gt; nodes){
        if(nodes.isEmpty()) return null;
        String first = nodes.removeFirst();
        if(first.equals(&quot;null&quot;))return null;
        TreeNode root = new TreeNode(Integer.parseInt(first));
        root.left = deserialize(nodes);
        root.right = deserialize(nodes);
        return root;
    }



}

</code></pre>
<p><strong>后序遍历</strong><br>前序遍历反序列化做了哪些事？<br>找到root节点的值，然后递归计算左右节点。<br>那么我们按照这个思路，后序遍历得到的左右中的顺序，那么只需要取最后一个得到root节点，然后递归右左节点就行了。</p>
<pre><code class="JAVA">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
      StringBuilder sb = new StringBuilder();
       serialize(root,sb);
       return sb.toString();
    } 
    void serialize(TreeNode root,StringBuilder sb){

        if(root == null){
            sb.append(&quot;null,&quot;);
            return;
        }//放前面防止报空指针异常的错误
        serialize(root.left,sb);
        serialize(root.right,sb);
        sb.append(root.val+&quot;,&quot;);


    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        //先将字符串转化成列表，问题就转换成如何根据列表构造二叉树
        LinkedList&lt;String&gt; nodes = new LinkedList&lt;&gt;();
        for(String s:data.split(&quot;,&quot;)){
            nodes.addLast(s);
        }
        return deserialize(nodes);
    }
    //通过辅助函数构造二叉树
    TreeNode deserialize(LinkedList&lt;String&gt; nodes){
        if(nodes.isEmpty()) return null;
        String first = nodes.removeLast();
        if(first.equals(&quot;null&quot;))return null;
        TreeNode root = new TreeNode(Integer.parseInt(first));

        root.right = deserialize(nodes);
        root.left = deserialize(nodes);
        return root;
    }
}
</code></pre>
<p><strong>中序遍历</strong></p>
<p>中序遍历无法实现反序列化方法，因为没有办法找到root节点。</p>
<p><strong>层次遍历</strong></p>
<p>序列化时，套入模板</p>
<pre><code class="JAVA">if(root == null) reutrn;
Queue&lt;TreeNode&gt;q = new LinkedList&lt;&gt;()
q.offer(root);
while(!q.isEmpty()){
    TreeNode cur = q.poll;
    //层次遍历的操作
    if(cur.left!= null){
        q.offer(cur.left);
    }
    if(cur.right != null){
        q.offer(cur.right);
    }
}
</code></pre>
<p>反序列化时，同样先将字符串转换成列表，然后再找根节点，列表顺序由层序遍历得到，那么还原根节点的时候也可以采用层次遍历还原。</p>
<pre><code class="JAVA">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if(root == null) return &quot;&quot;;
        StringBuilder sb = new StringBuilder();
        Queue&lt;TreeNode&gt;q = new LinkedList&lt;&gt;();
        q.offer(root);
        while(!q.isEmpty()){
        TreeNode cur = q.poll();
        //层次遍历的操作
        if(cur == null) {
        sb.append(&quot;null,&quot;);
        continue; 
        }
        sb.append(cur.val+&quot;,&quot;);
        q.offer(cur.left);
        q.offer(cur.right);
}       
    return sb.toString();
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if(data.isEmpty())return null;
        String[] nodes = data.split(&quot;,&quot;);
        //第一个元素是根节点。
        TreeNode root = new TreeNode(Integer.parseInt(nodes[0]));
         Queue&lt;TreeNode&gt;q = new LinkedList&lt;&gt;();
        q.offer(root);
        //循环获取到nodes数组中的每一个元素
        for(int i = 1;i&lt;nodes.length;){
            //队列中的就是父节点
            TreeNode cur = q.poll();
            //层序遍历是父节点取出后，左右孩子节点分别进入，那么此时先取出来的就是左孩子节点
            String left = nodes[i++];
            if(!left.equals(&quot;null&quot;)){
                cur.left = new TreeNode(Integer.parseInt(left));
                q.offer(cur.left); //放入是一个节点
            }else{
                cur.left = null;
            }
            String right = nodes[i++];
            if(!right.equals(&quot;null&quot;)){
                cur.right = new TreeNode(Integer.parseInt(right));
                q.offer(cur.right); //放入是一个节点
            }else{
                cur.right = null;
            }

        }
        return root;
    }
}

</code></pre>

  </article>
  <aside class="table-content" id="site-toc">
  <div class="table-content-title">
    <i class="fa fa-arrow-right fa-lg" id="site-toc-hide-btn"></i>
    <span>目录</span>
  </div>
  <div class="table-content-main">
    
  </div>
</aside>
  
  
    <div class="passage-tags">
     
      <a href="/tags/Java/"><i class="fa fa-tags"></i>Java</a>
    
    </div>
  
</div>

    </main>
    
    <div class="site-footer-wrapper">
  <footer class="site-footer">
    
    <!--<div class="site-footer-info">-->
      <!--<i class="fa fa-clock-o"></i> 本站已稳定运行<span id="site-time"></span>-->
    <!--</div>-->
    
    
      <div class="site-footer-info">
        <i class="fa fa-at"></i> Email: 981684424@qq.com
      </div>
    
    <div class="site-footer-info">
      <i class="fa fa-copyright"></i> 
      2019 <a href="https://github.com/dongyuanxin/theme-ad/" target="_blank">Theme-AD</a>.
      Created by <a href="https://godbmw.com/" target="_blank">GodBMW</a>.
      All rights reserved.
    </div>
  </footer>
</div>
    <div id="site-layer" style="display:none;">
  <div class="site-layer-content">
    <div class="site-layer-header">
      <span class="site-layer-header-title" id="site-layer-title"></span>
      <i class="fa fa-close" id="site-layer-close"></i>
    </div>
    <div class="site-layer-body" id="site-layer-container">
      <div class="site-layer-input" id="site-layer-search" style="display: none;">
        <div class="site-layer-input-choose">
          <a href="javascript:void(0);" title="Change Search Engine">Google</a>
        </div>
        <input type="text">
        <i class="fa fa-search"></i>
      </div>
      
      <div id="site-layer-welcome" style="display:none;"></div>
    </div>
  </div>
</div>
    

<div class="bottom-bar">
  <div class="bottom-bar-left">
    <a href="javascript:void(0);" data-enable="false">
      <i class="fa fa-arrow-left"></i>
    </a>
    <a href="/2020/12/23/note-二叉树的总结/" data-enable="true">
      <i class="fa fa-arrow-right"></i>
    </a>
  </div>
  <div class="bottom-bar-right">
    <a href="javascript:void(0);" data-enable="true" id="site-toc-show-btn">
      <i class="fa fa-bars"></i>
    </a>
    
    <a href="javascript:void(0);" id="site-toggle-share-btn">
      <i class="fa fa-share-alt"></i>
    </a>
    
    <a href="javascript:void(0);" id="back-top-btn">
      <i class="fa fa-chevron-up"></i>
    </a>
  </div>
</div>
    <div id="share-btn">
  
  
  
  
  
</div>
    





    
  </body>
</html>