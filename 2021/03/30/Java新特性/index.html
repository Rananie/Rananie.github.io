<!DOCTYPE html>
<html>
  
<head>
  <meta charset="utf-8">
  <meta name="author" content="Ranan" />
  
  
  <title>Java新特性 | Ranan_blog</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Java,Java," />
  

  
  <meta name="description" content="Ranan的博客">

  

  

  

  

  

  <script>
  // theme-ad's config script
  // it can be used in every script
  
  window.AD_CONFIG = {
    leancloud: {"appid":"Hyq9wkH495DgNHWhDQCOfQSp-gzGzoHsz","appkey":"WaR7nrzhliHj9aVwdQzkdlGd","comment":false,"count":false},
    welcome: {"enable":false,"interval":30},
    start_time: "2018-02-10",
    passwords: ["efe07af7441da2b69c4a41e42e73be4db47f66010a56900788a458354a7373ec", ],
    is_post: true,
    lock: false,
    author: "Ranan",
    share: {"twitter":false,"facebook":false,"weibo":false,"qq":false,"wechat":false},
    mathjax: false,
    page_type: "",
    root: "/"
  };
</script>

  <script src="/vendor/sha256.min.js"></script>
<script src="/js/auth.js"></script>
<script src="/js/index.js"></script>
<script src="/vendor/qrcode.min.js"></script>

  
    <link rel="icon" href="/images/favicon.ico">
    <link rel="apple-touch-icon" href="/images/touch-icon.png">
  

  <link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="stylesheet" href="/css/index.css">
<link rel="stylesheet" href="/styles/components/highlight/highlight.css">

  
</head>
  <body>
    <header class="site-header">
  <div class="site-header-brand">
    
      <span class="site-header-brand-title">
        <a href="/">Ranan</a>
      </span>
    
    
  </div>
  <div class="site-header-right">
    <nav class="site-header-navigation">
      
        <a href="/" target="_self">首页</a>
      
        <a href="/archives/" target="_self">归档</a>
      
        <a href="/tags/" target="_self">标签</a>
      
        <a href="/categories/" target="_self">分类</a>
      
        <a href="/about/" target="_self">关于</a>
      
    </nav>
    <div class="site-header-btn">
      
        <a href="https://github.com/Rananie" target="_blank" id="site-github">
          <i class="fa fa-github-alt"></i>
        </a>
      
      <a href="javascript:void(0);" id="site-search">
        <i class="fa fa-search"></i>
      </a>
      <a href="javascript:void(0);" id="site-nav-btn">
        <i class="fa fa-ellipsis-v"></i>
      </a>
    </div>
  </div>
</header>
<nav class="table-content" id="site-nav">
  <div class="table-content-title">
    <span>导航</span>
  </div>
  <div class="table-content-main">
    <ol class="toc">
      
        <li class="toc-item">
          <a href="/" target="_self">
            首页
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/archives/" target="_self">
            归档
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/tags/" target="_self">
            标签
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/categories/" target="_self">
            分类
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/about/" target="_self">
            关于
          </a>
        </li>
      
    </ol>
  </div>
</nav>
<div id="site-process"></div>
    <main>
      
  <div class="passage">
  <div class="passage-meta">
    <span>
      <i class="fa fa-calendar"></i>2021-03-30
    </span>
    
      <span>
        | <a href="/categories/Java/"><i class="fa fa-bookmark"></i>Java</a>
      </span>
    
    
      <span>
        | <i class="fa fa-unlock-alt"></i>UNLOCK
      </span>
    
  </div>
  <h1 class="passage-title">
    Java新特性
  </h1>
  
  <article class="passage-article">
    <h2 id="Java8"><a href="#Java8" class="headerlink" title="Java8"></a>Java8</h2><p>Java8(jdk1.8)是Java语言开发的一个主要版本。</p>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>核心思路:可推断的可省略<br>本质:作为<strong>函数式接口</strong>实现类的对象<br>格式:<code>() -&gt; {}</code><br><code>()</code> Lambda形参列表,接口中的抽象方法的形参列表<br><code>-&gt;</code> Lambda操作符,箭头操作符<br><code>{}</code> Lambda体,重写的抽象方法的方法体<br>使用场景:当需要对一个函数式接口实例化时 -&gt; 用匿名实现类实现的都可以用Lambda表达式</p>
<p><strong>Lambda的使用</strong></p>
<p>Lambad形参列表<br>1.只有一个参数  -&gt; 小括号可以省略<br>2.参数类型可以推断出来(基本都行) -&gt; 可以省略</p>
<p>Lambda体<br>只有一条语句 -&gt; 大括号、return可以省略</p>
<h4 id="函数式-Functional-接口"><a href="#函数式-Functional-接口" class="headerlink" title="函数式(Functional)接口"></a>函数式(Functional)接口</h4><p>定义:接口只声明了一个抽象方法 -&gt; 省略<code>new Runnable(){@ovverride public void run}</code><br>表示:<code>@FunctionalInterface</code><br>说明:Lambda表达式可以看成函数式接口实现类的对象 -&gt; 以前用匿名实现类表示的现在可以用Lambda表达式来写</p>
<p>java.util.funciton包下定义了java8的函数式接口</p>
<p><strong>Java内置四大核心函数式接口</strong><br>函数时式接口|参数类型|返回类型|用途<br>:-:|:-:|:-:|:-:<br>Consumer<t>消费型接口|T|void|对类型为T的对象应用操作,包含方法:void accept(T t)<br>Supplier<t>供给型接口|无|T|返回类型为T的对象，包含方法:T get()<br>Function&lt;T,R&gt;函数型接口|T|R|对类型为T的对象应用操作,并返回结果。结果是R类型的对象。包含方法:R apply(T t)<br>Predicate<t>断定型接口|T|boolean|确定类型为T的对象是否满足某约束,并返回boolean值,包含方法:<br>boolean test(T t)</t></t></t></p>
<pre><code class="java">public  void test(){
  //原来的写法
  happyTime(500, new Consumer&lt;Double&gt;() {
     @Override
     public void accept(Double aDouble) {
     System.out.println(&quot;购物花了&quot;+aDouble);
      }
    });

    //Lambda表达式
    happyTime(600,aDouble -&gt; System.out.println(&quot;购物花了&quot;+aDouble));
}
//具体的Consumer接口实现类由调用函数时确定
 public void happyTime(double money, Consumer&lt;Double&gt; con){
        con.accept(money);
}
</code></pre>
<h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>使用情况:当要传递给Lambda体的操作，已经有实现方法了，可以使用方法引用。</p>
<p>说明:方法引用就是Lambda表达式,也是函数式接口的一个实例,通过方法的名字来指向一个方法,也就是Lambda表达式的语法糖。</p>
<p>要求:<strong>实现接口的抽象方法的参数列表和返回值类型,必须与方法引用的方法的参数列表和返回值类型保持一致</strong>(针对情况1和情况2)</p>
<p>格式: 类(或对象/调用者) :: 方法名<br>情况1.对象::非静态方法<br>情况2.类::静态方法<br>情况3.类::非静态方法</p>
<pre><code class="java">//Consumer中的抽象方法void accept(T t)
//方法引用的方法：PrintStream中的void println(T t)
Consumer&lt;String&gt; con1 = str -&gt; System.out.println(str);
con1.accept(&quot;北京&quot;);
System.out.println(&quot;*******&quot;);
//方法引用替换的是Lambda体

//情况1:对象::非静态方法
PrintStream ps = System.out;
Consumer  &lt;String&gt; con2 = ps::println;
con1.accept(&quot;beijing&quot;);

//情况2:类::静态方法
Comparator&lt;Integer&gt; com1 = (t1, t2) -&gt; Integer.compare(t1,t2);
System.out.println(com1.compare(12, 21));
Comparator&lt;Integer&gt; com2 = Integer::compare;
System.out.println(com2.compare(12, 21));

//情况3:类::非静态方法
//Comparator中的int compare(T t1,T t2)
//String中的int t1.compareTO(t2)
//第一个参数t1调用了，在参数列表就没有必要写了，方法引用时的类就是调用者的类  保证参数都使用上了
Comparator&lt;String&gt; com3 = (s1,s2) -&gt; s1.compareTo(s2);
System.out.println(com3.compare(&quot;abc&quot;, &quot;abd&quot;));
Comparator&lt;String&gt; com4 = String::compareTo;
System.out.println(com4.compare(&quot;abc&quot;, &quot;abd&quot;));
</code></pre>
<h4 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h4><p>类似方法引用.函数式接口的抽象方法的形参列表和构造器的形参列表一致<br>抽象方法的返回值类型即为构造器所属的类的类型，也就是写在冒号前面的类</p>
<pre><code class="java">//构造器引用
//Supplier中的T get()
//Employee的空参构造器Employee()
Supplier &lt;Employee&gt; sup1 = () -&gt; new Employee();
Supplier &lt;Employee&gt; sup2 = Employee::new;

//Function中的R apply(T t)
Function&lt;Integer,Employee&gt; func1 = id-&gt; new Employee(id);
func1.apply(1001);
Function&lt;Integer,Employee&gt; func2 = Employee::new;
func2.apply(1002);
</code></pre>
<h3 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h3><p>Stream API对集合数据进行操作，就类似于使用SQL执行的数据库查询，提供了一种高效且易于使用的处理数据的方式。<br>非关系型数据库的数据需要Java层面去处理,关系型数据库一般由SQL处理。</p>
<p><strong>Stream说明</strong><br>1.Stream自己不存储元素<br>2.Stream不会改变源对象，会返回一个持有结果的新Stream<br>3.Stream操作是延迟执行的，会等到需要结果的时候才执行</p>
<p><strong>Stream和Collection集合的区别</strong><br>Collection:静态的内存数据结构，面向数据<br>Stream:有关计算，通过CPU实现计算，面向计算</p>
<p><strong>Stream操作的三个步骤</strong><br>1.创建Stream:一个数据源(如集合、数组)，获取一个流<br>2.中间操作：一个中间操作链，对数据源的数据进行处理<br>3.终止操作(终端操作)：一旦执行终止操作，<strong>就执行中间操作链，并产生结果,之后不会再被使用.</strong></p>
<h4 id="Stream的实例化"><a href="#Stream的实例化" class="headerlink" title="Stream的实例化"></a>Stream的实例化</h4><p>1.通过集合(或容器的实例对象),实例对象.stram()/实例对象，parallelStream()<br>2.通过数组，Arrays.stream(arr)<br>3.Stream.of(容器)<br>4.无限流</p>
<pre><code class="java">//1。通过集合
List &lt;Employee&gt; employees = EmployeeData.getEmployees()//得到集合
//default Stream&lt;E&gt; stream() Collection接口下的默认方法，返回一个顺序流(按顺序获取)
Stream&lt;Employee&gt; stram = employees.stram();
//default Stream&lt;E&gt; paralleStream() 返回一个并行流
Stream &lt;Employee&gt; parallelStream = employees.parallelStream();

//2.通过数组
//调用Arrays类的static &lt;T&gt; Stream &lt;T&gt; stream(T[] array) 返回一个流
/*
IntStream stream(int[] array)
LongStream stream(long[] array)
DoubleStream stream(double[] array)
Stream &lt;Employee&gt; stream = Arrays.stream(Employee[]的实例对象)
*/
int[] arr = new int[]{1,2.3,4}
IntStream stream = Arrays.stream(arr);

//3.通过Stream的of()
//public static&lt;T&gt; Stream &lt;T&gt; of (T...values) 返回一个流
Stream&lt;Integer&gt; stream = Stream.of(1,2,3,4,5,6) //这里的int是包装类

//4.创造无限流
//迭代 public static&lt;T&gt; Stream &lt;T&gt; iterate(final T seed,final UnayOperator&lt;T&gt; f) 第二个参数是特殊的Function，参数和返回值是同样的类型
Stream.iterate(0,t-&gt;t+2).limit(10).forEach(System.out::println); //输出0开始的10个偶数
//不加limit是不会被终止操作终止的

//生成 public static&lt;T&gt; Stream &lt;T&gt; generate(Supplier &lt;T&gt; s)
Stream.generate(Math::random).limit(10).forEach(System.out::println);
</code></pre>
<h4 id="Stream的中间操作"><a href="#Stream的中间操作" class="headerlink" title="Stream的中间操作"></a>Stream的中间操作</h4><p>多个<strong>中间操作</strong>可以连接起来形成一个<strong>流水线</strong>，除非流水线上触发终止操作，否则<strong>中间操作不会执行任何处理，而在终止操作时一次性全部处理，称为惰性求值</strong></p>
<p>中间操作返回的是一个Stream,这样才能链式操作形成一个流水线。</p>
<p><strong>筛选与切片</strong><br>1.filter(Predicate p)从流中过滤出符合lambda表达式的值<br>2.limit(n)截断流，使其元素不超过给定数量<br>3.skip(n)跳过元素，返回一个扔掉了前n个元素的流，若流中元素不足n，则返回空流<br>4.distinct()去重，通过元素的hashCode和equals()去除重复元素</p>
<pre><code class="java">int[] arr =new int[]{1,2,3,4,5,6,5,6};
IntStream stream = Arrays.stream(arr);
//filter(Predicate p)从流中过滤出符合lambda表达式的值
stream.filter(num -&gt; num % 2 == 0).forEach(System.out::print);

//limit(n)截断流，使其元素不超过给定数量
//错误写法,流一旦终止就被关闭
//stream.limit(3).forEach(System.out::print);
IntStream stream1 = Arrays.stream(arr);
stream1.limit(3).forEach(System.out::print);

//因为流一旦终止就被关闭需要重新创建，所以一般不需要变量承接stream，每次都新建如下面的写法
//skip(n)跳过元素，返回一个扔掉了前n个元素的流，若流中元素不足n，则返回空流
Arrays.stream(arr).skip(2).forEach(System.out::print);

//distinct()去重，通过元素的hashCode和equals()去除重复元素
Arrays.stream(arr).distinct().forEach(System.out::print);
</code></pre>
<p><strong>映射</strong></p>
<p>map(Function f):接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应用到每个元素上，并将其映射成一个新的元素,类似list的add</p>
<p>flatMap(Function f):接收一个函数作为参数,将一个流中的每个值都转成一个流(内部值取出来转化成一个流)，然后再将这些流扁平化成为一个流(方便链式操作)，类似list的addAll,把内部的值都取出来。</p>
<pre><code class="java">//map(Function f):接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应用到每个元素上，并将其映射成一个新的元素
List&lt;String&gt; list = Arrays.asList(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;);
list.stream().map(str -&gt; str.toUpperCase()).forEach(System.out::print);

//flatMap(Function f):接收一个函数作为参数，将一个流中的每个值都转成一个个流，然后再将这些流扁平化成为一个流 
//fliatMap类似addAll,map类似add
ArrayList list1 = new ArrayList();
list1.add(1);
list1.add(2);
list1.add(3);
ArrayList list2 = new ArrayList();
list2.add(4);
list2.add(5);
list2.add(6);
list1.add(list2); //[1,2,3,[4,5,6]]
list1.addAll(list2);//[1,2,3,4,5,6]
System.out.println(list1);
</code></pre>
<p><strong>排序</strong><br>sorted():产生一个新流,其中按自然排序排序<br>sorted(Comparator com):产生一个新流,其中按比较器顺序排序</p>
<pre><code class="java">//sorted():自然排序
List&lt;Integer&gt; list = Arrays.asList(12,43, 87, 0);
list.stream.sorted().forEach(System.out::print);

//sorted(Comparator com):产生一个新流,其中按比较器顺序排序
List&lt;Employee&gt; employees = EmployeeData.getEmployees();
employess.stream().sorted((e1,e2)-&gt;
  Integer.compare(e1.getAge(),e2.getAge())
).forEach(System.out.println);
</code></pre>
<h4 id="Stream的终止操作"><a href="#Stream的终止操作" class="headerlink" title="Stream的终止操作"></a>Stream的终止操作</h4><p>终止操作会从流的流水线生成结果，其结果可以是任何不是流的值。流进行了终止操作后，不能再次使用。</p>
<p><strong>匹配和查找</strong></p>
<p>allMatch(Predicate p)：检查所有元素是否匹配，返回布尔值<br>anyMatch(Predicate p）:至少一个匹配返回true<br>noneMatch(Predicate p):没有一个匹配返回true<br>findFirst():返回第一个元素 Optional类型<br>findAny():返回当前流中的任意元素<br>count():返回流中元素的个数，类型Long<br>max(Comparator c):返回流中最大值  Optional类型<br>min(Comparator c):返回流中最小值  Optional类型<br>forEach(Consumer c):内部迭代器</p>
<p><strong>规约</strong><br>1.reduce(T identity初始值,BinaryOperator)可以将流中元素反复结合起来，得到一个值,BinaryOperator传两个T返回T<br>2.reduce(BinaryOperator)可以将流中元素反复结合起来，得到一个值，返回Optional<t>,BinaryOperator传两个T返回T</t></p>
<pre><code class="java">//reduce(T identity初始值,BinaryOperator)可以将流中元素反复结合起来，得到一个值,BinaryOperator传两个T返回T
// 练习：计算1-10的自然数的和
List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7,8,9,10);
Integer sum = list.stream().reduce(0, Integer::sum);//Double::sum

//reduce(BinaryOperator)可以将流中元素反复结合起来，得到一个值，返回Optional&lt;T&gt;,BinaryOperator传两个T返回T
</code></pre>
<p><strong>收集</strong><br>collect(Collector c):将流转为其他形式，接收一个Collector接口的实现，用于给Stream中元素做汇总的方法<br>Collector接口中方法的实现决定了如何对流执行收集的操作(如收集到List、Set、Map)<br>另外，Collectors实用类提供了很多静态方法，可以方便地创建常见收集器实例</p>
<pre><code class="java">List&lt;Employee&gt; employees = EmployeeData.getEmployees();
employees.stream().filiter(e-&gt;e.getSalary&gt;6000).collect(Collects.toList());
//Collects.toSet()  Collects.toCollection
</code></pre>
<h3 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h3><p>作用:最大化减少空指针异常 -&gt; 问了解决空指针问题<br>说明:Optional<t>类(java.util.Optional)是一个容器类，可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。</t></p>
<p>Optional提供很多方法，这样不用显式进行空值检测。</p>
<p><strong>创建Optional类对象的方法</strong><br>Optional.of(T t):创建一个Optional实例，t必须非空<br>Optional.empty():创建一个空的Optional实例<br>Optional.ofNullable(T t):t可以为null，常用方法</p>
<p><strong>判断Optional容器是否包含对象</strong><br>boolean isPresent():判断是否包含对象</p>
<p><strong>获取Optional容器的对象</strong><br>T orElse(T other):如果有值就将其返回，没有就返回指定的other对象，也就是设置默认值。常用方法<br>T get():获取内部封装的数据value如果调用对象包含值，返回该值，否则抛异常。<br>T orElseGet(Supplier&lt;? extend T&gt; other):如果有值则返回，否则返回由Supplier接口实现提供的对象</p>
<p>不确定：Optional.ofNullable(T t) + T orElse(T other)<br>确定：Optional.of(T t) + T get()</p>
<p>使用举例</p>
<pre><code class="java">public String getGirlName(Boy boy){
  if(boy != null){
    Girl girl = boy.getGirl();
    if(girl !=null){
      return gitl.getName()
    }
  }
  return null;
}
//使用Optional类的getGirlName()
public String getGirlName(Boy boy){
Optional&lt;Boy&gt; optionalGirl =  Option.ofNullable(boy);
Boy boy = optionalGirl.orElse(new boy(&quot;ranan&quot;)); //有就返回，没有就返回ranan，也就是设置默认值

}
</code></pre>
<h2 id="Java9"><a href="#Java9" class="headerlink" title="Java9"></a>Java9</h2><h3 id="模块化系统"><a href="#模块化系统" class="headerlink" title="模块化系统"></a>模块化系统</h3><p>模块(module)不声明默认就是隐藏。因此，模块化使得代码组织上更安全，因为可以指定哪些暴露，哪些隐藏。</p>
<p>模板之间的暴露关系需要在src下新建module.info.java</p>
<pre><code class="java">//moduleName的module.info.java
module moduleName{
  exports packageName
}
//moduleName1的module.info.java
module moduleName1{
  requires moduleName;
}
</code></pre>
<h3 id="jShell命令"><a href="#jShell命令" class="headerlink" title="jShell命令"></a>jShell命令</h3><p>Java的交互式编程环境REPL(read - evaluate - print - loop),以交互式的方式对语句和表达式进行求值。</p>
<p>cmd:jshell命令进入交互式编程环境</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="接口的私有方法"><a href="#接口的私有方法" class="headerlink" title="接口的私有方法"></a>接口的私有方法</h4><p>java8中接口的方法，权限都是默认的public(可省略)<br>抽象方法:如果实现类覆盖(实现)了接口中的所有抽象方法，则此实现类就可以实例化;如果实现了没有覆盖覆盖(实现)接口所有的抽象方法，则此实现类为抽象类(加上abstract)<br>静态方法，只能由接口自己调用<br>默认(default关键字)的方法，可以重写,可以通过接口名.super.方法名调用或者使用实例对象调用</p>
<p>java9中方法的访问权限修饰符可以声明为peivate</p>
<pre><code class="java">//如下的三个方法的权限修饰符都是public
void methodAbstract();
static void methodStatic(){
        System.out.println(&quot;我是接口中的静态方法&quot;);
};
default void menthodDefault(){
        System.out.println(&quot;我是接口中的默认方法&quot;);
}
//Jdk9中允许定义私有方法
private void menthodPrivate(){
        System.out.println(&quot;我是接口中的私有方法&quot;);
}
</code></pre>
<h4 id="钻石操作符的使用升级"><a href="#钻石操作符的使用升级" class="headerlink" title="钻石操作符的使用升级"></a>钻石操作符的使用升级</h4><p>钻石操作符<code>&lt;&gt;</code></p>
<p>匿名实现类与钻石操作符共同使用时，可以进行类型推断。</p>
<pre><code class="java">//jdk7的新特性:类型推断
ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
//jdk8匿名实现类与钻石操作符共同使用时是不能进行类型推断的
Comparator&lt;Object&gt; com = new Comparator&lt;Object&gt;() {
  @Override
  public int compare(Object o, Object t1) {
               return 0;
  }
}
</code></pre>
<h4 id="try语句"><a href="#try语句" class="headerlink" title="try语句"></a>try语句</h4><p>java8可以实现<strong>资源的自动关闭</strong>(不用在finally)，但要求执行后必须关闭的所有资源必须在try小括号中初始化，否则编译不通过。<br>java9自动关闭的资源可以在try子句的外部初始化，初始化好了再传给try子句。</p>
<p><strong>注意</strong><br>1.try小括号里的资源是final类型的,只能使用不能修改。</p>
<pre><code class="java">//@Test 单元测试方式不能在控制台读数据
//java8之前处理资源关闭需要在finally中
public static void main(String[] args) {
InputStreamReader reader = null;
try {
  reader = new InputStreamReader(System.in);
  char[] cbuf = new char[20];
  int len;
   if((len = reader.read(cbuf)) !=-1){
    String str = new String(cbuf,0,len);
    System.out.println(str);
    }
   } catch (IOException e) {
     e.printStackTrace();
   } finally {
     if(reader!=null){
       try {
          reader.close();
         } catch (IOException e) {
          e.printStackTrace();
          }
        }
  }
}

//java8:自动关闭的资源初始化必须在try小括号中
try (InputStreamReader reader = new InputStreamReader(System.in)){
  char[] cbuf = new char[20];
  int len;
  if((len = reader.read(cbuf)) !=-1){
    String str = new String(cbuf,0,len);
    System.out.println(str);
  }
} catch (IOException e) {
            e.printStackTrace();
}

//java9:自动关闭的资源可以在外部初始化
InputStreamReader reader = new InputStreamReader(System.in);
try (reader){
  char[] cbuf = new char[20];
  int len;
  if((len = reader.read(cbuf)) !=-1){
     String str = new String(cbuf,0,len);
     System.out.println(str);
  }
} catch (IOException e) {
  e.printStackTrace();
}
</code></pre>
<h4 id="String存储结构变更"><a href="#String存储结构变更" class="headerlink" title="String存储结构变更"></a>String存储结构变更</h4><p>StringBuffer与StringBuilder和String存储结构也变了</p>
<p>char[] value  -&gt; byte[] value</p>
<h4 id="集合工厂方法-快速创建只读集合"><a href="#集合工厂方法-快速创建只读集合" class="headerlink" title="集合工厂方法:快速创建只读集合"></a>集合工厂方法:快速创建只读集合</h4><p>补充:Arrays.asList()得到的集合是只读集合</p>
<p>Java9的of()方法</p>
<pre><code class="java">//创建只读集合 
//java8的写法
ArrayList&lt;String&gt; nameList = new ArrayList&lt;&gt;();
nameList.add(&quot;Hoe&quot;);
nameList.add(&quot;Joe&quot;);
nameList.add(&quot;Bill&quot;);
nameList = (ArrayList&lt;String&gt;) Collections.unmodifiableList(nameList);
System.out.println(nameList);

//Java9
List&lt;Integer&gt; list = List.of(1, 2, 3, 4, 5);
Set&lt;Integer&gt; set = Set.of(23, 3, 54, 65, 43);
Map.ofEntries(Map.entry(&quot;tom&quot;,&quot;34&quot;),Map.entry(&quot;Lili&quot;,25));
</code></pre>
<h4 id="InputStream加强"><a href="#InputStream加强" class="headerlink" title="InputStream加强"></a>InputStream加强</h4><p>InputStream新方法<code>transferTo</code>,可以用来将数据直接传输到OutputStream</p>
<p>输入流.transferTo(输出流):把输入流中的所有数据直接自动复制到输出流</p>
<h4 id="Stream-API-1"><a href="#Stream-API-1" class="headerlink" title="Stream API"></a>Stream API</h4><p>Stream接口中添加了4个新方法</p>
<p><strong>Stream实例的生成</strong><br>Stream.of(null)是不行的，Stream.of(null,null)是可以的。Java8中的Steam不能只有单个元素null,否则会报空指针异常。<br>Java9中Stream.ofNullable(),参数只能是一个值，可以为null</p>
<p>iterate方法的新重载,第二个参数为断定型，满足条件才继续迭代，不满足条件则终止。</p>
<pre><code class="java">//java8
//迭代 public static&lt;T&gt; Stream &lt;T&gt; iterate(final T seed,final UnayOperator&lt;T&gt; f) 第二个参数是特殊的Function，参数和返回值是同样的类型
Stream.iterate(0,t-&gt;t+2).forEach(System.out::println); //是不会被终止操作终止的，创建的是无限流

//java9
//x=100时终止
Stream.iterate(0,x-&gt;x&lt;100,x-&gt;x+2).forEach(System.out::println); 
</code></pre>
<p><strong>中间操作方法</strong><br>takeWhile(Predicate p):在有序的Stream中,takeWhile返回从开头开始的尽量多的元素，有一个不满足就不再判断了，返回前面都满足的元素。<br>dropWhile(Predicate p):返回从开头开始第一个不满足条的件及其后面的元素,返回剩余的元素。</p>
<h4 id="Optional获取Stream的方法"><a href="#Optional获取Stream的方法" class="headerlink" title="Optional获取Stream的方法"></a>Optional获取Stream的方法</h4><p>Optional类(容器)中的Stream()的使用</p>
<pre><code class="java">ArrayList&lt;String&gt; list= new ArrayList&lt;&gt;();
list.add(&quot;Tom&quot;);
list.add(&quot;Jerry&quot;);
list.add(&quot;Tim&quot;);
Optional&lt;ArrayList&lt;String&gt;&gt; list1 = Optional.ofNullable(list);
Stream&lt;ArrayList&lt;String&gt;&gt; stream = list1.stream();
//stream.count(); 只有一个流，把流中的元素全部取出再封装成一个流
stream.flatMap(x-&gt;x.stream()).forEach(System.out::println);
</code></pre>
<h2 id="Java10"><a href="#Java10" class="headerlink" title="Java10"></a>Java10</h2><h3 id="局部变量类型推断"><a href="#局部变量类型推断" class="headerlink" title="局部变量类型推断"></a>局部变量类型推断</h3><p>从等号右边推断出等号左边的类型,用<code>var</code>代表类型。</p>
<p>工作原理:在处理var时，编译器先查看表达式右边部分，根据右边的类型进行推断，作为左边变量的类型，然后将该类型写入字节码中。</p>
<p>注意:<br>1.var不是关键字，所以可以声明方法名变量名为var<br>2.var并不会改变Java是一门静态类型语言(先编译再运行)的事实，</p>
<pre><code class="java">//int num = 10;
var num = 10;
/*
右边的&lt;&gt;里根据左边推断出来的,ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();如果使用类型推断省略左边的泛型类型，那么右边的泛型需要显示的写出来。
*/
var list = new ArrayList&lt;String&gt;();
//for(String i:list){}
for(var i:list){}
</code></pre>
<p><strong>不允许的情况</strong></p>
<p>总之就是右边可以把左边推出来就可以使用</p>
<p>1.方法的参数类型，返回值，构造器的参数类型。<br>2.类的属性不可以用，因为属性有默认值，需要知道类型。<br>3.catch块的参数</p>
<pre><code class="java">//1.局部变量不赋值，就不能实现类型推断
//var num;
//var num = null; 引用类型都是null不饿能推断出来

//2.使用了Lambda表达式，左边的函数式接口不能声明为var，因为Lambda表达式就是从左边的函数式接口推断出来的
//var sup = () -&gt; Math.random,
Supplier&lt;Double&gt; sup = ()-&gt;Math.random();

//3.var arr1 = {1,2,3,4}
int[] arr = new int[]{1,2,3,4};
var arr1 = new int[]{1,2,3,4};
int[] arr2 = {1,2,3,4};

</code></pre>
<h3 id="of方法与copyOf方法"><a href="#of方法与copyOf方法" class="headerlink" title="of方法与copyOf方法"></a>of方法与copyOf方法</h3><p>Java9开始，jdk里为集合(List/Set/Map)添加了of(9新增)和copyOf(10新增),两个方法都用来创建不可变的集合。</p>
<p>copyOf(参数) 参数本身是只读的，返回的就是原来的。参数本身不是只读的，返回新的只读集合。</p>
<pre><code class="java">//copyOf(参数) 参数本身是只读的，返回的就是原来的
var list = List.of(&quot;Java&quot;,&quot;Python&quot;,&quot;C&quot;);
var copy = List.copyOf(list);
System.out.println(copy == list);//true
//参数本身不是只读的，返回新的只读集合
var list2 = new ArrayList&lt;String&gt;();
var copy2 = List.copyOf(list2);
System.out.println(list2 == copy2);//false
</code></pre>
<h2 id="Java11"><a href="#Java11" class="headerlink" title="Java11"></a>Java11</h2><p>Java11是长期支持的版本。</p>
<h3 id="String的新增方法"><a href="#String的新增方法" class="headerlink" title="String的新增方法"></a>String的新增方法</h3><p>isBlank方法：判断字符串是否为空<br>strip方法:去掉字符串中的空白包括\n\t<br>//stripLeading去除开头的空白</p>
<pre><code class="java">//isBlank方法判断字符串是否为空
System.out.println(&quot; \n &quot;.isBlank()); //true

//strip方法去掉字符串中的空白包括\n\t
System.out.println(&quot;  xxx  &quot;.strip());
//之前的方法，去除首尾的白\n\t
System.out.println(&quot;  xxx  &quot;.trim());

//stripLeading去除开头的空白
System.out.println(&quot;  xxx  &quot;.stripLeading());
//stripTrailing()去除尾部的空白
System.out.println(&quot;  xxx  &quot;.stripTrailing());
//repeat方法重复n次
System.out.println(&quot;abc&quot;.repeat(5));

System.out.println(&quot; abcd \n ddd&quot;.lines().count()); //2
</code></pre>
<h3 id="Optional的新增方法"><a href="#Optional的新增方法" class="headerlink" title="Optional的新增方法"></a>Optional的新增方法</h3><p>boolean isEmpty() 判断value是否为空 JDK11<br>T orElseThrow() value非空返回value，否则抛异常NoSuchElementException JDK10<br>ifPresentOrElse(Consumer&lt;?super T&gt;action,Runnable emptyAction) value非空执行参数1功能，为空执行参数2功能 JDK9<br>Optional <t> or(Supplier&lt;? extend Optional&lt;? extend T&gt;&gt; supplier):value非空，返回对应的非空，value为空，返回形参封装的Optional，而orElse关注的是value</t></p>
<pre><code class="java">Optional&lt;Object&gt; op = Optional.empty();
System.out.println(op.isPresent()); //JDK8,判断内部的value是否存在
System.out.println(op.isEmpty());//JDK11，判断内部的value是否为空

Optional&lt;String&gt; op1 = Optional.of(&quot;hello&quot;);
Optional&lt;Object&gt; op2 = op.or(() -&gt; op1);
System.out.println(op2); //hello
</code></pre>
<h3 id="局部变量类型推断的升级"><a href="#局部变量类型推断的升级" class="headerlink" title="局部变量类型推断的升级"></a>局部变量类型推断的升级</h3><p>var前面可以添加注解</p>
<pre><code class="java">//错误形式
//Consumer&lt;String&gt;  con1 = (@Deprecated t) -&gt; System.out.print(t.toUpperCase());
//使用var的好处是在使用Lambda表达式时可以给参数加上注解
Consumer&lt;String&gt;  con1 = (@Deprecated var t) -&gt; System.out.print(t.toUpperCase());
</code></pre>
<h3 id="全新的HTTP客户端API"><a href="#全新的HTTP客户端API" class="headerlink" title="全新的HTTP客户端API"></a>全新的HTTP客户端API</h3><p>java.net.http包下,HttpClient类主要替换HttpURLConnection，提供对WebSocket和HTTP/2的支持。</p>
<h3 id="更简化的编译运行程序"><a href="#更简化的编译运行程序" class="headerlink" title="更简化的编译运行程序"></a>更简化的编译运行程序</h3><p>一个命令编译运行源代码的注意点<br>1.只执行源文件中的第一个类，第一个类必须包含main方法<br>2.不可以使用其他源文件中的自定义类，本文件中的自定义类是可以使用的</p>
<pre><code class="java">//编译
javac Javastack.java
//运行 Javastack类
java Javastack

//java11通过一个java命令
java Javastak.java
</code></pre>
<h3 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h3><p>GC(垃圾回收)是java的主要优势之一</p>
<p>ZGC,A Scalable Low-Latency Garbage Collector(Experimental),后面Experimental说明还不建议用到生产环境。ZGC是一个并发的，基于region，压缩型的垃圾收集器，只有root扫描阶段会STW(stop the world),因此GC停顿时间不会随着堆的增长和存活对象的增长而变从长。</p>

  </article>
  <aside class="table-content" id="site-toc">
  <div class="table-content-title">
    <i class="fa fa-arrow-right fa-lg" id="site-toc-hide-btn"></i>
    <span>目录</span>
  </div>
  <div class="table-content-main">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java8"><span class="toc-text">Java8</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda表达式"><span class="toc-text">Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#函数式-Functional-接口"><span class="toc-text">函数式(Functional)接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法引用"><span class="toc-text">方法引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#构造器引用"><span class="toc-text">构造器引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream-API"><span class="toc-text">Stream API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Stream的实例化"><span class="toc-text">Stream的实例化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Stream的中间操作"><span class="toc-text">Stream的中间操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Stream的终止操作"><span class="toc-text">Stream的终止操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Optional类"><span class="toc-text">Optional类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java9"><span class="toc-text">Java9</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#模块化系统"><span class="toc-text">模块化系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jShell命令"><span class="toc-text">jShell命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#语法"><span class="toc-text">语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#接口的私有方法"><span class="toc-text">接口的私有方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#钻石操作符的使用升级"><span class="toc-text">钻石操作符的使用升级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#try语句"><span class="toc-text">try语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String存储结构变更"><span class="toc-text">String存储结构变更</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#集合工厂方法-快速创建只读集合"><span class="toc-text">集合工厂方法:快速创建只读集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InputStream加强"><span class="toc-text">InputStream加强</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Stream-API-1"><span class="toc-text">Stream API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Optional获取Stream的方法"><span class="toc-text">Optional获取Stream的方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java10"><span class="toc-text">Java10</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#局部变量类型推断"><span class="toc-text">局部变量类型推断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#of方法与copyOf方法"><span class="toc-text">of方法与copyOf方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java11"><span class="toc-text">Java11</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String的新增方法"><span class="toc-text">String的新增方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Optional的新增方法"><span class="toc-text">Optional的新增方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#局部变量类型推断的升级"><span class="toc-text">局部变量类型推断的升级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#全新的HTTP客户端API"><span class="toc-text">全新的HTTP客户端API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更简化的编译运行程序"><span class="toc-text">更简化的编译运行程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZGC"><span class="toc-text">ZGC</span></a></li></ol></li></ol>
  </div>
</aside>
  
  
    <div class="passage-tags">
     
      <a href="/tags/Java/"><i class="fa fa-tags"></i>Java</a>
    
    </div>
  
</div>

    </main>
    
    <div class="site-footer-wrapper">
  <footer class="site-footer">
    
    <!--<div class="site-footer-info">-->
      <!--<i class="fa fa-clock-o"></i> 本站已稳定运行<span id="site-time"></span>-->
    <!--</div>-->
    
    
      <div class="site-footer-info">
        <i class="fa fa-at"></i> Email: 981684424@qq.com
      </div>
    
    <div class="site-footer-info">
      <i class="fa fa-copyright"></i> 
      2019 <a href="https://github.com/dongyuanxin/theme-ad/" target="_blank">Theme-AD</a>.
      Created by <a href="https://godbmw.com/" target="_blank">GodBMW</a>.
      All rights reserved.
    </div>
  </footer>
</div>
    <div id="site-layer" style="display:none;">
  <div class="site-layer-content">
    <div class="site-layer-header">
      <span class="site-layer-header-title" id="site-layer-title"></span>
      <i class="fa fa-close" id="site-layer-close"></i>
    </div>
    <div class="site-layer-body" id="site-layer-container">
      <div class="site-layer-input" id="site-layer-search" style="display: none;">
        <div class="site-layer-input-choose">
          <a href="javascript:void(0);" title="Change Search Engine">Google</a>
        </div>
        <input type="text">
        <i class="fa fa-search"></i>
      </div>
      
      <div id="site-layer-welcome" style="display:none;"></div>
    </div>
  </div>
</div>
    

<div class="bottom-bar">
  <div class="bottom-bar-left">
    <a href="javascript:void(0);" data-enable="false">
      <i class="fa fa-arrow-left"></i>
    </a>
    <a href="/2021/03/27/Java反射/" data-enable="true">
      <i class="fa fa-arrow-right"></i>
    </a>
  </div>
  <div class="bottom-bar-right">
    <a href="javascript:void(0);" data-enable="true" id="site-toc-show-btn">
      <i class="fa fa-bars"></i>
    </a>
    
    <a href="javascript:void(0);" id="site-toggle-share-btn">
      <i class="fa fa-share-alt"></i>
    </a>
    
    <a href="javascript:void(0);" id="back-top-btn">
      <i class="fa fa-chevron-up"></i>
    </a>
  </div>
</div>
    <div id="share-btn">
  
  
  
  
  
</div>
    





    
  </body>
</html>