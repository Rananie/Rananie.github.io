<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ranan_blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-11-04T11:40:31.621Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ranan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前缀和(未更新)</title>
    <link href="http://yoursite.com/2020/11/05/note-%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    <id>http://yoursite.com/2020/11/05/note-前缀和/</id>
    <published>2020-11-05T11:28:23.000Z</published>
    <updated>2020-11-04T11:40:31.621Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目</strong><br><a href="https://leetcode-cn.com/problems/unique-substrings-in-wraparound-string/" target="_blank" rel="noopener">leetcode467</a></p><p><a href="https://leetcode-cn.com/problems/number-of-subarrays-with-bounded-maximum/" target="_blank" rel="noopener">leetcode795</a></p><p><a href="https://leetcode-cn.com/problems/fruit-into-baskets/" target="_blank" rel="noopener">leetcode904</a></p><p><a href="https://leetcode-cn.com/problems/subarrays-with-k-different-integers/" target="_blank" rel="noopener">leetcode992</a></p><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>适用场景：题目要求连续的限制<br>好处:优化时间复杂度</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/unique-substrings-in-wraparound-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
      
    
    </summary>
    
      <category term="刷题笔记" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>note-深度优先算法</title>
    <link href="http://yoursite.com/2020/11/04/note-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/11/04/note-深度优先算法/</id>
    <published>2020-11-04T12:17:28.000Z</published>
    <updated>2020-11-04T12:59:21.090Z</updated>
    
    <content type="html"><![CDATA[<p><strong>图的遍历</strong></p><p>从已给的连通图中某一顶点出发，沿边访问图中所有顶点，每个顶点仅被访问一次。<br>遍历实质:找每个顶点的邻接点的过程。</p><p>如何避免重复访问?<br>解决思路:设置辅助数组visited[n],用来标记每个被访问过的顶点。</p><ul><li>初始状态visited[i]为0。</li><li>顶点i被访问,改visited[i]为1，防止多次被访问。</li></ul><p><strong>深度优先搜索DFS</strong></p><p>利用栈，一条路走到底全部入栈，没有路走则出栈重新找路，直到所有的顶点都被访问。</p><p><img src="/img/leetcode/深度优先.png"></p><pre><code>void DFS(AMGraph G, int V){    //图G为邻接矩阵类型,V是开始的顶点    visited[v] = true ;    for(w=0;w&lt;G.vexnum;w++){        //依次检查邻接矩阵v所在行        if((G.arcs[v][w]!=0)&amp;&amp;(!visited[w]))            DFS(G,w);            //w是v的邻接点，如果w未访问，则递归调用DFS            //递归结束返回上一层,就是在实现回退的操作    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;图的遍历&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从已给的连通图中某一顶点出发，沿边访问图中所有顶点，每个顶点仅被访问一次。&lt;br&gt;遍历实质:找每个顶点的邻接点的过程。&lt;/p&gt;
&lt;p&gt;如何避免重复访问?&lt;br&gt;解决思路:设置辅助数组visited[n],用来标记每个
      
    
    </summary>
    
      <category term="刷题笔记" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>day4-栈 字符串解码(待更新)</title>
    <link href="http://yoursite.com/2020/11/04/day4-%E6%A0%88%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/"/>
    <id>http://yoursite.com/2020/11/04/day4-栈 字符串解码/</id>
    <published>2020-11-04T12:08:11.000Z</published>
    <updated>2020-11-05T12:33:25.916Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目</strong></p><p><a href="https://leetcode-cn.com/problems/shortest-distance-to-a-character/" target="_blank" rel="noopener">leetcode394.字符串解码</a></p><p>给定一个经过编码的字符串，返回它解码后的字符串。<br>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复k次。注意k保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p><p>示例 ：</p><pre><code>输入：s = &quot;3[a]2[bc]&quot;输出：&quot;aaabcbc&quot;输入：s = &quot;3[a2[c]]&quot;输出：&quot;accaccacc&quot;输入：s = &quot;2[abc]3[cd]ef&quot;输出：&quot;abcabccdcdcdef&quot;输入：s = &quot;abc3[cd]xyz&quot;输出：&quot;abccdcdcdxyz&quot;</code></pre><p><strong>思路</strong></p><p>看见方括号，首先想到用栈。</p><p>题目给定的条件有四种可能出现的字符<br>1.字母 -&gt; 直接拼接str<br>2.数字 -&gt; 拼接到数字字符串<br>3.[   -&gt; 当前的str与当前的num入栈,清空str与num<br>4.]   -&gt; {str,num}出栈,当前的str是需要重复的字符串，{}里的str是[前的字符串</p><p>示例: <code>xy3[a2[c]]</code></p><pre><code>   | str | num |stackx  | &quot;x&quot; |&quot;&quot; | []y  | &quot;xy&quot;|&quot;&quot; | []3  | &quot;xy&quot;|&quot;3&quot;| [][  | &quot;&quot;| &quot;&quot;| [{str:&quot;xy&quot;,num:&quot;3&quot;}]a  | &quot;a&quot; | &quot;&quot;| [{str:&quot;xy&quot;,num:&quot;3&quot;}]2  | &quot;a&quot; | &quot;2&quot;| [{str:&quot;xy&quot;,num:&quot;3&quot;}][  | &quot;&quot; | &quot;&quot;| [{str:&quot;xy&quot;,num:&quot;3&quot;},{str:&quot;a&quot;,num:&quot;2&quot;}]c  | &quot;c&quot;|&quot; &quot; |[{str:&quot;xy&quot;,num:&quot;3&quot;},{str:&quot;a&quot;,num:&quot;2&quot;}]]  | &quot;a&quot; + &quot;cc&quot;|&quot;&quot; |[{str:&quot;xy&quot;,num:&quot;3&quot;}]]  | &quot;xy&quot; + &quot;accaccacc&quot;|&quot;&quot; |[]</code></pre><p><strong>代码</strong></p><pre><code class="js">/** * @param {string} s * @return {string} */var decodeString = function(s) {    let num = &#39;&#39;,str=&#39;&#39;;    let stack = [] ;    for(let char of s){        if(!isNaN(char)){            num += char;             }else if(char == &quot;[&quot;){          stack.push({str,num});          str =&quot;&quot;;          num =&quot;&quot;;        }else if(char ==&quot;]&quot;){        let date = stack.pop();        str = date.str + str.repeat(date.num);        }else{        str += char;        }    }    return str;};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/shortest-distance-to-a-character/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;le
      
    
    </summary>
    
      <category term="刷题笔记" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>note-滑动窗口法</title>
    <link href="http://yoursite.com/2020/11/04/note-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B3%95/"/>
    <id>http://yoursite.com/2020/11/04/note-滑动窗口法/</id>
    <published>2020-11-04T11:39:21.000Z</published>
    <updated>2020-11-04T12:05:33.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>使用场景：解决连续问题，如”连续子串xxx”,”连续子数组xxx”。<br>优点：把嵌套的for循坏转换为单个for循坏，优化时间复杂度。</p><p>由于区间连续，因此当区间发生变化时，可以通过旧有的计算结果对搜索空间进行剪枝，这样便减少了重复计算，降低了时间复杂度。</p><p>假设有数组[a,b,c,d,e],一个大小为2的滑动窗口在其滑动，滑动窗口也可以说是在合法区间内滑动，动态的拥有一些数据。</p><pre><code>[a,b]    [b,c]        [c,d]            [d,e]</code></pre><h2 id="滑动窗口的分类"><a href="#滑动窗口的分类" class="headerlink" title="滑动窗口的分类"></a>滑动窗口的分类</h2><ul><li>固定窗口大小</li><li>窗口大小不固定，求解最大的满足条件的窗口</li><li>窗口大小不固定，求解最小的满足条件的窗口</li></ul><p><strong>固定窗口大小</strong></p><p>对于固定窗口，我们只需要固定初始化左右指针left和right之间的距离。</p><p>1.left初始化为0。<br>2.初始化right，使 窗口大小 = right - left + 1。<br>3.同时移动left和right，固定住窗口的大小。<br>4.判断窗口内的连续元素是否满足题目限定的条件。<br>    4.1 如果满足，再判断是否需要更新最优解，如果需要则更新最优解。<br>    4.2 如果不满足，则继续。</p><p><strong>可变窗口大小</strong></p><p>对于可变窗口，同样固定初始化左右指针left和right,分别表示窗口的左右顶点。</p><p>1.left和right都初始化为0。<br>2.right指针移动一步<br>3.判断窗口内的连续元素是否满足题目限定的条件<br>    3.1 如果满足，再判断是否需要更新最优解，如果需要则更新最优解。并尝试通过移动 left 指针缩小窗口大小。循环执行 3.1<br>    3.2 如果不满足，则继续。</p><p>也就是说right指针先右移，直到窗口满足条件，然后移动left指针，缩小范围。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://github.com/azl397985856/leetcode/blob/master/thinkings/slide-window.md" target="_blank" rel="noopener">参考文章</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h2&gt;&lt;p&gt;使用场景：解决连续问题，如”连续子串xxx”,”连续子数组xxx”。&lt;br&gt;优点：把嵌套的for循坏转换为单个for循坏，优化时间复杂度。&lt;
      
    
    </summary>
    
      <category term="刷题笔记" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>exp-数组 有效的山脉数组</title>
    <link href="http://yoursite.com/2020/11/03/exp-%E6%95%B0%E7%BB%84%20%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/11/03/exp-数组 有效的山脉数组/</id>
    <published>2020-11-03T14:42:05.000Z</published>
    <updated>2020-11-04T11:27:52.075Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目</strong></p><p><a href="https://leetcode-cn.com/problems/shortest-distance-to-a-character/" target="_blank" rel="noopener">leetcode941</a></p><p>给定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。</p><p>让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：</p><p>A.length &gt;= 3<br>在 0 &lt; i &lt; A.length - 1 条件下，存在 i 使得：<br>A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i]<br>A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]</p><p><img src="/img/leetcode/mountain_array.png.png"></p><p><strong>思路</strong></p><p>1.先找到最大值记录下坐标i。<br>2.一个变量记录元素与最大值的差<br>3.i的左边，当前元素与最大值的差与变量比较，应该越来越大<br>4.i的右边，当前元素与最大值的差与变量比较，应该越来越小</p><p><strong>代码</strong></p><pre><code class="JAVA">class Solution {    public boolean validMountainArray(int[] A) {        int length = A.length;        int pre = -10000;        int next =  10000;        if(length == 0){            return false;        }        //找到最大值        int cur = A[0],index = 0;        for(int i = 1  ; i&lt;length ; i++){            if(A[i] &lt;= cur ){                break;            }            cur = A[i];            index = i ;        }        //如果最大值在第一个元素和最后一个返回false        if(index == 0 || index == length-1){            return false;        }        //循坏比较        for(int i = 0; i&lt;length;i++){            if(i&lt;index){                //说明在最大值的左边                if(A[i] - cur &lt;= pre){                return false ;                }                pre = A[i] - cur ;            }            if(i&gt;index){                //说明在最大值右边                if(A[i] == cur || A[i] - cur &gt;= next){                    return false;                }                next = A[i] - cur ;            }        }        return true;    }}</code></pre><p><strong>优化</strong></p><p>第二天起来看，感觉写的太复杂了。要多花时间在思考上面，而不是写代码QAQ<br>转换了下思维，可以从开头往右找峰值，找到峰值返回；然后从后面往左找峰值，找到峰值返回，再比较峰值数的索引是不是一样就行了。这样想想好像比之前的思路更简洁一点，至少代码是简洁了好多。</p><pre><code class="JAVA">class Solution {    public boolean validMountainArray(int[] A) {        int length = A.length;        if(length &lt; 3){            return false;        }         //左右两个指针        int left = 0,right = length-1;        //从左往又找最大值        while(left &lt; length-1 &amp;&amp; A[left] &lt; A[left+1]){            left++;        }        //从右往左找       while(right &gt; 0 &amp;&amp; A[right] &lt; A[right-1]){            right--;        }        if(left == 0 || right == length-1 ||left != right){            return false;        }        return true;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/shortest-distance-to-a-character/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;le
      
    
    </summary>
    
      <category term="刷题笔记" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>day3-栈 设计一个支持增量操作的栈</title>
    <link href="http://yoursite.com/2020/11/03/day3-%E6%A0%88%20%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81%E5%A2%9E%E9%87%8F%E6%93%8D%E4%BD%9C%E7%9A%84%E6%A0%88/"/>
    <id>http://yoursite.com/2020/11/03/day3-栈 设计一个支持增量操作的栈/</id>
    <published>2020-11-03T13:08:17.000Z</published>
    <updated>2020-11-04T12:11:07.861Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目</strong></p><p><a href="https://leetcode-cn.com/problems/shortest-distance-to-a-character/" target="_blank" rel="noopener">leetcode1384.设计一个支持增量操作的栈</a></p><p>实现自定义栈类 CustomStack ：</p><p>CustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。<br>void push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。<br>int pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1。<br>void inc(int k, int val)：栈底的 k 个元素的值都增加val。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。</p><p>示例</p><pre><code>输入：[&quot;CustomStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;increment&quot;,&quot;increment&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;][[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]输出：[null,null,null,2,null,null,null,null,null,103,202,201,-1]解释：CustomStack customStack = new CustomStack(3); // 栈是空的 []customStack.push(1);                          // 栈变为 [1]customStack.push(2);                          // 栈变为 [1, 2]customStack.pop();                            // 返回 2 --&gt; 返回栈顶值 2，栈变为 [1]customStack.push(2);                          // 栈变为 [1, 2]customStack.push(3);                          // 栈变为 [1, 2, 3]customStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4customStack.increment(5, 100);                // 栈变为 [101, 102, 103]customStack.increment(2, 100);                // 栈变为 [201, 202, 103]customStack.pop();                            // 返回 103 --&gt; 返回栈顶值 103，栈变为 [201, 202]customStack.pop();                            // 返回 202 --&gt; 返回栈顶值 202，栈变为 [201]customStack.pop();                            // 返回 201 --&gt; 返回栈顶值 201，栈变为 []customStack.pop();                            // 返回 -1 --&gt; 栈为空，返回 -1</code></pre><p><strong>代码</strong></p><pre><code class="JAVA">class CustomStack {    private int length; //记录当前元素，默认为0    private int arr [];    public CustomStack(int maxSize) {        this.arr = new int [maxSize];    }    public void push(int x) {        if(length == arr.length){            //说明栈满了            return;        }        arr[length++] = x;    }    public int pop() {        if(length == 0){            return -1;        }        return arr[--length];    }    public void increment(int k, int val) {       int min = Math.min(k, length);        for(int i = 0; i &lt; min; i++)            arr[i] += val;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/shortest-distance-to-a-character/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;le
      
    
    </summary>
    
      <category term="刷题笔记" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://yoursite.com/2020/11/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/11/03/设计模式/</id>
    <published>2020-11-03T10:52:38.000Z</published>
    <updated>2020-11-04T12:12:41.121Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>某个类只能存在一个对象实例，且该类只提供一个取得其对象的方法。要让类在虚拟机中只能产生一个对象，首先将类的构造器的访问权限设置为private，这样就不能用new在类外产生类的对象了，但可以在内部产生该类的对象。因为在类的外部无法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以只指向类内部产生的该类对象的变量也必须定义成静态的。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">好处</th><th style="text-align:center">坏处</th></tr></thead><tbody><tr><td style="text-align:center">饿汉式</td><td style="text-align:center">对象加载时间过长</td><td style="text-align:center">线程安全的</td></tr><tr><td style="text-align:center">懒汉式</td><td style="text-align:center">延迟对象的创建</td><td style="text-align:center"></td></tr></tbody></table><pre><code class="JAVA">//饿汉式Class Bank(){    private Bank(){}    //内部创建类的对象    Private static Bank() instance = new Bank()    //提供公共的方法，返回类的实例    Public static Bank getInstance(){    return instance;    }}//懒汉式 --------------还要修改Class Order(){    //私有化构造器    private Order(){}    //声明当前类对象，没有初始化    private static Order instance = null    //在方法中造对象    public static Order getInstance(){      If(instance == null){      Instance = new Order()        }    return instance    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;单例设计模式&quot;&gt;&lt;a href=&quot;#单例设计模式&quot; class=&quot;headerlink&quot; title=&quot;单例设计模式&quot;&gt;&lt;/a&gt;单例设计模式&lt;/h2&gt;&lt;p&gt;某个类只能存在一个对象实例，且该类只提供一个取得其对象的方法。要让类在虚拟机中只能产生一个对象，首先将类的构
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>day2-数组 字符的最短距离</title>
    <link href="http://yoursite.com/2020/11/02/day2-%E6%95%B0%E7%BB%84%20%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/"/>
    <id>http://yoursite.com/2020/11/02/day2-数组 字符的最短距离/</id>
    <published>2020-11-02T10:59:24.000Z</published>
    <updated>2020-11-04T12:11:16.578Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目</strong></p><p><a href="https://leetcode-cn.com/problems/shortest-distance-to-a-character/" target="_blank" rel="noopener">leetcode821.字符的最短距离</a></p><p>给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。</p><p>示例 1:<br>输入: S = “loveleetcode”, C = ‘e’<br>输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]</p><p>说明:<br>字符串 S 的长度范围为 [1, 10000]。<br>C 是一个单字符，且保证是字符串 S 里的字符。<br>S 和 C 中的所有字母均为小写字母。</p><p><strong>思路</strong></p><ol><li>初始化一个数组distanceArr，赋最大值。</li><li>找到S中与C相等的字符。</li><li>先往左边扫，直到扫到第一个或者distanceArr[left] &lt; distance。</li><li>再往右边扫，直到扫到下一个C或者最后一个数组元素。</li></ol><p>说明：</p><ul><li>往右扫时扫到下一个C就停止而不用比是不是最短距离的原因是：以下一个C为基准往左扫的时候会比较距离。</li><li>数组元素默认值为0，0已经是最小距离了，为方便比较赋最大值    。</li></ul><p><strong>代码</strong></p><pre><code class="JAVA">import java.util.Arrays;class Solution {    public int[] shortestToChar(String S, char C) {        int length = S.length();        int distanceArr [] = new int [length];        //刚开始数组的距离不能全部为0,因为这样就是最小的距离的没办法比较之后更改        Arrays.fill(distanceArr,Integer.MAX_VALUE);        for(int i = 0 ; i &lt; length ; i++){            //S中找到C            if(C == S.charAt(i)){                //记录左指令与右指针，并且距离distance                int left = i,right = i + 1,distance = 0 ;                //往左边扫,扫到最开始或者遇见数组中距离比distance小的结束                while(left &gt;= 0 &amp;&amp; distanceArr[left] &gt; distance){                    distanceArr[left--] = distance++ ;                 }                //跳出循环之后，应该更新distance                distance = 1 ;                //往右边扫,扫到下一个C或者最后一个数组元素                while(right &lt; length &amp;&amp; C != S.charAt(right) ) {                    distanceArr[right++] = distance ++;                }            }        }        return distanceArr;    }}</code></pre><p><strong>反思</strong><br>可以先对可能情况进行分类帮助分析：<br> 1.只有左边有C字符： sdafC…<br> 2.左右两边都有C字符：…CdsfsC…<br> 3.只有右边有C字符：…Cdsff</p><p><strong>其他解法</strong></p><pre><code class="JAVA">class Solution {    public int[] shortestToChar(String S, char C) {        int length = S.length();        int distanceArr [] = new int [length];        int pre = - 10000; //刚开始没有e距离就无限大,因为后面的-pre        //先从左往右遍历        for(int i = 0 ; i &lt; length ; i++){            //每一个元素计算与pre的距离，遇见C把C的当前位置更新为pre            //looexxevx v离第二个e的距离小于第一个e所以更新e的位置为pre            if(C == S.charAt(i)){                pre = i;            }            distanceArr[i] = i - pre;        }        //从右往前遍历        pre = 10000;        for(int i =length-1 ; i&gt;=0 ;i--){            if(C == S.charAt(i)){                pre = i;            }            distanceArr[i] = Math.min(distanceArr[i], pre - i);        }        return distanceArr;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/shortest-distance-to-a-character/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;le
      
    
    </summary>
    
      <category term="刷题笔记" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>day1-数组 嘉义</title>
    <link href="http://yoursite.com/2020/11/01/day1-%E6%95%B0%E7%BB%84%20%E5%8A%A0%E4%B8%80/"/>
    <id>http://yoursite.com/2020/11/01/day1-数组 加一/</id>
    <published>2020-11-01T10:57:23.000Z</published>
    <updated>2020-11-04T12:11:25.252Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目</strong></p><p><a href="https://leetcode-cn.com/problems/plus-one/" target="_blank" rel="noopener">leetcode66.加一</a></p><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。<br>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。<br>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p>示例 1:<br>输入: [1,2,3]<br>输出: [1,2,4]<br>解释: 输入数组表示数字 123。<br>示例 2:<br>输入: [4,3,2,1]<br>输出: [4,3,2,2]<br>解释: 输入数组表示数字 4321。</p><p>提示：不要将数组转化为数字做加法再转回来。</p><p><strong>思路</strong></p><p>从最后一个数组元素开始往前遍历，不是9直接+1返回数组，是9变为0进入下一次循环，不断的重复直到某一个数组元素不是9或者找到了第一个元素。<br>特殊情况数组元素全为9的时候，例子:[9,9] -&gt; [1,0,0]</p><p><strong>代码</strong></p><pre><code class="JAVA">class Solution {    public int[] plusOne(int[] digits) {        for(int i = digits.length-1 ; i &gt;= 0 ; i--) //从后往前遍历        {            if(digits[i] != 9){                digits[i]++ ;                return digits;            }            digits [i] = 0 ;        }        //如果退出循环说明是特殊情况，且目前的数组元素全是0。        //因为JAVA数组长度一确定就不能修改，所以用返回一个新数组        //数组中为int型元素默认值为0，所以只需要修改第一个元素为1         int newArr [] = new int [digits.length + 1];          newArr[0] = 1;         return newArr;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/plus-one/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode66.加一&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给
      
    
    </summary>
    
      <category term="刷题笔记" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>10.24-10.25 pla算法/pocket算法</title>
    <link href="http://yoursite.com/2020/10/23/10-24pla%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/10/23/10-24pla算法/</id>
    <published>2020-10-23T12:15:19.000Z</published>
    <updated>2020-10-25T05:16:35.603Z</updated>
    
    <content type="html"><![CDATA[<p>机器学习的第一次作业,思路还是比较好懂的,就是补了好多numpy的知识。</p><p><strong>pla算法</strong></p><pre><code>from matplotlib import pyplot as pltimport numpy as np# 生成数据def generateData(loc1,scale1,loc2,scale2):    # 此产生两组正态分布数据,每组为形状为20行2列    nD1=np.random.normal(loc1,loc2,size=(20,2))    nD2=np.random.normal(scale1,scale2,size=(20,2))    # 将返回的元组转换成np中的数组形式,x的数据    data1X=np.array(nD1)    data2X=np.array(nD2)    # 区分两类正太分布数据    data1Y = np.ones(20)    data2Y = np.negative(np.ones(20))    # 产生训练数据    data1 = np.c_[data1X,data1Y]    data2 = np.c_[data2X,data2Y]    # 合并成一个矩阵    data = np.vstack((data1, data2))    return data1,data2,datadef pla():    # 初始化向量,cout为计数器，    W = np.ones(3)    cout = 0    data1,data2,data = generateData(10,2,3,2)    # 插入列向量[1,1,...,1]，实现w=[b,w1,w2] * [1,x1,x2],用于运算    data = np.c_[np.ones(40), data]    while True:        iscompleted = True        cout = cout + 1        if(cout&gt;5000):            print(&quot;线性不可分&quot;)            break        for i in range(0, len(data)):            X = data[i][:-1]            # 两个矩阵相乘的结果,通过函数计算得到的Y            Y = np.dot(W,X)            if np.sign(Y) == np.sign(data[i][-1]):                continue            # 有错则退出循环            iscompleted = False            # 计算之后修正w            W = W + data[i][-1] * X        if iscompleted:            break    # 画图    # 取第一个元素为x,第二个元素为y    plt.plot(data1[:,0],data1[:,1],&quot;yo&quot;)    plt.plot(data2[:,0],data2[:,1],&quot;bo&quot;)    # x是二维数组 wx = w·（x,y) = (b,w1,w2)·(1,x,y) 推出y的表达式    y = -W[1] / W[2] * data[:,1] - W[0] / W[2]    plt.plot(data[:,1], y, c=&#39;g&#39;)    plt.show()if __name__==&#39;__main__&#39;:    pla()</code></pre><p><strong>pocket算法</strong></p><pre><code>from matplotlib import pyplot as pltimport numpy as npdef generateData(loc1,scale1,loc2,scale2):    # 此产生两组正态分布数据,每组为形状为10行2列    nD1=np.random.normal(loc1,loc2,size=(100,2))    nD2=np.random.normal(scale1,scale2,size=(100,2))    # 将返回的元组转换成np中的数组形式,x的数据    data1X=np.array(nD1)    data2X=np.array(nD2)    # 区分两类正太分布数据    data1Y = np.ones(100)    data2Y = np.negative(np.ones(100))    # 产生训练数据    data1 = np.c_[data1X,data1Y]    data2 = np.c_[data2X,data2Y]    # 合并成一个矩阵    data = np.vstack((data1, data2))    return data1,data2,datadef compare(datas,w):    currentCount = 0    updateW = True    for i in range(0, len(datas)):        X = datas[i][:-1]        # 两个矩阵相乘的结果,通过函数计算得到的Y        Y = np.dot(w, X)        if np.sign(Y) == np.sign(datas[i][-1]):            currentCount = currentCount + 1        else:            if(updateW):                 w = w + (datas[i][-1]) * X            updateW = False    return {&#39;currentCount&#39;:currentCount,&#39;w&#39;:w}def main():    data1,data2,data = generateData(10,2,4,2)    data = np.c_[np.ones(200), data]    W = np.ones(3)    comparew = W  # 用于循环比较的    maxCount = 0    n = 500 # 迭代次数    while(n):        current = compare(data,comparew)        comparew = current[&#39;w&#39;]        if(current[&#39;currentCount&#39;] &gt; maxCount):            W = current[&#39;w&#39;]        n = n - 1    # 画图    # 取第一个元素为x,第二个元素为y    plt.plot(data1[:,0],data1[:,1],&quot;yo&quot;)    plt.plot(data2[:,0],data2[:,1],&quot;bo&quot;)    y = -W[1] / W[2] * data[:, 1] - W[0] / W[2]    plt.plot(data[:, 1], y, c=&#39;g&#39;)    plt.show()if __name__ == &#39;__main__&#39;:    main()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;机器学习的第一次作业,思路还是比较好懂的,就是补了好多numpy的知识。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pla算法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from matplotlib import pyplot as plt
import numpy as np
      
    
    </summary>
    
      <category term="刷题笔记" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python总结</title>
    <link href="http://yoursite.com/2020/10/22/python%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/10/22/python总结/</id>
    <published>2020-10-22T11:54:25.000Z</published>
    <updated>2020-10-22T12:02:01.300Z</updated>
    
    <content type="html"><![CDATA[<p>1.两个数组合成一个数组</p><p><strong>List extend()方法</strong></p><p>extend()函数用于在列表的后面追加新列表的值，用新列表扩展原来的列表。</p><p>list.extend(元素列表),没有返回值</p><p><strong>+操作符</strong></p><pre><code>c1 = [&quot;Red&quot;,&quot;Green&quot;,&quot;Blue&quot;]c2 = [&quot;Orange&quot;,&quot;Yellow&quot;,&quot;Indigo&quot;]c3 = c1 + c2# c3 = [&quot;Red&quot;,&quot;Green&quot;,&quot;Blue&quot;,&quot;Orange&quot;,&quot;Yellow&quot;,&quot;Indigo&quot;]</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.两个数组合成一个数组&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;List extend()方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;extend()函数用于在列表的后面追加新列表的值，用新列表扩展原来的列表。&lt;/p&gt;
&lt;p&gt;list.extend(元素列表),没有返回值&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>linux学习笔记(学习中)</title>
    <link href="http://yoursite.com/2020/10/19/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/10/19/linux学习笔记/</id>
    <published>2020-10-19T09:00:19.000Z</published>
    <updated>2020-10-28T02:16:11.957Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux内核基础上进行开发包装,Linux的主要发行版:Ubuntu(乌班图)、RedHat(红帽)、CentOS…</p><p><strong>虚拟机连接的三种模式</strong></p><p>双击进去,crtl+alt退出</p><p>虚拟机网络连接的三种模式:</p><p>张三:192.168.14.100(windows)<br>李四:192.168.14.110</p><p>桥接模式:<br>1.大家都在同一个网段,相互可以通讯<br>2.因为ip地址有限,可能造成ip冲突</p><p>centos虚拟机张三:192.168.14.xxx,与李四在同一个网段相互可以通信</p><p>Nat网络地址转换模式:<br>1.虚拟机不占用其他的ip,不会ip冲突<br>2.内网的其他人不能和虚拟机通讯</p><p>王五:192.168.14.130(windows)<br>转换的新地址:192.168.20.33<br>centos虚拟机:192.168.20.xxx<br>王五可以通过转化成14网段与李四通讯,但李四找不到王五</p><p>主机模式:<br>单独的一台电脑</p><p><img src="/img/大数据/虚拟机网络连接的三种方.png"></p><p>startx 启动图形化界面</p><h2 id="Linux的目录结构"><a href="#Linux的目录结构" class="headerlink" title="Linux的目录结构"></a>Linux的目录结构</h2><p>Linux的文件系统是采用树状目录结构，只有一个根目录，<strong>在Linux世界里，一切皆文件。</strong></p><p>bin 是Binary的缩写,这个目录存放着最经常使用的命令<br>sbin s是Super User的意思,这里存放的是系统管理员使用的系统管理程序<br>home 存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的<br>root 该目录为系统管理员，也称作超级权限者的用户主目录<br>etc 所有的系统管理所需要的配置文件和子目录<br>user 这个目录很重要，用户的很多应用程序和文件都放在这个目录下，类似windows下的program files目录<br>boot 存放的启动Linux使用的一些核心文件，包括一些连接文件以及镜像文件<br>proc/srv/sys 这些目录最好不要修改<br>media linux系统会自动识别一些设备,例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下<br>mut 系统提供该目录是为了让用户临时挂载别的文件系统的，可以将外部的存储挂载在mut上，然后进入该目录就可以查看里面的内容了<br>usr/local 给主机额外安装软件所安装的目录，一般是通过编译源码方式安装的程序<br>var 这个目录存放着在不断扩充的东西，习惯将经常被修改的目录放在这个目录下，包括各种日志文件</p><h2 id="Linux操作"><a href="#Linux操作" class="headerlink" title="Linux操作"></a>Linux操作</h2><h3 id="远程登陆Linux"><a href="#远程登陆Linux" class="headerlink" title="远程登陆Linux"></a>远程登陆Linux</h3><p><strong>为什么需要远程登陆Linux</strong><br>1.Linux服务器是开发小组共享的<br>2.正式上线的项目是运行在公网的<br>3.因此程序员需要远程登陆到centos进行项目管理或者开发</p><p><strong>XShell</strong><br>远程登陆Linux的软件(登陆后基本是命令行操作) XShell,前提是Linux启动了SSHD服务，该服务会监听22号端口</p><p>1.首先需要知道需要连接的Linux的IP地址<br>2.在Xshell中新建会话 协议:SSH,端口号:22,主机:需要连接的Linux的IP地址<br>3.输入Linux的用户名和密码<br>注意：如果在Xshell中输入reboot重启的是Linux</p><p><strong>SecureCRT</strong><br>用于远程登陆Linux的软件,在大数据开发中使用较多</p><p>解决乱码问题: 会话选项 - 外观 - 编码UTF-8</p><p><strong>Xftp</strong><br>远程上传文件到Linux与从Linux中下载文件的软件 XFtp</p><p>1.操作步骤和上述一样,协议是SFTP端口号是22<br>2.解决乱码问题：设置中使用UTF-8编码</p><h3 id="Vi与Vim编辑器"><a href="#Vi与Vim编辑器" class="headerlink" title="Vi与Vim编辑器"></a>Vi与Vim编辑器</h3><p>Vi文本编辑器，Vim是Vi的增强版本</p><p><strong>vi和vim三种常见模式</strong></p><p>正常模式：<br>    可以使用快捷键 -&gt; 以vim打开一个档案直接进入一般模式<br>插入模式/编辑模式:<br>    程序员可以输入内容 -&gt; 按i进入编辑模式<br>命令行模式：<br>    可以输入相关命令完成读取、存盘、替换、离开vim等  -&gt; 按：</p><h3 id="开机、重启和用户登陆注销"><a href="#开机、重启和用户登陆注销" class="headerlink" title="开机、重启和用户登陆注销"></a>开机、重启和用户登陆注销</h3><p><strong>关机&amp;重启命令</strong></p><p>shutdowm<br>    shutdown -h now:表示立即关机<br>    shutdown -h 1:表示一分钟后关机<br>    shutdown -r now:立即重启<br>halt<br>    效果等价与关机<br>reboot<br>    重启系统<br>sync<br>    将内存的数据同步到磁盘</p><p><strong>用户登陆和注销</strong><br>1.登陆时尽量少用root账号登陆，因为系统管理员是最大的权限，避免操作失误。可以利用普通用户登陆，登陆后再用su-用户名命令来切换成系统管理员身份<br>2.在提示符下输入logout可注销用户(退出)</p><p>使用细节：<br>1.logout注销指令在图形运行级别无效，在运行级别3下有效</p><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>用户家目录的概念<br>/home/目录下有各个用户对应的家目录，当用户登陆时，会自动进入到自己的家目录，如/home/ranan</p><p><strong>添加用户</strong><br>一个用户至少属于一个用户组<br>基本语法: useradd [选项] 用户名</p><p>使用细节:<br>1.如果在添加用户的时候没有指定分到哪个用户组，则会默认创建一个同名用户组<br>2.可以通过useradd -d 指定目录(不能是已经存在的目录) 新的用户名给新创建的用户指定家目录,如 useradd -d /home/ranan ran。没有指定的话就默认创建同名家目录。<br>3.useradd -g 用户组名 用户名 指定用户在哪个组</p><p><strong>指定/修改密码</strong></p><p>基本语法:passwd 用户名</p><p><strong>删除用户</strong><br>使用root权限<br>基本语法:userdel [选项] 用户名</p><p>userdel ranan  :保留家目录,删除用户<br>userdel -r ranan :删除家目录与用户</p><p>使用细节:<br>实际开发中会保留家目录</p><p><strong>查询用户信息</strong><br>基本语法:id 用户名<br>返回值:用户id号,所在组的id,所在组的名称</p><p><strong>切换用户</strong><br>在操作Linux中,如果当前用户的权限不够，可以通过su -指令切换到高权限用户</p><p>基本语法: su - 切换用户名<br>细节说明:<br>1.从权限高的用户切换到权限低的用户，不需要输入密码<br>2.当需要返回到原来用户时，使用exit指令</p><p><strong>查看当前用户/登录用户</strong><br>基本语法:whoami</p><h4 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h4><p><strong>新增组</strong><br>语法: groupadd 组名</p><p><strong>删除组</strong><br>语法: groupdel 组名</p><p><strong>修改用户的组</strong><br>语法：usermod -g 用户组 用户名</p><p><strong>用户和组的相关文件</strong></p><p>/etc/passwd文件 - 用户(user)配置文件<br>    记录用户的各种信息<br>    每行的含义：用户名:口令(密码):用户标识符(id):组标识号:家目录:shell</p><p>/etc/group文件 - 组配置文件<br>    记录组的各种信息<br>    每行含义:组名:口令:组标识符:组内用户列表</p><p>/etc/shadow文件 - 口令配置文件<br>    记录密码和登陆信息是加密文件<br>    每行含义:登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</p><h3 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h3><p><strong>指令运行级别</strong><br>常用运行级别是3和5,系统的运行级别配置文件/etc/inittab<br>0:关机<br>1:单用户(找回丢失密码)<br>2:多用户无网络服务<br>3:多用户有网络服务<br>4:保留<br>5:图形界面<br>6:重启</p><p>命令:init [希望进入的级别号0123456] 切换到指定运行级别的指令</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Linux内核基础上进行开发包装,Linux的主要发行版:Ubuntu(乌班图)、RedHat(红帽)、CentOS…&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虚拟机连接的三种模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;双击进去,crtl+alt退出&lt;/p&gt;
&lt;p&gt;虚拟机网络连接的三种模
      
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="linux" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/linux/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>python-matplotlib</title>
    <link href="http://yoursite.com/2020/10/16/python-matplotlib/"/>
    <id>http://yoursite.com/2020/10/16/python-matplotlib/</id>
    <published>2020-10-16T08:20:23.000Z</published>
    <updated>2020-10-23T12:05:54.989Z</updated>
    
    <content type="html"><![CDATA[<p>完成机器学习pla算法和pocket算法作业的时候,想要把数据可视化出来,发现需要用到matplotlib,此篇博客记录matplotlib的学习笔记。</p><p>matplotlib专门用于开发2D(3D)图表,mat-matrix矩阵、plot画图、lib-library库</p><h2 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h2><h3 id="matplotlib的三层结构"><a href="#matplotlib的三层结构" class="headerlink" title="matplotlib的三层结构"></a>matplotlib的三层结构</h3><p>1.容器层<br>    1.1画板层Canvas 一般不会接触<br>    1.2画布层Figure:plt.figure() 一个画布上可以创建多个绘图区<br>    1.3绘图区/坐标系axes:plt.subplots<br>        x、y轴张成的区域<br>        2.辅助显示层:图表的一些标注,辅助图表的显示<br>        3.图像层:画不同的图表</p><p>matplotlib.pyplot的函数(类似与matlab的画图函数)作用于当前图形(figure)的当前坐标系(axes)</p><p>简单的案例:</p><pre><code># 创建画布plt.figure(figsize=(长,宽),dpi=)    # figsize:设置画布大小    # dpi：图形的清晰度    # 返回fig对象# 绘制图像x = [1,2,3,4,5]plt.plot(x,[5,4,3,2,1]) # 对此调用就可以画多个图标plt.xticks(x[::5]) # 准备x的刻度说明  # 保存图片plt.savefig(&quot;test.png&quot;)# 显示图像plt.show()</code></pre><p><strong>注意</strong><br>1.plt.show()会释放figure资源,如果在显示图片之后保存图片将只能保存空图片<br>2.显示中文需要下载字体<br>    2.1安装字体<br>    2.2删除matplotlib缓存文件<br>    2.3配置文件<br><a href="https://www.zhihu.com/question/25404709" target="_blank" rel="noopener">解决的教程</a></p><p><strong>辅助显示层</strong><br>编辑坐标轴<br>plt.xticks(x,<strong>kwargs)<br>x:要显示的刻度值,后面参数可以传显示的值<br>plt.yticks(y,</strong>kwargs)<br>y:要显示的刻度值</p><pre><code>from matplotlib import pyplot as pltimport randomx = range(10)y = [random.uniform(15,18) for i in x]x_ticks_label = [&quot;11点{}分&quot;.format(i) for i in x]plt.figure()plt.plot(x,y)# x的刻度说明plt.xticks(x[::3],x_ticks_label[::3])plt.show() # 展现图片</code></pre><p>网格显示<br>plt.grid(True,linestyle=”–”,alpha=0.5)<br>参数1:是否显示网格<br>参数2:线条风格<br>参数3:透明度</p><p>添加描述信息<br>plt.xlabel(“描述信息”)<br>plt.ylabel(“描述信息”)<br>plt.title(“”)</p><p><strong>图像层</strong></p><p>多次调用就可以画多个图表</p><p>图例不仅需要在图像层修改还需要在辅助层修改plt.legend(loc=”low right”),可以空参</p><p><strong>绘图区</strong></p><p>figure axes = matplotlib.subplots(nrows=1,ncols=1,**fig_kw)创建一个带有多个axes(坐标系/绘图区)的图,返回一个图对象和绘图区</p><pre><code>figure, axes = plt.subplots(nrows=1,ncols=1,**fig_kw) # 返回两个实例对象# axes[0].方法的形式来画图,具体的可以看文档</code></pre><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>散点图scatter:用两组数据构成多个坐标点，考察坐标点的分布，判断两变量之间是否存在某种关联趋势<br>plt.scatter(x,y)</p><p>柱状图bar:统计/对比<br>plt.bar(x,y,width,align=”center”,**kwargs)<br>对比形式的柱状图:<br>1.调用两次bar<br>2.两个bar的x要岔开,否则画出来的柱状图会覆盖</p><p>直方图histogram:分布状态</p><p>饼图:分类数据的占比情况</p><h2 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h2><p>numpy中在数值计算,多用于多维数组上执行数值运算</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><strong>numpy.array()</strong></p><p>Python中的list容器，可以当成数组使用，但由于里面的元素可以是任何对象，因此列表中保存的是对象的指针，保存一个简单的列表[1,2,3]，需要三个指针和三个整数对象，结构不高效<br>Python中提供的array模块，只支持一维数组，不支持多维数组(矩阵)</p><p>numpy.array(arr)<br>参数:数值<br>返回值:ndarray类型,也就是numpy里面的数组类型</p><p><strong>numpy.arange()</strong><br>参数表示范围,根据范围返回一个可迭代的数组类型</p><pre><code>numpy.arange(10) = np.array(range(10))# [0,1,2,3,4,6,7,8,9]a = numpy.arange(4,10,2)# [4,6,8] 从4开始到10结束,步长为2type(a) # 返回a的数据类型a.dtype # 数组中数据的类型a.shape # 返回一个元组(几个值就是几维的)，输出矩阵的形状</code></pre><h4 id="数组计算"><a href="#数组计算" class="headerlink" title="数组计算"></a>数组计算</h4><p><strong>np.r_[]/np._c[]</strong></p><p>np.r_：是按列连接两个矩阵，就是把两矩阵上下相加，要求列数相等</p><p>np.c_：是按行连接两个矩阵，就是把两矩阵左右相加，要求行数相等</p><pre><code>import numpy as npa = np.array([1, 2, 3])b = np.array([4, 5, 6])c = np.c_[a,b]print(np.r_[a,b])print(c)print(np.c_[c,a])# 结果：[1 2 3 4 5 6][[1 4] [2 5] [3 6]][[1 4 1] [2 5 2] [3 6 3]]</code></pre><p><strong>numpy.vstack(tup)</strong></p><p>垂直按照行顺序把每个数组给堆叠起来,返回一个新的数组</p><p>参数:元组、列表或者numpy数组<br>返回值:numpy的数组</p><pre><code>a=[[1],[2],[3]]b=[[1],[2],[3]]c=[[1],[2],[3]]d=[[1],[2],[3]]print(np.vstack((a,b,c,d)))# 输出：[[1] [2] [3] [1] [2] [3] [1] [2] [3] [1] [2] [3]]a=[1,2,3]b=[4,5,6]print(np.vstack((a,b)))# 输出：[[1 2 3] [4 5 6]]</code></pre><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><pre><code># 返回值是一个数组X = np.array ([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9], [10, 11], [12, 13], [14, 15], [16, 17], [18, 19]])# X[:,0]就是取所有行的第0个数据print(X[:, 0])#输出：[ 0  2  4  6  8 10 12 14 16 18]#X[1,:]第一维中下标为1的元素的所有值print(X[1,:])#输出：[2 3]Y = np.array([[0,1,2],[3,4,5],[6,7,8],[9,10,11],[12,13,14],[15,16,17],[18,19,20]])#Y[:, m:n]，即取所有数据的第m到n-1列数据，含左不含右print (Y[:,1:3])&#39;&#39;&#39;输出：[[ 1  2] [ 4  5] [ 7  8] [10 11] [13 14] [16 17] [19 20]]</code></pre><p><strong>numpy.random.normal()</strong><br>numpy.random.normal(loc=0,scale=1e-2,size=shape)</p><p>生成正态分布</p><p>参数：<br>1.loc(float)：正态分布的均值，对应着这个分布的中心。loc=0说明这一个以Y轴为对称轴的正态分布，<br>2.scale(float)：正态分布的标准差，对应分布的宽度，scale越大，正态分布的曲线越矮胖，scale越小，曲线越高瘦。<br>3.size(int 或者整数元组):输出的形状,默认为None。如(10,2) -&gt; 输出一个10行2列的元组</p><p>返回值:元组数据</p><p>标准正太分布（μ=0, σ=1）:np.random.normal(loc=0, scale=1, size)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;完成机器学习pla算法和pocket算法作业的时候,想要把数据可视化出来,发现需要用到matplotlib,此篇博客记录matplotlib的学习笔记。&lt;/p&gt;
&lt;p&gt;matplotlib专门用于开发2D(3D)图表,mat-matrix矩阵、plot画图、lib-libr
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Java面向对象(学习中)</title>
    <link href="http://yoursite.com/2020/10/11/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2020/10/11/Java面向对象/</id>
    <published>2020-10-11T11:55:52.000Z</published>
    <updated>2020-11-04T12:12:08.334Z</updated>
    
    <content type="html"><![CDATA[<p>Java类及类的成员:属性、方法、构造器;代码块、内部类<br>面向对象的三大特征:封装性、继承性、多态性<br>其他关键字:this、super、static、final、abstract、package、import、interface</p><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>类(Class)与对象(Object)是面向对象的核心概念。<br>类是对一类事务的抽象描述<br>对象是实际存在的该类事务的每个个体，也称为实例(instance)</p><p>面向对象程序设计的重点是类的设计，也就是类的成员(属性与方法)的设计。</p><p><strong>类的成员</strong></p><ul><li>实例变量,不以static修饰</li><li>类变量,以static修饰</li></ul><p>类的实例化: 类名(变量类型) 类的实例名(变量) = new 类名()</p><p>类中方法的声明: 权限修饰符(可省略) 返回值类型(没有就void) 方法名(形参类型 形参名,形参列表){方法体}</p><p>权限修饰符:private、public、缺省、protected  –&gt; 封装性</p><p><strong>成员变量与局部变量</strong></p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">位置</th><th style="text-align:center">权限修饰符</th><th style="text-align:center">默认初始化值</th><th style="text-align:center">内存加载位置</th></tr></thead><tbody><tr><td style="text-align:center">成员变量</td><td style="text-align:center">类的{}里</td><td style="text-align:center">可以使用权限修饰符</td><td style="text-align:center">根据其类型有默认初始化值</td><td style="text-align:center">非static的 堆空间</td></tr><tr><td style="text-align:center">局部变量</td><td style="text-align:center">方法内、方法形参、构造器内、构造器形参、代码块内</td><td style="text-align:center">不可以使用权限修饰符</td><td style="text-align:center">没有默认初始化值,在调用局部变量前要显示赋值</td><td style="text-align:center">栈空间</td></tr></tbody></table><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><strong>方法的重载(overload)</strong><br>同一个类中,允许存在同名方法,只要他们的参数个数或者参数类型不同。  -&gt; 两同一不同:同一个类、相同方法名，参数列表不同</p><p>通过对象调用方法时，如何确定某一个指定的方法?    方法名 -&gt; 参数列表(参数的个数,数据类型及顺序)</p><p>Java的重载是可以包括父类和子类的,子类可以重载父类的同名不同参数的方法</p><p><strong>方法的重写(override/overwrite)</strong></p><p>子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作</p><p>重写的规定：<br>    方法声明：权限修饰符 返回值类型 方法名(形参列表) throws 异常的类型{<br>    //方法体<br>    }<br>1.子类重写继承的方法：要求方法名、形参列表要相同<br>2.子类重写的方法权限修饰符 &gt; =  父类被重写方法权限修饰符  –&gt; 子类不能重写父类中声明为private权限的方法<br>3.异常类型也是包含关系  子类 &lt;= 父类<br>4.返回值类型:基本数据类型同，引用数据类型同或子类<br>    父类void,子类void<br>    父类返回A类型,子类A类或A类的子类<br>    父类基本数据类型,子类相同的基本数据类型<br>5.重写的是非static  -&gt; static方法不能被覆盖,随类的加载而加载</p><p><strong>可变个数的形参</strong></p><p>格式:数据类型 … 变量名</p><p>String …strs = String[] strs</p><p>使用:<br>1.当调用可变个数形参的方法时，可以传参0,1,2…<br>2.会与本类中方法名相同,形参不同的方法之间构成重载<br>3.此写法类似JS的三点运算符,所有参数会被封装成一个数组<br>4.可变个数形参在方法的形参中，必须声明在<strong>末尾</strong><br>5.注意如果子父类的形参分别是…strs与[]strs也会重写<br>6.优先会调用参数列表个数确定的方法</p><p><strong>方法参数的值传递机制-值传递</strong><br>基本数据类型:数据值<br>引用数据类型:地址值(含变量的数据类型 –&gt; 用于赋值的检查)</p><h3 id="构造器-constructor"><a href="#构造器-constructor" class="headerlink" title="构造器(constructor)"></a>构造器(constructor)</h3><p>任何一个类都有构造器constructor,构造器与类同名</p><p><strong>构造器的作用</strong><br>1.创建对象:new + 构造器<br>2.初始化对象的信息</p><p><strong>构造器的说明</strong><br>1.如果没有显式的定义类的构造器,系统默认提供一个空参的构造器，<strong>空参的构造器权限跟类一样</strong><br>2.定义构造器的格式:权限修饰符 类名(形参列表) 不需要返回值类型<br>3.一个类中定义的多个构造器,彼此构成重载<br>4.显示定义了有参数的构造器之后,系统就不提供默认的空参构造器<br>5.一个类中至少有一个构造器</p><pre><code>//创建类的对象: new + 构造器Person p = new Person()class Person{    //属性...    //构造器    public Person(){    }    //方法...}</code></pre><p><strong>属性赋值的先后顺序</strong></p><p>1.默认初始化<br>2.显示初始化<br>3.构造器中初始化</p><p><strong>JavaBean</strong><br>JavaBean是Java语言写成的可重用组件<br>JavaBean其实就是指符合如下标准的Java类:<br>①类是公共的<br>②有一个无参的公共的构造器<br>③有属性,且有对应的get、set方法</p><h2 id="面向对象的特点"><a href="#面向对象的特点" class="headerlink" title="面向对象的特点"></a>面向对象的特点</h2><h3 id="封装与隐藏"><a href="#封装与隐藏" class="headerlink" title="封装与隐藏"></a>封装与隐藏</h3><p>为什么需要封装性？设计程序追求”高内聚，低耦合”<br>高内聚:类的内部数据操作细节自己完成，不允许外部干涉<br>低耦合:仅对外暴露少量的方法用于使用</p><p><strong>封装性的体现</strong><br>1.将类的属性私(xx)有化(private),提供公共的(public)方法来获取(getxx)和设置(setxx)该私有属性<br>2.不对外暴露的私有方法<br>3.单例模式(将构造器私有化)</p><p>封装性的体现，需要权限修饰符来配合<br>封装性:Java提供了4种权限修饰符来修饰类及类的内部结构，体现其在被调用时的可见性大小</p><p><strong>权限修饰符</strong><br>1.权限从小到大 private、缺省、protected、public<br>2.4种权限可以用来修饰类的属性、方法、构造器、内部类<br>3.对于class的权限修饰只可以用public和default(缺省);public类可以在任意地方被访问,default类只可以被同一个包内部的类访问</p><table><thead><tr><th style="text-align:center">修饰符</th><th style="text-align:center">类内部</th><th style="text-align:center">同一个包</th><th style="text-align:center">不同包的子类</th><th style="text-align:center">同一个工程</th></tr></thead><tbody><tr><td style="text-align:center">private</td><td style="text-align:center">Yes</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">- </td></tr><tr><td style="text-align:center">(缺省)</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">- </td></tr><tr><td style="text-align:center">public</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td></tr></tbody></table><p>不同包下的普通类(非子类)不能调用声明为private、缺省、protected权限的属性</p><h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><p>继承在原有类的基础上进行扩展,一个子类只能有一个父类</p><pre><code>public class Student extend Person{    //与Person重复的就不用写的}</code></pre><p><strong>继承性的好处</strong><br>1.减少了代码的冗余，提高了代码的复用性<br>2.便于功能的扩展<br>3.为多态性的使用提供前提</p><h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><p>对象的多态性,<strong>父类的引用指向子类的对象</strong>,可以理解为一个事物的多种形态。</p><p><strong>多态的使用(虚拟方法调用)</strong><br>1.当<strong>调用子父类同名同参数的方法</strong>时，实际执行的是子类重写父类的方法。此时称父类的方法为虚拟方法。<br>2.在编译期,只能调用父类中声明的方法,但在运行期,我们实际执行的是子类重新父类的方法<br>3.对象的多态性只适用与方法,不适用于属性—&gt; 属性不会被重写,若同名则在内存中会出现两个。使用的时候声明的是什么类型使用的就是什么类型的属性。(属性编译和运行都看左边) </p><p><strong>虚拟方法调用</strong><br>方法编译时看左边,运行时看右边,编译的时候以为调用的是父类的方法,实际调用的是子类的方法。</p><p>不能调用子类所特有的方法，编译时，该实例是父类的。</p><p>常用场景:<br>当一个方法的形参是父类时,实参可以传子类的实例(父类的引用指向子类的对象),调用时实际调用的是子类重写的方法,这样就不用分别定义形参是子类的该方法。</p><p><strong>多态是运行时行为</strong>,父类动态调用属于子类的该方法，在编译时是无法确定调用的是哪一个子类的方法，所以是运行时行为。(动态绑定)</p><pre><code>class Animal{    protected void eat(){        ...    }}class Cat extends Animal{    protected void eat(){        ...    }}class Dog extends Animal{    protected void eat(){        ..    }}public class Test{    public static Animal get(int key){        switch(key){            case 0:                return new Cat();            case 1：                return new Dog();        }    }    public static void main(String[] args){        int key = new Random().nextInt(2);        Animal animal = get(key);        animal.eat();    }}</code></pre><p><strong>多态性的使用前提</strong><br>1.类的继承关系<br>2.方法的重写</p><p><strong>向下转型</strong></p><p>前提:存在子父类关系<br>目的:使用子类的特定方法</p><p>有了多态性以后，内存中实际上是加载了子类的属性和方法，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。</p><pre><code>// 调用子类特有属性和方法//p的地址值指向new出来的空间，但是编译器只看的Person的属性和方法或者Person和Man共有的Person p = new Man()Person p1 = new Woman()//把p的地址赋值给m1，由于m1是Man类型，所以看得见Man特有的属性和方法Man m1 = (Man)pObject o = new Man()//o可以转到Man的父类,最低可转换到Man</code></pre><p>使用强转时，可能出现ClassCaseException的异常。可以先用instanceof关键字判断一下再向下转型。</p><p><img src="/img/Java/向下转型.png"></p><h4 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h4><p>Java.lang.Object类是所有类(除Object类本身)的祖先类</p><p><strong>equals(Object obj)方法</strong></p><p>只适用于引用数据类型，比较的是地址值<br>Obhect类中equals()定义的方法和==作用是相同的</p><pre><code>public boolean equals(Object obj){    return (this == obj)}</code></pre><p>String、Date、File、包装类等都重写了Object类中的equals()方法，比较的两个对象的实体类容是否相同</p><p>通常情况下，自定义的类如果使用equals()方法，也会比较对象的实体类容是否相同，所以可以重写equals()方法</p><pre><code>//手写版本,class Customer{public boolean equals(Object obj){    if(this == obj){        return true    }    if(obj instanceof Customer){        //Customer是父类,转换了后父类可以调用子类的特有方法用于比较        Customer cust = (Customer)obj        //比较两个对象的每个属性是否相同        ....    }</code></pre><p>特殊：String类型在常量池,重新定义一个变量是，若在常量池中发现有内容一样的字符串，会直接把该字符串的地址赋值给该变量。new String()方法创建的字符串除外</p><p><strong>toString()方法</strong></p><p>1.当我们打印一个引用对象时,实际上就是调用当前对象的toString(),输出地址<br>2.Object类中toString()的定义:</p><pre><code>public String toString(){    return getClass().getName() + &quot;@&quot; + Integer.toHexString((hashCode));}</code></pre><p>3.String、Date、File、包装类等都重写了Object类中的toString()方法，返回”实体内容”信息</p><p>特例：</p><pre><code class="JAVA">String s = &quot;abc&quot;;s = null ;System.out.println(s) //nullSystem.out.println(s.toString) //出现空指针异常</code></pre><p><strong>getClass方法</strong></p><p>实例.getClass()方法,返回实例的直接父类</p><h4 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h4><p>Java中的JUnit单元测试<br>1.使用JUnit<br>test目录(src同级)用于存放测试类，在此目录上右击鼠标并将此目录标记为Test Resources Root<br>选择要进行测试的类文件，在类文件中按下组合键CTRL+SHIFT+T弹出创建测试类的窗口或者右键goto -&gt; test<br>2.自动创建的Java类，进行单元测试<br>    此类是public<br>    此类提供公共的无参构造器(默认的不需要去写)<br>3.此类中声明单元测试方法<br>    此方法的权限是public,没有形参与返回值<br>4.此单元测试方法的上面需要声明注释@Test,并导入import org.junit.Test</p><h4 id="包装类Wrapper"><a href="#包装类Wrapper" class="headerlink" title="包装类Wrapper"></a>包装类Wrapper</h4><p>包装类(封装类):针对八种基本数据类型定义相应的引用类型</p><p><img src="/img/Java/包装类.png"></p><p>基本数据类型、包装类与String类间的转换</p><p><img src="/img/Java/基本数据类型包装类的转换.png"></p><p><strong>基本数据类型与包装类</strong></p><p>JDK5.0新特性：的自动装箱与自动拆箱</p><pre><code>int num = 10Integer num1 = new Integer(num)int num0 = num1.intValuemethod(num1);//自动装箱int num2 = 10Integer in1 = num2//自动拆箱int num3 = in1//methodpublic void method(Object obj)</code></pre><p><strong>基本数据类型、包装类 -&gt; String</strong></p><p>方法1：连接运算<br>方法2：调用String重载的valueOf(xxx)</p><pre><code>//方法1：连接运算int num = 10;String str = num + &quot;&quot;;//方法2：调用Strinf重载的valueOf(xxx)float f = 12.3fString str2 = String.valueof(f)</code></pre><p><strong>String -&gt; 基本数据类型、包装类</strong></p><p>调用包装类的parseXxx(String str)</p><pre><code>String str1 = &quot;123&quot;;int num = Integer.paserInt(str1)</code></pre><p><strong>习题</strong></p><p>三目运算符要求:前后的数据类型统一,所以整型会自动类型提升到浮点型。</p><pre><code>//习题1Object o1 = true ? new Integer(1) : new Double(2.0)System.out.println(o1) //1.0//习题2public void test(){    Integer i = new Integer(1);    Integer j = new Integer(1);    System.out.println(i == j); //false    //Integer内部定义了IntegerCache结构,自动装箱的时候从Integer cache数组(-128~127)中找,不需要重新new了，所以找到的是同一个地址    Integer m = 1;    Integer n = 1;    System.out.println(m == n); //true    Integer x = 128;    Integer y = 128 ;    System.out.println(x == y); //false}</code></pre><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this指向当前实例,可以理解为当前对象。</p><p>this可以调用:属性、方法、构造器</p><p>在类的方法中,我们可以使用’this.属性’或’this.方法’的方式,调用当前对象属性或方法,通常会省略’this.’，但如果方法的形参和类的属性同名时,必须显示用”this.变量”来表明是属性。</p><p>this还可以用来调用构造器,在构造器中通过使用”this(形参列表)”来调用其他不同的构造器。”this(形参列表)”必须声明在当前构造器的<strong>首行</strong></p><pre><code>public Person(){   //... }public Person(String name){    this(); //调用空参,通过传不同类型的参数调用其他不同的构造器}</code></pre><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>super理解为父类的，可以用来调用属性、方法、构造器</p><p>this与super都是解决子类父类成员重名时，用谁的问题</p><p><strong>super的使用</strong><br>1.子类重写父类的方法后,想使用父类的原方法可以使用super<br>2.super(形参列表)的形式调用父类中的构造器,必须声明在子类构造器的<strong>首行</strong><br>3.构造器首行没有显示声明this(形参列表)或super(形参列表),默认调用的super()</p><h4 id="子类对象的实例化过程"><a href="#子类对象的实例化过程" class="headerlink" title="子类对象的实例化过程"></a>子类对象的实例化过程</h4><p>从结果上来看(继承性):<br>    子类继承父类以后,就获取了父类中声明的属性或方法<br>    创建子类的对象,在堆空间中,就会加载所有父类中声明的属性<br>从过程上来看:<br>    通过子类的构造器创建子类对象时，最先会直接或间接调用其父类的构造器(super在第一行)，直到调用到java.lang.Object类中空参的构造器为止,在调用自己的构造器。</p><p>明确:虽然创建子类对象时,调用了父类的构造器但没有new,所以只创建了一个new子类出来的对象。</p><h3 id="package"><a href="#package" class="headerlink" title="package"></a>package</h3><p>1.为了更好的实现项目中类的管理提供包的概念<br>2.使用package声明类或接口所属的包，声明在源文件的首行<br>3.包属于标识符，遵循标识符的命名规则、规范(都小写)<br>4.每’.’一次，就代表一层文件目录</p><p>补充:同一个包下，不能命名同名的接口、类;不同的包下，可以命名同名的接口、类</p><h4 id="MVC设计模式"><a href="#MVC设计模式" class="headerlink" title="MVC设计模式"></a>MVC设计模式</h4><p>MVC将整个程序分成视图模式层(view)、控制器层(controller)、数据模型层(model)三层</p><p>模型层 model 主要处理数据<br>数据对象封装 model.bean/domain<br>数据库操作类 model.dao<br>数据库 model.db</p><p>视图层 view 显示数据<br>相关工具栏 view.utils<br>自定义view view.ui</p><p>控制层 controller 处理业务逻辑<br>应用界面相关 controller.activity<br>存放fragment controller.fragment<br>显示列表的适配器 controller.adapter<br>服务相关 controller.service<br>抽取的基类 controller.base</p><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>1.导入指定包下的类、接口(导入所有用通配符<em>)<br>2.声明在包声明和类声明之间<br>3.使用是的本包或者java.lang包下的，则可以省略import结构，<strong>用其他包的内容都要引用</strong><br>4.在源文件中使用了不同包下的同名类，至少一个类以全类名的方式使用(包名.类 …)<br>5.如果’xxx.</em>‘方式表明可以调用xxx包下的所有结构(当前层次)，但是如果使用的是xxx的子包仍然需要显示调用  –&gt; 只要跨包就要import<br>6.import static 导入指定类或接口中的静态结构 -&gt; import 落脚点是类或接口，import static 落脚点是类中的静态结构</p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>引入：编写一个类(无static)时，实际在描述其对象的属性和行为，而并没有产生实质上的对象，只有通过new关键字才会分配内存空间给对象，其方法才可以被外部调用。有时候希望无论是否产生了对象或无论产生了多少对象的情况下，<strong>某些特定的数据在内存空间里只有一份</strong>，所有对象共享。</p><p>说明:<br>1.static可以用来修饰属性、方法、代码块、内部类<br>2.static修饰属性 -&gt; 静态变量/类变量<br>   属性按是否使用static修饰分为 静态属性 VS 非静态属性(实例变量)<br>   类的多个对象共享同一个静态变量<br>   静态变量随类的加载而加载早于对象的创建，由于类只加载一次(缓存在方法区)所以静态变量在内存中只会存在一份<strong>存在方法区的静态域中</strong> (方法区:类的加载信息、静态域、常量池)<br>3.使用static修饰方法 -&gt; 静态方法<br>   (从生命周期思考)<br>   静态方法随类的加载而加载,所以静态方法中不能使用this和super。<br>   静态方法中只能调用静态方法或静态属性 ，非静态方法中，既可以调用非静态的也可以调用静态的</p><p><strong>总结</strong></p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">静态方法/类变量</th><th style="text-align:center">非静态方法/实例变量 </th></tr></thead><tbody><tr><td style="text-align:center">类</td><td style="text-align:center">yes</td><td style="text-align:center">no</td></tr><tr><td style="text-align:center">对象</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td></tr></tbody></table><h3 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h3><p>语法: a instanceof A 判断对象a是否是类A的实例(间接的也行)<br>返回值：是返回true,不是返回false<br>说明：<br>1.要求a所属的类与类A必须是父子类关系，否则编译会出错。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java类及类的成员:属性、方法、构造器;代码块、内部类&lt;br&gt;面向对象的三大特征:封装性、继承性、多态性&lt;br&gt;其他关键字:this、super、static、final、abstract、package、import、interface&lt;/p&gt;
&lt;h2 id=&quot;类和对象
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>10.9数组练习</title>
    <link href="http://yoursite.com/2020/10/09/10-9%E6%95%B0%E7%BB%84%E7%BB%83%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/10/09/10-9数组练习/</id>
    <published>2020-10-09T02:38:26.000Z</published>
    <updated>2020-10-11T12:13:36.018Z</updated>
    
    <content type="html"><![CDATA[<h2 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h2><p><strong>题目</strong><br>使用二维数组打印一个杨辉三角形(二维数组的内容输出是一个杨辉三角)<br>杨辉三角形:<br>1<br>1 1<br>1 2 1<br>1 3 3 1<br>1 4 6 4 1</p><p><strong>思路</strong><br>1.第一个有1个元素,第n行有n个元素<br>2.第一行的第一个元素和最后一个元素都是1<br>3.从第三行开始，对于非第一个元素和最后一个元素的元素的元素 arr[i][j] = arr[i-1][j-1] + arr[i-1][j]</p><p><strong>代码</strong></p><pre><code class="java">public class YangHuiTriangle {    public static void main(String[] args) {        //1.声明并初始化二维数组        int yangHui[][] = new int[10][];        //2.给数组的元素赋值        for (int i=0;i&lt;yangHui.length;i++){            //第n行有n个元素            yangHui[i] = new int [i+1];            //首位数组赋值            yangHui[i][0] = yangHui[i][i] = 1;            //非首位元素赋值                for (int j=1;j &lt; yangHui[i].length-1;j++){                    yangHui[i][j] = yangHui[i-1][j-1] + yangHui[i-1][j];            }        }        //3.输出二维数组        for(int i=0;i&lt;yangHui.length;i++){            for(int j=0;j&lt;yangHui[i].length;j++){                System.out.print(yangHui[i][j] + &quot; &quot;);            }            System.out.println();        }    }}</code></pre><h2 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h2><p>1.创建一个长度为6的int型数组，要求数组元素的值都在1-30之间，且是随机赋值。同时要求元素的值各不相同。<br>思路：赋值之后与数组前面的元素比较，相同则重新赋值</p><pre><code class="java">public class Test {    public static void main(String[] args) {        int arr [] = new int[6];        for (int i=0;i&lt;arr.length;i++){            arr[i] = (int)(Math.random()*30)+1;            //与该元素前面的元素进行比较            for (int j =0;j&lt;i;j++){                if (arr[i]==arr[j]){                    //说明相同了                    i--;                    break;                }            }        }        //输出        for (int i = 0;i &lt; arr.length;i++){            System.out.println(arr[i]);        }    }}</code></pre><h3 id="数组的复制-反转-查找"><a href="#数组的复制-反转-查找" class="headerlink" title="数组的复制/反转/查找"></a>数组的复制/反转/查找</h3><p>数组的复制(区别于数组变量的赋值)</p><pre><code>int[] array1,array2;array1 = new int[]{1,2,3,4,5};array2 = new int[array1.length];for(int i=0;i&lt;array2.length;i++){    array2[i] = array1[i];}</code></pre><p>数组的反转</p><pre><code>for(int i=0,j=arr.length-1;i&lt;j;i++,j++){    String temp = arr[i];    arr[i] = arr[j];    arr[j] = temp;}</code></pre><h3 id="数组元素的排序算法"><a href="#数组元素的排序算法" class="headerlink" title="数组元素的排序算法"></a>数组元素的排序算法</h3><p>内部排序：所有操作都在内存中完成<br>外部排序：借助外部存储器由多次内部排序组成</p><p>交换排序:冒泡排序、快速排序</p><p><strong>冒泡排序</strong><br>冒泡排序思想:依次比较相邻元素的排序码，发现逆序则交换，使排序码较大的元素往后移</p><p>因为排序的过程中，各元素不断接近自己的位置，所以如果一趟比较下来没有进行过交换说明有序，因此需要在排序过程中设置一个标志swap判断元素是否进行过交换，从而较少不必要的比较</p><p>1.最多进行length-1趟<br>2.每趟是的比较次数arr.length-1-i<br>3.比较的是相邻的两个元素<br>4.结束条件:某一趟没有交换元素</p><pre><code>//时间复杂度O(n^2)public class BubbleSort {    public static void main(String [] args){        int[] arr = new int[]{0,1,2,3,4};        boolean swap = false;        //冒泡排序,最多进行arr.length-1趟        for(int i=0;i&lt;arr.length-1;i++){            for (int j = 0; j&lt;arr.length-1-i;j++){                //比较次数arr.length-1-i                if (arr[j] &gt; arr[j+1]){                    //每趟都是相邻元素比较                    int temp = arr[j];                    arr[j] = arr[j+1];                    arr[j+1] = temp;                    swap = true;                }            }            //某趟没有交换元素说明有序可以直接退出            if (!swap){                break;            }        }    }}</code></pre><p><strong>快速排序</strong><br>内排序中速度最快的排序方法，冒泡排序的升级版，时间复杂度O(nlog(n))</p><p>基本思想(大规模化小规模使用同样的办法-递归)：<br>1.任取一个元素(如:第一个)为中心pivot<br>2.所有比它小的元素放前,比它大的放后,形成左右两个子表<br>3.对各子表重新选择中心元素并依此规律调整<br>4.直到每个子表的元素只剩下一个</p><p><img src="/img/Java/挖坑法.png"></p><pre><code>//时间复杂度O(nlogn)public class QuickSort {    //实现快排的代码    public static void subSort(int[] data,int start,int end){        //当开始位置小于结束位置时，可以开始排序        if(start &lt;end){            int pivot = data[start];            //记录需要进行排序的下标            int low = start,high = end;            while (low &lt; high){                //从右往左找，找到一个比基准数小的数                while (low&lt;high &amp;&amp; pivot&lt;=data[high]){                    high--;                }                //找到比基数小的,填左边坑                data[low] = data[high];                //从做往右找，找到一个比基准数大的数                while (low &lt; high &amp;&amp; pivot &gt;= data[low]) {                    low++;                }                //填右边坑                data[high] = data[low];            }//low = high跳出循环            //基准数找到正确的位置            data[low] = pivot;            //处理所有比基准数小的数字            subSort(data,start,low);            //处理所有比基准数大的数字            subSort(data,low+1,end);    }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;杨辉三角&quot;&gt;&lt;a href=&quot;#杨辉三角&quot; class=&quot;headerlink&quot; title=&quot;杨辉三角&quot;&gt;&lt;/a&gt;杨辉三角&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;br&gt;使用二维数组打印一个杨辉三角形(二维数组的内容输出是一个杨辉三角)&lt;br&gt;杨辉
      
    
    </summary>
    
      <category term="刷题笔记" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java总结(学习中)</title>
    <link href="http://yoursite.com/2020/10/09/Java%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/10/09/Java总结/</id>
    <published>2020-10-09T02:34:20.000Z</published>
    <updated>2020-11-04T12:12:14.139Z</updated>
    
    <content type="html"><![CDATA[<h2 id="辨析"><a href="#辨析" class="headerlink" title="辨析"></a>辨析</h2><h3 id="1-break和continue的相同点与不同点"><a href="#1-break和continue的相同点与不同点" class="headerlink" title="1.break和continue的相同点与不同点"></a>1.break和continue的相同点与不同点</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">使用场景</th><th style="text-align:center">作用 </th></tr></thead><tbody><tr><td style="text-align:center">break</td><td style="text-align:center">switch-case和循环</td><td style="text-align:center">结束当前循环</td></tr><tr><td style="text-align:center">continue</td><td style="text-align:center">循环</td><td style="text-align:center">结束本次循环</td></tr></tbody></table><h3 id="2-面向过程-procedure-oriented-programming-与面向对象-object-oriented-programming"><a href="#2-面向过程-procedure-oriented-programming-与面向对象-object-oriented-programming" class="headerlink" title="2.面向过程(procedure oriented programming)与面向对象(object oriented programming)"></a>2.面向过程(procedure oriented programming)与面向对象(object oriented programming)</h3><p>例子:人把大象装进冰箱</p><p><strong>面向过程:强调的是功能行为,考虑怎么做</strong><br>①把冰箱门打开<br>②抬起大象，塞进冰箱<br>③把冰箱门关闭</p><p><strong>面向对象:强调具备了功能的对象,考虑谁来做</strong><br>面向对象的三个点:封装（encapsulation），继承（Inheritance），多态（polymorphism）<br>实体：人、冰箱、冰箱<br>人{<br>  打开(冰箱){<br>    冰箱.打开();<br>  }<br>  抬起(大象){<br>    大象.进入(冰箱);<br>  }<br>  关闭(冰箱){<br>    冰箱.关闭();<br>  }<br>}<br>冰箱{<br>  打开(){}<br>  关闭(){}<br>}<br>大象{<br>  进入(冰箱){}<br>}</p><h3 id="3-成员变量与局部变量的区别"><a href="#3-成员变量与局部变量的区别" class="headerlink" title="3.成员变量与局部变量的区别"></a>3.成员变量与局部变量的区别</h3><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">位置</th><th style="text-align:center">权限修饰符</th><th style="text-align:center">默认初始化值</th><th>内存加载位置</th></tr></thead><tbody><tr><td style="text-align:center">成员变量</td><td style="text-align:center">类的{}里</td><td style="text-align:center">可以使用权限修饰符</td><td style="text-align:center">根据其类型有默认初始化值</td><td>非static的 堆空间</td></tr><tr><td style="text-align:center">局部变量</td><td style="text-align:center">方法内、方法形参、构造器内、构造器形参、代码块内</td><td style="text-align:center">不可以使用权限修饰符</td><td style="text-align:center">没有默认初始化值,在调用局部变量前要显示赋值</td><td>栈空间</td></tr></tbody></table><p>补充： 有默认初始化值-&gt; 数组元素、属性</p><h3 id="4-区分方法的重载和重写"><a href="#4-区分方法的重载和重写" class="headerlink" title="4.区分方法的重载和重写"></a>4.区分方法的重载和重写</h3><p>① 重载：同类下同方法名不同形参列表的方法之间，构造器可以重载<br>  重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作。构造器不能重载</p><p>② 可以介绍一下重载和重写的具体规则<br>  重载:两同一不同 -&gt; 同一个类、相同方法名，参数列表不同<br>  重写:继承,同名同参数</p><p>③ 重载：不表现为多态性<br>  重写:表现为多态性<br>  -&gt; 从编译和运行的角度看,编译器是知道同名不同参数列表的方法是不同得的方法,所以重载在编译时知道调用地址，所以是静态绑定的。而重写只有等方法调用的时候才知道具体的调用，所以是动态绑定的。</p><p>如何定位到一个方法: 1.先看方法名 2.对比参数列表</p><h3 id="5-final、finally、finalize的区别"><a href="#5-final、finally、finalize的区别" class="headerlink" title="5.final、finally、finalize的区别"></a>5.final、finally、finalize的区别</h3><p>finalize:当对象被回收前,垃圾回收器自动调用该对象的finalize方法</p><h3 id="6-equals-与-的区别"><a href="#6-equals-与-的区别" class="headerlink" title="6.equals()与==的区别"></a>6.equals()与==的区别</h3><p>== : 运算符,基本数据类型比较数值(不一定数据类型一样),引用数据类型比较两个对象的地址值。 -&gt; == 符号使用时，左右两边的变量一致(可以通过某种方法统一)<br>equals(): 方法,只使用于引用数据类型,没重写equals()比较的是地址，重写的比较的是实体内容</p><pre><code>int i =10double d = 10.0//存在自动类型提升//以 + 为例子，但是在其他运算符中也会存在自动类型提升i == d //true，</code></pre><p><strong>待解决</strong><br>1.面向对象的编程思想？</p><p>  == 对于引用类型来讲，比较的是两个引用数据类型变量的地址值是否相同<br>3.toString方法的重写<br>4.new</p><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><h3 id="1-万事万物皆对象？"><a href="#1-万事万物皆对象？" class="headerlink" title="1.万事万物皆对象？"></a>1.万事万物皆对象？</h3><p>①在Java语言中，我们将功能、结构等封装到类中，通过类的实例化，来调用具体的结构<br>②在与前端后端交互时，前后端的结构在Java层交互时，都体现为类、对象</p><h3 id="2-println参数为char数组时的重载"><a href="#2-println参数为char数组时的重载" class="headerlink" title="2.println参数为char数组时的重载"></a>2.println参数为char数组时的重载</h3><pre><code>char[] arr = new char[]{&#39;a&#39;,&#39;b&#39;,&#39;c&#39;};System.out.println(arr); //输出abc 而不是地址值</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;辨析&quot;&gt;&lt;a href=&quot;#辨析&quot; class=&quot;headerlink&quot; title=&quot;辨析&quot;&gt;&lt;/a&gt;辨析&lt;/h2&gt;&lt;h3 id=&quot;1-break和continue的相同点与不同点&quot;&gt;&lt;a href=&quot;#1-break和continue的相同点与不同点&quot; cla
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>10.8循环-质数/完数</title>
    <link href="http://yoursite.com/2020/10/08/10-8%E5%BE%AA%E7%8E%AF-%E8%B4%A8%E6%95%B0.%E5%AE%8C%E6%95%B0/"/>
    <id>http://yoursite.com/2020/10/08/10-8循环-质数.完数/</id>
    <published>2020-10-08T05:55:22.000Z</published>
    <updated>2020-10-09T12:51:59.712Z</updated>
    
    <content type="html"><![CDATA[<h2 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h2><p><strong>思路</strong><br>质数：只能被1和它本身整除的自然数</p><p>利用循环,如果这个数可以与其他数取余为0，说明不是质数。</p><p>不是质数的数都可以拆成两个数相乘,也就是成对出现的，所有循环的条件到这个数的根号就行了</p><pre><code>public class PrimeNumber {    public static void main(String[] args) {        for(int i= 3 ;i&lt;=100;i++){            boolean isFlag = true;            //优化二：对本身是质数的自然数是有效的            for (int j =2;j &lt;= Math.sqrt(i);j++){                if(i%j==0){                    //可以除尽，说明不是质数退出当前循环                    isFlag = false;                    break;//优化1：只对本身非质数的自然数是有效的                }            }            if(isFlag){                System.out.println(i + &quot;是质数&quot;);            }        }    }}</code></pre><p><strong>优化</strong><br>利用标签可以有更加简单的写法</p><pre><code>public class PrimeNumber {    public static void main(String[] args) {       label:for(int i= 3 ;i&lt;=100;i++){            for (int j =2;j &lt;= Math.sqrt(i);j++){                if(i%j==0){                    continue label;                }            }                System.out.println(i + &quot;是质数&quot;);        }    }}</code></pre><h2 id="完数"><a href="#完数" class="headerlink" title="完数"></a>完数</h2><p><strong>题目</strong><br>一个数如果恰好等于它的因子(除去这个数本身的其他约数)之和，这个数就称为”完数”。例如6=1+2+3，找出1000以内的所有完数。</p><p><strong>思路</strong><br>需要找因子</p><p>1.由于因子的成对出现，所以找到这个数的开根号为止<br>2.1是任何数的因子且1不是完数,所以从2开始找<br>3.需要一个变量来记录因子和,是因子就加上，最后和这个数比较</p><pre><code>public class wanshu {    public static void main(String[] args) {        for (int i=2;i&lt;=1000;i++){            //因为1是所有数的因子，所以因子之和从1开始            int total = 1;            //为了避免每次循环都计算            double end = Math.sqrt(i);            for (int j=2;j &lt;= end;j++){                if ( i%j ==0){                    total = total + j + i/j ;                }            }            if (i == total){                System.out.println(i + &quot;是完数&quot;);            }        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;质数&quot;&gt;&lt;a href=&quot;#质数&quot; class=&quot;headerlink&quot; title=&quot;质数&quot;&gt;&lt;/a&gt;质数&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;br&gt;质数：只能被1和它本身整除的自然数&lt;/p&gt;
&lt;p&gt;利用循环,如果这个数可以与其他数取余为0，说
      
    
    </summary>
    
      <category term="刷题笔记" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础(学习中)</title>
    <link href="http://yoursite.com/2020/09/25/Java%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/09/25/Java基础/</id>
    <published>2020-09-25T07:33:54.000Z</published>
    <updated>2020-11-04T13:26:08.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章-Java概述"><a href="#第一章-Java概述" class="headerlink" title="第一章 Java概述"></a>第一章 Java概述</h2><p><strong>java特点</strong><br>1.面向对象:类与对象两个基本概念，封装、继承与多态三大特点<br>2.健壮性：吸收了c/c++语言的优点，去掉了其影响程序健壮性的部分<br>3.跨平台:不同版本的JVM(java虚拟器)</p><p><strong>java两种核心机制</strong><br>1.Java虚拟机 Java Virtal Machines<br>2.垃圾回收机制 Garbage Collection</p><p>Java程序还是会出现内存泄露和内存溢出问题</p><p><strong>JDK、JRE</strong></p><p>JDK(Java Development Kit) Java开发工具包：是提供给Java开发人员使用，其中包含了java的开发工具与JRE  –&gt; JDK = JRE + 开发工具集(javac.exe,java.exe,javadoc.exe)</p><p>JRE(Java Runtime Environment) Java运行环境:包括java虚拟机和hava程序所需的核心类库等，如果想要运行一个开发好的Java程序，只需要JRE即可 –&gt; JRE = JVM + Java SE标准类库</p><p>JDK的开发工具完成Java程序，JRE运行</p><p>java  -javac 文件名.java 编译-&gt; .class文件（字节码文件） -java 字节码文件名 运行-&gt; 结果</p><p><strong>注释</strong></p><p>单行注释<code>//</code><br>多行注释<code>/**/</code><br>文档注释<code>/** */</code>,注释内容可以被<br>JDK提供的工具javadoc所解析(javadoc -d 生成的文件夹名字 -author -version 文件名)，生成一套以网页文件形式体现的说明文档</p><p><strong>注意</strong></p><p>1.在一个java源文件中可以有多个类，但只能给与<strong>文件名一样的类添加public</strong><br>2.每一行执行语句都以<code>;</code>结束<br>3.程序的入口是main()方法，格式是固定的</p><pre><code class="java">public static void main(String[] args){    System.out.println(&quot;输出语句换行&quot;);    System.out.print(&quot;输出语句不换行&quot;);}</code></pre><p>4.编译之后会生成一个或多个字节码文件，字节码文件的文件名与java源文件中的类名相同</p><h2 id="第二章-基本语法"><a href="#第二章-基本语法" class="headerlink" title="第二章 基本语法"></a>第二章 基本语法</h2><p><strong>Java命名规范(建议)</strong><br>包名：所有小写xxxyyy<br>类名、接口名：驼峰命名法(第一个单词首字母大写)XxxYyy<br>变量名、方法名：第一个单词首字母小写，其余单词首字母大写xxxYyy<br>常量名：所有字母都大写，多单词用下划线连接xxx_yyy</p><p><strong>变量</strong><br>1.Java中每个变量必须先声明并初始化后使用<br>2.变量的作用域:其定义所在的一对<code>{}</code>内<br>3.变量是程序中最基本的存储单元。包含变量类型、变量名和存储的值 –&gt; 数据类型 变量名 = 变量值</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>按数据类型分类:<br><img src="/img/Java/数据类型.png"></p><p>1.string是class类型<br>2.定义long型变量，必须以”l”或”L”结尾<br>3.定义float型变量，变量要以”f”或”F”结尾<br>4.char型初始化要有值,单引号括住</p><p>按声明的位置不同:</p><ul><li>成员变量,在方法体外,类体内声明的变量<ul><li>实例变量,不以static修饰</li><li>类变量,以static修饰</li></ul></li><li>局部变量,在方法体内部声明的变量</li></ul><p><strong>基本数据类型之间的运算规则</strong><br>前提:这里讨论7种基本数据类型变量间的运算，不包含布尔类型。</p><p>1.自动类型提升<br>    byte/short/char -&gt; int -&gt; long -&gt; float-&gt;double<br>    当byte/short/char三种类型(同类型也是)做运算时,结果至少用int接收<br>    java在做运算时，如果操作数均在int范围内，那么一律在int的空间内运算<br>2.强制类型转换  - 自动类型提升的逆运算<br>(强制转换的类型)xx </p><p><strong>特殊情况</strong><br>情况1: long l = 12315465111  会把12315465111当作int型(此时会编译失败因为超出int的范围),类型提升到long型<br>情况2: 浮点型默认的是double,所以float型后面一定需要添加f/F</p><p><strong>String</strong><br>1.String属于引用数据类型,双引号括住<br>2.String可以与其他类型做连接运算</p><p><strong>运算符</strong><br>只有单目运算符、三元运算符、赋值运算符是从右向左运算的</p><p>%：取余运算结果的符号与被模数的符号相同<br>++/–/+=/-=/..：不会改变变量本身的数据类型<br>=:支持连续赋值,类型相同可以赋值(或者变量提升),赋值时会先检查类型是否相同</p><pre><code class="Java">int n =10n += (n++) + (++n)// n = n + (n++) + (++n)// n = 10 + 10 + 12 </code></pre><p>逻辑运算符(操作数是布尔类型)-常用短路与/短路或<br><img src="/img/Java/逻辑运算符.png"></p><p>位运算符 - 最高效方式的计算 2*8? 2&lt;&lt;3 或 8&lt;&lt;1<br><img src="/img/Java/位运算符.png"></p><p>交换两个变量的值<br>1.使用临时变量<br>2.m = (m^n)^n 有局限性:适用于数值类型 m = 原来n的值</p><p>三元运算符：(条件表达式)?表达式1：表达式2</p><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p><strong>Scanner类</strong><br>1.导包: import java.util.Scanner<br>2.Scanner实例化<code>Scanner scan = new Scanner(System.in)</code><br>3.调用Scanner类的相关方法(next()/nextXxx())，来获取指定类型的变量</p><pre><code class="java">//使用scanner从键盘获取int型数据import java.util.Scanner;class ScannerTest{    public static void main(String[] args){        Scanner scan = new Scanner(System.in);        String num = scan.next();    }}</code></pre><p><strong>随机数</strong><br>Math.random() [0.0,1.0)<br>公式:[a,b] –&gt; Math.random()*(b-a+1) + a</p><p><strong>switch</strong><br>根据switch表达式中的值，依次匹配case中的常量，有break才退出,没有会向下执行。<br>switch结构中的表达式只能是byte、short、char、int、枚举类型、String类型</p><p>注意:在case中不要定义重复的变量，switch下的变量作用域是同一个</p><pre><code class="java">switch(表达式){    //合并    case 常量1:    case 常量2:        语句;    default:        语句;}</code></pre><p><strong>循坏</strong><br>循环结构的4个要素:<br>①初始化条件<br>②循环条件<br>③循环体<br>④迭代条件</p><pre><code>for(①;②;③){    ④}//for循环和while循环可以相互转化①while(②){    ③;    ④; }</code></pre><p>技巧：循环嵌套时，外层控制行数，内层控制列数</p><p><strong>break和continue/return</strong></p><p>break: swich-case/循环结构  - 默认结束当前循环<br>continue: 循环结构  - 默认结束当次循环</p><p>如果要结束外层的for，可以通过标签实现</p><pre><code>label:for(..){    for(..){        ....        break label; //结束指定标识的一层循环结构    }}</code></pre><p>return:并非专门用于结束循环的,当一个方法执行到一个return语句时,这个方法将被结束。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组长度一旦确定就不能修改<br>数组是一种特殊的类，因为它也继承了Object</p><p><strong>一维数组的使用</strong><br>1.声明和初始化,初始化时要指定长度<br>2.数组的长度,属性length<br>3.数组元素的默认初始化值 -&gt;  整型(byte、short、int、long)0,浮点型(float、double)0.0，char型(ACSII=0),布尔型false(0),引用数据类型null。</p><pre><code>//静态初始化//int ids[] = 这种写法也可以int[] ids = new int[]{1001,1002,1003}int arr[] = {1234,5}; //类型推断//动态初始化,分配了5个空间String[] names = new String[5];</code></pre><p><strong>一维数组的内存解析</strong><br>虚拟机栈(stack):局部变量。<br>堆(heap):new出来的结构,对象(非static的成员变量)、数组<br>方法区：常量池(String…) + 类信息(方法) + 静态变量…</p><p><img src="/img/Java/数组的内存解析0.png"></p><p>当局部变量没用之后，会依次出栈，堆里的空间会在一个不确定的时间被回收。</p><p><strong>二维数组的使用</strong></p><pre><code>//静态初始化,可以省略new int[][]int[][] arr = new int[][]{{123},{4,5}};int arr[][] = {{123},{4,5}}; //类型推断//动态初始化[[0,0],[0,0],[0,0]]String[][] arr2 = new String[3][2]//动态初始化String[][] arr2 = new String[3][]</code></pre><p><img src="/img/Java/数组的内存解析1.png"></p><p><strong>Arrays工具类</strong><br>java.util.Arrays类为操作数组的工具类</p><p>Arrays.equals(arr1,arr2) 判断两个数组是否相等,返回布尔值<br>Arrays.toString(arr) 输出数组信息,返回String<br>Arrays.fill(arr,val) 将val填充到arr数组中,返回void<br>Arrays.sort(arr) 数组排序,返回void<br>Arrays.binarySearch(arr,key) 二分查找key,arr需要有序,返回数组下标int,没找到返回负数</p><p><strong>数组使用中的常见异常</strong><br>1.数组角标越界的异常:ArrayIndexOutOdBoundsException<br>2.空指针异常:NullPointerException</p><pre><code>//空指针异常举例子int [] arr = new int[] {1,2}arr = nullSystem.out.print(arr[0])</code></pre><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p><a href="https://biubiuins.github.io/2020/10/11/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" target="_blank" rel="noopener">面向对象</a></p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String存放在常量池中(不可变的字符序列),在底层以char[]存放(数组长度不能改-&gt; string是不可变的字符序列)<br>修改String类型变量，是新建了一个char[]数组把新的地址赋值给该变量</p><p>获取String的长度用length()方法，而数组有length属性。</p><pre><code>//可以不用newString s1 = &quot;hello&quot;;String s2 = new String()</code></pre><p><strong>charAt(index)方法</strong></p><p>string.charAt(index) 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一章-Java概述&quot;&gt;&lt;a href=&quot;#第一章-Java概述&quot; class=&quot;headerlink&quot; title=&quot;第一章 Java概述&quot;&gt;&lt;/a&gt;第一章 Java概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;java特点&lt;/strong&gt;&lt;br&gt;1.面向对象:类与对象
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>9.14数组-主要元素</title>
    <link href="http://yoursite.com/2020/09/14/9-14%E4%B8%BB%E8%A6%81%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2020/09/14/9-14主要元素/</id>
    <published>2020-09-14T07:11:01.000Z</published>
    <updated>2020-10-08T05:55:27.517Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目:</strong> </p><p>数组中占比超过一半的元素称之为主要元素。给定一个整数数组，找到它的主要元素。若没有，返回-1</p><p>示例:</p><pre><code>输入：[1,2,5,9,5,9,5,5,5]输出：5输入：[3,2]输出：-1</code></pre><p><strong>思路</strong></p><p>首先需要知道数组的长度，其次是查询一个元素出现的次数比较是否超过数组长度的一半，若超过则输出该元素，如果没有超过，查询下一个元素。</p><p><strong>实现过程</strong></p><pre><code>var majorityElement = function(nums) {let flag = 1let number = nums.length/2if(nums.length == 1){    return nums[0]}for(let i = 0;i&lt;nums.length;i++){    //获取到当前比较的元素    let current = nums [i]    //如果当前元素是第一次出现则查询次数，如果不是第一次出现，则执行下一次循环    if(nums.indexOf(current) != i){        //不是第一次出现,则执行下一次循环        continue    }    for(let j = i+1;j&lt;nums.length;j++){        //获取到该元素的后续元素        if(current == nums [j]){            flag ++        }        if(flag &gt; number){            console.log(flag)            //如果次数已经超过了一半则直接返回该元素            return current        }    }  }return -1};</code></pre><p><strong>其他方法</strong></p><p>评论中提及最多的是使用Map容器，Map容器是一组key不重复的键值对的结构。</p><pre><code>var majorityElement = function (nums) {    //初始化一个max的作用是当前数组的元素仅一个时比较    let len = nums.length / 2, m = new Map(), max = 0    for (let num of nums) {        //设置key为num，如果该key已经存在，当前值+1        m.set(num, m.has(num) ? m.get(num) + 1 : 1)        //比较当前元素出现的次数与之前出现元素的最大次数        max = Math.max(max, m.get(num))        if (max &gt; len) {            return num        }    }    return -1};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目:&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;数组中占比超过一半的元素称之为主要元素。给定一个整数数组，找到它的主要元素。若没有，返回-1&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：[1,2,5,9,5,9,5,5,5]
输出：5

输入：[3,
      
    
    </summary>
    
      <category term="刷题笔记" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>9.13数组-转置矩阵</title>
    <link href="http://yoursite.com/2020/09/13/9-13%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5/"/>
    <id>http://yoursite.com/2020/09/13/9-13转置矩阵/</id>
    <published>2020-09-13T07:35:32.000Z</published>
    <updated>2020-10-08T05:55:40.866Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目:</strong><br>给定一个矩阵A,返回A的转置矩阵。<br>矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。</p><p>示例：</p><pre><code>输入：[[1,2,3],[4,5,6],[7,8,9]]输出：[[1,4,7],[2,5,8],[3,6,9]]输入：[[1,2,3],[4,5,6]]输出：[[1,4],[2,5],[3,6]]</code></pre><p><strong>思路:</strong></p><p>通过观察矩阵,发现当i(行数)=j(列数)时数字处于对角位置,不需要置换(也可以置换统一处理,置换后不影响);当i ≠ j 时,i与j需要发生置换。 </p><p><strong>实现过程</strong></p><pre><code class="js">let transpose = function (A) {let newArray = new Array(A.length)for (let i = 0; i &lt; A.length; i++) {//得到每一行元素    for (let j = 0; j &lt; A[i].length; j++) {    //得到每一个元素     newArray[j][i] = A[i][j]    }    }    return newArray };let test = [    [1, 2, 3],    [4, 5, 6],    [7, 8, 9]]console.log(transpose(test));</code></pre><p>问题1:<br>报错:Cannot set property ‘0’ of undefined<br>原因:需要先初始化数组,再进行赋值。</p><p>修改版本:</p><pre><code class="js">var transpose = function(A) {let newArray = []//根据A[0]的长度，为新数组创建一系列内部空数组for (let i =0; i &lt; A[0].length; i++) {     newArray[i] = [] }console.log(&#39;newArray&#39;,newArray); for(let i=0;i&lt;A.length;i++){//得到每一行元素    for(let j=0;j&lt;A[i].length;j++){    //得到每一个元素    newArray[j][i] = A[i][j]    }}return newArray};</code></pre><p><strong>反思优化</strong></p><p>看了别人的代码，发现可以在以下方面进行优化。<br>初始化新数组的时候，如果使用<code>arr[i][j] = A[j][i]</code>,可以少进行一次循环。这里可以多思考一下，现在才开始感觉思维并不是很开阔。</p><pre><code>var transpose = function (A) {    var rows = A.length    var cols = A[0].length    var arr = []    for (var i = 0; i &lt; cols; i++) {        arr[i] = []        for (var j = 0; j &lt; rows; j++) {            arr[i][j] = A[j][i]        }    }    return arr}</code></pre><p>还看见了一个更精简的。<br>Array.from把v的伪数组(字符串也可)转换为真数组,第一个参数为有length属性的伪数组，第二个参数作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。<br>暂时可以理解但自己想不出来。</p><pre><code class="js">var transpose = function(A) {    return Array.from({length:A[0].length},(v,i)=&gt;A.map(v=&gt;v[i]))};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目:&lt;/strong&gt;&lt;br&gt;给定一个矩阵A,返回A的转置矩阵。&lt;br&gt;矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：[[1,2,3],[4,5,6],[7,8,9]]
输出：[[
      
    
    </summary>
    
      <category term="刷题笔记" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>自定义拷贝</title>
    <link href="http://yoursite.com/2020/08/31/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B7%B1%E5%BA%A6%E5%85%8B%E9%9A%86/"/>
    <id>http://yoursite.com/2020/08/31/自定义深度克隆/</id>
    <published>2020-08-31T06:10:40.000Z</published>
    <updated>2020-08-31T07:15:52.941Z</updated>
    
    <content type="html"><![CDATA[<p>补充：循环引用</p><pre><code class="js">const obj1 = {    a:1,    b:[&#39;e&#39;,&#39;f&#39;],    c:{h:{i:2}},    d:function(){}}//循环引用obj1.b.push(obj1.c)obj1.c.j = obj1.b</code></pre><p><strong>大众版本</strong><br>问题1：函数属性会丢失(JSON存不了函数)<br>问题2：循环引用会出错(死循环)</p><pre><code>function deepClone(target){    return JSON.parse(JSON.stringify(target))}</code></pre><p><strong>面试基础版</strong><br>解决问题1：函数属性不会丢失<br>仍然存在问题:循环引用会出错</p><pre><code class="js">function deepClone(target) {    //数组/对象    if (target instanceof Array || (target !==null &amp;&amp; typeof target ===&quot;object&quot;)) {        const cloneTarget = target instanceof Array ? [] : {}        for (const key in target) {            if (target.hasOwnProperty(key)) {                cloneTarget[key] = deepClone(target[key])            }        }        return cloneTarget    }else {        return target    }}</code></pre><p><strong>面试加强版本</strong><br>解决问题1：函数属性不会丢失<br>解决问题2：循环引用<br>解决思路:<br>    目标：同一个对象/数组只能被克隆一次<br>    创建克隆对象前：如果克隆对象已经存在，直接返回<br>    创建克隆对象后：保存克隆对象<br>    缓存容器：Map key:target value:cloneTarget</p><p>问题：为什么选择Map容器不使用对象？<br>因为对象的键是字符串,使用Map容器保存的键是数组/对象，值是克隆之后的数组/字符串</p><pre><code class="js">function deepClone(target,map = new Map()) {    //数组/对象    if (target instanceof Array || (target !==null &amp;&amp; typeof target ===&quot;object&quot;)) {        //先判断是否已经产生了克隆对象        let cloneTarget = map.get(target)        if (cloneTarget) {            //如果产生了就直接返回克隆对象，不要对同一个对象多次克隆            return cloneTarget        }        //创建克隆容器        cloneTarget = target instanceof Array ? [] : {}        //一产生克隆对象就存进去key:原容器、value为克隆产生的容器        map.set(target,cloneTarget)        for (const key in target) {            if (target.hasOwnProperty(key)) {                //map缓存要继续用下去，不传就相当于又重新产生了一个map对象                cloneTarget[key] = deepClone(target[key],map)            }        }        return cloneTarget    }else {        return target    }}</code></pre><p><strong>面试加强版本2</strong><br>耗时：for..in  &gt;&gt;&gt; for | forEach |while<br>优化数组遍历性能：数组用for..in循环耗时太多</p><pre><code>export function deepClone(target,map = new Map()) {    //数组/对象    if (target instanceof Array || (target !==null &amp;&amp; typeof target ===&quot;object&quot;)) {        //先判断是否已经产生了克隆对象        let cloneTarget = map.get(target)        if (cloneTarget) {            //如果产生了就直接返回克隆对象            return cloneTarget        }        //创建克隆容器        if (target instanceof Array) {            cloneTarget = []            map.set(target,cloneTarget)            //向数组添加元素            target.forEach((item,index)=&gt;{                cloneTarget[index] = deepClone(target[key],map)            })        }else{            cloneTarget = {}            map.set(target,cloneTarget)            //向对象添加属性            for (const key in target) {                if (target.hasOwnProperty(key)) {                    cloneTarget[key] = deepClone(target[key],map)                }            }        }        return cloneTarget    }else {        return target    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;补充：循环引用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;const obj1 = {
    a:1,
    b:[&amp;#39;e&amp;#39;,&amp;#39;f&amp;#39;],
    c:{h:{i:2}},
    d:function(){}
}
//循环引用
o
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>python-文件</title>
    <link href="http://yoursite.com/2020/08/30/python-%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/08/30/python-文件/</id>
    <published>2020-08-30T10:22:35.000Z</published>
    <updated>2020-08-30T11:56:37.736Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><strong>open()函数</strong></p><p>通过open函数来打开一个文件<br>参数：<br>    file 打开文件的名字(路径),如果在同一目录下直接使用文件名即可<br>    encoding：文本文件的编码默认None，utf-8中文编码encoding = ‘utf-8’<br>    mode:默认是读取文件,’r’只读;’w’可写,覆盖性的写;’a’追加内容;”+”为操作符增加功能’r+’可读可写、文件不存在报错…;x用来新建文件、文件存在则报错。读取模式写在r/w/a后面，默认是r读取文本文件，b读取二进制文件<br>返回值：<br>    代表当前打开文件的对象,可以看作是一个文件的标识符</p><p><strong>read()方法</strong><br>文件标识符.read()用来获取文件中的内容，将内容全部保存为一个字符串返回。<br>    如果读取的文件太大的话，会一次性将文件的内容加载到内存中，容易导致内存泄露，所以对于较大的文件，不要直接调用read()<br>    read()第一个参数size，读取文本文件时，size是以字符为单位的，读取二进制文件时，size用来指定用读取的字符数量，默认-1<br>    如果多次调用read()会继续上一次读的内容继续往下读，如果已经读取到了文件的最后，则会返回’’空串</p><p><strong>readline()方法/readlines()方法</strong><br>文件标识符.readline()用来读取一行内容<br>文件标识符.readlines()该方法用于一行一行读取内容，会一次性将读取的内容封装到一个列表中返回<br>for t in file_obj采用迭代也可以一行一行读</p><p><strong>write()方法</strong><br>如果操作的是一个文本文件的话，则write()需要传递一个字符串作为参数，返回值是写入字符的个数<br>文件标识符.write(string),一个文件多次调用write则会接着往后写</p><p><strong>with as语句</strong></p><p>文件标识符.close()用来关闭文件</p><p>with … as 语句,可以自动关闭文件<br>with open(file_name) as file_obj:<br>    pass  </p><pre><code># 在with语句中可以直接使用file_obj做文件的标识符# 这个文件只能在with中使用，一旦with结束则文件会自动close</code></pre><p><strong>tell()/seek()方法</strong><br>文件标识符.tell()用来查看当前读取的位置<br>文件标识符.seek()用来修改当前读取的位置，第一参数是要切换到的位置，第二个参数是计算位置方式0从头计算、1从当前位置开始计算、2从最后位置开始计算</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;open()函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过open函数来打开一个文件&lt;br&gt;参数：&lt;br&gt;    file 打开
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>数组声明式方法</title>
    <link href="http://yoursite.com/2020/08/24/%E6%95%B0%E7%BB%84%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%B3%BB%E5%88%97%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/08/24/数组声明式系列方法/</id>
    <published>2020-08-24T07:56:50.000Z</published>
    <updated>2020-08-24T09:01:36.987Z</updated>
    
    <content type="html"><![CDATA[<p>有两种编程方式:命令式和声明式</p><p>·命令式编程：命令“机器”如何去做事情(how)，这样不管你想要的是什么(what)，它都会按照你的命令实现。<br>·声明式编程：告诉“机器”你想要的是什么(what)，让机器想出如何去做(how)。</p><p>声明式内部的实现都已经封装好，只要按照要求传参数就可以。</p><p>map(callback):按照原始元素依次处理元素,返回新数组<br>    callback2个参数，当前元素item、当前元素的下标index<br>reduce(callback,[initValie]):累计器,返回累计结果<br>    callback4个参数,上一次调用回调返回的值(第一次为初始值)、item当前被处理的元素、index当前元素的索引<br>filter(callback):过滤器,在数组中筛选出符合条件的元素，返回新素组<br>    callback3个参数.当前元素、当前元素索引、当前元素所在的数组<br>find(callback):找到数组中第一个满足条件返回true的元素<br>    callback2个参数，当前元素、当前元素索引<br>findIndex(callback):找到第一个满足条件返回true的元素下标<br>    callback2个参数，当前元素、当前元素索引<br>every(callback):数组进行检查，有一个元素不满足要求，整个表达式返回false，其余元素不检查<br>    callback3个参数.当前元素、当前元素索引、当前元素所在的数组<br>some(callbcak):对整个数组进行检查，如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。反之返回false。<br>    callback3个参数.当前元素、当前元素索引、当前元素所在的数组</p><pre><code>//产生一个每个元素都比原来大10的新数组const arr = [1,3,6,9,15,19,16]console.log(arr.map((item,index)=&gt;item+10));//得到所有奇数的和console.log(arr.reduce((preTotal,item,index)=&gt;{    return preTotal + (item%2 ===1?item:0)},0));//得到值大于8且下标是偶数的元素组成的数组console.log(arr.filter((item,index)=&gt;index%2 ===0&amp;&amp;item&gt;8));//找出一个值大于8且下标是偶数位的元素console.log(arr.find((item,index)=&gt;index%2 ===0&amp;&amp;item&gt;8));//找出一个值大于8且下标是偶数的元素的下标console.log(arr.findIndex((item,index)=&gt;index%2 ===0&amp;&amp;item&gt;8));//判断下标为偶数的元素是否都是奇数console.log(arr.every((item,index)=&gt; index%2===1 || (index%2===0&amp;&amp;item%2 ===1)));//判断是否有下标为偶数的元素为奇数console.log(arr.some((item,index)=&gt; index%2===1 || (index%2===0&amp;&amp;item%2 ===1)));</code></pre><p><strong>自定义</strong></p><pre><code>//map()Array.prototype.map = function (callback) {    let arr = []    //遍历当前数组的每个元素，调用callback得到结果数据添加arr    for (let index = 0; index &lt; this.length;index++) {     let element = this[index]     const result = callback(element,index)     arr.push(result)    }    return arr }//reduce()Array.prototype.reduce = function (callback,initValue) {    //结果为初始值    let total = initValue    //遍历当前数组的每个元素，调用callback得到累加的结果数据    for (let index = 0; index &lt; this.length;index++) {     let element = this[index]     total = callback(total,element,index)    }    //返回结果    return total }//filter()Array.prototype.filter = function (callback) {    let arr = []      //遍历当前数组的每个元素，得到布尔值    for (let index = 0; index &lt; this.length;index++) {    let element = this[index]    if(callback(element,index)){    arr.push(element)    }    }    return arr }//find()Array.prototype.find = function (callback) {    //遍历当前数组的每个元素，得到布尔值,为true返回当前的元素    for (let index = 0; index &lt; this.length;index++) {    let element = this[index]    if(callback(element,index)){        return element    }    }     return undefined}//findIndex()Array.prototype.findIndex = function (callback) {    //遍历当前数组的每个元素，得到布尔值,为true返回当前的元素下标    for (let index = 0; index &lt; this.length;index++) {    let element = this[index]    if(callback(element,index)){        return index    }    }     return -1}//every()Array.prototype.every = function (callback) {    //遍历当前数组的每个元素，调用callback得到一个布尔值，一旦是false返回false    for (let index = 0; index &lt; this.length;index++) {    let element = this[index]    const result = callback(element,index)    if(!result){        return false    }    }     return true}//some()Array.prototype.some = function (callback) {    //遍历当前数组的每个元素，调用callback得到一个布尔值，一但是true，返回true    for (let index = 0; index &lt; this.length;index++) {    let element = this[index]    const result = callback(element,index)    if(result){        return true    }    }     return false}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有两种编程方式:命令式和声明式&lt;/p&gt;
&lt;p&gt;·命令式编程：命令“机器”如何去做事情(how)，这样不管你想要的是什么(what)，它都会按照你的命令实现。&lt;br&gt;·声明式编程：告诉“机器”你想要的是什么(what)，让机器想出如何去做(how)。&lt;/p&gt;
&lt;p&gt;声明式内部
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>call-apply-bind</title>
    <link href="http://yoursite.com/2020/08/22/call-apply-bind/"/>
    <id>http://yoursite.com/2020/08/22/call-apply-bind/</id>
    <published>2020-08-22T13:13:53.000Z</published>
    <updated>2020-08-24T09:44:34.214Z</updated>
    
    <content type="html"><![CDATA[<p><strong>函数对象的call方法与apply方法</strong></p><p>函数对象：函数像对象一样去使用,<code>函数.xx</code>。</p><p>共同点：<br>1.这两个方法都是函数对象的方法，需要通过函数对象来调用<br>2.当对函数调用 call()和apply()时，都会执行该函数<br>3.call()和apply()的第一个参数为对象，执行call()与apply的函数对象里的this指向第一个参数</p><p>不同点：<br>call()方法方法可以将实参在第一个参数对象之后依次传递<br>apply()方法需要将实参封装到一个数组中统一传递</p><p><strong>bind()、call()、apple()的区别</strong></p><ul><li>都能指定函数中的this</li><li>Array.prototype.call()/Array.prototype.apply()是立即调用函数，Array.prototype.bind()是将函数返回</li><li>Array.prototype.call(obj)/Array.prototype.bind()从第二个参数开始依次传，Array.prototype.apply(obj)第二个参数是数组，传入的数据放入数组中</li></ul><pre><code>let obj ={name:&quot;ranan&quot;}function f(data,data2) {    console.log(this);    console.log(data + data2);    return data+data2}f.call(obj,33,22) //{name:&quot;ranan&quot;} 55f.apply(obj,[33,22])//{name:&quot;ranan&quot;} 55//所以apply通常用于将数组转化为函数的参数let bar=f.bind(obj) //bind不调用函数bar(33,22)//{name:&quot;ranan&quot;} 55//上面也可以写成f.bind(obj)(33,22)//{name:&quot;ranan&quot;} 55</code></pre><p><strong>Function.prototype.bind(obj)</strong></p><p>作用:将函数内的this绑定为obj，并将函数返回(并不调用)</p><ul><li>返回原函数的拷贝，我们称这个拷贝的函数为绑定函数。</li><li>将函数中的this固定为调用bind方法时的第一个参数，</li><li>绑定this之后，无论有哪个对象调用绑定函数，绑定函数中的this依旧之前绑定的第一个参数</li><li>如果绑定函数作为构造函数，已经捆绑的this会被忽略掉，this依然指向实例对象</li></ul><pre><code>function Person(name){this.name = name;}var bindPerson = Person.bind({name:&quot;绑定函数&quot;}) new bindPerson(&quot;张三&quot;)          // Person {name: &quot;张三&quot;}</code></pre><p><strong>通常用于指定回调函数的this，因为apply与call会立即调用</strong></p><p><strong>使用场景</strong></p><p>保持上下文的方法</p><pre><code>var o={    f: function () {        var self=this;        var fff=function() {            console.log(this.value);             // bind(this) 中 this 指向的是o，这里也可直接写成 bind(o)        }.bind(this);        fff();    },    value: &quot;Hello World!&quot;};o.f(); // Hello World！</code></pre><p><strong>总结</strong></p><ul><li>call()<ul><li>立即调用函数</li><li>从第二个参数开始依次传</li><li>将函数内的this绑定为obj</li><li>undefined/null this指向window</li></ul></li><li>bind()<ul><li>将函数返回</li><li>从第二个参数开始依次传,指定返回函数的参数</li><li>将函数内的this绑定为obj</li><li>undefined/null this指向window</li></ul></li><li>apply()<ul><li>立即调用函数</li><li>第二个参数是数组，传入的数据放入数组中</li><li>将函数内的this绑定为obj</li><li>undefined/null this指向window</li></ul></li></ul><p><strong>应用</strong><br>call()/bind():根据伪数组生成真数据<br>bind():vue中的事件回调函数内部</p><p><strong>自定义</strong></p><pre><code class="js">Function.prototype.call = function (obj,...args) {    //参数被封装成数组    //处理obj是undefined与null的情况    if (obj === undefined || obj === null) {        obj = window    }    //给obj添加一个方法tempFn,this指的是fn函数对象     obj.tempFn = this    //fn里的this指向obj    const result = obj.tempFn(...args)    //调用后，删除obj上的该方法    delete obj.tempFn    return result}Function.prototype.apply = function (obj,args) {      //处理obj是undefined与null的情况    if (obj === undefined || obj === null) {    obj = window    }    //给obj添加一个方法tempFn,this指的是fn函数对象     obj.tempFn = this    //fn里的this指向obj    const result = obj.tempFn(...args)    //调用后，删除obj上的该方法    delete obj.tempFn    return result }Function.prototype.bind = function (obj,...args) {    //返回新函数    return (...args2) =&gt; {    //调用原来函数，指定this为obj，参数列表由args和atgs2依次组成      return this.call(obj,...args,...args2)    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;函数对象的call方法与apply方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数对象：函数像对象一样去使用,&lt;code&gt;函数.xx&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;共同点：&lt;br&gt;1.这两个方法都是函数对象的方法，需要通过函数对象来调用&lt;br&gt;2.当对函数调用 c
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>函数节流和防抖</title>
    <link href="http://yoursite.com/2020/08/22/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96/"/>
    <id>http://yoursite.com/2020/08/22/函数节流和防抖/</id>
    <published>2020-08-22T08:47:15.000Z</published>
    <updated>2020-08-24T07:53:15.803Z</updated>
    
    <content type="html"><![CDATA[<p><strong>事件频繁触发可能造成的问题？</strong></p><p>1.一些浏览器事件:window.onresize、window.mousemove等，触发的频率非常高，会造成浏览器性能问题<br>2.如果向后台发送请求，频繁触发(搜索)，对服务器造成不必要的压力</p><p><strong>如何限制事件处理函数频繁调用?</strong><br>1.函数节流<br>2.函数防抖</p><p><img src="/img/vue/防抖与节流.png"></p><p><strong>函数节流(throttle)</strong></p><p>理解:<br>    在函数需要频繁触发时，函数执行依次后，只有大于设定的执行周期后才会执行第二次，适合多次事件按时间做平均分配触发<br>场景：<br>    窗口调整resize<br>    页面滚动scroll<br>    DOM元素的拖拽功能实现mousemove<br>    抢购疯狂点击click</p><p><strong>函数防抖(debounce)</strong><br>理解：<br>    在函数需要频繁触发时，在规定时间内，只让最后一次生效，前面的当作抖动不生效<br>场景:<br>    输入框实时搜索联想keyup、input</p><p><strong>自定义</strong></p><pre><code class="js">//用来返回节流函数的工具函数   function throttle(callback,delay){let pre = 0return function(event){     //Dom事件回调的函数里this是发生事件的标签     //节流函数/真正的事件回调函数    const current = Date.now() //当前时间     //事件触发后，节流函数也会被返回，只是满足一定的条件再调用    if (current - pre &gt; delay) { //只有离上一次调用callback的时间差大于delay     //callback()是window调用的，所以callback函数里的this是window    callback.call(this,event)      //记录此次调用的时间    pre = current    }}}//用来返回防抖函数的工具函数 function debounce(callback,delay){      //事件发生指定时间后才调用处理事件的回调函数    return function (event) {        //如果上次事件还没有真正处理，又重复触发就取消它        if(callback.hasOwnProperty(&quot;timeoutId&quot;)){        clearTimeout(callback.timeoutId)        }        callback.timeoutId = setTimeout(() =&gt; {            callback.call(this,event)              //标记事件已经正在处理            delete callback.timeoutId        }, delay);     }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;事件频繁触发可能造成的问题？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.一些浏览器事件:window.onresize、window.mousemove等，触发的频率非常高，会造成浏览器性能问题&lt;br&gt;2.如果向后台发送请求，频繁触发(搜索)，对服务器造成不必要的
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>python-class</title>
    <link href="http://yoursite.com/2020/08/20/python-%E7%B1%BB/"/>
    <id>http://yoursite.com/2020/08/20/python-类/</id>
    <published>2020-08-20T10:36:51.000Z</published>
    <updated>2020-08-29T08:31:27.885Z</updated>
    
    <content type="html"><![CDATA[<p>类是type类型的对象，定义类实际上就是定义了一个type类型的对象。<br>类和对象都是对现实生活中的事物或程序中内容的抽象</p><p><strong>方法的每次被调用时，默认传递一个参数(调用方法的实例对象本身，类似this)，所以方法中至少要定义一个形参</strong></p><p><strong>使用类创建实例对象的流程</strong><br>1.创建一个变量mc<br>2.在内存中创建一个新对象(type=Person)<br>3.调用init方法<br>4.将新对象的id赋值给变量ranan</p><p><strong>类的定义</strong></p><p>1.属性和方法的查找流程：先找自身对象 -&gt; 再找类对象<br>2.类中定义的属性和方法都是公共的，任何该类实例都可以访问。但是方法中不能直接访问类中的属性</p><p>所以一般情况下，属性保存到实例对象中，方法保存到类对象中。</p><p><strong>类的<strong>init</strong>方法</strong><br>类中有一些特殊方法,以<code>__</code>开头，<code>__</code>结尾。<br>特殊方法不需要自己调用。</p><p>类的init方法类似与构造器,调用类创建对象时，类后边的所有参数都会依次传递到init()中</p><p><strong>实例方法</strong><br>实例方法:以self为第一个参数的方法<br>实例调用时，会自动将当前调用对象作为self传入<br>当通过类调用时，不会自动传递self，必须手动传入   </p><p><strong>类方法</strong><br>在类内部使用@classmethod 来修饰的方法属于类方法<br>类方法的第一个参数是cls(class),也会被自动传入，cls就是当前的类对象<br>类方法可以通过类去调用，也可以通过实例调用，没有区别</p><p><strong>静态方法</strong><br>在类中使用 @staticmethod来修饰的方法属于静态方法，静态方法不需要任何默认参数。<br>静态方法可以通过类和实例去调用，静态方法基本是一个和当前类无关的方法，只是一个保存到当前类中的函数，一般都是一些工具方法。</p><pre><code># class 类名([父类]):# 没父类括号也可以省略#    代码块class Person:    def __init__(self,name):        self.name = name    def hello(self):        print(&quot;你好!&quot;)    @classmethod    def test(cls):        print(&quot;这是类方法&quot;)# mc为类Myclass的实例  # 调用Person等于调用init  ranan = Person(&#39;biubiu&#39;)# 默认传递一个参数ranan.hello()</code></pre><p>类属性:属于类<br>实例属性:只能通过实例对象来访问和修改，属于实例<br>类方法:第一个参数cls<br>实例方法:第一个参数self<br>静态方法:不默认传参</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>为了增加数据的安全性，引入了封装的概念，封装是面向对象的三大特性之一。</p><p>封装指的是隐藏对象中一些不希望被外部访问到的属性或方法。</p><p>封装的优点:<br>1.隐藏了属性名，使调用者无法随意的修改对象中的属性<br>2.增加了getter和setter方法，很好的控制了属性是否只读<br>3.使用setter方法设置属性，可以增加数据的验证，确保数据的值是正确的<br>4.使用getter方法获取属性，使用setter方法设置属性，可以在读取属性和修改属性的同时做一些其他的处理</p><p>如何隐藏一个对象的属性名?</p><pre><code>- 将对象的属性名，修改为一个外部不知道的名字</code></pre><p>如何获取/修改对象中的属性？</p><pre><code>- 提供getter和setter方法使外部可以访问到属性- getter获取对象中的指定属性(get_属性名)</code></pre><pre><code>class Dog:    &#39;&#39;&#39;    表示狗的类    &#39;&#39;&#39;    def __init__(self,name):        self.hidden_name = name    def get_name(self):        return self.hidden_name        def set_name(self,name):        self.hidden_name = name</code></pre><p><strong>隐藏属性</strong></p><p>上述的方法其实通过hidden_name还是可以访问到，如果想彻底隐藏，可以为对象的属性使用双下划线开头<code>__xxx</code>，是对象的隐藏属性(私有属性)，隐藏属性只能在类内访问，类外不能访问。</p><p>其实隐藏属性只不过是Python自动为属性改了名字，实际上是将名字修改成<code>_类名_属性名</code>。所以一般不用这种方式。</p><p>一般我们会将一些私有属性以<code>—</code>开头结合封装假装是私有属性。</p><p><strong>property装饰器</strong></p><p>property装饰器用来将一个get方法，转换为对象的属性，让我们像调用属性一样使用get方法<br>使用property装饰的方法名必须和属性名一样,setter方法的装饰器:<code>@属性名.setter</code>(属性名不算上下划线，因为下划线仅仅表示这是一个私有属性)</p><pre><code>class Dog:    &#39;&#39;&#39;    表示狗的类    &#39;&#39;&#39;    def __init__(self,name):        self._name = name    # def get_name(self):    #   return self.hidden_name        @property    def name(self):        return _self.ame    @name.setter    def name(self,name):       self._name = name    print(p.name)    p.name = &#39;xxx&#39;    </code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承是面向对象的三大特性之一，子类可以直接继承父类中的所有的属性和方法。<br>继承之后子类的实例也是父类的实例。<br>class 类名(父类):    –如果创建类时,省略了父类，则默认父类为object</p><p><strong>super()</strong><br>如果子类有自己init，希望可以直接调用父类的init来初始化父类中定义的属性<br>super()可以用来获取当前类的父类，super()返回对象调用父类方法时，不需要传递self</p><pre><code>class Animal:    def __init__(self,name):        passclass Dog(Animal):    def __init__(self,name,age):        super().__init__(name)        self._age = age      </code></pre><p><strong>多重继承</strong></p><p>在开发中没有特殊情况，应该避免使用多重继承，因为多重继承会让代码过于复杂</p><p><code>__bases__</code>这个属性可以用来获取当前类的所有父类,返回一个元组。</p><p><strong>在python中，一个类可以同时有多个父类</strong>,如果多个父类中有同名方法，则会先在第一个父类中寻找、然后找第二个……</p><pre><code>class Dog(Animal1,Animal2):    pass</code></pre><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是面向对象的三大特征之一，多态从字面上理解是多种形态，比如狗(狼狗，藏獒….都是狗的形态),一个对象可以使用不同的形态去呈现。</p><pre><code># 对于say_hello()这个函数来说，只要对象中含有name属性，就可以作为参数传递# 这个函数并不会考虑对象的类型，只要有name属性即可def say_hello(obj)    print(&quot;你好%s&quot;%obj.name)# say_hello2违反了多态，因为要求对象是A的实例# 违反了多态的函数，只适用一种类型的对象，函数的适应性def say_hello2(obj2)    if isinstance(obj,A):        print(&quot;你好%s&quot;%obj.name)   </code></pre><p>鸭子类型：如果一个东西，走路像鸭子，叫声像鸭子，那么它就是鸭子？？</p><h2 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h2><p>特殊方法一般不需要手动调用，在一些特殊情况下自动调用</p><p><code>__new__</code>在创建对象时调用<br><code>__ninit__(self,[....])</code>初始化对象时调用<br><code>__del__(self)</code>对象删除前调用</p><p>当我们打印一个对象时，实际上打印的是对象中的特殊方法<code>__str__(self)</code>的返回值，这个方法将对象转换成字符串的时候调用<br><code>__repr__(self)</code>在当前对象使用repr()函数时调用，它的作用是指定对象在交互模式中输出的效果</p><pre><code>class Person:    # __gt__会在对象做大于比较的时候调用，该方法的返回值将会作为比较的结果  self&gt;ohter,self是比较左边的，other是比较右边的    def __gt__(self,other):        return self.age &gt; other.agep1 = Person()# print(p1) 实际上等于 print(str(p1)),调用了对象内部的__str__(self) 特殊方法print(p1)print(repr(p1))</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;类是type类型的对象，定义类实际上就是定义了一个type类型的对象。&lt;br&gt;类和对象都是对现实生活中的事物或程序中内容的抽象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法的每次被调用时，默认传递一个参数(调用方法的实例对象本身，类似this)，所以方法中至少要定义一个形参&lt;/str
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>debug调试</title>
    <link href="http://yoursite.com/2020/08/20/debug%E8%B0%83%E8%AF%95/"/>
    <id>http://yoursite.com/2020/08/20/debug调试/</id>
    <published>2020-08-20T06:38:39.000Z</published>
    <updated>2020-08-20T07:29:05.557Z</updated>
    
    <content type="html"><![CDATA[<p><strong>调试的目的</strong><br>1.查找bug:不断缩小可疑代码的范围<br>2.查看程序的运行流程，用于熟悉接手项目的代码</p><p><strong>如何开启调试模式</strong><br>1.运行前添加debugger语句,常用于打包后才运行的项目<br>2.浏览器打断点，程序运行前或者过程中，常用于运行源码js</p><p><strong>调试操作</strong></p><p>resume:恢复程序的执行，可能程序执行完或者进入下一个断点处<br>step over:单步跳转，尝试执行完当前语句(如果内部有断点，自动跳入内部断点处)，进入下一条语句<br>step into:跳入，进入当前调试函数内部，停在函数第一条语句前<br>step out:跳出，一次性执行完当前函数后面所有语句并出去<br>deactivate breakpoints: 使所有断点暂时失效</p><p>call stack: 调用栈，显示程序函数调用的过程<br>scope:作用域链，当前执行环境对应的作用域中包含的变量数据</p><p>注意点:<br>1.如果想看回调函数内部的一步步实现，给异步函数内部打断点，因为回调函数放入队列中执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;调试的目的&lt;/strong&gt;&lt;br&gt;1.查找bug:不断缩小可疑代码的范围&lt;br&gt;2.查看程序的运行流程，用于熟悉接手项目的代码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何开启调试模式&lt;/strong&gt;&lt;br&gt;1.运行前添加debugger语句,常用于打包后才运行的
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>vue2.0源码分析</title>
    <link href="http://yoursite.com/2020/08/19/vue2.0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/08/19/vue2.0源码分析/</id>
    <published>2020-08-19T06:39:24.000Z</published>
    <updated>2020-08-22T08:58:06.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h2><p><strong>实现更新显示</strong></p><p>data对象的所有属性的操作由vm对象来代理操作<br>好处:通过vm对象就可以方便的操作data中的数据<br>实现：<br>1.通过<code>Object.defineProperty(vm,key,{})</code>给vm添加data对象的key<br>2.所有添加的属性都设置get/set方法<br>3.读/改vm对象时,通过get/set返回/修改data中对应的属性值</p><pre><code>const vm = new Vue({    data:{        name:&#39;tom&#39;    }})console.log(vm.name,vm._data.name) //tom 代理读vm.name = &#39;jack&#39;  //代理写console.log(vm._data.name) //jack</code></pre><h2 id="模板解析"><a href="#模板解析" class="headerlink" title="模板解析"></a>模板解析</h2><p><strong>实现初始化显示</strong></p><p>基本流程:<br>使用DocumentFragment，一次页面更新批量处理DOM</p><p>1.将el元素中的所有子节点保存到一个fragment容器<br>2.编译fragment中所有层次子节点</p><pre><code>- 对表达式文本节点进行解析- 对元素节点的指令属性进行解析</code></pre><p>3.将编译好的fragment插入到el中</p><p><strong>插值语法</strong></p><p>1.根据正则对象得到匹配出的表达式字符串:子匹配/RegExp.$1<br>2.从data中取出表达式对应的属性值<br>3.将属性值设置为文本节点的textNode.textContent</p><pre><code>&lt;p&gt;{{name}}&lt;/p&gt;</code></pre><p><strong>事件指令</strong><br>指令（Directives）带有前缀 <code>v-</code></p><p>elementNode.addEventListener(“eventName”,callback.bind(vm))</p><p>1.从指令中取出事件名<br>2.根据指令的值从methods中得到对应的事件处理函数对象<br>3.给当前节点绑定指定事件名和回调函数的DOM事件监听<br>4.解析完之后在节点中移除指令属性</p><pre><code>// button.addEventListener(&quot;click&quot;,this.test.bind(vm))//test里面的this指向vm&lt;button v-on:click=&quot;test&quot;&gt;&lt;/button&gt;</code></pre><p><strong>一般指令</strong><br>1.得到指令名和指令值<br>2.从data中根据表达式得到对应的值<br>3.根据指令名确定需要操作元素节点的属性<br>    v-text -&gt; elementNode.textContent = value<br>    v-html -&gt; elementNode.innerHTML = value<br>    v-class -&gt; elementNode.className += value<br>4.将得到的表达式的值设置到对应的属性上<br>5.移除元素的指令属性</p><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><p><strong>数据绑定</strong></p><p>数据绑定:一旦更新了data中的某个属性数据，所有界面上直接使用或间接使用了此属性的节点都会更新</p><p><strong>数据劫持</strong></p><blockquote><p>数据绑定是实现的效果，数据劫持是实现数据绑定的一种技术</p></blockquote><p>数据劫持是vue中用来实现数据绑定的一种技术。<br>基本思想:通过defineProperty()来监视data中所有的属性(任意层次)数据的变化，一旦变化就去更新界面。</p><p><strong>发布者-订阅者模式</strong></p><p>发布者:observer对象，对data中所有层次属性进行监视，包含监视data数据的setter方法。发生变化更新data中的数据，并通知dep。</p><p>订阅器(中间者):dep对象，个数与data中的属性一一对应，每个属性的setter都引用了对应的dep对象用于通知dep数据发生了改变，并且每个dep对象与watcher建立了n:n关系。dep接收到发布者通知后通知对应的watcher订阅者。</p><p>订阅者:watcher对象，包含更新对应节点的回调函数。个数与模板表达式(插值/一般指令)一一对应。更新对应的节点。</p><p>watcher -&gt; dep 用于判断当前watcher与dep关系是否已经建立<br>dep -&gt; watcher 用于通知watcher对象更新对应的节点。</p><p>黑色初始化，红色数据发生变化<br><img src="/img/vue/mvvm.png"></p><h2 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h2><p>双向数据绑定是建立在单向数据绑定(model-&gt;view)的基础上</p><p>实现流程:<br>1.解析v-model指令时，给当前元素添加input监听<br>2.当input的value发生改变时，将最新值保存到表达式在data中对应的属性上-&gt;触发数据绑定</p><p><strong>什么是单向数据绑定？什么是双向数据绑定?</strong></p><p>双向数据绑定:model改变view自动更新，view改变model自动更新。<br>单向数据绑定:model -&gt; view</p><p>单向绑定：插值形式，v-bind也是单向绑定<br>双向绑定：表单的v-model，用户对View层的更改会直接同步到Model层</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据代理&quot;&gt;&lt;a href=&quot;#数据代理&quot; class=&quot;headerlink&quot; title=&quot;数据代理&quot;&gt;&lt;/a&gt;数据代理&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;实现更新显示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;data对象的所有属性的操作由vm对象来代理操作&lt;br&gt;好处:
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>mutations常量中括号</title>
    <link href="http://yoursite.com/2020/08/19/mutations%E5%B8%B8%E9%87%8F%E4%B8%AD%E6%8B%AC%E5%8F%B7/"/>
    <id>http://yoursite.com/2020/08/19/mutations常量中括号/</id>
    <published>2020-08-19T06:39:02.000Z</published>
    <updated>2020-08-19T06:57:31.830Z</updated>
    
    <content type="html"><![CDATA[<p>学习vuex一直有一个疑问，为什么mutations里面方法名要加上大括号?</p><p>通过看文档以及查资料发现了原因</p><p><strong>为什么使用常量代替?</strong><br>使用常量代替mutation事件类型可以让工具发挥作用，且把常量放在单独的文件中可以让让你的代码合作者对整个app包含的mutation一目了然</p><p><strong>为什么使用中括号</strong><br>原来这里使用的是ES6的写法，一下子没转过弯</p><p>首先mutations.js对象,在ES6中的对象的扩展中讲到了方法的简写。如下列代码所示，由于对象的属性名就算没有添加引号也会自动的加上引号变成字符串，some_mutation会被解析成’some_mutation’,但如果我们使用的是变量SOME_MUTATION，那么需要对属性名添加中括号。</p><pre><code>//-------------ES5的写法const SOME_MUTATION = &#39;some_mutation&#39;let mutations = {}mutations[SOME_MUTATION] = function (state) {// mutate state}//方法,对象的属性名会自动被解析成字符串const mutations = {    //方法名，会自动被解析成字符串&#39;some_mutation&#39;    some_mutation:function(){    }    //如果方法名是变量    [SOME_MUTATION]some_mutation:function(){    }}//方法的简写const mutations = {    [SOME_MUTATION](){    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习vuex一直有一个疑问，为什么mutations里面方法名要加上大括号?&lt;/p&gt;
&lt;p&gt;通过看文档以及查资料发现了原因&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么使用常量代替?&lt;/strong&gt;&lt;br&gt;使用常量代替mutation事件类型可以让工具发挥作用，且把常量放在单独的
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vuex学习笔记</title>
    <link href="http://yoursite.com/2020/08/18/vuex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/08/18/vuex学习笔记/</id>
    <published>2020-08-18T15:00:13.000Z</published>
    <updated>2020-08-19T06:45:59.397Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/img/vue/流程.png">流程图</a></p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><pre><code class="js">//store/index.js/*vuex最核心的管理对象模块*/import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;Vue.use(Vuex)//这部分可以单独写成一个文件，然后通过import引入const state = {}const mutations = {    FN(state){      //state状态更新      }}const actions = {    fn({commit,state}){        commit(&quot;FN&quot;)    }}//依赖state里面的属性，计算生成的属性写在getters里面const getters = {    xxx(state){        //计算    }}//建立统一数据容器，唯一的容器let store = new Vuex.Store({    state,    mutations,    actions,    getters})</code></pre><ul><li>stat:状态对象 </li><li>mutations:<ul><li>操作state,直接更新state的多个方法对象</li><li>只操作state,若组件中只需要修改state无异步无逻辑操作，可以直接操作mutations</li></ul></li><li>actions<ul><li>commit–&gt; 操作mutations 间接更新state的多个方法对象</li><li>异步操作、逻辑代码处理、发送请求 </li></ul></li><li>getters:包含多个基于state的getter计算属性的对象 </li><li>mutations-type:包含n个mutations的type名称常量 </li></ul><p>store 对象中的属性<br>1.state 包含所有state数据的对象<br>2.getters 包含所有getter计算属性的对象<br>3.dispatch(actionName,data) 触发action调用<br>4.commit(mutationName,data) 触发mutation调用</p><p>store(容器)注册到实例上，main.js里面，所有的组件都会有一个属性$store</p><pre><code class="js">import store from &#39;&#39;new Vue({store,})//----------组件对象中//在组件中使用{{$store.state.XXX}}//在js中使用this.$store.xxx</code></pre><h3 id="使用map函数简化store使用"><a href="#使用map函数简化store使用" class="headerlink" title="使用map函数简化store使用"></a>使用map函数简化store使用</h3><p>map函数，参数是数组，返回值为对象。<br>使用的前提是计算属性/方法名等要和store里面的名字一致。</p><pre><code>import {mapState,mapGetters,mapMutations,mapActions} from &quot;vuex&quot;//常用mapState，mapGetterscomputer:{    count(){        return this.$store.state.count    }    //使用map函数    ...mapState([&#39;count&#39;]) //返回值{count(){return this.$store.state[&#39;count&#39;]}},...解构出来    ...mapGetters([&#39;evenOrOdd&#39;])//返回值{evenOrOdd(){return this.$store.getters[&#39;evenOrOdd&#39;]}},...解构出来}methods:{    increment(){        this.$store.commit(&#39;INCREMENT&#39;)    }    //使用map函数写法    ...mapMutations({increment:&#39;INCREMENT&#39;})}</code></pre><h3 id="拆分文件"><a href="#拆分文件" class="headerlink" title="拆分文件"></a>拆分文件</h3><p>store/index.js  vuex最核心的管理对象store</p><pre><code>import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;import state .....  //引入state,getters等文件export default new Vuex.Store({  state,  mutations,  actions,  getters})//此文件在项目根目录index.js里面进入store,并在Vue中注册store，让所以组件都能通过$store看到store对象</code></pre><p>store/state.js</p><p>store/mutations-types 包含n个mutation函数名的常量模块</p><pre><code>export const REQ_SUCCESS = &#39;req_success&#39;</code></pre><p>store/mutations.js  一个包含n个用于直接更新状态数据的方法的对象模块</p><pre><code>import {REQ_SUCCESS} from &#39;./mutation-types&#39;export default{    //直接使用REQ_SUCCESS被解析成&#39;REQ_SUCCESS&#39;    [REQ_SUCCESS](state,y){           state.xxx = true           state.yyy = y  //y是从action里接收的数据    }}</code></pre><p>store/actions.js 一个包含n个用于间接更新状态数据的方法的对象模块，可以包含异步和逻辑处理代码</p><pre><code>import {REQ_SUCCESS} from &#39;./mutation-types&#39;export default{    //搜索的异步action，包含了异步代码的action    async search({commit},params){        //params用于异步ajax请求获取数据的参数        //如果成功了，提交请求成功的mutation        //这种写法传递的数据y本身        commit(REQ_SUCCESS,y)        //还可以通过对象的形式来传递        commit(REQ_SUCCESS,{y})        //这种写法mutations里应该改成 [REQ_SUCCESS](state,{y})    }}</code></pre><p>store/getters.js 一个包含n个基于state的getter计算属性方法的对象模块，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;/img/vue/流程.png&quot;&gt;流程图&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;基本使用&quot;&gt;&lt;a href=&quot;#基本使用&quot; class=&quot;headerlink&quot; title=&quot;基本使用&quot;&gt;&lt;/a&gt;基本使用&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;//
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>JS常用操作总结</title>
    <link href="http://yoursite.com/2020/08/13/js%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/08/13/js常用操作总结/</id>
    <published>2020-08-13T09:03:39.000Z</published>
    <updated>2020-08-31T07:08:52.496Z</updated>
    
    <content type="html"><![CDATA[<h2 id="判断对象是否是数组-对象的元素-属性"><a href="#判断对象是否是数组-对象的元素-属性" class="headerlink" title="判断对象是否是数组/对象的元素/属性"></a>判断对象是否是数组/对象的元素/属性</h2><p><strong>(常用于对象) in</strong></p><p>格式： 变量 in 对象/数组<br>当是数组时，变量指的是索引(不常用)<br>当是对象时，变量指的是对象的属性名</p><p><strong>(对象)Object.prototype.hasOwnProperty(value)</strong></p><p>格式:object.hasOwnProperty(value)<br>该方法只能判断对象自身属性是否存在，对于继承属性会返回false</p><p><strong>(常用于数组和字符串) Array.prototype.includes(value)</strong></p><p>格式:array/string.includes(value)</p><p>返回值为布尔值。<br>以前判断用indexOf返回的是数字。</p><p><strong>(常用于数组和字符串) Array.prototype.indexOf(value)/lastIndexOf(value)</strong></p><p>返回value在数组中出现的第一个下标和最后一下下标，没有出现则返回-1<br>应用场景：<br>两个方法结合判断下标是否相等，可以用来判断数组中唯一出现的值</p><h2 id="如何判断数据类型"><a href="#如何判断数据类型" class="headerlink" title="如何判断数据类型"></a>如何判断数据类型</h2><p><code>typeof</code>返回的数据类型:<strong>String,Number,Boolean,Undefined,Object(Array,null也是),Function</strong>，不能准确的确定数据的类型。</p><p><strong>Object.prototype.toString.call()</strong></p><p><code>Object.prototype.toString.call(target)</code>可以区分各种类型，但它无法区分自定义对象类型，自定义类型可以采用instanceof区分。</p><p>那么为什么<code>Object.prototype.toString.call(target)</code>可以区分？</p><p>toString方法返回反映这个对象的字符串（除了null和undefined之外）</p><pre><code>console.log({name:&quot;张三&quot;}.toString());//[object Object]console.log([1,2].toString());//1,2console.log(typeof [1,2].toString())//String</code></pre><p>obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？</p><p>因为toString为Object的原型方法，而Array,function等类型作为Object的实例重写了toString方法，调用toString方法时，优先调用的是重写之后的toString方法，所以要使用Object原型上的toString才可以反映对象的具体类型。</p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p><strong>对象的遍历性能</strong></p><p>for..in/keys+forEach 耗时差不多</p><p><strong>for..in</strong></p><p>循环的是key</p><pre><code>for (const key in object) {    if (object.hasOwnProperty(key)) {        const element = object[key];     }}</code></pre><p><strong>Object.keys(obj) + forEach</strong></p><pre><code>Object.keys(obj).forEach(key =&gt;{   const element = object[key];  })</code></pre><p><strong>数组遍历性能</strong><br>for..in / for /forEach/while<br>耗时：for..in  &gt;&gt;&gt; for | forEach |while</p><h2 id="将伪数组转化成真数组"><a href="#将伪数组转化成真数组" class="headerlink" title="将伪数组转化成真数组"></a>将伪数组转化成真数组</h2><p>使用场景:所有dom元素获取的标签都是<strong>伪数组</strong>,当需要对伪数组进行遍历的时候就需要转化成真数组。</p><p>伪数组:最基本的要求就是具有<strong>length属性的对象</strong>,length属性的值为数字下标的个数,对象的属性名必须为数值型或字符串型的数字。</p><pre><code>obj={    &quot;0&quot;:&quot;zhang&quot;,    &quot;1&quot;:18,    length:2</code></pre><p><strong>Array.from(lis)</strong></p><p>此方法是ES6的语法</p><p>返回一个真数组，第一个参数为伪数组,还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p><p><strong>扩展运算符</strong></p><p>ES6的语法</p><pre><code>let newArr= [...obj]</code></pre><p><strong>[].slice.call(lis)</strong></p><p>此方法是ES5的语法</p><p>[].slice.call(obj) = Array.protype.slice.call(obj)</p><p>[].slice()  slice会通过索引位置获取新的数组，该方法不会修改原数组，只是返回一个新的子数组。没传参数相当于返回一个浅拷贝。该方法内部是通过for循环和length结合实现的，可以改变为伪数组调用<br>call会把this的指向改为传进去的obj，call()会立即调用slice函数<br>此方法会让obj/伪数组拥有slice()方法且立即调用该方法</p><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><p>方法一:利用forEach和indexOf，会有隐式遍历。<br>方法二:利用forEach和对象容器,只需要一重遍历，效率更高。<br>方法三，ES6语法，Set容器的元素唯一与三点运算符。</p><pre><code>/*方法一，利用forEach和indexOf*/export function unique1(array) {    let arr = []    array.forEach(item =&gt; {        if (arr.indexOf(item) === -1) {            //indexOf隐式遍历            arr.push(item)        }    });    return arr}/*方法二，利用forEach和对象容器只需要一重遍历，效率更高*/export function unique2(array) {    let arr = []    let contain = {} //属性名是item，属性值是true，主要判断的属性名    array.forEach(item =&gt; {        if (!contain.hasOwnProperty(item)) {            arr.push(item)            contain[item] = true //arr与contain容器数据保持一致        }    });    return arr}/*方法三，ES6语法，Set容器的元素唯一与三点运算符*/export function unique3(array) {    return [...new Set(array)]}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;判断对象是否是数组-对象的元素-属性&quot;&gt;&lt;a href=&quot;#判断对象是否是数组-对象的元素-属性&quot; class=&quot;headerlink&quot; title=&quot;判断对象是否是数组/对象的元素/属性&quot;&gt;&lt;/a&gt;判断对象是否是数组/对象的元素/属性&lt;/h2&gt;&lt;p&gt;&lt;stron
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>vue-router学习笔记</title>
    <link href="http://yoursite.com/2020/08/12/vue-router%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/08/12/vue-router学习笔记/</id>
    <published>2020-08-12T05:59:22.000Z</published>
    <updated>2020-08-18T15:02:15.113Z</updated>
    
    <content type="html"><![CDATA[<p>Vue Router 是 Vue.js官方的路由管理器</p><pre><code>import Vue from &#39;vue&#39;impor VueRouter from &#39;vue-router&#39;//使用Vue插件Vue.use(VueRouter)//创建路由器的构建函数new VueRouter({    //应用中所有路由    routes:[    ]}),//路由配置routes:[    {        path:&quot;&quot;,        component:    },]//注册路由器import....  //引入路由new Vue({    router //所有组件都能通过$router属性看到router对象,所有组件都有一个代表当前路由的$route数据})//使用//用来生成路由链接&lt;router-link to=&quot;&quot;&gt;&lt;/router-link&gt;//用来显示当前路由组件界面&lt;router-view&gt;&lt;/router-view&gt;</code></pre><h2 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h2><p>通过$route可以获取到当前的路由数据。</p><pre><code>routes:[    {    path:&quot;/home&quot;,    component:    redirect: //重定向路由    children:[//注册子路由        path:&quot;/home/news&quot;        component:        children:[            {   //动态路由                path:&quot;/home/news/detail/:id&quot;            },            {                   //进入/home后自动显示当前的子路由                path:&quot;&quot;,                redirect:&quot;/home/news&quot;            }        ]    ]      }</code></pre><p><strong>path加/和不加/有什么区别</strong></p><p>/xx就是根路径。下面代码去到children是/#/child而不是/#/fa/child。而不以斜杠开头的，都会被当成普通的字符串拼到当前路径的后面。</p><pre><code>path: &quot;/fa&quot;children: {    path: &quot;/child&quot;}</code></pre><p><strong>路径参数</strong><br>1.query参数，跟在路径?后面<br>2.params参数</p><p><strong>动态路由及监视</strong></p><p>路由组件对象是在第一次请求对应路径时才创建，从一个路由组件离开、路由组件死亡，再进入需要重新创建。<br>当在同一个路由路径上做切换(只是改了参数),当前路由组件对象被直接复用,也就是说<strong>组件的生命周期钩子不会再被调用</strong>。</p><p>解决办法:<br>1.监视<code>$route</code></p><pre><code>watch:{    &#39;$route&#39;(to,from){        //当请求参数发生改变时，内部指定了新的$route属性，所以一般监视就可以了    }}</code></pre><p>2.路由导航</p><p><strong>编程式路由导航</strong></p><p>声明式:router-link<br>编程式:$router.push()/replace()</p><p>push往栈中放元素，repalce是替换栈顶元素。</p><p><strong>命名路由</strong></p><pre><code> path:&quot;/home&quot;, component: redirect: //重定向路由 name:&quot;home&quot;</code></pre><p>通过name关键字对该路由进行命名，在<code>router-link</code>中的路径可以直接使用命名路由<code>:to:&quot;{name:home,params:{id}}&quot;</code>来使用,第一个表示跳转之后的路由，第二个表示传递该路由的参数，这种写法也可以使用在编程式路由导航之中。</p><p><strong>props</strong></p><p>可以将路由参数映射成props<br>在路径配置中设置props之后，会自动把接收的parmas参数以标签属性传入路由组件</p><pre><code>// 之前通过$route来获取参数ID：{{$route.params.id}}//将路由参数映射成propsprops:[&quot;id&quot;]routes:[    // 在路径中设置props之后，会自动把接收的parmas参数以标签属性传入路由组件    //布尔写法    {path:&#39;/user/:id&#39;,props:true}    //函数写法,可以获取query参数    {     path:&#39;/user/:id&#39;,     //函数返回的对象中的所有属性都会以标签属性传入组件中     props:(route) =&gt; ({         id:route.params.id,         name:route.query.name     })    }]</code></pre><p><strong>router-link</strong></p><p>router-link-active 表示当前被选中的link的类名</p><p><strong>router-link与a标签的区别</strong><br><code>a</code>点击之后，会发送普通的HTTP请求,刷新页面。<br>路由链接点击后不会发送请求，不会刷新页面会局部更新组件。</p><h3 id="HTML5-history模式"><a href="#HTML5-history模式" class="headerlink" title="HTML5 history模式"></a>HTML5 history模式</h3><pre><code>const router = new VueRouter({    mode:&quot;history&quot;,    //应用中所有路由    routes:[...]})</code></pre><p><strong>history模式与history模式</strong></p><p>hash模式<br>    路径:<a href="http://localhost:8000/#/home" target="_blank" rel="noopener">http://localhost:8000/#/home</a><br>    发送请求的路径:<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a><br>    响应:返回index页面 -&gt; path(/home)被解析为前台路由路径</p><p>hash模式无论在什么路径下请求的都是根路径，#之后的路径发请求的时候<strong>不会携带</strong>。</p><p>history模式<br>    路径:<a href="http://localhost:8000/home" target="_blank" rel="noopener">http://localhost:8000/home</a><br>    发送请求的路径:<a href="http://localhost:8000/home" target="_blank" rel="noopener">http://localhost:8000/home</a><br>    响应: 404错误<br>    希望: 如果没有对应的资源，返回index页面 -&gt; path(/home)被解析为前台路由路径<br>    解决办法:添加配置<br>            devServer:true,<br>            output:publicPath:”/“</p><pre><code>//webpack.config.jsmodule.exports = {    //开发服务器配置    devServer:{        //更详细的可以看文档        //fallback：planB的意思        histortApiFallback:true    }    //可能还需要配置出口的publicPath:&quot;/&quot;，引入打包文件的路径左侧以/开头}</code></pre><h3 id="缓存路由组件keep-alive"><a href="#缓存路由组件keep-alive" class="headerlink" title="缓存路由组件keep-alive"></a>缓存路由组件keep-alive</h3><p>路由组件对象在访问对应路径的时候创建，默认情况下，切换到其他路由对象会死亡释放，再切换回来是重新创建的组件对象</p><p><code>&lt;keep-alive&gt;</code>能在组件切换的过程中将状态保留在内存中，防止重复渲染DOM。</p><p>设置了keepAlive缓存的组件：</p><ol><li>第一次进入：beforeRouterEnter -&gt;created-&gt;…-&gt;activated-&gt;…-&gt;deactivated</li><li>后续进入时：beforeRouterEnter -&gt;activated-&gt;deactivated</li><li><code>activated</code>和<code>deactivated</code>仅在keepAlive缓存的组件里被激活<br>只有第一次进入该组件时，才会走created钩子，而需要缓存的组件中activated是每次都会走的钩子函数。</li></ol><p>属性<br>1.include: 字符串或正则表达式。只有匹配的组件会被缓存。<br>2.exclude: 字符串或正则表达式。任何匹配的组件都不会被缓存。</p><pre><code>// 需要对组件对象进行name命名&lt;keepAlive exclude=&quot;组件的name名&quot;&gt;&lt;/keepAlive&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vue Router 是 Vue.js官方的路由管理器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import Vue from &amp;#39;vue&amp;#39;
impor VueRouter from &amp;#39;vue-router&amp;#39;
//使用Vue插件
Vue.use(VueR
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vue组件通信</title>
    <link href="http://yoursite.com/2020/08/06/vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2020/08/06/vue组件通信/</id>
    <published>2020-08-06T07:48:58.000Z</published>
    <updated>2020-08-11T15:01:04.089Z</updated>
    
    <content type="html"><![CDATA[<p>一个组件接收属性数据不是用来直接修改，只是用来读取显示的，所以子组件最好不要直接修改父组件的值，通常通过set来设置。</p><h2 id="父子组件传值"><a href="#父子组件传值" class="headerlink" title="父子组件传值"></a>父子组件传值</h2><h3 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h3><p>父组件传值</p><p>通过动态绑定数据传值</p><pre><code>&lt;Person :age =&quot;age&quot; /&gt;</code></pre><p>子组件接收<br>语法:props:[]/{}</p><pre><code>//更详细的查看文档props:{    //简单的检测类型    height:Number,    //检测类型+其他验证    age:{        typr:Number,        default:0,        required:true    }}</code></pre><h4 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h4><p>父组件 -&gt; 子组件  <strong>带数据的标签结构</strong></p><p>插槽相当于占位,本身不显示。<br>传给插槽的是静态页面,相关的数据等解析是在父组件解析好了再传给子组件的,所以需要的数据和方法都定义在父组件。</p><pre><code>//子组件&lt;slot name=&quot;slotName&quot;&gt;如果父组件没传默认显示的内容&lt;/slot&gt;//父组件在子组件的标签体内传值&lt;Son&gt;    &lt;h1 slot=&quot;slotName&quot;&gt;    如果子组件有多个插槽，可以指定传给哪个插槽    &lt;/h1&gt;&lt;/Son&gt;</code></pre><h3 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h3><p>1.如果子组件要更新父组件的数据，调用父组件的更新函数来更新父组件的数据。</p><p>自定义vue事件</p><p>this.$emit(“myEvent”,value) 表示子组件向父组件分发myEvent事件</p><p>父组件监听(以-命名)myEvent事件后，触发doSomething回调函数调用</p><pre><code>//@ 绑定事件监听&lt;my-component @my-event=&quot;doSomething&quot;&gt;&lt;/my-component&gt;</code></pre><p>2.this.$emit(update: prop, “newPropVulue”)  </p><p>使子组件向父组件传达：更新属性，并抛出新的属性值。</p><p>从上述代码中可以看出首先更新的值要是从父组件中接收的，也就是props里面的值。其次父组件该值需要写成</p><pre><code>  &lt;ProjectPagination :filter-data=&quot;filterData&quot; @update:filter-data=&quot;filterData=$event&quot;&gt;&lt;/ProjectPagination&gt;</code></pre><p>更简单的写法是<code>.sync</code>修饰符</p><pre><code> &lt;ProjectPagination  :filter-data=&quot;filterData&quot; :filter-data.sync=&quot;filterData&quot;&gt;&lt;/ProjectPagination&gt;</code></pre><p><strong>注意:</strong><br>这里有一个Vue.sync修饰符与$emit(update:xxx)写法的坑</p><p>使用.sync修饰符</p><pre><code>//有效this.$emit(&quot;update:filterData&quot;, this.data.slice(0, val));//无效this.$emit(&quot;update:filter-Data&quot;, this.data.slice(0, val));</code></pre><p>不使用.sync修饰符</p><pre><code>//无效this.$emit(&quot;update:filterData&quot;, this.data.slice(0, val));//有效this.$emit(&quot;update:filter-Data&quot;, this.data.slice(0, val));</code></pre><h2 id="兄弟组件传值"><a href="#兄弟组件传值" class="headerlink" title="兄弟组件传值"></a>兄弟组件传值</h2><p>所有组件对象的原型对象都是不同的vm,所有的vm都是Vue的实例、都有一个共同的原型对象。</p><p>又根据这个特点，利用原型链实现子孙组件通信与兄弟组件通信</p><p>用来分发事件以及绑定事件监听的全局对象被称为全局事件总线(Global Event Bus)</p><pre><code>//在vue原型上创建一个全局事件总线对象，所有的组件都可以看见这个事件总线Vue.prototype.$globalEventBus = new Vue()//可以优化，不用再创建一个vue实例new Vue({   beforeCreate(){    Vue.prototype.$globalEventBus = this  }})//一个组件分发事件this.$globalEventBus.$emit(&quot;分发事件名&quot;,value)//一个组件进行事件监听this.$globalEventBus.$on(&quot;监听的事件名&quot;,function触发的回调函数)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个组件接收属性数据不是用来直接修改，只是用来读取显示的，所以子组件最好不要直接修改父组件的值，通常通过set来设置。&lt;/p&gt;
&lt;h2 id=&quot;父子组件传值&quot;&gt;&lt;a href=&quot;#父子组件传值&quot; class=&quot;headerlink&quot; title=&quot;父子组件传值&quot;&gt;&lt;/a&gt;父
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>python基础</title>
    <link href="http://yoursite.com/2020/07/31/python-%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/07/31/python-基础/</id>
    <published>2020-07-31T13:06:53.000Z</published>
    <updated>2020-08-30T12:05:19.150Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>Python是解释型语言，用途有Web应用、爬虫程序、科学计算、自动化运维、大数据、云计算、人工智能等。</p><p>补充:解释型语言:不会在执行前对代码进行编译，而是在执行的同时一边执行一边编译。</p><p><strong>Python开发环境搭建</strong><br>开发环境搭建就是安装Python的解释器<br>安装解释器的同时会安装python开发工具IDLE，在IDLE中可以通过TAB键来查看代码的提示。交互模式写一行执行一行，并不适用于我们日常的开发。</p><p><strong>基本语言</strong><br>1.Python中严格区分大小写<br>2.Python中的每一行就是一条语句，每条语句以换行结束<br>3.Pyhton中每一行语句不要太长<br>4.一条语句可以分多行编写，以<code>\</code>结尾<br>5.Python是缩进严格的语言<br>6.注释符<code>#</code>，习惯上注释符后跟一个空格</p><p><strong>字面量和变量</strong><br>字面量表示的意思就是它的字面的值，在程序中可以直接使用，比如:1,2,’hello’<br>变量可以用来保存字面量</p><p>Python中使用变量，不需要声明，直接变量赋值，但不能使用没有赋值的变量。<br>Python是一个动态类型的语言，可以为变量赋任意类型的值。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><strong>数值</strong><br>Python数值分成了整数、浮点数、复数。<br>在python中所有的整数都是int类型，如果数字的长度过大，可以使用下划线作为分隔符，比如123456可以写成123_456</p><p>其他进制的整数<br>二进制0b  八进制0o 十六进制0x</p><p>在python中所有小数都是float类型，对浮点数进行运算时，可能得到一个不精确的结果。</p><p><strong>字符串</strong></p><p>大部分同JS类似。<br>1.用三重引号来表示JS中的模板字符串。<br>2.字符串不能和其他类型进行加法运算<br>3.在创建字符串时，可以在字符串中指定占位符,%s在字符串中表示任意字符<br>4.格式化字符串，可以通过在字符串引号外面添加f来创建一个格式化字符串,在格式化字符串中可以直接嵌入变量,该变量必须已经赋值。</p><pre><code># 表示用孙悟空替换%sb = &#39;Hello %s&#39;%&#39;孙悟空&#39;b = &#39;Hello %s 你好%s&#39;%(&#39;tom&#39;,&#39;孙悟空&#39;)# 还可以限制位数，不够就补空格b = &#39;Hello %2s&#39;%&#39;孙悟空&#39;# 表示限制在3-5之间b = &#39;Hello %3.5s&#39;%&#39;孙悟空&#39;# %f 浮点数占位符,会四舍五入 # %d 整数占位符，不会四舍五入b = &#39;Hello %.5f&#39;%123.123# 打印print(&quot;a=&quot;,a)print(&quot;a=%s&quot;%a)print(f&#39;a={a}&#39;)# 格式化字符串c = f&#39;hello{a}&#39;</code></pre><p><strong>字符串的复制</strong></p><p>字符串和数字相乘，则解释器会将字符串重复指定的次数并返回。</p><pre><code>a=&#39;abc&#39;a= a*2print(a) abcabc</code></pre><p><strong>布尔值和空值</strong></p><p>True表真，False表假，注意开头大写，<strong>布尔值实际上也属于整型</strong>，True相当于1，False相当于0。</p><p>None空值专门表示不存在</p><p><strong>类型检查type</strong></p><p>type()用来检查值的类型，返回值为其类型</p><p><strong>对象object</strong></p><p><strong>一切皆对象</strong>,上面的数据类型都是对象，程序运行当中，所有的数据都是存储到内存中然后再运行，对象是内存中专门用来存储指定数据的一块区域，对象实际上就是一个存储数据的容器。</p><p>每个对象都要保存三种数据</p><ul><li>id 标识 通过id()来查看对象的id，在CPython中,id就是对象的内存地址，id一旦创建就不能改变。</li><li>type 类型 用来表示对象所属的类型，如int str float bool等，通过type()查看类型，Python是一门强类型语言，类型创建后不可以改变。</li><li>value 值  值就是对象中存储的数据，可变对象的值可以改变，不可变对象的值不可以改变。</li></ul><p>在python中，对象并没有直接存储到变量中，变量更像是给对象起的别名，变量中存储的是对象的id(地址)。</p><p><strong>变量中保存的对象id，只有在为变量重新赋值才会改变。</strong></p><p><strong>类型转换</strong>将一个类型的对象转换为其他对象，并不是改变对象本身的类型，而是根据当前对象的值创建一个新对象<br>int()  浮点数直接取整，整数字符串直接转整数，其他类型字符串报错，None也会报错。<br>float() float和int基本一致<br>str()/bool() 表空的都会转化成False</p><h2 id="运算符-操作符"><a href="#运算符-操作符" class="headerlink" title="运算符(操作符)"></a>运算符(操作符)</h2><p><strong>算术运算符</strong></p><p>两个不同类型不能进行加法<br>字符串和数字相乘，会对字符串指定重复次数<br><code>/</code>除法运算结果总会返回一个浮点类型<br><code>//</code>整除，只保留计算后的整数位。对浮点数运算时，结果也是浮点数即使是整除运算。</p><p><strong>关系运算符</strong></p><p>关系运算符用来比较两个<strong>值</strong>之间的关系，总会返回一个布尔值</p><p>可以对两个字符串进行大于/小于的运算，当对字符串进行逐位比较时，比较的是字符串的Unicode编码，比出大小后直接返回后面的字符串将不会进行比较了。</p><p><code>==</code>与<code>!=</code>比较的是对象的值<br><code>is</code>比较两个对象是否是同一个对象，比较的是ID<br><code>is not</code> 比较两个对象是否不是同一个对象，比较的是ID</p><p>逻辑运算符可以连着用,表示关系成立，以中间的数为基准比较</p><pre><code># 相当于 1&lt;2 and 2&lt;3 和中间数进行比较 Python独有1&lt;2&lt;3</code></pre><p><strong>逻辑运算符</strong></p><p>not 逻辑非  对非布尔值，非运算符会将其转换为布尔值，再取反<br>and 逻辑与  Python中的逻辑与和JS一样，也是短路的与，对非布尔值会先转化为布尔值运算，<strong>最终返回原值</strong><br>or 逻辑或   短路的或</p><pre><code># 与运算找false 21 and 2 # 或运算找true 1 1 or 2 </code></pre><p><strong>条件运算符(三元运算符)</strong></p><p>语法: 语句1 if 条件表达式 else 语句2</p><p>条件运算符在执行时，先对条件表达式进行求值判断，执行相应语句并返回执行结果。</p><h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><p><strong>条件判断语句(if)</strong></p><p>语法: if 条件表达式 : 语句 </p><p>Python是通过<strong>缩进</strong>表达代码块的,Python代码中使用的缩进方式必须统一，要么全缩进要么全空格</p><p>依次判断找到表达式结果为True的，执行代码块，然后语句结束。所以if-elif中只有一个代码块被执行。</p><pre><code>    if True：        # Tab缩进 或者 4个空格        # end=&quot;&quot; 可以控制打印之后不换行        print(123,end=&quot;&quot;)    # else:        # else的代码块    elif 条件表达式 :        # 代码块  </code></pre><p><strong>input函数</strong></p><p>input()函数用来获取用户的输入，调用后程序会立即暂停，等待用户输入，点击回车程序才会继续向下执行。</p><p>输入的内容会作为返回值返回，返回值为字符串<br>参数为字符串，作为提示文字显示</p><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>while 条件表达式:<br>    代码块<br>else:<br>    代码块，仅跳出循环后执行一次</p><p><strong>break与continue</strong></p><p>break 可以用来立即退出循环语句,后面与循环一套的else<br>continue 可以退出本次循环，本次循环continue后面的语句将不会被执行，执行下一次循环，不会影响循环一套的else</p><p>pass 用于在判断或循环语句中占位</p><h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表(list)是Python中的一个对象，列表中可以保存多个有序的数据<br>列表存储的数据，称为元素<br>列表的索引可以是负数，如果是负数从后向前获取元素</p><p><strong>切片</strong></p><p>切片指从现有列表中，获取一个子列表，索引传<br>个值，起始位置包括，结束位置不包括。或者可以理解为从索引的左边切下。<br>语法: 列表[起始:结束]   列表[起始:结束:步长]<br>步长表示每次获取元素的间隔，默认值是1，不能是0但是可以是负数，负数则会从列表的后面像前面取<br>切片操作不会影响原来的列表，会返回一个新的列表<br>起始位置和结束位置的索引可以省略不写</p><p>通过切片来修改列表，进行赋值时，只能使用序列中元素的个数没有要求。<br>当设置了步长时，序列中元素的个数必须和切片中元素的个数一致。</p><pre><code># 列表的创建my_list = [1,2,3]# 列表的使用，通过索引使用my_list[0:0] = [9] //[9 1 2 3]# 删除元素del list[0]# 通过len()函数获取列表的长度,列表的最大索引+1len(my_list)</code></pre><p><strong>列表的方法</strong></p><p><strong>都是直接修改原列表</strong></p><p>插入：<br>s.append(value) 序列的最后添加value，不可以使用直接赋值的办法是因为索引超过最大值了会保存<br>s.insert(i,value) 想列表的指定位置插入一个元素，参数1要插入的位置，参数2插入的元素<br>s.extend(list) 使用新的序列来扩展当前序列，会将当前序列中的元素添加到当前列表中，相当于<code>+ =</code></p><p>删除:</p><p>s.clear() 清空序列<br>s.pop() 根据索引删除并返回指定元素<br>s.remove() 删除指定值的一个元素<br>s.reverse() 序列反转<br>s.sort() 用来对列表中的元素进行排序，默认升序排列，如果需要降序，则需要传递一个reverse = True作为参数</p><p><strong>range()函数</strong></p><p>range() 可以生成一个自然数序列,可以创建一个指定执行次数的for循环。</p><p>该函数需要三个参数<br>1.起始位置，可以省略，默认是1<br>2.结束位置<br>3.步长，可以省略，默认是1</p><pre><code>range(5) # 生成一个序列[0,1,2,3,4]for i in range(30):    print(i)</code></pre><p><strong>列表的常用操作/序列通用操作</strong></p><p><code>+</code> 两个列表拼接为一个列表<br><code>*</code> 可以将列表重复指定的次数<br><code>in</code> 用来检查指定元素是否存在列表中，语法：元素 in 列表 ，返回布尔值<br><code>not in</code> 用来检查指定元素是否不在列表中</p><p>函数:<br>len(list) 获取列表中的元素个数<br>min(list) 获取列表中的最小值<br>max(list) 获取列表中的最大值</p><p>两个方法:方法和函数基本是一致的，只不过方法必须通过对象.方法()的形式调用<br>s.index() 获取指定元素在列表中的位置,如果列表中没有会报错，仅返回第一次出现的索引。第一次参数表示查找的元素，第二个参数表示查找的起始位置，第三个参数表示查找的结束位置<br>s.count() 统计指定元素在列表中出现的次数</p><h3 id="序列-sequence"><a href="#序列-sequence" class="headerlink" title="序列(sequence)"></a>序列(sequence)</h3><p>序列是Python中最基本的一种数据结构，数据结构指计算机中数据存储的方式</p><p>序列用于保存一组有序的数据，所有的数据在序列当中都有一个唯一的位置(索引)</p><p>序列的分类<br>    可变序列:序列中的元素可以改变<br>        列表(list)<br>    不可变序列:序列中的元素不可以改变<br>        字符串(str)<br>        元组(tuple)</p><p>可以通过<code>list()</code>函数将其他的序列转换为list</p><p>所有的序列都可以进行解包。</p><p><strong>遍历序列</strong></p><p><code>for-in</code>循环将序列中的所有元素取出来,每执行一次会将序列中的一个元素赋值给变量，变量指的是<strong>键值</strong>,这里是和JS不同的地方</p><p>for 变量 in 序列:<br>    代码块</p><h3 id="元组tuple"><a href="#元组tuple" class="headerlink" title="元组tuple"></a>元组tuple</h3><p>把元组当成是一个不可变的列表，一般当我们希望数据不改变时，就是用元组，其余情况都使用列表。</p><p>创建元组，使用小括号<code>()</code>，当元组不是空元组时，可以省略括号,<strong>至少有一个逗号</strong>(可以看成元组的信号)</p><p>元组的特殊用法类似JS的解构赋值，在对一个元组进行解包时，变量的数量必须和元组中的元素的数量一致，也可以在变量前面添加<code>*</code>,这样变量将会获取元组中所有的剩余元素，变量为一个列表</p><pre><code>my_tuple = 10,20,30,40# 元组的解构赋值（解构）a,b,c,d = my_tuple# c=[30,40]a,b,*c = my_tuple</code></pre><h3 id="字典-dict"><a href="#字典-dict" class="headerlink" title="字典 dict"></a>字典 dict</h3><p>字典属于一种新的数据结构，称为映射。字典的作用和列表类似，都是用来存储对象的容器。</p><p>列表存储数据的性能很好，但是查询数据的性能很差</p><p>在字典中每一个元素都有一个唯一的名字(键名)，通过这个唯一的名字就可以快速的查找到指定的元素(键值)</p><p>字典的键是任意的不可变对象，一般为字符串，不可以重复，如果重复，后面的会替换前面的；值可以是任意对象。</p><pre><code># 创建字典,类似JSON格式d = {&#39;age&#39;:18}d[&#39;age&#39;]</code></pre><p><strong>字典的操作</strong><br>函数:<br>dict() 来创建字典,这种方式 创建的字典，key都是字符串<br>    也可以将一个包含双值(仅两个值如’ab’)子序列的序列转换为字典。<br>len() 获取字典中键值对的个数<br>in 检查字典中是否包含指定的<strong>键</strong><br>not in 检查字典中是否不包含指定的<strong>键</strong></p><p>方法:<br>d.get(key[,default]) 根据键来获取字典中的值，如果键不存在，会返回None;通过[]来获取值时，如果键不存在，会抛出异常。<br>d.setdefault(key[,default]) 可以用来向字典中添加key-value，如果key存在，则返回key的值不会对字典做任何操作，如果key不存在，则向字典中添加这个key，并设置value<br>d.updata(other d) 将其他字典中的key-value添加到当前字典中<br>d.popitem() 随机删除字典中的一个键值对，一般都会删除最后一个键值对并以元组形式返回，删除空字典时报错<br>d.pop(key[,default]) 根据key删除字典中的key-value，返回值是删除的value。删除不存在的key会报错，如果指定了默认值就不会报错并直接返回默认值<br>d.clear() 用来清空字典<br><strong>copy()</strong><br>d.copy() 该方法用于对字典进行<strong>浅复制</strong></p><p>复制以后的对象和原对象是独立的，修改一个不会另外一个，浅复制仅是简单的复制对象内部的值，如果值是一个可变对象，这个可变对象不会被复制(会影响原来的值)</p><pre><code>d = dict(name=&#39;孙悟空&#39;,age=18)# {&quot;name&quot;:&quot;孙悟空&quot;，&quot;age&quot;:18}d = dict([(name,&#39;孙悟空&#39;),(age,18)])# 获取字典中的值,注意引号,有引号为字符串，没有引号为变量，d[&#39;name&#39;] = &quot;value&quot; # key存在修改，不存在添加# 删除字典中的key-value，key不存在报错del d[&#39;name&#39;]</code></pre><p><strong>字典的遍历</strong><br>d.keys()该方法会返回字典的所有key的序列<br>d.values()该方法会返回字典的所有value的序列<br>d.items(k,v)该方法会返回字典中所有项的序列<code>[(k,v),(k,v)]</code></p><h3 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h3><p>集合和列表非常相似，类似JS的Set</p><p>不同点</p><pre><code>- 集合中只能存储不可变对象- 集合中存储的对象是无序- 集合中不能出现重复的元素</code></pre><p>集合的创建使用<code>{}</code>或使用<code>set()</code>,创造空集合只能使用<code>set()</code>,使用<code>{}</code>默认是创建的字典。</p><p>set可以将序列和字典(的键)转换为集合，<strong>利用这点可以去重</strong>，</p><p>in 检查集合中的元素<br>len()来获取集合中元素的数量</p><p>s.add() 向集合中添加元素<br>s.update() 将一个集合/元组/字典(key<br>)中的元素添加到当前集合中<br>s.pop() 随机删除集合中的元素并返回<br>s.remove(value) 删除集合中的指定元素<br>s.clear()清空集合<br>s.copy() 对集合进行浅复制</p><p><strong>集合的运算</strong></p><pre><code># 在对集合做运算时，不会影响原来的集合，而是将运算结果返回# 创建两个集合s = {1,2,3,5,9}s2 = {4,6,7,8,9}# &amp; 交集运算result = s &amp; s2# | 并集运算result = s | s2# - 差集result = s - s2# ^ 异或集(除去交集的剩余部分，只在一个集合中出现的元素)result = s ^ s2# &lt;= 检查一个集合是否是另外一个集合的子集 # &lt; 检查一个集合是否是另外一个集合的真子集</code></pre><h2 id="函数-function"><a href="#函数-function" class="headerlink" title="函数 function"></a>函数 function</h2><p>函数也是一个对象<br>def 函数名([形参1=默认值,形参2]):<br>    代码块</p><p>位置参数:将对应位置的参数复制给对应位置的形参<br>关键字参数:通过参数名直接传递参数，可以不按照形参定义的顺序去传递<br>混合使用关键字和位置参数时，必须将位置参数写到前面</p><p>函数在调用时，解析器不会检查实参的类型，实参可以传递任意类型的对象</p><p>当传的参数是可变参数时，不想形参影响实参，传参可以通过<code>x.copy()</code>或<code>x[:]</code>传副本，这样形参和实参之间互不影响</p><p><strong>不定长参数</strong></p><p>在定义函数时，可以在形参前边加上<code>*</code>,这个形参将会获取到所有的实参，它会将所有的实参保存到一个<strong>元组</strong>,带<code>*</code>的参数后的所有的参数，必须以关键字参数的形式传递必须按形参顺序。</p><pre><code># 如果*后没跟变量，可以使用这种写法要求调用函数时必须使用关键字参数的形式传值def fn(*,a,b,c):    代码块# * 形参只能接收位置参数，而不能接收关键字参数def fn(*a):    代码块# **形参可以接收其他的关键字参数，将这些参数统一保存到字典中，字典的key就是参数的名字，字典value就是参数的值# **只能有一个且写在参数的最后    def fn(**a):    代码块    </code></pre><p><strong>参数的解包</strong><br>通过一个星号，对序列进行参数的解包。<br>通过两个星号，对字典进行参数的解包</p><pre><code>def fn(a,b,c):    代码块# 传递实参时，也可以在序列类型的参数前添加星号，这样会依次将序列中的元素作为参数传递。# 序列中元素的个数必须和形参的个数一致t = (10,20,30)fn(*t)d = {&#39;a&#39;:100,&#39;b&#39;:200,&#39;c&#39;:300}# 通过**来对字典进行解包操作,相当于关键字参数，所以key要和参数名一致fn(**d)</code></pre><p><strong>help()</strong></p><p>help()是python的内置函数，通过help(函数对象)函数可以查询python中的函数的用法</p><p>文档字符串(doc str)<br>在定义函数时，可以在函数内部第一行用<code>&#39;&#39;&#39;文档字符串&#39;&#39;&#39;</code>编写文档字符串，文档字符串就是函数的说明，可以通过help()函数来查看函数的说明。</p><p><strong>作用域</strong></p><p>作用域分两种</p><ul><li><p>全局作用域:在程序执行时创建，在程序执行结束时销毁</p></li><li><p>函数作用域:在函数调用时创建，在调用结束时销毁，每调用一次就会产生一个新的函数作用域</p></li></ul><p>如果希望在函数内部修改全局变量，可以通过global关键字来声明变量，表示这个变量不是函数内部的而是全局的。</p><p><strong>命名空间</strong><br>命名空间指的是变量存储的位置，每一个变量都需要存储到指定的命名空间中。<br>每一个作用域都会有一个它对应的命名空间，命名空间实际上就是一个字典，是一个专门用来储存变量的字典。</p><p>locals() 用来获取当前作用域的命名空间，返回当前作用域的命名空间<br>globals() 用来获取全局命名空间</p><p><strong>递归</strong></p><p>基线条件,问题可以被分解为的最小问题，当满足基线条件时，递归就不在执行了<br>递归条件，将问题继续分解的条件</p><p><strong>函数式编程</strong></p><p>在Python中，函数是一等对象<br>一等对象一般特点：<br>1.对象是在运行时创建的<br>2.能赋值给变量或作为数据结构中的元素<br>3.能作为参数传递<br>4.能作为返回值返回</p><p>高阶函数至少符合以下两个特点的一个:<br>1.接收一个或多个函数作为参数<br>2.将函数作为返回值返回</p><p><strong>filer()函数</strong><br>可迭代结构中过滤出符合条件的元素，保存到新的序列中<br>参数:<br>1.函数，根据函数来过过滤课迭代结构(需要返回bool值)<br>2.需要过滤的可迭代结构<br>返回值：<br>过滤后的新可迭代的结构</p><p>这个的函数可以传匿名函数,也可以将匿名函数赋值给一个变量，这里的返回值直接返回不需要使用<code>return</code></p><p>语法:lambda 参数列表 : 返回值</p><p><strong>map()函数</strong></p><p>map()函数可以对可迭代对象中的所有元素做指定的操作，然后将其添加到一个新的对象中返回。<br>语法:map(函数,可迭代对象)</p><p><strong>sort()方法/sorted()函数</strong></p><p>sort()方法用来对列表中的元素进行排序，会影响原列表。<br>该方法是直接比较列表中元素的大小。</p><p>在sort()可以接收一个关键字参数key，key需要一个函数作为参数，当设置了函数作为 参数，每次都会以列表中的一个元素作为参数来调用函数，并且使用函数的返回值来比较元素的大小。<br>如:<code>l.sort(key=len)</code>利用列表元素的长度排序。<br>key = int 每个元素转换成int类型排序<br>key = string 每个元素转换成string类型排序</p><p>这种用法只在比较的时候转换，不影响原来列表的类型</p><p>sorted()可以对任意的序列进行排序,不会影响原来的序列，返回一个新的对象。<br>第一个参数为序列，第二个参数为key</p><p><strong>闭包</strong></p><p>将函数作为返回值返回</p><p>产生闭包的条件<br>1.函数嵌套<br>2.内部函数引用了外部函数的数据</p><p><strong>装饰器</strong></p><p>开闭原则，程序的设计要求开发对程序的扩展，要关闭对程序的修改</p><p>在希望不修改原函数的情况下，对函数进行扩展</p><p>只需要在现在的函数，创建一个新的函数，把原来的函数在新的函数中运行。这种方式要求每扩展一个函数就要手动创建一个新函数，为了避免麻烦，我们创建一个函数，让这个函数可以自动帮助我们生产函数</p><pre><code>def begin_end(old_function):    &#39;&#39;&#39;    用来对其他函数进行扩展，使其他函数可以在执行前打印开始执行，执行后打印执行结束    参数：要扩展的函数对象    &#39;&#39;&#39;    # 打包    def new_function(*args,**kwargs):        print(&quot;开始执行&quot;)        # 解包        old_function(*args,**kwargs)        print(&quot;执行结束&quot;)    return new_function</code></pre><p>像begin_end()这种函数就被称为装饰器，在开发中使用装饰器扩展函数的功能。<br>在定义函数时，可以通过@装饰器来指定装饰器，可以同时为一个函数指定多个装饰器，函数将会被由内到外的装饰</p><pre><code># 在函数前面@装饰器，表示下面的函数被该装饰器装饰@begin_end@装饰器2def say_hello():    代码块# 执行的结果是被装饰器装饰后的结果  say_hello()    </code></pre><p><strong>可变对象</strong></p><p>列表、字典</p><p>变量中保存的对象id，只有在为变量重新赋值才会改变。<br>可变对象指的是对象的值可变<br>列表中的对象改变，该改变的是值，并没有重新给列表赋值</p><pre><code># 改对象a[0] = 10# 改变量a = [1,2,3]</code></pre><h2 id="对象Object"><a href="#对象Object" class="headerlink" title="对象Object"></a>对象Object</h2><p>对象由三部分组成<br>1.对象的标识，不可变(id)<br>2.对象的类型，不可变(type)<br>3.对象的值(value)</p><p><strong>面向对象</strong></p><p>面向对象的语言就是语言中的所有操作都是通过对象来进行的</p><h3 id="类class"><a href="#类class" class="headerlink" title="类class"></a>类class</h3><p><a href="https://biubiuins.github.io/2020/08/20/python-%E7%B1%BB/" target="_blank" rel="noopener">class</a></p><p><strong>isinstance()/issubclass()函数</strong></p><p>isinstance(mc,MyClass) 用来检查mc(第一个参数)是否是MyClass(第二个参数)的实例，返回布尔值<br>issubclass()用来检查第一个参数是否是第二个参数的子类</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>程序运行过程中产生的垃圾会影响到程序运行的运行性能，所以这些垃圾必须被及时清理。<br>在Python中有自动的垃圾回收机制，它会自动将这些没有被引用的对象删除，所以不用手动处理垃圾回收<br>程序结束之后，对象也会被自动回收</p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>在Python中一个py文件就是一个模块，模块名要符合标识符的规范。<br>语法: import 模块名  – 模块名为python文件的名字<br>可以引用同一个模块多次，但是模块的实例只会创建一次。<br>在每一个模块内部都有一个<strong>name</strong>属性，通过这个属性可以获取到模块的名字,<strong>name</strong>属性值为<strong>main</strong>的模块是主模块，一个程序中只会有一个主模块，主模块就是直接通过python执行的模块</p><p>模块中添加了_的变量，通过<code>import *</code>引入是看不见该变量的</p><pre><code># 给模块起别名import test_module as testprint (test.__name__)  # 输出test_moduleprint (__name__)  # 输出__main__# 访问模块中的变量:模块名.属性/方法()# 引入模块中的部分内容# 语法 from 模块名 import 变量,变量from m import Person,test# 引入模块中所有内容，一般不会使用from m import * # 也可以为引入的变量使用别名# 语法: from 模块名 import 变量名 as 别名# 测试代码，当前文件为主模块的时候才需要执行if __name__ == &#39;__main__&#39;:    # 测试代码</code></pre><p><strong>time模块</strong></p><p>time()可以用来获取当前的时间，返回的单位是秒</p><pre><code>from time import *begin = time() </code></pre><p><strong>pprint模块</strong></p><p>pprint 模式给我们提供了一个方法pprint()该方法可以用来对打印的数据做简单的格式化。</p><h3 id="包package"><a href="#包package" class="headerlink" title="包package"></a>包package</h3><p>包也是一个模块，当我们模块中代码过多时，或者一个模块需要被分解为多个模块时，就需要使用包</p><p>普通的模块就是一个py文件，而包是一个文件夹。包中必须要一个<code>__init__.py</code>,在这个中可以包含有包的主要的内容</p><pre><code># 这个包里有很多模块，这里引入a.py ,b.pyform package_test import a,b</code></pre><p><code>__pycache__</code>是模块的缓存文件，py代码在执行前，需要被解析器先转换为机器码，然后再执行，python会在编译一次以后，将转化后的机器码保存到缓存文件中</p><h3 id="python标准库"><a href="#python标准库" class="headerlink" title="python标准库"></a>python标准库</h3><p>sys模块，可以获取到python解析器的信息<br>os模块让我可以对操作系统进行访问</p><pre><code># 引入sys模块import sys# 获取执行代码时，命令行中包含的参数(指令后面紧跟的)# 该属性是一个列表，列表保存了当前命令的所有参数sys.argv# 当前程序中引入的所有模块，modules是一个字典，key为模块名，value是模块对象sys.modules# 该属性是一个保存了模块的搜索路径的列表，有点类似环境变量pathsys.path# 表示当前python运行的平台sys.platform# 用来退出程序sys.exit(&quot;提示语句&quot;)# 通过这个属性可以获取到系统的环境变量os.environos.environ[&#39;path&#39;]# 可以执行操作系统的命令os.system(&quot;命令名&quot;)# os.listdir(path=&quot;.&quot;)获取当前目录的目录结构,返回一个列表，列表中的每一个元素都是文件夹/文件名r = os.listdir()# os.getcwd()获取当前所在的目录r = os.getcwd</code></pre><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>Python是希望在出现异常时,我们可以编写代码来对异常进行处理，避免因为异常导致整个程序的终止。</p><p>try-except语句，try必须、except和finally至少有一个。</p><pre><code>try:    代码块，可能出现错误的语句except:    代码块，出现错误以后的处理方式else:    代码块，没出错时要执行的语句finally:    代码块，该代码块总会执行</code></pre><p><strong>异常的传播</strong></p><p>函数中出现异常时，如果函数中对异常进行了处理，异常将不会传播；如果函数中没有对异常进行处理，异常会传播到函数的调用处。<br>在异常传播时，实际上就是把异常对象抛给了调用处，如NameError类的对象专门用来处理变量错误的异常。</p><p><strong>异常对象</strong></p><p>如果except后不跟任何内容(默认Exception)，此时会捕获到所有的异常;如果except后跟着一个异常的类型，那么此时只会捕获该类型的异常<br>一个try后可能跟n个except,类似elif,可以跟n个但只执行一个except<br>Exception是所有异常类的父类，效果等于except后不跟任何内容<br>可以在异常类后面跟着一个as xx,此时xx就是异常对象</p><pre><code>try:    print(c)    print(10/0)except NameError as err:    print(&quot;出现NameError异常&quot;) except ZeroDivisionError:    print(&quot;出现ZeroDivisionError异常&quot;)finally:    print(&quot;无论是否出现异常，该子句都会执行&quot;)</code></pre><p><strong>抛出异常</strong></p><p>可以使用raise语句来抛出异常，raise语句后需要跟一个异常类或者异常类的实例。<br>也可以自定义异常类，主要创建一个类继承Exception就可</p><pre><code>class MyError(Exception):    passdef add(a,b):    # 如果a和b中有负数，就向调用出抛出异常    if a&lt;0 or b&lt;0        # 抛出异常类        raise Exception        # 抛出异常类的实例        raise MyError(&quot;两个参数中不能有负数&quot;)    r = a + b    return r</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;p&gt;Python是解释型语言，用途有Web应用、爬虫程序、科学计算、自动化运维、大数据、云计算、人工智能等。&lt;/p&gt;
&lt;p&gt;补充:解释型语言:不
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>vue基础</title>
    <link href="http://yoursite.com/2020/07/31/vue%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/07/31/vue基础/</id>
    <published>2020-07-31T08:01:12.000Z</published>
    <updated>2020-08-22T07:27:14.463Z</updated>
    
    <content type="html"><![CDATA[<p><strong>创建vue实例</strong></p><pre><code class="bash">//————html&lt;div id=&quot;app&quot;&gt;&lt;a href = &quot;msg&quot;&gt;&lt;/a&gt;&lt;button v-on:click=&quot;test&quot;&gt;test&lt;/button&gt;&lt;/div&gt;//——————jsconst vm =new Vue({  //配置对象:属性名是一些特定的名称  el:&quot;#app&quot; ,   //值是选择器 element 用来查找根元素 该根元素所覆盖的htlm+js为模板页面  data:{  //包含多个可变数据的对象,为模板页面提供数据    msg:&quot;xxx&quot;  },  //data还可以是函数，一定要有返回值  //data(){return{}}  methods:{ //包含n个事件回调函数    test(event){      event.target.innerHTML    }  }})</code></pre><p>vm会自动拥有data中所有属性，页面中可以直接访问使用不用使用this<br>数据代理:由vm对象来<strong>代理</strong>对data中所有属性的操作</p><p><strong>问题1：js以什么形式存在</strong><br>    指令:vue自定义标签属性 例子:v-model<br>    插值:动态显示数据，可以写表达式</p><p>知识点1:强制数据绑定v-bind:<br>  为某个标签属性绑定动态data时，要在属性前面添加:</p><p>知识点2:绑定事件监听v-on:<br>  简写@事件名=”回调函数” 也可以写成@事件名=”回调函数(参数)” methods里面常常放回调函数</p><p><strong>Object.definePropertiy</strong></p><p>该方法的存储器属性(setter,getter)可以实现简单的数据双向绑定</p><pre><code>const p = {    firstName:&quot;A&quot;,    lastName:&quot;B&quot;    //还可以在这直接写get/set    //get fullName(){}}Object.defineProperty(p,&quot;fullName&quot;,{   //当读取属性值时自动调用(回调)，函数返回值作为属性值   get(){     //this是对象p        return this.firstName +&#39;-&#39;+ this.lastName       },   //当设置属性时自动调取,监视属性值的变化   set(value){        const names = value.split(&quot;-&quot;)        this.firstName = names[0]        this.lastName = name[1]   }})console.log(p.fullName);</code></pre><p><strong>computed</strong></p><p>计算属性，通过已有数据(依赖数据)计算动态产生一个要显示的结果数据，相当于使用了属性的get方法。<br>执行的时机：<br>  1.初始显示第一次执行，得到初始值显示<br>  2.依赖数据发生改变就会再次调用。</p><p>注意：所有vue控制的回调函数的this都是vm或者组件对象。</p><pre><code>computed：{  //计算属性的套路 filterPersons(){    //1.得到依赖的数据    const {searchName,persons} = this    //2.进行计算处理，产生结果数据并返回    const newPersons = persons.filter(p =&gt; p.name.includes(searchName))    return newPersons    }}</code></pre><p><strong>问题2:如果页面中需要fullName多次渲染，是否computed里的fullName函数会执行多次？</strong></p><p>答：不会执行多次，计算属性会先去缓存取，取不到在执行一次getter计算，计算的结果放入缓存。</p><p><strong>问题3:用什么结构来缓存计算属性？</strong><br>用对象来缓存计算属性，对象的属性名永远是<strong>字符串</strong>。</p><p><strong>getter和setter</strong><br>属性的set方法称为setter、属性的get方法称为getter,如果要自己设置get与set，那么该计算属性后面接对象。</p><pre><code>computed：{  fulllName:{      get(){      return this.firstName +&#39;-&#39;+ this.lastName        }      set(value){       const names = value.split(&quot;-&quot;)        this.firstName = names[0]        this.lastName = name[1]      }  }}</code></pre><p><strong>总结</strong><br>1.只用getter，计算属性就是一个函数<br>2.使用getter/setter，计算属性是一个包含geeter的setter的对象</p><p><strong>watch监视</strong></p><p>当监视的属性变化时自动调用，<strong>初始显示的时候不调用。</strong></p><pre><code>//用于监视vm的哪个属性的变化watch:{firstName(newValue,oldValue)=&gt;{//当firstName发生改变时自动调用},//一般监视todos(){}}</code></pre><p>假设监视的todos是一个数组，数组内部发生变化，但todos数组在内存中存的是地址，地址并没有改变，这种监视叫做一般监视。<br>如果想要监视todos以及todos里面的数据变化，可以使用深度监视。</p><p>深度监视:</p><pre><code>watch:{todos:{  deep:true,  //深度监视  handler(value){    //监视的回调函数，value最新的todos值  }}}</code></pre><p><strong>class动态绑定/style动态绑定</strong></p><p>动态绑定的class会和静态绑定的class合并。</p><pre><code>//值为字符串 &lt;p :class=&quot;classA&quot;&gt;//动态绑定多个class&lt;p :class=&quot;{classA:true,classB:false}&quot;&gt;//hasA，hasB是data里面的变量，通常操作hasA，hasB变量的改变改变样式&lt;p :class=&quot;{classA:hasA,classB:hsaB}&quot;&gt;//style的值为对象&lt;p :style = &quot;{color:myColor,fontSize:mySize+&#39;px&#39;}&quot;&gt;</code></pre><p>使用场景:<br>值为字符串 –&gt; 类名不确定时使用<br>值为对象 –&gt; 类名确定，不确定是否有该类的样式</p><p><strong>重点:HTML不区分大小写，所以HTML之中用连接线写法，而Js之中用驼峰写法</strong></p><p><strong>条件渲染</strong></p><p>v-if/v-else的标签二选一，</p><p>v-show是通过改变标签的样式实现显示与隐藏的</p><p><strong>v-for遍历</strong></p><pre><code>&lt;li v-for = &quot;(p,index) in persons&quot; :key=&quot;p.id&quot;&gt;&lt;/li&gt;data:{  persons:[]},methods:{  updataP(index,newP){    //这种方法不会更新页面    //this.persons[index] = newP    //这种方法可以更新页面    this.persons[index].name = newP.age    this.persons.splice(index,1,newp)   }}</code></pre><p><strong>问题4：vue的数据绑定如何实现</strong><br>1.vue会监视data中所有层次的属性<br>2.对象中的属性数据通过添加set方法来实现监视<br>3.数组中的元素也实现了监视data的数据,重写数组一系列更新元素的方法。首先调用原生对应的方法对元素进行处理，再更新界面。</p><p>重写的数组方法:push()、pop()、shift()、unshift()、splice()、sort()、reverse()</p><blockquote><p>在定义数据时，可以考虑根据状态赋值，如数组排序，比如有不排序，升序，降序三种状态，可以考虑用一个数字来表示该状态 0-不排序、1-升序、2-降序</p></blockquote><blockquote><p>如果两个不同的事件回调函数里面操作大部分相同，也可以尝试参数用true/false来表示不同的事件</p></blockquote><p><strong>事件处理</strong></p><p>1.绑定监听</p><p>当函数需要操作事件对象时，可以显示的传<code>$event</code></p><pre><code>&lt;button @click=&quot;test(&#39;x&#39;,$event)&quot;&gt;&lt;/buuton&gt;</code></pre><p>2.事件修饰符</p><p>阻止(prevent)事件的默认行为 / 停止(stop)事件冒泡 / once 只触发一次</p><pre><code>&lt;button @click.prevent=&quot;test(&#39;x&#39;)&quot;&gt;&lt;/buuton&gt;</code></pre><p>3.按键修饰符</p><p>@keyup.enter 表示回车按键起来时执行</p><p>还可以自定义按键修饰符</p><pre><code>Vue.config.keyCodes.f1 = 112//@key.f1=&quot;&quot;使用</code></pre><p><strong>声明周期钩子(回调)函数</strong><br>钩子函数都是自己定义</p><p>beforeCreate()</p><p>在这两个回调之间，vue会实现<strong>数据代理</strong>，后面可以通过vm读取data中的数据。</p><p>created()</p><p>beforeMount() 在显示前执行一次</p><p>这期间，会把之前模块中解析的内容批量替换el里的内容</p><p>mounted() 在第一次显示之后执行1次,同一个组件对象只执行一次。</p><p>这里的更新指的是<strong>页面更新</strong>,通常通过数据改变触发页面更新，也就是一下两个回调<strong>都发生在数据改变后</strong>，只不过一个页面还没有更新，一个页面更新完毕</p><p>beforeUpdate() 读老页面<br>updated()  读新页面</p><p>beforeDestroy() 销毁前执行1次</p><p>常用的声明周期方法<br>created()/mounted() 常用于异步请求,发送ajax请求，启动定时器等异步任务<br>beforeDestory() 做收尾工作，清除定时器等</p><p><strong>过渡和动画</strong></p><p>transition标签，需要有过渡和动画的标签部分需要包裹在transition标签内。</p><p><img src="/img/vue/动画.png"></p><p>在x-enter-active里面写transition/animation样式，定义进入动画的过渡<br>在x-leave-active里面写transition/animation样式，定义离开动画的过渡</p><pre><code>&lt;transition name:&quot;自定义过渡的动画名称如:fade&quot;&gt;...&lt;transition&gt;</code></pre><p><strong>过滤器</strong></p><p>功能:对要显示的数据进行特定格式化后再显示，没有改变原有数据。<br>语法:</p><pre><code>Vue.filter(filterName,function(value被处理的数据,formatStr传过来的值{return 显示的数})</code></pre><p>在html使用</p><pre><code>{{xxx | filterName(formatStr)}}</code></pre><p><strong>常用内置指令</strong><br>指令的作用是操作标签</p><p>v-if:如果为true，当前标签才会输出到页面<br>v-show:通过控制display样式来控制显示/隐藏<br>v-for:遍历数组/对象<br>v-on:绑定事件监听，简写@<br>v-model:双向数据绑定<br>ref:为某个元素/组件注册一个唯一标识，vue对象通过$refs属性访问这个元素/组件对象<br>v-html:更新元素的innerHTML，会解析标签<br>v-text:更新元素的textContent</p><p>自定义标签</p><p>1.注册全局指定</p><pre><code>Vue.directive(&quot;指令名称如:xxx&quot;,function(el,binding){  //el:指令属性所在的标签元素对象  //binding:包含指令相关信息数据的对象，如指令名，指令值等})</code></pre><p>2.定义局部指令<br>指令在vue实例上的局部指令</p><pre><code>new Vue({  directives:{  //&quot;xxx&quot;:function() ES6中省略fuction和冒号  &quot;xxx&quot;(el,binding){}  }})</code></pre><p><strong>插件</strong><br>每个插件对象都必须有一个install方法，该方法通过Vue.use(插件名)调用。<br>所以声明使用Vue插件，Vue.use(插件名)内部调用插件的install方法来安装插件。</p><p><strong>单文件组件</strong></p><p><strong>组件中的data必须用函数返回对象的形式</strong>,因为每个组件标签都会产生一个实例，如果直接会对象形式，每个组件就共享了data中的数据，而使用函数返回对象的形式，每个组件通过调用data函数使用独立的数据。</p><p>保证对一个组件的多个实例对象的data对象不是共有的，而是各自的data对象。</p><p>每个组件只能有一个<strong>根标签</strong>,一个组件对象就是一个小的vm，组件内回调函数的this是指向组件对象，模板中获取数据读取组件对象的对应属性值。</p><p>单文件vue组件，后缀名为vue</p><pre><code>&lt;template&gt;&lt;/template&gt;&lt;script&gt;//1.引入组件 importexport default{  //声明接收属性，该属性在组件标签中传值  //接收的所有标签属性都会成功组件对象的属性  props:[]/{},  data(){    return{    }  },  methods:{},  watch:{},  //2.注册组件  components:{    //组件名  },  filters:{},  directive{},}&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><p>引入组件时的<strong>问题:什么时候加./什么时候不加？</strong></p><p>不加时直接用模块名引入的是第三方库，默认从node_modules里面找，如果是自己定义的组件不是第三方引用的则需要添加</p><p>组件化编码的基本流程<br>1.拆分界面，抽取组件<br>2.编写静态组件<br>3.编写动态组件，初始化数据、动态显示初始化界面、实现与用户交互功能</p><p>设置数据 -&gt; 类型，名称，位置如果是哪些组件用则交给共有的父组件。<br>数据的更新-&gt; data数据定义在哪个组件，更新数据的行为就定义在哪个组件，如果子组件要更新父组件的数据，调用父组件的更新函数来更新父组件的数据。一个组件接收属性数据不是用来直接修改，只是用来读取显示的。</p><p><strong>问题：组件对象和vm之间的关系</strong></p><p>所有组件对象的原型对象都是不同的vm,所有的vm都是Vue的实例、都有一个共同的原型对象。</p><p><a href="https://biubiuins.github.io/2020/08/06/vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/" target="_blank" rel="noopener">组件传值</a></p><h2 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h2><p><strong>脚手架的使用</strong></p><p>目前常用的是2.0版本和3.0版本</p><pre><code class="js">//3.0npm install -g @vue/clivue create project_namenpm run server//2.0npm insstall -g @vue/cli-initvue init webpack project_namenpm run dev</code></pre><p><strong>v2与v3创建的项目区别</strong></p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">V2</th><th style="text-align:center">V3</th></tr></thead><tbody><tr><td style="text-align:center">配置文件</td><td style="text-align:center">配置直接可见,可直接修改</td><td style="text-align:center">隐藏配置文件,扩展修改配置通过创建vue.config.js文件</td></tr><tr><td style="text-align:center">main.js</td><td style="text-align:center">components:…template:..使用template要用带编译器的vue版本</td><td style="text-align:center">render:h =&gt; h(app)默认使用的运行时的vue版本,打包文件更小</td></tr></tbody></table><p>补充：</p><p>1.render</p><pre><code>//&lt;App&gt;&lt;/App&gt; 创建App的组件对象返回，最终会被渲染到el指定的页面、import App ...render:createElment =&gt; createElenment(App) </code></pre><p>2.vue.config.js</p><pre><code>module.exports ={       configureWebpacl:{        //内部写webpack原生配置    }//只能写vue封装的配置}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;创建vue实例&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;//————html
&amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;
&amp;lt;a href = &amp;quot;msg&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>奇奇怪怪的坑们</title>
    <link href="http://yoursite.com/2020/07/30/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E5%9D%91%E4%BB%AC/"/>
    <id>http://yoursite.com/2020/07/30/奇奇怪怪的坑们/</id>
    <published>2020-07-30T08:56:46.000Z</published>
    <updated>2020-08-22T10:32:46.430Z</updated>
    
    <content type="html"><![CDATA[<h2 id="7-30-hexo拒绝访问"><a href="#7-30-hexo拒绝访问" class="headerlink" title="7.30 hexo拒绝访问"></a>7.30 hexo拒绝访问</h2><p>今天发现博客无法访问，报错是ERR_CONNECTION_REFUSED。开始慢慢寻找原因。</p><p>先重新上传了本地库，发现可以上传成功并且<code>hexo s</code>启动后本地可以访问。<br>然后用手机流量可以访问博客。那么问题就到了PC端。<br>ping了网址发现是127.0.0.1,检查了浏览器没开代理。<br>通过朋友的帮助，在hosts文件中，添加<code>185.199.111.153 biubiuins.github.io</code>，让DNS在解析该域名时解析成前面的ip。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;7-30-hexo拒绝访问&quot;&gt;&lt;a href=&quot;#7-30-hexo拒绝访问&quot; class=&quot;headerlink&quot; title=&quot;7.30 hexo拒绝访问&quot;&gt;&lt;/a&gt;7.30 hexo拒绝访问&lt;/h2&gt;&lt;p&gt;今天发现博客无法访问，报错是ERR_CONNECTI
      
    
    </summary>
    
      <category term="questions" scheme="http://yoursite.com/categories/questions/"/>
    
      <category term="其他" scheme="http://yoursite.com/categories/questions/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="http://yoursite.com/2020/07/28/promise/"/>
    <id>http://yoursite.com/2020/07/28/promise/</id>
    <published>2020-07-28T09:36:10.000Z</published>
    <updated>2020-07-28T10:16:15.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><h4 id="1-函数对象与实例对象"><a href="#1-函数对象与实例对象" class="headerlink" title="1.函数对象与实例对象"></a>1.函数对象与实例对象</h4><p>函数对象：将函数作为对象使用<br>实例对象：new函数产生的对象</p><blockquote><p>括号左边是函数，点左边是对象</p></blockquote><pre><code class="bash">function Fn(){ //Fn函数}const fn = new Fn() //这里的Fn是构造函数，fn是实例对象（new返回的，简称对象）Fn.prototype  //Fn本身是个函数，但是使用了XX.XXX(使用了.)，把该函数作为对象来使用，所以这里的Fn是函数对象</code></pre><h4 id="2-两种类型的回调函数"><a href="#2-两种类型的回调函数" class="headerlink" title="2.两种类型的回调函数"></a>2.两种类型的回调函数</h4><pre><code class="bash">/*-----------同步回调函数--------------*/const arr = [1,3,5]arr.forEach(item =&gt;{  //遍历回调，同步回调函数，一上来就执行，不会放入队列 console.log(item)})//forEach是一个函数，回调函数也是一个函数。说明该回调函数是同步回调函数，等完全执行完毕之后才执行最后一个打印语句console.log(&quot;forEach()执行完毕之后&quot;)//输出//1，3，5 forEach()执行完毕之后/*-----------异步回调函数--------------*/setTimeout(()=&gt;{//异步回调函数，会放入队列中将来执行 console.log(&quot;timeout callback()&quot;)},0)console.log(&quot;setTimeout()之后&quot;)//输出//setTimeout()之后 timeout callback()</code></pre><p><strong>同步回调</strong></p><p>理解：立即执行，完全执行完了才结束，不会放入回调队列中<br>例子：数组遍历相关的回调函数 /promise的excutor函数</p><p><strong>异步回调</strong></p><p>理解：不会立即执行，会放入回调队列中来执行<br>例子：定时器回调 /ajax回调 /promise的成功与失败的回调</p><h4 id="3-error处理"><a href="#3-error处理" class="headerlink" title="3.error处理"></a>3.error处理</h4><p><strong>错误类型</strong></p><p>Error:所有错误的父类型<br>子类型(常见的)：<br>ReferenceError: 引入错误，引用的变量不存在<br>TypeError: 数据类型不正确的错误<br>RangeError：数据值不在其所允许的范围内。<br>SyntaxError：语法错误</p><p><strong>错误处理</strong></p><p>若没有捕获error，后续的代码是不会执行的<br>捕获错误:try{}catch(error){}<br>抛出错误:throw new Error(message)</p><pre><code class="bash">//抛出错误，自己定义错误function something(){if(Date.now()%2 ===1){  console.log(&quot;当前时间为奇数,可以执行任务&quot;)}else{//  throw new Error(里面为传出的message) 固定格式  throw new Error(&#39;当前时间为偶数，无法执行任务&#39;)}try{  something()} catch(error){//error下面两个属性message与stackconsole.log(error.message)//错误相关信息console.log(error.stack)//函数调用栈记录信息}}</code></pre><h3 id="Promise的理解和使用"><a href="#Promise的理解和使用" class="headerlink" title="Promise的理解和使用"></a>Promise的理解和使用</h3><p>Promise是JS中进行异步编程的新的解决方案（旧的是纯回调的方式）<br>从语法来说：Promise是一个构造函数<br>从功能上说：Promise对象用来封装一个异步操作并可以获取其结果</p><p><strong>Promise的状态</strong></p><ol><li>pending变为resolved（成功）</li><li>pending变为rejected (失败)</li></ol><p>说明：只有这两种变化，且<strong>一个Promise对象只能改变一次</strong>。无论是成功还是失败，都会有一个结果数据。成功的结果数据一般称为value，失败的结果数据一般称为reason</p><p><img src="/img/js/promise.png"></p><pre><code class="bash">//1.创建一个新的promise对象,里面传一个回调函数const p = new Promise((resolve,reject)=&gt;{ //执行器函数excutor 同步回调//2.执行异步操作,promise常用于封装异步函数。setTimeout(()=&gt;{const time = Date.now() //如果当前时间是偶数代表成功，否则代表失败if(time%2 ==0){//3.1 如果成功了，调用resolve(value)  resolve(&quot;成功的数据,time=&quot;+time)}else{//3.2 如果失败了，调用reject（reason） reject(&quot;成功的数据,time=&quot;+time)}},1000);})p.then( value =&gt;{ //接收得到成功的value数据  onResolved   console.log(&quot;成功的回调&quot;,value) }, reason =&gt; { //接收得到失败的reason数据 onRejected    console.log(&quot;失败的回调&quot;,reason) })//输出 成功的回调 成功的数据,time=XXXX</code></pre><p><strong>优势</strong></p><ol><li><p>指定回调函数的方式更加灵活。旧的，必须在启动异步任务前指定回调函数;promise：启动异步任务 =&gt; 返回peomise对象 =&gt; 给promise对象绑定回调函数(甚至可以在异步执行之后才指定他的回调函数)</p></li><li><p>支持链式调用，可以解决回调地狱问题（回调函数嵌套调用，不便于阅读/不便于异常）。</p></li></ol><p><strong>几个关键问题</strong></p><p>1.如何改变promise的状态？<br>（1）resolve(value):如果当前是pending就会变为resolved<br>（2）reject（reason）：如果当前是pending就会变为rejected<br>（3）抛出异常(throw)：如果当前是pending就会变成rejected <code>throw new Error(&quot;出错了&quot;)</code> reason值是你抛出的东西</p><p>2.一个promise指定多个成功/失败的回调函数，都会调用吗？</p><p>当promise改变为对应状态时<strong>都会</strong>调用</p><p>3.改变promise状态和指定回调函数谁先执行。</p><pre><code class="bash">/*---------先指定回调函数后改状态------------*/new Promise((resolve,reject)=&gt;{ setTimeout(()&gt;{  resolve(1)//后改变的状态，同时指定数据，异步执行回调函数 },1000);}).then(//先指定回调函数，保存当前指定的回调函数value=&gt;{},reason=&gt;{})/*---------先改状态后指定回调函数------------*/new Promise((resolve,reject)=&gt;{ //同步回调  resolve(1)//先改变的状态，同时指定数据);}).then(//异步回调value=&gt;{},reason=&gt;{}//后指定回调函数，异步执行回调函数)</code></pre><p>4.promise.then()返回的新的promise的结果状态由什么决定</p><p>then方法返回的结构也是promise，返回的promise的状态由then执行的回调函数结果决定。</p><p>回调函数中return的值是非promise类型的数据，则返回的promise的状态为成功，value为return值。<br>若return的值是新promise，由返回的promise状态决定。</p><p>5.promise异常传透和中止</p><p>当使用promise的then链式调用时，可以在最后指定失败的回调，因为没有处理异常相当于 <code>reason =&gt; {throw reason}</code>，会一层一层往下寻找异常处理直到找到。</p><p>当使用promise的then链式调用时，若想中断promise链，可以<code>return new Promise(()=&gt;{})</code>返回一个处于pending的promise。</p><blockquote><p>自定义promise链接：<a href="https://github.com/biubiuins/promise-/tree/master" target="_blank" rel="noopener">https://github.com/biubiuins/promise-/tree/master</a></p></blockquote><h3 id="promise方法"><a href="#promise方法" class="headerlink" title="promise方法"></a>promise方法</h3><p><strong>Promise.resolve()/reject()</strong></p><p>Promise.resolve()：该方法返回一个新的成功的promise，值为参数<br>Promise.reject():该方法返回一个新的失败的promise，值为参数。</p><p><strong>Promise.race()</strong></p><p>返回一个新的promise，第一个完成的promise的结果就是最终返回的promise结果。</p><p><strong>Promise.allSettled()</strong></p><p>该方法接收promise数组，返回promise对象，该对象的状态永远为成功，该对象的值为一个数组，数组的元素为参数中每一个promise的当前值与当前状态。</p><p><strong>Promise.all(iterable)</strong></p><p>包含n个promise的数组(可迭代对象)，返回一个新的promise，所有promise都成功返回的新的promise状态才成功。<br>成功则返回一个数组，里面包含参数中promise成功的返回值，顺序与参数顺序一致。<br>失败则返回失败的原因。</p><h2 id="async与await"><a href="#async与await" class="headerlink" title="async与await"></a>async与await</h2><p>本质:Generator语法糖，async取代Generator函数的星号*.await取代的是yield</p><p>ES7的async/await进一步的优化Promise的写法，async函数始终返回一个Promise，await可以实现一个”等待”的功能，async/await被称为异步编程的终极解决方案，即用同步的形式书写异步代码，并且能够更优雅的实现异步代码顺序执行。</p><h3 id="1-async-函数"><a href="#1-async-函数" class="headerlink" title="1.async 函数"></a>1.async 函数</h3><p>async是’异步’的简写，用于申明这个函数是异步的。<br>函数的返回值为<strong>Promise对象</strong>，promise对象的结果由async函数执行的<strong>返回值</strong>决定。</p><h3 id="2-await-表达式"><a href="#2-await-表达式" class="headerlink" title="2.await 表达式"></a>2.await 表达式</h3><p>await相当于then的语法糖。<br>当await后面的表达式为promise，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，得到的结果就是promise成功的value。如果右侧表达不是promise，得到的结果就是它本身。</p><p><strong>注意：</strong><br>1.await必须放在async函数里面<br>2.await只能得到成功的结果，失败的结果需用try-catch<br>3.try catch只能捕获同步代码，不能捕获异步代码，在async函数内，使用await可以捕获异步代码，这里实际上是异步代码变成了同步代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Promise&quot;&gt;&lt;a href=&quot;#Promise&quot; class=&quot;headerlink&quot; title=&quot;Promise&quot;&gt;&lt;/a&gt;Promise&lt;/h2&gt;&lt;h3 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>promise链式调用顺序</title>
    <link href="http://yoursite.com/2020/07/28/promise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/07/28/promise链式调用顺序/</id>
    <published>2020-07-28T07:43:54.000Z</published>
    <updated>2020-07-29T13:16:24.025Z</updated>
    
    <content type="html"><![CDATA[<p><strong>第一题</strong></p><pre><code class="bash">    setTimeout(()=&gt;{        console.log(1);    },0)    Promise.resolve().then(()=&gt;{        console.log(2);    })    Promise.resolve().then(()=&gt;{        console.log(3);    })    console.log(4);    /*    输出：4 2 3 1     */</code></pre><p><strong>第二题</strong></p><pre><code>    setTimeout(() =&gt; {        console.log(1);    }, 0)    //Promise为构造函数    new Promise(resolve =&gt; {        console.log(2); //同步执行        resolve()//成功    }).then(() =&gt; { //成功的回调        console.log(3);    }).then(() =&gt; {//此处的then等上一个执行完之后再放入微队列执行        console.log(4);    })    console.log(5);//同步执行    /*    输出:2 5 3 4 1     */</code></pre><p><strong>注意：链式的then要等前一个then执行完毕才知道状态，才可以进入微队列执行。</strong></p><p><strong>第三题</strong></p><pre><code class="bash">  //定义了一个返回promise的函数     const first = () =&gt; (new Promise((resolve, reject) =&gt; {          console.log(1);  //同步执行1          //返回promise的函数          let p = new Promise((resolve, reject) =&gt; {              console.log(2); //同步执行2              //放入宏队列1              setTimeout(() =&gt; {                  console.log(3);                  resolve(4) //最后执行宏队列时状态已经修改，不再是等待，所以该行代码不执行              }, 0)              resolve(5) //立刻执行，p的状态立刻成功          })          resolve(6) //first的状态变成成功          //成功的回调放入微队列1          p.then((arg) =&gt; {              console.log(arg);          })      }))      //成功的回调放入为微队列2      first().then((arg)=&gt;{          console.log(arg);      })      console.log(7);//同步执行3      /*输出      1 2 7 5 6 3      开始：输出 1 2 7      宏[3]      微[5 6]      输出微队列：5 6      输出宏队列：3       */</code></pre><p><strong>第四题</strong></p><pre><code>    //加入宏队列1    setTimeout(()=&gt;{        console.log(0);    },0)    new Promise((resolve,reject) =&gt;{        console.log(1); //同步执行1        resolve()        //成功的回调加入微队列1    }).then(()=&gt;{        console.log(2);        new Promise((resolve, reject) =&gt; {            console.log(3);            resolve()            //成功的回调加入微队列3        }).then(()=&gt;{            console.log(4);            //成功的回调加入微队列5        }).then(()=&gt;{            console.log(5);        })        //成功的回调加入微队列4    }).then(()=&gt;{        console.log(6);    })    new Promise((resolve, reject) =&gt; {        console.log(7); // 同步执行2        resolve()        //成功的回调加入微队列2    }).then(()=&gt;{        console.log(8);    })    /*    输出：1 7 2 3 8 4 6 5 0    状态1：同步执行输出1 7 宏[0]  微[2 8]    状态2,执行微任务1（整个then）：输出2 3 宏[0]  微[8 4 6]    状态3,执行微任务2：输出 8 宏[0]  微[4 6]    状态4,执行微任务3：输出4 宏[0]  微[6 5]    ....    */</code></pre><p>这道题我错在6和5的顺序上面，不太懂为什么6在5前面。阅读了<a href="https://www.jianshu.com/p/aa3d8b3adde3" target="_blank" rel="noopener">一篇文章</a>之后才明白，下面是对知识点进行摘录+总结。</p><p><strong>知识点1</strong></p><p>当执行 then 方法时，如果前面的 promise 已经是 resolved 状态，则直接将回调放入微队列中。</p><p><strong>then方法是同步执行的，但是then中的回调是异步执行的。</strong></p><p>在同步执行then方法时，会进行判断：</p><ul><li>如果前面的 promise 已经是 resolved 状态，则会立即将回调推入微队列</li><li>如果前面的 promise 是 pending 状态则会将回调存储在 promise 的内部(不会被执行，也不会被放入微队列中)，一直等到 promise 被 resolve 才将回调推入微队列</li></ul><p><strong>知识点2</strong></p><p>resolve的作用除了将当前的 promise 由 pending 变为 resolved，还会遍历之前通过 then 给这个 promise 注册的所有回调，将它们<strong>依次放入微队列中</strong>，很多人以为是由 then 方法来触发它保存回调，而事实上是由 promise 的 resolve 来触发的，then 方法只负责注册回调。</p><p>对于 then 方法返回的 promise 它是没有 resolve 函数的，取而代之只要 then 中回调的代码执行完毕并获得同步返回值，这个 then 返回的 promise 就算被 resolve</p><pre><code> new Promise((resolve,reject) =&gt;{   console.log(1);   resolve()//第一个then }.then(()=&gt;{   ... //第二个then }).then(()=&gt;{ ... })</code></pre><p>首先Promise是实例化，同步执行函数，打印1，执行resolve函数，将 promise 变为 resolved，但由于此时 then 方法还未执行。由知识点2：resolve会触发保存它的回调。then是同步的，所以会依次保存第一个then和第二个then</p><p>[主]外部第一个 then，外部第二个 then [微] 空</p><p>然后执行第一then,由于前面的promise已经被resolve了，所以将第一then的回调放入微队列。</p><p>[主]外部第二个 then  [微]外部第一个 then的回调</p><p>但是这个回调还没有执行，所以第一then返回的promise 仍为 pending 状态，所以同步执行第二个then。由于前面的 promise 是 pending 状态，所以外2then 的回调也不会被推入微任务队列也不会执行</p><p>[主]空  [微]外一 then的回调</p><p>现在主线程空了，执行微任务，也就外一 then的回调，首先打印出2，随后实例化内部promise，打印3，执行resolve函数<br>,遍历then保存。</p><pre><code> new Promise((resolve,reject) =&gt;{ .... //外1  }.then(()=&gt;{   console.log(2);   new Promise((resolve, reject) =&gt;{   console.log(3);    resolve()   }.then(()=&gt;{   //内部第一个then     console.log(4);   }).then(()=&gt;{   //内部第二个then    console.log(5);   })  }  //外2  .then(()=&gt;{  .....  })</code></pre><p>[主]内1 then 内2的then  [微]空</p><p>然后执行内1的then，由于前面的 promise 已被 resolve，所以将回调放入微任务队列中。</p><p>[主]内2的then  [微]内1then的回调</p><p>然后执行内2的then，因为内部第一个then的回调还未执行所以状态为pending，所以内2then 的回调和外2then 的回调一样，不注册不执行。</p><p>[主]空  [微]内1then的回调</p><p><strong>外1的回调全部执行完毕</strong>，这里尤其注意:内2then的回调没执行，但是内2then是执行了的，相当于回调执行完毕。<br>外1then 返回的 promise 的状态由 pending 变为 resolved，同时遍历之前通过 then 给这个 promise 注册的所有回调，将它们的回调放入微任务队列中。</p><p>[主]空  [微]内1then的回调 外2then 的回调</p><p>主线程执行完毕，取出内1then的回调执行</p><p>[主]内1then的回调  [微]外2then 的回调</p><p>打印4，内1then返回的promise状态由 pending 变为 resolved，同时遍历之前通过 then 给这个 promise 注册的所有回调，将它们的回调放入微任务队列中。</p><p>[主] 空 [微]外2then 的回调 内2的回调</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;第一题&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;    setTimeout(()=&amp;gt;{
        console.log(1);
    },0)
    Promise.resolve().then(()=&amp;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>js异步:宏队列与微队列</title>
    <link href="http://yoursite.com/2020/07/28/%E5%AE%8F%E9%98%9F%E5%88%97%E4%B8%8E%E5%BE%AE%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/07/28/宏队列与微队列/</id>
    <published>2020-07-28T05:50:43.000Z</published>
    <updated>2020-07-28T10:48:39.796Z</updated>
    
    <content type="html"><![CDATA[<p>异步执行的函数(回调函数)放入队列中执行。队列分为宏队列与微队列。</p><p>宏队列：用来保存执行的宏任务（回调），比如：dom事件回调，ajax回调，定时器回调<br>微队列：用来保存执行的微任务（回调），比如：promise回调，mutation回调</p><p>1.JS为单线程引擎，必须先执行所有的初始化同步任务代码。<br>2.每次取出第一个宏任务<strong>执行前</strong>，都要将所有的微任务执行完毕。</p><p>注:取到栈里执行，若有嵌套的情况如下列代码，执行第一个setTimeout回调时，把里面的微任务放入微队列，执行第二宏任务前，先将所有的微任务执行完毕。</p><pre><code> setTimeout(()=&gt;{ //会立即放入宏队列        console.log(&quot;timeout callback1()&quot;);        Promise.resolve(3).then(            value =&gt;{ //会立即放入微队列                console.log(&quot;Promise onResolved3()&quot;,value);            }        )    },0)    setTimeout(()=&gt;{ //会立即放入宏队列        console.log(&quot;timeout callback2()&quot;);    },0)    Promise.resolve(1).then(        value =&gt;{ //会立即放入微队列            console.log(&quot;Promise onResolved1()&quot;,value);        }    )    Promise.resolve(2).then(        value =&gt;{ //会立即放入微队列            console.log(&quot;Promise onResolved2()&quot;,value);        }    )    /*    输出:Promise onResplved(),1          Promise onResplved(),2          timeout callback1()          Promise onResolved3()          timeout callback2())     */</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;异步执行的函数(回调函数)放入队列中执行。队列分为宏队列与微队列。&lt;/p&gt;
&lt;p&gt;宏队列：用来保存执行的宏任务（回调），比如：dom事件回调，ajax回调，定时器回调&lt;br&gt;微队列：用来保存执行的微任务（回调），比如：promise回调，mutation回调&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>数组的方法</title>
    <link href="http://yoursite.com/2020/07/27/%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/07/27/数组的方法/</id>
    <published>2020-07-27T13:02:27.000Z</published>
    <updated>2020-09-13T08:54:30.673Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h2><h3 id="slice-与splice"><a href="#slice-与splice" class="headerlink" title="slice()与splice()"></a>slice()与splice()</h3><p>语法:array.slice(start,end)<br>第一个参数截取开始的位置索引，包含<br>第二个参数为结束的位置索引，不包含</p><ul><li>不修改原数组</li><li>返回截取的新数组</li></ul><p>语法:array.splice(start,length,increase1,increase2..)<br>删除数组中的指定元素，并为数组添加新元素<br>第一个参数是开始的索引<br>第二个参数是删除的数量<br>第三个参数及以后是新添加的元素，添加的位置在开始索引之前。</p><ul><li>修改原数组</li><li>返回值为删除的元素，有添加的元素返回值是整个数组</li></ul><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><p>语法:array.concat(array2,array3..)<br>concat()可以连接两个或多个数组</p><p>如果是值直接放进去，如果是数组，取出值来再放进</p><ul><li>不修改原数组</li><li>返回值为新数组</li></ul><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p>语法:arrayy.join(连接符)<br>join()将数组转换为一个字符串，默认逗号</p><ul><li>不修改原数组</li><li>返回值为转换的字符串</li></ul><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h3><p>语法:array.reverse()<br>反转数组</p><ul><li>修改元素组</li></ul><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><p>语法:array.sort()<br>对数组中的元素进行排序,默认按照Unicode编码进行排序，默认<strong>升序</strong></p><ul><li>修改原数组</li></ul><p>指定排序的规则,浏览器将会分别使用数组中的元素作为实参去调用回调函数，回调函数需要定义两个形参。<br>浏览器根据回调函数的返回值来决定元素的顺序，<br><strong>返回值大于0</strong>则元素a、b交换位置,其余不变<br>语法:array.sort(function(a,b){<br>    //a一定在b前面,比如升序<br>    return a&gt;b?1: 0<br>    //return a-b 更简单<br>})</p><h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><p><strong>Array.from(v)</strong></p><p>把伪数组(字符串也可)转换为真数组<br>类数组(伪数组)最基本的要求就是具有length属性的对象,该类数组对象的属性名必须为数值型或字符串型的数字。</p><pre><code>let arrayLike = {    0: &#39;tom&#39;,    1: &#39;65&#39;,    2: &#39;男&#39;,    3: [&#39;jane&#39;,&#39;john&#39;,&#39;Mary&#39;],    &#39;length&#39;: 4}let arr = Array.from(arrayLike)console.log(arr) // [&#39;tom&#39;,&#39;65&#39;,&#39;男&#39;,[&#39;jane&#39;,&#39;john&#39;,&#39;Mary&#39;]]</code></pre><p>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。如下：</p><pre><code>  let arr = [1,2,2,2,3,4,5]    let set = new Set(arr)    console.log(Array.from(set, item =&gt; item + 1)) // [2,3,4,5,6]</code></pre><p><strong>Array.of(v1,v2,v3)</strong></p><p>将v1，v2..等元素转换成数组</p><p><strong>find()</strong></p><p>找到第一个满足条件返回true的元素</p><pre><code>let arr = [2,4,6]console.log(arr.find((value, index) =&gt; value &gt; 4));//输出6</code></pre><p><strong>findIndex()</strong></p><p>找到第一个满足条件返回true的元素下标</p><pre><code>let arr = [2,4,6]console.log(arr.findIndex((value, index) =&gt; value &gt; 4));//输出2</code></pre><p><strong>Array.prototype.includes(value)</strong></p><p>字符串与数组都有includes方法，判断数组中是否包含指定的value，返回值为布尔值。<br>以前判断用indexOf返回的是数字。</p><p><strong>Array.prototype.indexOf(value)/lastIndexOf(value)</strong></p><p>返回value在数组中出现的第一个下标和最后一下下标，没有出现则返回-1</p><p>应用场景：<br>两个方法结合判断下标是否相等，可以用来判断数组中唯一出现的值</p><p><strong>Array.prototype.flat()/flatMap()</strong></p><p>Array.prototype.flat()将多维数组转化为低维数组,从外层括号开始删，默认一次删一个，比如从三维到一维，需要删2个则flat()传参2</p><pre><code>const arr = [1,2,3,4,[5,6,[7,8]]]console.log(arr.flat())//输出[1,2,3,4,5,6,[7,8]]</code></pre><p>Array.prototype.flatMap()类似map()。先执行map在执行flat，也就是先返回数组再降低维度。</p><h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><h3 id="Array-prototype-forEach"><a href="#Array-prototype-forEach" class="headerlink" title="Array.prototype.forEach()"></a>Array.prototype.forEach()</h3><p>语法: array.forEach(function(currentValue, index, array){})<br>调用数组的每个元素，并将元素传递给回调函数。<br>第一个参数，当前遍历的元素。<br>第二个参数，当前遍历的元素索引<br>第三个元素，当前遍历的数组</p><p><strong>特点</strong></p><ul><li>不返回新数组</li><li>不能中断</li><li>对空数组不执行回调</li></ul><h3 id="Array-prototype-map"><a href="#Array-prototype-map" class="headerlink" title="Array.prototype.map()"></a>Array.prototype.map()</h3><p>语法: array.map(function(currentValue,index,arr), thisValue)</p><p>按照原始数组元素顺序依次处理元素，结果放在一个新数组里返回。</p><pre><code>/*------从接口得到数据------*/const users=res.items.map(item =&gt; ({    url: item.html_url,    img: item.avatar_url,    name: item.login,    }));</code></pre><p><strong>特点</strong></p><ul><li>返回新数组，不改变原始数组。</li></ul><h3 id="for-of-for-in"><a href="#for-of-for-in" class="headerlink" title="for-of / for-in"></a>for-of / for-in</h3><p><code>for-of</code>不仅仅可以遍历数组，<strong>具有iterator接口的，都可以使用<code>for-of</code>进行遍历</strong></p><pre><code>for (var value of arr) {      console.log(value); // 1,2,3}</code></pre><p>与<code>for-in</code>的区别：<br>1.for-in 获取的是<strong>键名</strong>，数组的键名是索引，for-of获取的是<strong>键值</strong><br>2.for-in 会遍历对象的整个原型链,性能非常差不推荐使用。</p><h3 id="Array-prototype-filter"><a href="#Array-prototype-filter" class="headerlink" title="Array.prototype.filter()"></a>Array.prototype.filter()</h3><p>语法：array.filter(function(currentValue,index,arr), thisValue)</p><p>创建一个新的数组，指定数组中符合条件的元素放入新数组。</p><p><strong>返回一个新数组，按照约定条件筛选数组元素时比较常用</strong></p><pre><code>/*-----去重问题----*/var arr = [1, 2, 2, 3, 4, 5, 5, 6, 7, 7,8,8,0,8,6,3,4,56,2];var arr2 = arr.filter((x, index,self)=&gt;self.indexOf(x)===index)console.log(arr2); //[1, 2, 3, 4, 5, 6, 7, 8, 0, 56]</code></pre><h3 id="every-some"><a href="#every-some" class="headerlink" title="every()/some()"></a>every()/some()</h3><p>ever<br>语法: array.every(function(currentValue,index,arr), thisValue)</p><p>对整个数组进行检查，如有一个元素不满足，整个表达式返回false，且其余元素不检查。否则返回true。</p><p><strong>不会改变原数组</strong></p><p>语法:array.some(function(currentValue,index,arr),thisValue)</p><p>对整个数组进行检查，如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。反之返回false。</p><p><strong>不会改变原数组</strong></p><p>这两个方法在实际开发中，大有可用之处。比如在判定用户是否勾选了不可操作的数据，或者是否勾选了一条可以操作的数据可以使用这两个方法遍历循环数组。</p><h3 id="reduce-reduceRight"><a href="#reduce-reduceRight" class="headerlink" title="reduce()/reduceRight()"></a>reduce()/reduceRight()</h3><p>语法:arr.reduce(callback,[initialValue])</p><p>callback （执行数组中每个值的函数，包含四个参数）</p><ul><li>previousValue 必选。上一次调用回调返回的值，或者是提供的初始值（initialValue）</li><li>currentValue 必选。数组中当前被处理的元素</li><li>index 可选。当前元素在数组中的索引。</li><li>arr    可选。当前元素所属的数组对象。</li></ul><p>initialValue （作为第一次调用 callback 的第一个参数。）</p><p>将数组元素做“叠加”处理，<strong>返回一个值。</strong> reduce方向从左向右，reduceRight方向从右向左</p><pre><code>var arr = [1, 2, 3, 4];var sum = arr.reduce(function(prev, cur, index, arr) {    console.log(prev, cur, index);    return prev + cur;})console.log(arr, sum);/*-----打印结果---*/1 2 13 3 26 4 3[1, 2, 3, 4] 10</code></pre><p>index是从1开始的，第一次的prev的值是数组的第一个值。数组长度是4，<strong>但是reduce函数循环3次。</strong></p><pre><code>var  arr = [1, 2, 3, 4];var sum = arr.reduce(function(prev, cur, index, arr) {    console.log(prev, cur, index);    return prev + cur;}，0) //注意这里设置了初始值console.log(arr, sum);/*----打印结果----*/0 1 01 2 13 3 26 4 3[1, 2, 3, 4] 10</code></pre><p>这个例子index是从0开始的，第一次的prev的值是我们设置的初始值0，数组长度是4，reduce函数循环4次。</p><p><strong>如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始</strong></p><p>对空数组来说，不设置初始值会报错，设置了初始值不会报错，所以一般来说我们提供初始值通常更安全。</p><p>使用场景也很多，具体可以看 <a href="https://www.jianshu.com/p/e375ba1cfc47" target="_blank" rel="noopener">参考文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数组的方法&quot;&gt;&lt;a href=&quot;#数组的方法&quot; class=&quot;headerlink&quot; title=&quot;数组的方法&quot;&gt;&lt;/a&gt;数组的方法&lt;/h2&gt;&lt;h3 id=&quot;slice-与splice&quot;&gt;&lt;a href=&quot;#slice-与splice&quot; class=&quot;header
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>字符串的方法</title>
    <link href="http://yoursite.com/2020/07/27/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/07/27/字符串的方法/</id>
    <published>2020-07-27T12:55:53.000Z</published>
    <updated>2020-07-29T13:52:09.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串的属性"><a href="#字符串的属性" class="headerlink" title="字符串的属性"></a>字符串的属性</h2><p>在底层字符串是以<strong>字符数组</strong>的形式保存的[“h”,”e”]</p><h2 id="charAt"><a href="#charAt" class="headerlink" title="charAt()"></a>charAt()</h2><p>语法：string.charAt()<br>根据索引获取指定的字符，返回值为获取的字符</p><h2 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h2><p>语法:string.concat(str1，str2….)<br>连接一个或多个字符串，返回值为新的字符串</p><h2 id="indexof"><a href="#indexof" class="headerlink" title="indexof()"></a>indexof()</h2><p>语法:string.indexof(“x”,start)<br>在string中寻找x的位置，找到返回索引，没找到返回-1<br>第一个参数为查找的字符<br>第二个参数为开始查找的位置<br>indexof()是从前往后找<br>lastindexof()是从后往前找</p><h2 id="slice-substring"><a href="#slice-substring" class="headerlink" title="slice()/substring()"></a>slice()/substring()</h2><p>语法:string.slice(start,end)<br>第一个参数截取开始的位置索引，包含<br>第二个参数为结束的位置索引，不包含</p><p>如果为-1值的是从后往前的第一个</p><ul><li>不修改原字符串</li><li>返回截取的字符串</li></ul><p>语法:string.substring(start,end)</p><p>与slice类似<br>区别：</p><ul><li>substring不可以传递负值，传了默认为0</li><li>如果第二个参数小于第一个参数，会自动调整参数的位置</li></ul><h2 id="toUpperCase-toLowerCase"><a href="#toUpperCase-toLowerCase" class="headerlink" title="toUpperCase()/toLowerCase()"></a>toUpperCase()/toLowerCase()</h2><p>语法：string.toUpperCase()</p><p>字符串转换成大写</p><ul><li>不修改原字符串</li><li>返回转化的大写字符串</li></ul><h3 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h3><p>语法：string.split(“,”)/string.split(/[0-9]/)<br>join()的功能相反,可以将一个字符串拆分为一个数组<br>参数为拆分规则,如例子的根据字符串里的逗号拆分数组,参数可以是正则表达式</p><p>默认全拆<br>不修改原字符串，返回值为数组</p><pre><code>let str=&quot;1a2b3c4d5e6f&quot;let result = str.split(/[0-9]/)//输出[a,b,c,d,e,f]</code></pre><h3 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h3><p>语法:string.search(搜索的内容)<br>搜索字符串中是否含有指定内容,返回<strong>第一次</strong>(g失效)出现的索引或者-1<br>参数是指定内容可以是正则表达式</p><h3 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h3><p>语法:string.match(条件)<br>根据正则表达式，从一个字符串中将符合条件的内容提取出来,返回值是<strong>数组</strong></p><p>默认返回符合条件的第一个内容<br>要找所有内容，开启全局匹配模式<br>可以为一个正则表达式设置多个匹配模式，顺序无所谓</p><pre><code>let str=&quot;1a2b3c4d5e6f&quot;let result = str.match(/[0-9]/g)//输出[1,2,3,4,5,6]</code></pre><h3 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h3><p>语法:string.search(被替换的内容，新的内容)<br>可以将字符串中指定内容替换为新内容，被替换的内容可以是正则表达式。</p><p>默认只替换第一个<br>不影响原来的字符串，返回新的字符串</p><p><strong>可以使用它去空格</strong></p><pre><code>//会去掉全部的空格str = str.replace(/\s/g,&quot;&quot;)//去掉开头的空格str = str.replace(/^\s*/,&quot;&quot;)//去掉结尾的空格str = str.replace(/\s*$/,&quot;&quot;)//去掉开头和结尾的空格str = str.replace(/^\s*|\s*$/g,&quot;&quot;)</code></pre><p>这里去掉字符串的头尾空格可以使用字符串的<strong>trim()</strong>方法</p><h2 id="字符串的扩展属性"><a href="#字符串的扩展属性" class="headerlink" title="字符串的扩展属性"></a>字符串的扩展属性</h2><p><strong>string.includes(str)</strong></p><p>判断是否包含指定的字符串<br>返回值：包含true,不包含false</p><p><strong>string.startsWith(str)</strong></p><p>判断是否以指定字符串开头<br>返回值：是true,否false</p><p><strong>string.endsWith(str)</strong></p><p>判断是否以指定字符串结尾<br>返回值：是true,否false</p><p><strong>string.repeat(count)</strong></p><p>指定目标字符串重复的次数<br>返回值:重复后的字符串</p><p><strong>string.trim()/string.trimStart()/string.trimEnd()</strong></p><p>trim()清除字符串左侧与右侧的空格<br>trimStart()清除字符串左侧的空格<br>trimEnd()清除字符串右侧的空格</p><p><strong>String.prototype.matchAll() 实用</strong></p><p>常用来获取正则批量匹配的结果，返回可迭代对象，可以用for of进行遍历或者扩展运算符展开。<br><strong>爬虫常用</strong></p><pre><code>let str = `&lt;ul&gt;          &lt;li&gt;            &lt;a&gt;ranan&lt;/a&gt;            &lt;p&gt;喜欢粉色&lt;/p&gt;         &lt;/li&gt;         &lt;li&gt;            &lt;a&gt;linin&lt;/a&gt;            &lt;p&gt;喜欢白色&lt;/p&gt;         &lt;/li&gt;         &lt;/ul&gt;         `const reg = /&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\/a&gt;.*?&lt;p&gt;(.*?)&lt;\/p&gt;/sgconst result = str.matchAll(reg)for (let v of result) {  console.log(v);  }//输出[exec匹配返回的结果1],[exec匹配返回的结果2]</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;字符串的属性&quot;&gt;&lt;a href=&quot;#字符串的属性&quot; class=&quot;headerlink&quot; title=&quot;字符串的属性&quot;&gt;&lt;/a&gt;字符串的属性&lt;/h2&gt;&lt;p&gt;在底层字符串是以&lt;strong&gt;字符数组&lt;/strong&gt;的形式保存的[“h”,”e”]&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>深度克隆</title>
    <link href="http://yoursite.com/2020/07/27/%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2020/07/27/拷贝/</id>
    <published>2020-07-27T11:46:18.000Z</published>
    <updated>2020-08-31T06:09:47.760Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深拷贝浅拷贝"><a href="#深拷贝浅拷贝" class="headerlink" title="深拷贝浅拷贝"></a>深拷贝浅拷贝</h2><p>深浅拷贝只是针对引用数据类型。</p><p>浅拷贝：修改拷贝以后的数据会影响原数据，拷贝的引用。使得原数据不安全。(只拷贝一层)<br>深拷贝：修改拷贝以后的数据不会影响原数据，拷贝的时候生成新数据。</p><p><strong>js的数据类型</strong></p><p>基本数据类型： Undefined、Null、Boolean、Number、String和Symbol(ES6)<br>引用数据类型： Object(Array, Date, RegExp, Function)</p><h2 id="拷贝数据的方法"><a href="#拷贝数据的方法" class="headerlink" title="拷贝数据的方法"></a>拷贝数据的方法</h2><p>1.引用类型直接赋值是浅拷贝<br>2.Object.assign()</p><pre><code>    let obj = {        a: {            a1: &#39;a1&#39;        },        b: &#39;b&#39;    }    let ass = Object.assign({}, obj);    ass.a.a1 = &#39;aaa&#39;;    ass.b=&quot;c&quot;    console.log(obj);    /*    输出：a:{a1:&quot;aaa&quot;},          b:&quot;b&quot;    */</code></pre><p>说明: Obejct.assign()只能对一层进行深拷贝,如果拷贝的层数超过了一层的话，那么就会进行浅拷贝。</p><p>这种克隆方式，只能克隆原始对象自身的值，不能克隆它的继承值。</p><pre><code>function clone(origin) {  return Object.assign({}, origin);}</code></pre><p>如果要保持继承链。</p><pre><code>function clone(origin) {  //Object.getPrototypeOf方法返回指定对象的原型（内部[[Prototype]]属性的值）  let originProto = Object.getPrototypeOf(origin);  //Object.create方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。  return Object.assign(Object.create(originProto), origin);}</code></pre><p>3.三点运算符<br>对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p><pre><code>let obj = {    a: {        a1: &#39;a1&#39;    },    b: &#39;b&#39;}let ass = {...obj};ass.a.a1 = &#39;aaa&#39;;ass.b = &#39;bbb&#39;console.log(obj); /*    输出：a:{a1:&quot;aaa&quot;},          b:&quot;b&quot;    */</code></pre><p>说明:扩展运算符只能对一层进行深拷贝,如果拷贝的层数超过了一层的话，那么就会进行浅拷贝。</p><p>Object.assign(）和展开原算符对于深浅拷贝的结果是一样。</p><p>4.Array.prototype.concat()</p><p>concat() 方法用于连接两个或多个数组。<br>该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。</p><pre><code>    let arr= [1,3,{name:&#39;ran&#39;}]      let arr2 = arr.concat()   // arr2[1]=55  //输出[1，3，{name:&#39;ran&#39;}]    arr2[3].name = &#39;ke&#39;    console.log(arr);    //输出 [1,3,{name:&#39;ke&#39;}]</code></pre><p>遍历arr数组时得到arr数组的元素，把该元素赋值给arr2对应的位置，当遍历的元素是对象时，因为对象的赋值浅拷贝，所有会改变原来的值。</p><p>5.Array.prototype.slice(startindex,endindex)</p><pre><code>  let arr= [1,3,{name:&#39;ran&#39;}]  let arr2 = arr.slice()  arr2[1]=55  arr2[2].name = &#39;ke&#39;  console.log(arr); // 输出[1,3,{name:&#39;ke&#39;}]</code></pre><p>因此，slice和concat这两个方法，仅适用于对不包含引用对象的一维数组的深拷贝</p><p>6.JSON.parse(JSON.stringify()) <strong>深拷贝</strong></p><p>JSON.stringify()：将JavaScript对象转换为JSON字符串<br>JSON.parse()：可以将JSON字符串转为一个对象。</p><pre><code>let arr= [1,3,{name:&#39;ran&#39;}]  let arr2 = JSON.parse(JSON.stringify(arr))  //在JSON.stringify()完成后，对象就转为了字符串，也就可以说实实在在的复制了一个字符串，字符串是基本数据类型。  arr2[1]=55  arr2[2].name = &#39;ke&#39;  console.log(arr);//输出[1,3,{name:&#39;ran&#39;}]</code></pre><p>缺点：拷贝会忽略undefined,symbol,function、也有可能导致原型链缺失。</p><p><strong>补充1</strong></p><p><strong>判断数组是否包含某对象，或者判断对象是否相等。</strong></p><p>转化成字符串比较。</p><pre><code>//判断数组是否包含某对象let data = [    {name:&#39;echo&#39;},    {name:&#39;听风是风&#39;},    {name:&#39;天子笑&#39;},    ],    val = {name:&#39;天子笑&#39;};JSON.stringify(data).indexOf(JSON.stringify(val)) !== -1;//true//判断两数组/对象是否相等let a = [1,2,3],    b = [1,2,3];JSON.stringify(a) === JSON.stringify(b);//true</code></pre><p><strong>补充2</strong></p><p>localStorage/sessionStorage默认只能存储字符串，而实际开发中，我们往往需要存储的数据多为对象类型，那么这里我们就可以在存储时利用json.stringify()将对象转为字符串，而在取缓存时，只需配合json.parse()转回对象即可</p><p><strong>补充3</strong><br>JSON.stringify()与toString()的区别，这两者虽然都可以将目标值转为字符串，但本质上还是有区别的。</p><pre><code>let arr = [1,2,3];JSON.stringify(arr);//&#39;[1,2,3]&#39;arr.toString();//1,2,3</code></pre><p>JSON.stringify常用于对象，toString()常用于数组</p><p><a href="https://www.cnblogs.com/echolun/p/9631836.html" target="_blank" rel="noopener">参考文章</a></p><h2 id="如何实现深拷贝？"><a href="#如何实现深拷贝？" class="headerlink" title="如何实现深拷贝？"></a>如何实现深拷贝？</h2><p>拷贝的数据里面不能有引用类型。如果有，只要拿到的是基本数据类型，然后再去赋值，就可以实现深拷贝</p><h3 id="如何判断数据类型"><a href="#如何判断数据类型" class="headerlink" title="如何判断数据类型"></a>如何判断数据类型</h3><p><code>typeof</code>返回的数据类型:<strong>String,Number,Boolean,Undefined,Object(Array,null也是),Function</strong>，不能准确的确定数据的类型。</p><p><strong>Object.prototype.toString.call()</strong></p><p><code>Object.prototype.toString.call()</code>可以区分各种类型，但它无法区分自定义对象类型，自定义类型可以采用instanceof区分。</p><pre><code>console.log(Object.prototype.toString.call(&quot;jerry&quot;));//[object String]console.log(Object.prototype.toString.call(12));//[object Number]console.log(Object.prototype.toString.call(true));//[object Boolean]console.log(Object.prototype.toString.call(undefined));//[object Undefined]console.log(Object.prototype.toString.call(null));//[object Null]console.log(Object.prototype.toString.call({name: &quot;jerry&quot;}));//[object Object]console.log(Object.prototype.toString.call(function(){}));//[object Function]console.log(Object.prototype.toString.call([]));//[object Array]console.log(Object.prototype.toString.call(new Date));//[object Date]console.log(Object.prototype.toString.call(/\d/));//[object RegExp]function Person(){};console.log(Object.prototype.toString.call(new Person));//[object Object]</code></pre><p>那么为什么<code>Object.prototype.toString.call()</code>可以区分？</p><p>toString方法返回反映这个对象的字符串（除了null和undefined之外）</p><pre><code>console.log({name:&quot;张三&quot;}.toString());//[object Object]console.log([1,2].toString());//1,2console.log(typeof [1,2].toString())//String</code></pre><p>obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？</p><p>因为toString为Object的原型方法，而Array,function等类型作为Object的实例重写了toString方法，调用toString方法时，优先调用的是重写之后的toString方法，所以要使用Object原型上的toString才可以反映对象的具体类型。</p><p><strong>获取标识类</strong></p><p>Object.prototype.toString.call()返回的是字符串类型的[object xxx],但是我们只需要后面的标识数据类型的xxx，可以使用Array的slice方法。</p><pre><code>let data = [1,3]//slice包含开始的位置，不包含结束的位置，结束位置为-1console.log(Object.prototype.toString.call(data).slice(8,-1));//Array</code></pre><h3 id="最终实现"><a href="#最终实现" class="headerlink" title="最终实现"></a>最终实现</h3><pre><code>//检测数据类型的功能函数function checkedType(target) { return Object.prototype.toString.call(target).slice(8,-1)}//实现深度克隆 数组/对象function  clone(target) {  let result,targetType=checkedType(target)    switch (targetType) {    case &#39;Object&#39;:        result = {};        break;    case &#39;Array&#39;:        result = []        break;    default:        return target}  //遍历，基本数据类型的赋值    for (let i in target){      //获取数据结构的每一项值      let value = target[i]      //判断目标结构里的每一值是否存在对象/数组       if (checkedType(value) === &#39;Object&#39; || checkedType(value) === &#39;Array&#39;){        //继续遍历获取到的value           result[i] = clone(value)       }else { //获取到的value值是基本的数据类型或者函数           result[i] = value       }    }    return result}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;深拷贝浅拷贝&quot;&gt;&lt;a href=&quot;#深拷贝浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;深拷贝浅拷贝&quot;&gt;&lt;/a&gt;深拷贝浅拷贝&lt;/h2&gt;&lt;p&gt;深浅拷贝只是针对引用数据类型。&lt;/p&gt;
&lt;p&gt;浅拷贝：修改拷贝以后的数据会影响原数据，拷贝的引用。使得原数据
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>对象的方法</title>
    <link href="http://yoursite.com/2020/07/27/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/07/27/对象的方法/</id>
    <published>2020-07-27T10:31:03.000Z</published>
    <updated>2020-08-31T06:53:04.592Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象的扩展属性"><a href="#对象的扩展属性" class="headerlink" title="对象的扩展属性"></a>对象的扩展属性</h2><p><strong>Obejct.setPrototypeOf/getPrototypeOf</strong></p><p>Obejct.setPrototypeOf(对象，对象的原型指向的元素)<br>设置原型<strong>proto</strong></p><p>Object.getPrototypeOf(对象)<br>获取指定对象的<strong>proto</strong>指向的值,没有返回null</p><p> <strong>Object.is(v1,v2)</strong></p><p>判断对象v1与v2是否完全相等。</p><pre><code>console.log(0 === -0)  //trueconsole.log(NaN == NaN)//false NaN与任何数都不相等console.log(Object.is(0,-0)) //falseconsole.log(Object.is(NaN,NaN))//true</code></pre><p>由上面代码可知该方式是以字符串是否相等来判断的</p><p><strong>Object.assign(target,source1,source2..)</strong></p><p>这个Object静态方法允许我们进行多个对象的合并，遍历需要合并给target的对象（仅可枚举属性），用等号进行赋值(这里可能有深浅拷贝的问题)</p><p><strong>注意</strong>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p><pre><code>const target = { a: 1, b: 1 };const source1 = { b: 2, c: 2 };const source2 = { c: 3 };Object.assign(target, source1, source2);target // {a:1, b:2, c:3}</code></pre><p><strong>常见用途</strong></p><p>1.<a href="https://biubiuins.github.io/2020/02/19/%E6%8B%B7%E8%B4%9D/" target="_blank" rel="noopener">关于拷贝的用法</a><br>2.为属性指定默认值</p><pre><code>```const DEFAULTS = {  logLevel: 0,  outputFormat: &#39;html&#39;};//options对象是用户提供的参数。function processContent(options) {  options = Object.assign({}, DEFAULTS, options);  console.log(options);  // ...}```</code></pre><p><strong>Object.keys(obj)</strong><br>获取对象自身的所有的键名，返回数组</p><p><strong>Object.values(obj)</strong><br>获取对象所有的值，返回数组</p><p><strong>Object.entries(obj)</strong><br>返回数组[[键名，键值],[键名，键值]]，此方法可以用于创建Map对象。</p><pre><code>const m = new Map(Object.entries(obj))</code></pre><p><strong>Object.fromEntries()</strong><br>用于创建一个对象，参数为二维数组或者Map</p><pre><code>Object.fromEntries([    [&quot;name&quot;,&quot;ranan&quot;],     [&quot;like&quot;,&quot;pink&quot;,&quot;white&quot;]])//{name:&quot;ranan&quot;,like:&quot;pink,white&quot;}</code></pre><p>Object.entries(obj)/Object.fromEntries(二维数组)互为逆运算。</p><p><strong>Object.create(prototype,[descriptors])</strong></p><p>作用：以指定对象为原型创建新的对象。为新的对象指定新的属性，并对属性进行描述</p><p>第一个参数指定原型，第二个参数为实例添加属性。</p><pre><code>let obj = {name:&quot;ranan&quot;,age:2}//第一个参数指定原型，第二参数为实例添加属性let obj1 = Object.create(obj,{sex:{    value:&quot;女&quot;,//value指定值    //属性的描述    writable:true,//标识当前属性是否可以被删除，默认为false    configurable:true,//表示当前属性是否可以被删除，默认为false    enumerable:true,//标识当前属性是否能用for-in枚举，默认false    }})//obj1的原型__proto__指向obj  console.log(obj1);</code></pre><p>克隆保持原型链</p><pre><code>function clone(origin) {  //Object.getPrototypeOf方法返回指定对象的原型（内部[[Prototype]]属性的值）  let originProto = Object.getPrototypeOf(origin);  //Object.create方法创建一个新对象，originProto为原型创建新对象  return Object.assign(Object.create(originProto, origin));</code></pre><p>getOwnPropertyDescriptor/getOwnPropertyDescriptors就是获取内部属性的描述,可以用于深层次的克隆。</p><pre><code>const obj = Object.create(null,{    //内部属性的描述    name:{        value:&#39;尚硅谷&#39;,        //属性特性        writable:true, //修改        configurable:true //删除        enumerable:true //枚举    }})</code></pre><p>如果不指定configurable, writable, enumerable ，则这些属性默认值为false，如果不指定value, get, set，则这些属性默认值为undefined。</p><p><strong>Object.defineProperties(object,descriptors)</strong></p><p>作用:为指定的object对象扩展多个属性</p><p>一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</p><p>Object的defineProperty/defineProperties主要功能就是用来定义或修改这些内部属性。</p><p>语法: Object.defineProperty(obj, prop, descriptor)</p><p>obj: 需要被操作的目标对象<br>prop: 目标对象需要定义或修改的属性的名称<br>descriptor: 将被定义或修改的属性的描述符</p><pre><code>var obj = new Object();Object.defineProperty(obj, &#39;name&#39;, {    configurable: false,    writable: true,    enumerable: true,    value: &#39;张三&#39;})console.log(obj.name)  //张三</code></pre><p>语法: Object.defineProperties(obj, props)</p><p>obj: 将要被添加属性或修改属性的对象<br>props: 该对象的一个或多个键值对定义了将要为对象添加或修改的属性的具体配置</p><p>方法直接在一个对象上定义一个或多个新的属性或修改现有属性，并返回该对象。</p><pre><code>var obj = new Object();Object.defineProperties(obj, {    name: {        value: &#39;张三&#39;,        configurable: false,        writable: true,        enumerable: true    },    age: {        value: 18,        configurable: true    }})console.log(obj.name, obj.age) // 张三, 18</code></pre><p>该方法的存储器属性(setter,getter)可以实现简单的数据双向绑定</p><pre><code>&lt;body&gt;   &lt;input type=&quot;text&quot; id=&quot;input1&quot;&gt;&lt;div&gt;    上面输入的数据是    &lt;span id=&quot;span&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;    let oInput1 = document.getElementById(&#39;input1&#39;);    let oSpan = document.getElementById(&#39;span&#39;);    let obj = {};    Object.defineProperties(obj, {    //惰性求值，get之后才有值        val1: {            configurable: true,//可修改            get: function() {                oInput1.value = 0;                oSpan.innerHTML = 0;                return 0            },            set: function(newValue) {                oSpan.innerHTML = newValue            }        },    })    //设置默认值为0 调用get方法    oInput1.value = obj.val1;    oInput1.addEventListener(&#39;keyup&#39;, function() {        //调用set方法        obj.val1 = oInput1.value;    }, false)&lt;/script&gt;</code></pre><p><strong>get/set propertyName(){}</strong></p><p>对象本身的两个方法，用法和上面的get/set一样</p><pre><code>let obj = {firstName:&quot;xx&quot;,lastName:&quot;xx&quot;, get fullName(){return this.firstName+ this.lastName}}</code></pre><p><strong>判断对象是否是数组/对象的元素/属性</strong><br>格式： 变量 in 对象/数组<br>当是数组时，变量指的是索引(不常用)<br>当是对象时，变量指的是对象的属性名</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;对象的扩展属性&quot;&gt;&lt;a href=&quot;#对象的扩展属性&quot; class=&quot;headerlink&quot; title=&quot;对象的扩展属性&quot;&gt;&lt;/a&gt;对象的扩展属性&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Obejct.setPrototypeOf/getPrototypeOf&lt;/stro
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>class类</title>
    <link href="http://yoursite.com/2020/07/26/js-%E7%B1%BB/"/>
    <id>http://yoursite.com/2020/07/26/js-类/</id>
    <published>2020-07-26T07:59:42.000Z</published>
    <updated>2020-08-29T04:47:27.245Z</updated>
    
    <content type="html"><![CDATA[<p>ES6的class可以看作只是一个语法糖，只是<br>让对象原型的写法更加清晰，更像面向对象编程的语言。</p><pre><code>//定义一个人物的类class Person{//类的构造方法,es5写在构造函数上的 constructor(){} //这里不需要逗号 //其余(原型)方法的写法必须使用该语法(静态的可以不用)。方法名(){}  es6简写 //es5写在原型上的,实例都可以使用 call(){ }}</code></pre><p>构造方法名字不能修改且当new实例对象时，会自动执行。<br><strong>注意</strong> 类里面方法的写法。方法名(){}</p><pre><code>console.log(typeof Person);//functionconsole.log(Person===Person.prototype.constructor);//true</code></pre><p>从上面的代码可以看出类实质上就是一个函数，可以任务ES6的类就是构造函数的另外一种写法。<br>实际上类的所有方法都定义在类的prototype属性上。<br>constructor内的属性可以称为实例属性（和前面说的实例成员一样）,constructor外声明的属性都是定义在原型上的，可以称为原型属性（即定义在class上)</p><p><strong>注意</strong>  <code>class</code>不存在变量提升，所以需要先定义再使用</p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>实例对象和函数对象的属性是独立的，实例对象的属性和该构造函数的原型上的属性是相通的。</p><p>实例对象和函数对象的独立属性称为<strong>静态成员/方法</strong>，只能函数对象使用。在ES6中，在方法/属性前加上<strong>static关键字</strong>，该类属性属于类不属于识类对象。</p><pre><code>class Foo{  static classMethod() {    return &#39;hello&#39;;  }}//Foo.classMethod()使用</code></pre><h3 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h3><p>私有属性前面加<code>#</code>,私有属性类外部直接获取不到结果会报错，只能通过类里面使用。</p><pre><code>class Person{  //公有属性  name;  //私有属性  #age;  constructor(name,age,weight){    this.name = name;    this.#age = age ;    this.#weight = weight;  }}</code></pre><h3 id="extends继承"><a href="#extends继承" class="headerlink" title="extends继承"></a>extends继承</h3><p>ES5的继承</p><pre><code>function Father(name,age){    this.name = name;    this.age = age;}Father.prototype.money= ()=&gt;{    console.log(&#39;父亲要上班&#39;);}function  Son(name,age) {    Father.call(this,name,age)}Son.prototype = new Father();Son.prototype.constructor = Son</code></pre><p>ES6的extends继承</p><pre><code>class Son extends Father{//子类的构造方法constructor(name,age,height){// 调用父类的构造方法，这里也要注意参数//父类的方法也会继承  super(name,age)  //子类自己的方法  this.height = height;}}</code></pre><p>子类继承父类相当于子类的<strong>proto</strong>指向父类Father。</p><p><strong>get和set</strong></p><pre><code>class Phone{    get price(){        console.log(&quot;该属性被读取了&quot;)        return &quot;属性调用的返回值&quot;    }    set price(newVal){         console.log(&quot;该属性被修改了&quot;)    }}let s = new Phone()s.prices.price = &quot;free&quot;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ES6的class可以看作只是一个语法糖，只是&lt;br&gt;让对象原型的写法更加清晰，更像面向对象编程的语言。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//定义一个人物的类
class Person{
//类的构造方法,es5写在构造函数上的
 constructor(){}
 //这里不
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>迭代器</title>
    <link href="http://yoursite.com/2020/07/26/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>http://yoursite.com/2020/07/26/迭代器/</id>
    <published>2020-07-26T02:15:09.000Z</published>
    <updated>2020-07-26T03:23:10.894Z</updated>
    
    <content type="html"><![CDATA[<p>iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署了iterator接口(对象里面的一个属性)，就可以用来完成遍历操作。</p><p>iterator接口是解构赋值，三点运算符，生成器，<code>for-of</code>循环的基础，主要供<code>for-of</code>消费。</p><p>默认具有iterator接口的数据结构有以下几个，注意普通对象默认是没有iterator接口的（可以自己创建iterator接口让普通对象也可以迭代）</p><ul><li>Array</li><li>Map</li><li>Set</li><li>String</li><li>TypedArray（类数组）</li><li>函数的 arguments 对象</li><li>NodeList 对象</li></ul><p>工作原理:<br>1.symbol.iterator对应的函数创建一个指针对象，指向数据结构的起始位置。<br>2.第一次调用next方法，指针自动指向数据结构的第一个成员<br>3.接下来不断调用next方法，直到指向最后一个成员<br>4.每次调用next方法返回的是一个包含value和done的对象</p><p>注意：第一个next方法是symbol.iterator对应函数执行的返回值，每次调用next方法返回的是一个包含value和done的对象{value:当前成员的值，done：布尔值}其中done对用的布尔值表示当前的数据的结构是否遍历结束。当遍历结束的时候返回的value值是undefined，done值为true</p><pre><code>let zimu = [a,b,c,d]//返回一个iterator对象,该对象对象里面有next方法let iterator = zimu[Symbol.iterator](); //调用对象的next方法,返回值{value:a,done:false}console.log(iterator.next()); </code></pre><p>1.可迭代的数据结构会有一个[Symbol.iterator]方法,<br>2.[Symbol.iterator]执行后返回一个iterator对象</p><p>自定义部署iterator接口</p><pre><code>let obj = {    data: [&quot;a&quot;, &quot;b&quot;],    [Symbol.iterator]() {        const self = this //用于返回值对象        let index = 0 //索引变量        return {//遍历器对象，返回iterator对象            next() {                if (index &lt; self.data.length) {                    return {                        value: self.data[index++],                        done: false                    }                } else {                    return {                        value: undefined,                        done: true                    }                }            }        }    }}</code></pre><h3 id="for-of"><a href="#for-of" class="headerlink" title="for..of"></a>for..of</h3><p>以前我们遍历数组中的元素的时，最开始使用的是for</p><pre><code>let arr = [1,2,3]for(let i = 0;i&lt;arr.length;i++){console.log(arr[i])//输出1，2，3}</code></pre><p>自ES5之后，可以使用<code>forEach</code></p><pre><code>arr.forEach(function (value) {    console.log(value);    //输出1，2，3});</code></pre><p>但是<code>foeEach</code>有两个缺点：<br>1.不能使用<code>break</code>语句中断循环<br>2.不能使用<code>return</code>语句返回到外层函数</p><p>ES6增加了<code>for-of</code>循坏，是现在简洁、最直接的<strong>遍历数组</strong>元素的语法。<code>for-of</code>不仅仅可以遍历数组，<strong>具有iterator接口的，都可以使用<code>for-of</code>进行遍历</strong></p><pre><code>for (var value of arr) {      console.log(value); // 1,2,3}</code></pre><p>与<code>for-in</code>的区别：<br>1.for-in 获取的是对象的键名，for-of获取的是键值<br>2.for-in 会遍历对象的<strong>整个原型链</strong>,性能非常差不推荐使用。</p><p><strong>使用场景</strong></p><p>1.对数组和Set结构进行结构赋值时<br>2.扩展运算符<br>3.yieId后面跟的是一个可遍历的结构<br>4.由于数组的遍历会调用遍历器接口，所以任何接收数组作为参数的场合其实都调用了遍历器接口。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署了iterator接口(对象里面的一个属性)，就可以用来完成遍历操作。&lt;/p&gt;
&lt;p&gt;iterator接口是解构赋值，三点运算符，生成器，&lt;code&gt;for-of&lt;/code&gt;循环的
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>箭头函数</title>
    <link href="http://yoursite.com/2020/07/24/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2020/07/24/箭头函数/</id>
    <published>2020-07-24T13:12:22.000Z</published>
    <updated>2020-07-24T13:54:36.844Z</updated>
    
    <content type="html"><![CDATA[<p>用处：常用在回调函数</p><p>let a = ()=&gt;{ … }</p><p>形参</p><ul><li>只有一个形参的时候，()可以省略</li><li>其余时候，()不能省略</li></ul><p>函数体</p><ul><li>函数体内只有一条语句或者表达式，{}可省略，省略后自动return</li><li>其余情况不可以省略，并且需要返回值时，需要加上return</li></ul><p>注意：由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</p><pre><code>//报错let getTempItem = id =&gt; { id, name: &quot;Temp&quot; };// 不报错let getTempItem = id =&gt; ({ id, name: &quot;Temp&quot; });</code></pre><p>特点：<br>1.箭头函数没有arguments，但是如果在箭头函数需要参数时，可以使用rest运算符来取代arguments<br>2.箭头函数没有prototype属性，不能用作构造函数（不能用new关键字调用）<br>3.箭头函数<strong>本身是没有this</strong>，它的this不是调用的时候决定的，而是<strong>声明时所在作用域下的this值</strong>。</p><pre><code>let obj = {   getName(){   btn2.onclick = ()=&gt;{   console.log(this)   }   }   }   obj.getName()   //输出obj    let obj = {    getName:()=&gt;{    btn2.onclick = ()=&gt;{    console.log(this)    }    }    }    obj.getName()   //输出window</code></pre><p>因此，箭头函数替代了以前需要显式的声明一个变量保存this的操作，使得代码更加的简洁。<br>还有一个好处在数组的迭代中使用箭头函数更加简洁，并且省略了return关键字。</p><pre><code>let arr = [1,2,3]arr.filter (item=&gt; item === 2)//[2]arr.map(item =&gt; item*2 ) //[2,4,6]arr.reduce((acc,cur) = acc+cur) //6</code></pre><p><strong>总结</strong></p><p>1.箭头函数适合与this无关的问题，定时器、数组的方法回调<br>2.箭头函数不适合与this有关的回调，事件回调，对象的方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用处：常用在回调函数&lt;/p&gt;
&lt;p&gt;let a = ()=&amp;gt;{ … }&lt;/p&gt;
&lt;p&gt;形参&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只有一个形参的时候，()可以省略&lt;/li&gt;
&lt;li&gt;其余时候，()不能省略&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;函数体&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数体内只有
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>es6(含之后的版本)</title>
    <link href="http://yoursite.com/2020/07/24/es6/"/>
    <id>http://yoursite.com/2020/07/24/es6/</id>
    <published>2020-07-24T04:51:14.000Z</published>
    <updated>2020-08-31T06:29:36.811Z</updated>
    
    <content type="html"><![CDATA[<h2 id="let-const"><a href="#let-const" class="headerlink" title="let/const"></a>let/const</h2><p>特点:</p><ul><li>不能重复定义</li><li>在块级作用域内有效,不影响作用域链</li><li>不存在变量提升</li><li>const不可以被修改，声明时必须赋值</li></ul><p>补充:<br>1.新增块级作用域：if、else\while、for后面的{}或者直接的{}<br>2.数组和对象常量的元素是可以修改的，因为常量地址是没有变化的。</p><p>变量的声明提前:使用var关键字声明的变量。会在所有的代码执行前被声明（但是不会赋值）<br>函数的声明提前：使用function 函数名{}声明的函数会在所有的代码执行前就被创建</p><p>使用let/const定义的变量在没声明前是无法使用的。</p><p>在循环使用中常用。如下述代码，结果会全部输出2，原因是：点击事件是回调函数进入队列，等同步执行的代码执行完毕之后，再执行,i是全局变量，此时的i已经是最后一次循环之后的i了。es6中的let也可以解决这个问题，因为let有自己的块级作用域，使用i值的时候，仅当次循环有用。</p><pre><code>//html  &lt;button&gt;测试1&lt;/button&gt;  &lt;button&gt;测试2&lt;/button&gt;  &lt;button&gt;测试3&lt;/button&gt;//js   let btns = document.getElementsByTagName(&quot;button&quot;);   for (var i = 0;i&lt;btns.length;i++) {   var btn = btns[i];    btn.onclick =function () {      alert(i)        }      }  //执行回调时此时的i已经是最后一次循环之后的i了     //{var i = 0} {var i = 1}   {var i = 2}          </code></pre><p>还有一点是let/const<strong>不属于顶层全局变量</strong>，不用担心污染全局的window对象。</p><pre><code>let a = 0console.log(window.a)//undefinedvar b = 1console.log(window.b)//1</code></pre><h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><p>理解：从对象或数组中提取数据，并赋值给变量(多个)。<br>常用：函数形参对象的解构赋值。</p><p>例：交换对象,解构的目标是数组，所以以数组的形式来接收。</p><pre><code>let a = 1let b = 2[a,b] = [b,a]//a=2 , b =1</code></pre><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>作用：简化字符串的拼接<br>使用：模板字符串必须用<code></code>包含，变化的部分使用${xxx}定义</p><h2 id="对象属性-方法简写"><a href="#对象属性-方法简写" class="headerlink" title="对象属性/方法简写"></a>对象属性/方法简写</h2><p>对象属性简写：当对象的属性和值相同时，省略属性名</p><ul><li>省略的是属性名而不是值</li><li>必须是一个变量</li></ul><p>方法的简写：当对象的属性是一个方法，可以使用简写形式。</p><pre><code>//es5let obj ={ func:function(){} }}//es6let obj2={ func(){}  //不太常用 func:()=&gt;{} //常用箭头函数}</code></pre><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p><a href="https://biubiuins.github.io/2020/07/24/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/" target="_blank" rel="noopener">箭头函数</a></p><h2 id="形参默认值"><a href="#形参默认值" class="headerlink" title="形参默认值"></a>形参默认值</h2><p>在定义函数时可以定义形参的默认值，当不传入参数的时候默认使用形参里的默认值。一般有默认值的形参放在最后。</p><pre><code>//定义形参默认值function add(a=0,b=1) {        return a+b}console.log(add());//输出1</code></pre><h2 id="…"><a href="#…" class="headerlink" title="…"></a>…</h2><p>rest参数<code>...</code> 把<strong>实参</strong>封装成数组，rest参数中的变量代表一个数组。主要用于形参，且rest参数之后不能有其他参数。<br>在ES9中，封装成对象也可以了。</p><p>剩余运算符：用来代替arguments，比arguments灵活。</p><p>补充:arguments.callee()方法的意思是：调用函数本身。</p><pre><code>function foo(...value){ //收集传过来的2，65两个元素console.log(value)//输出[2,65]是一个真数组}function foo(value){console.log(arguments)//2,65是一个伪数组}foo(2,65)</code></pre><p>扩展运算符<code>...</code>将<strong>数组转换为逗号分割的参数序列</strong>，常用于函数调用<br>ES9中也可以将对象转换为逗号分割的参数序列。</p><blockquote><p>扩展运算符可以和数组的解构赋值一起使用，但是必须放在最后一个，因为剩余/扩展运算符的原理其实是利用了数组的迭代器，它会消耗3个点后面的数组的所有迭代器，读取所有迭代器生成对象的value属性，剩余/扩展运算符后不能在有解构赋值，因为剩余/扩展运算符已经消耗了所有迭代器，而数组的解构赋值也是消耗迭代器，但是这个时候已经没有迭代器了，所以会报错</p></blockquote><pre><code>let [first,...arr]=[1,2,3,4,5]//不会报错let[...arr,last] = [1,2,3,4,5] //报错</code></pre><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>Symbol主要用于解决ES5的对象属性名都是字符串，容易造成属性名的冲突问题。是一种类似于字符串的数据类型。</p><p>Symbol是ES6中添加的新的数据类型(原来的有：String，Number,Boolean,Object,Null(空对象指针),Undefined(声明的变量未被初始化时))</p><p>特点:</p><ul><li>Symbol的值是唯一的，解决命名冲突问题。(类似id)</li><li>Symbol值不能与其他数据进行计算，包括同字符串拼接</li><li>Symbol可以转化为布尔值</li><li>Symbol定义的对象属性不能用for/in 循环遍历，可以使用Reflect.ownKeys来获取对象的所有键名。</li></ul><pre><code>//创建Symbol，通过Symbol函数创建 let symbol = Symbol();console.log(symbol) //输出Symbol//Symbol(&#39;对实例的描述&#39;),Symbol是唯一的与如何描述实例无关//对实例进行描述，主要是用于控制台输出时容易区分let s1 = Symbol(&quot;a&quot;)let s2 = Symbol(&quot;a&quot;)console.log(s1===s2) //false//Symbol.for 创建let s3 = Symbol.for(&quot;b&quot;)let s4 = Symbol.for(&quot;b&quot;)console.log(s3===s4) //true</code></pre><p>symbol的作用场景就是给对象添加属性/方法</p><p>1.当symbol作为对象的属性时，用[Symbol]形式，不用XX.Symbol形式。并且在定义的时候也需要加中括号<br>2.除了自己定义使用的Symbol值以外，ES6还提供了11个内置的Symbol方法，比如<code>Symbol.iterator</code>属性</p><p><strong>Symbol.prototype.description</strong></p><p>获取创建symbol实例时对其的描述。</p><h2 id="iterator迭代器"><a href="#iterator迭代器" class="headerlink" title="iterator迭代器"></a>iterator迭代器</h2><p><a href="https://biubiuins.github.io/2020/07/26/%E8%BF%AD%E4%BB%A3%E5%99%A8/" target="_blank" rel="noopener">iterator迭代器</a></p><h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><p>概念：ES6提供的解决异步编程的方案之一。</p><p>特点：<br>1.写法:<code>function函数名*</code><br>2.内部用yield表达式来定义不同的状态<br>3.其返回值是一个Iterator迭代器（指针对象）<br>4.通过调用返回值的next()方法执行函数内部语句</p><p>比如某个事物只有三种状态（状态A，状态B，状态C），而这三种状态的变化是 状态A =&gt; 状态B =&gt; 状态C =&gt; 状态A ，这就是状态机。Generator特别适用于处理这种状态机。</p><pre><code class="bash">// A，B，C三种状态循环function* state(){    while(1){        yield &#39;A&#39;;        yield &#39;B&#39;;        yield &#39;C&#39;;    }}  let status = state();//返回的是指针对象,迭代器对象//碰到yield返回console.log(status.next()); // 先暂停到A，后面的代码不执行，返回{value: &quot;A&quot;, done: false}console.log(status.next()); // 执行下一条指令，暂停到B，返回{value: &quot;B&quot;, done: false}console.log(status.next()); // {value: &quot;C&quot;, done: false}console.log(status.next()); // {value: &quot;A&quot;, done: false}console.log(status.next()); // {value: &quot;B&quot;, done: false}function* state(){        yield &#39;A&#39;;        yield &#39;B&#39;;        yield &#39;C&#39;;} for(let v of gen(){ console.log(v) //输出A,B,C})</code></pre><p>Iterator迭代器遍历结束时，返回的是：{value: undefined, done: true},Generator函数可以使用return来改变最后的返回值</p><p>next传的参数可以作为yield语句(默认返回undefined)的返回值。<br>第一个next表示启动，第二个next对应的才是第一个yieId语句。</p><pre><code>function * state(){    let result = yield &#39;hello&#39;    console.log(result)//输出xxx    }    let iterator = state()    iterator.next(&quot;aaa&quot;)    iterator.next(&quot;xxx&quot;)</code></pre><p><strong>实例</strong>如何实现异步</p><pre><code>//需求:1s 输出111，2s后输出 222，3s输出 333//定时器方法setTimeout(() =&gt; {    console.log(111);    setTimeout(() =&gt; {        console.log(222);        setTimeout(() =&gt; {            console.log(333);        }, 3000)    }, 2000)}, 1000)//使用生成器函数function one(){    setTimeout(()=&gt;{        console.log(111);        iterator.next();    },1000)}function two(){    setTimeout(()=&gt;{        console.log(111);        iterator.next()    },2000)}function three(){    setTimeout(()=&gt;{        console.log(111);        iterator.next()    },3000)}function * gen(){    yield one();    yield two();    yield three();}//调用生成器函数let iterator = gen()</code></pre><h2 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h2><p>Promise是JS中进行异步编程的新的解决方案，之前是纯回调的方法。</p><p>回调函数的一些缺点:<br>1.多重嵌套，导致回调地狱<br>    Promise引入了链式调用的概念，每个then方法同样也是一个promise，所以可以链式调用下去。其次将异步操作以同步的流程表达出来，更方便阅读。<br>2.不清楚回调是否都是异步调用的（可以同步调用ajax，在收到响应前会阻塞整个线程，会陷入假死状态，非常不推荐）<br>3.第三方库可能没有提供错误处理<br>    Promise在异步请求发送错误的时候，即使没有捕获错误，也不会阻塞主线程的代码</p><p>更深入的内容，在之前的博客中<a href="https://biubiuins.github.io/2020/01/08/promise/" target="_blank" rel="noopener">Promise学习笔记</a></p><h2 id="Set-Map容器"><a href="#Set-Map容器" class="headerlink" title="Set/Map容器"></a>Set/Map容器</h2><p>Set容器：无序不可重复的多个value的集合体,<strong>类似数组</strong>但成员唯一，集合实现了iterator接口。</p><ul><li>new Set(array)创建方法</li><li>add(value)添加方法</li><li>delete(value)删除方法</li><li>has(value)判断是否存在方法</li><li>clear()清空方法</li></ul><pre><code>let set = new Set([1,3,2,2])console.log(set);//输出唯一出现的值//add(value)添加方法set.add(7)console.log(set.size,set)//set.size相当于数组的length</code></pre><p><strong>遍历</strong><br>可以使用Set/Map<strong>实例对象</strong>的keys()，values()，entries()方法进行遍历。<br>由于Set的键名和键值是同一个值，它的每一个元素的key和value是相同的，所有keys()和values()的返回值是相同的，entries()返回的元素中的key和value是相同的。</p><pre><code>  let set = new Set([4, 5, &#39;hello&#39;])    for(let item of set.keys()) {        console.log(item) //输出4，5，hello    }    for(let item of set.values()) {        console.log(item) // 输出4，5，hello    }    for(let item of set.entries()) {        console.log(item) //[4,4],[5,5],[&#39;hello&#39;,&#39;hello&#39;]    }</code></pre><p>Map容器:Map是一组键值对(key-value，只取前两个元素)的结构,key不重复。</p><pre><code>let a = new Map()m.set(&#39;Adam&#39;, 67); //添加新的key-valuem.has(&#39;Adam&#39;);//是否存在key&quot;Adam&quot;  truem.get(&#39;Adam&#39;); //获得key为Adam的value  67m.delete(&#39;Adam&#39;);//删除key&quot;Adam&quot;m.clear() //清空Map容器</code></pre><p>一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉。</p><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p><a href="https://biubiuins.github.io/2020/07/26/class%E7%B1%BB/" target="_blank" rel="noopener">class类</a></p><h2 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h2><p>Number.EPSILON 属性的值表示JavaScript里面的最小值</p><p><strong>进制表示法</strong><br>二进制用0b，八进制用0o</p><pre><code>console.log(0b1010);//输出10</code></pre><p><strong>Number.isFinite(i)</strong></p><p>判断i是否有限大的数<br>返回值：是true,否false</p><pre><code>Number.isFinite(Infinity)//false</code></pre><p><strong>Number.isNaN(i)</strong></p><p>判断i是否NaN<br>返回值：是true,否false</p><p><strong>Number.isInteger(i)</strong></p><p>判断i是否整数<br>返回值：是true,否false</p><pre><code>Number.isInteger(120.0)//true</code></pre><p><strong>Number.parseInt(str)</strong></p><p>将字符串转换为对应的数值<br>返回值：对应的数值</p><p><strong>Math.trunc(i)</strong></p><p>直接i的去除小数部分<br>返回值:整数部分</p><p><strong>Math.sign(i)</strong></p><p>判断i是正数、负数、还是零</p><p><strong>指数运算符(幂)</strong></p><pre><code>  console.log(3 ** 3);  //3的3次方=27</code></pre><p><strong>BigInt</strong></p><p>在普通数据后面加上n，数据类型是大整型。用于很大的数值运算，只能大整型与大整型运算。</p><pre><code>//创建大整型let n = 521n//正数转化成大整型let n = 123console.log(BigInt(n)) //输出123n</code></pre><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>模块功能主要由两个命令构成<br>export 命令用于规定模块的对外接口<br>import 命令用于输入其他模块提供的功能</p><pre><code>//分别暴露export let name = &quot;ranan&quot;export let fun = function(){}//统一暴露export {name,fun}//默认暴露export default {   name : &quot;ranan&quot; ,   fun : function(){}}//通用导入的方式 as 别名 from 地址import * as data from &quot;path&quot; //如果是默认暴露方式，使用时应该是data.default.fun()//解构赋值形式,如果重复了可以使用as别名import {name,fun} from &quot;path&quot;import {name as na,function} from &quot;path&quot;//默认暴露的写法，必须要写别名import {default as data} from &quot;path&quot; //简便形式 针对默认暴露import data from &quot;path&quot;console.log(data) //输出{name : &quot;ranan&quot; ,fun : functio(){}}</code></pre><p><strong>动态import加载</strong></p><p>实现懒加载/按需加载,使用import()函数，返回值是promise对象,pormise返回的成功值就是暴露的对象。</p><pre><code>import(path).then(data =&gt; data.xx)</code></pre><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>Proxy也就是在目标对象之前设置一层拦截，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p><p>Proxy的作用</p><ul><li>拦截和监视外部对对象的访问</li><li>降低函数或类的复杂度</li><li>在复杂操作前对操作进行校验或对所需资源进行管理</li></ul><p>语法：new Proxy(target,handler)</p><ul><li>target就是被设置一层拦截的对象，可以是任何类型的对象(包括原生数组，函数，甚至另一个代理)</li><li>handler是一个对象，用来定制拦截行为</li></ul><p><strong>Proxy一般和Reflect配套使用,前者拦截对象,后者返回拦截的结果,Proxy上有的的拦截方法Reflect都有</strong></p><p><img src="/img/js/Proxy.png" width="50%"></p><p>1.set/get方法</p><p>set方法接收两个常用参数</p><ul><li>target：得到的目标值</li><li>key：目标的key值，相当于对象的属性</li></ul><p>set方法可以接收四个参数</p><ul><li>target:目标值。</li><li>key：目标的Key值。</li><li>value：要改变的值。</li><li>receiver：改变前的原始值。</li></ul><pre><code>    let handler = {        get:function (target,key) {            if (target.hasOwnProperty(key)){                return target[key]//key为属性名，target[key]为属性值            }            else{                console.warn(`对不起，没有这个${key}`)                return            }        },        set:function (target,key,value) {            console.log(&quot;set&quot;,target,key,value);            target[key] =value //设置了p.a才打印1        },        //删除属性        deleteProperty:function (target,key) {            console.log(`删除${key}属性的${target[key]}值`);            delete target[key]        },        // 拦截key in object操作        has(target, key) {            // 自定义限制：只暴露a属性            if (key === &#39;a&#39;) {                return target[key];            } else {                return false;            }        },    }    let p = new Proxy({},handler)    p.a=1 //set {} a 1    p.b=2    console.log(&#39;b&#39; in p); // false,没有暴露    console.log(&#39;a&#39; in p); //true    //console.log(p.a);    //delete p.b //删除了b属性的2值    //console.log(p.b); //undefined</code></pre><p>可以使用Proxy实现表单验证。</p><p>Object.defineProperty也可以实现数据拦截，Proxy有什么优势吗？<br>1.支持数组<br>数组的key是下标，对象的key是属性名</p><pre><code>    let arr = [1,2,3]    let proxy = new Proxy(arr, {        get (target, key, receiver) {            console.log(&#39;get&#39;, key)            return Reflect.get(target, key, receiver)        },        set (target, key, value, receiver) {            console.log(&#39;set&#39;, key, value)            return Reflect.set(target, key, value, receiver)        }    })    proxy.push(4)    // get push     (寻找 proxy.push 方法)    // get length   (获取当前的 length)    // set 3 4      (设置 proxy[3] = 4)    // set length 4 (设置 proxy.length = 4)</code></pre><p>2.Object.defineProperty()的升级版</p><p>外界对某个对象的访问，都必须经过这层拦截。因此它是针对整个对象，而不是对象的某个属性。</p><h2 id="可选链操作符"><a href="#可选链操作符" class="headerlink" title="可选链操作符"></a>可选链操作符</h2><p>可选链操作符<code>?.</code>允许读取一个被连接对象的深层次的属性的值而无需明确校验链条上每一个引用的有效性，类似<code>.</code>运算。<br><code>.</code>:如果对象链.上有数据为null或undefiend，操作符会抛出一个错误<br><code>?.</code>:如果对象链上有数据为null或undefiend，操作符则会按照短路计算的方式进行处理，返回 undefined。</p><p>比如读取一个对象的深层属性</p><pre><code>const obj = {  foo: {    bar: {      baz: 42,      fun: ()=&gt;{}    },  },};// 不使用?.  需要层层判断防止报错let baz = obj &amp;&amp; obj.foo &amp;&amp; obj.foo.bar &amp;&amp; obj.foo.bar.baz;// 使用?.  不需要层层判断let baz = obj?.foo?.bar?.baz; // 结果：42</code></pre><h2 id="绝对全局对象globalThis"><a href="#绝对全局对象globalThis" class="headerlink" title="绝对全局对象globalThis"></a>绝对全局对象globalThis</h2><p>不管是浏览器还是nodejs还是其他环境，<code>globalThis</code>永远表示全局对象，比如浏览器环境表示window，nodejs下表示global</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;let-const&quot;&gt;&lt;a href=&quot;#let-const&quot; class=&quot;headerlink&quot; title=&quot;let/const&quot;&gt;&lt;/a&gt;let/const&lt;/h2&gt;&lt;p&gt;特点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不能重复定义&lt;/li&gt;
&lt;li&gt;在块级作用域内有效
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript高级</title>
    <link href="http://yoursite.com/2020/07/22/JavaScript%E9%AB%98%E7%BA%A7/"/>
    <id>http://yoursite.com/2020/07/22/JavaScript高级/</id>
    <published>2020-07-22T12:36:14.000Z</published>
    <updated>2020-07-24T09:42:32.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>typeof返回数据类型的<strong>字符串</strong>表达,它的返回值都是’数据类型’</p><p>undefined -&gt; ‘undefined’<br>string -&gt; ‘string’<br>boolean -&gt;’boolean’<br>null -&gt; ‘object’  因为该类型只有一个值，所以可以用=== 来判断类型<br>object -&gt;’object’<br>object(function) -&gt; ‘function’<br>object(array) -&gt;’object’</p><p><strong>总结</strong><br>typeof不能明确的区别null和object、object和array</p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>可以使用instanceof对对象进行细分</p><p>A instanceof 构造函数</p><p>通过instanceof可以检查一个对象是否一个构造函数的实例，instanceof原来是寻找实例对象A的原型链</p><p>function -&gt; Function object -&gt; Object array-&gt; Array</p><p><strong>综合例题</strong></p><pre><code>let a = {    age: 12}function fu(obj) {    obj = {        age: 13    }}fu(a)console.log(a.age);//输出12//开始传参可以理解成obj=a，函数执行时obj重新指向另外一个空间//函数执行完毕函数作用域销毁，obj自动释放，obj所指对象的空间在后面的某个时刻由垃圾回收器回收</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p><a href="https://biubiuins.github.io/2020/02/23/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/" target="_blank" rel="noopener">回调函数</a></p><h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><p>防止污染全局命名空间,编写js模块<br>匿名函数自调用;(function(){})()</p><p><strong>分号的问题</strong><br>需要加分号的语句,一般js最终执行时会压缩。<br>1.小括号开头的前一条语句，如匿名函数自调用<br>2.中括号开头的前一条语句</p><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p><a href="https://biubiuins.github.io/2020/07/15/this%E6%8C%87%E9%92%88/" target="_blank" rel="noopener">this指针</a></p><h2 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h2><p><a href="https://biubiuins.github.io/2020/07/15/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/" target="_blank" rel="noopener">原型与原型链</a></p><h2 id="变量提升与函数提升"><a href="#变量提升与函数提升" class="headerlink" title="变量提升与函数提升"></a>变量提升与函数提升</h2><p>通过var声明的变量，会被提升。定义的函数，可以在定义语句前执行，这就是函数提升。</p><pre><code>var a=3function fu(){    console.log(a)    var a = 4     //输出undefined 局部函数定义个变量a会提升到函数的最开始}fn()</code></pre><p>在全局代码执行前，JS引擎会创建一个栈来存储管理所有的执行上下文。在全局执行上下文(window)确定后，将其添加到栈中，在函数执行上下文(调用函数时产生)，将其添加到栈中。在当前函数执行完后，函数执行上下文出栈，最后所有代码执行完后，栈中只剩下window</p><p>作用域是静态的，开始就存在且不会变化。函数上下文是动态的。</p><pre><code>var x = 10;//fn作用域，开始就存在了function fn(){    console.log(x)}//show作用域function show(f){    var x = 20    f() //执行时先在fn的作用域里面找x是不存在的，然后再从全局作用域中找 所以输出10}show(fn) //输出10</code></pre><p><strong>全局执行上下文</strong></p><p>在执行全局代码前，将window确定为全局执行上下文<br>对全局数据进行预处理:<br>var 定义的全局变量 -&gt; undefined 添加为window的属性<br>function 声明的全局函数 -&gt; 赋值，添加为window的方法<br>this -&gt; 赋值(window)<br>开始执行全局代码</p><p><strong>函数执行上下文</strong><br>在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象（虚拟对象，因为函数执行完毕会销毁）<br>对局部数据进行预处理:<br>1.函数的上下文对象 this<br>2.封装<strong>实参</strong>的对象 arguments 是一个类数组对象/有length、可以通过索引操作的对象<br>3.形参变量 -&gt; 赋值 -&gt; 添加为执行上下文的属性<br>其余类似全局执行上下文</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><a href="https://biubiuins.github.io/2020/02/23/%E9%97%AD%E5%8C%85/" target="_blank" rel="noopener">闭包</a></p><h2 id="宏队列与微队列"><a href="#宏队列与微队列" class="headerlink" title="宏队列与微队列"></a>宏队列与微队列</h2><p><a href="https://biubiuins.github.io/2020/02/16/%E5%AE%8F%E9%98%9F%E5%88%97%E4%B8%8E%E5%BE%AE%E9%98%9F%E5%88%97/" target="_blank" rel="noopener">宏队列与微队列</a></p><p><strong>H5 Web Workers(多线程)</strong></p><p>Web Workers 是 HTML5 提供的一个javascript多线程解决方案（常用于计算），但是子线程完全受主线程控制，且不得操作DOM，所以这个新标准并没有改变javascript单线程的本质。</p><p>1.创建一个分线程执行的js文件</p><p><strong>分线程的全局对象不再是window了</strong>，所以分线程不得操作DOM</p><pre><code>var onmessage = function(event){    //不能用函数声明，只能用赋值的形式    var upper = event.data //通过event.data获得主线程发来的数据    postMessage(upper) //将数据发给主线程}</code></pre><p>2.在主线程中的js中发消息并设置回调</p><pre><code>//创建一个Woker对象var worker = new Worker(&quot;分线程执行的js文件地址&quot;)//向分线程发送消息worker.postMessage(&quot;向分线程执行的js发送数据&quot;)//接收worker传过来的数据函数worker.onmessage = function(event){    alert(event.data) //分线程返回的数据在event.data里面}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;判断数据类型&quot;&gt;&lt;a href=&quot;#判断数据类型&quot; class=&quot;headerlink&quot; title=&quot;判断数据类型&quot;&gt;&lt;/a&gt;判断数据类型&lt;/h2&gt;&lt;h3 id=&quot;typeof&quot;&gt;&lt;a href=&quot;#typeof&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>BOM</title>
    <link href="http://yoursite.com/2020/07/21/BOM/"/>
    <id>http://yoursite.com/2020/07/21/BOM/</id>
    <published>2020-07-21T03:30:48.000Z</published>
    <updated>2020-07-22T14:40:27.305Z</updated>
    
    <content type="html"><![CDATA[<p>BOM 浏览器对象模型，可以通过js代码操作浏览器</p><p>BOM对象<br>window代表的是整个浏览器窗口，同时window也是网页中的全局对象<br>navigator代表的当前浏览器的信息，通过该对象识别不同的浏览器<br>location代表当前浏览器的地址栏信息，可以操作页面重定向<br>history代表浏览器的历史记录，可以通过该对象操作浏览器的历史记录，由于隐私获取不到具体的历史记录，只能操作浏览器后退与前进，只在当次访问时有效<br>screen代表用户的屏幕信息</p><p>这些BOM对象在浏览器中作为window对象的属性保存，可以通过window对象来使用，也可以直接使用。</p><h2 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h2><p>由于历史原因，navigator对象中的大部分属性都已经不能帮助我们识别浏览器了。<br>一般只会使用userAgent属性来判断浏览器的信息<br>/chrom/i.test(navigator.userAgent) 测试是否是chrom浏览器,但是最新的IE判断不出来了</p><h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><p>history.length 可以获取当前访问了的页面数<br>history.back() 返回上一个页面，类似浏览器的回退按钮<br>history.forword() 可以跳转到下一个页面，类似浏览器前进<br>history.go(整数) 可以跳转到指定页面 -1回退一个界面，1前进一个页面</p><h2 id="location"><a href="#location" class="headerlink" title="location"></a>location</h2><p>如果直接打印location，则可以获得当前页面的完整路径<br>通过location修改的路径，会有历史记录(可回退)。</p><p>location.assign(path) 用来跳转到其他页面，类似直接修改location路径。<br>location.reload() 刷新页面，默认会情况缓存。<br>location.replace(path) 用新页面代替当前页面，不会生成历史记录。</p><h2 id="window"><a href="#window" class="headerlink" title="window"></a>window</h2><p><strong>定时器</strong></p><p>setInterval(回调函数,时间)<br>回调函数每个一段时间就被调用一次。<br>返回一个Number类型的数据，用于标识定时器，利用返回值可以关闭定时器<br>clearInterval(标识是哪一个定时器)，可以接收任意参数，如果参数不是一个有效的标识，也不会报错只是什么 都不做。</p><p>为了防止开启多个定时器，导致定时器重叠，<strong>在开启定时器之前，需要将上一个定时器关闭。</strong></p><p><strong>延时调用</strong><br>延时调用一个函数不马上执行，而是隔一段时间后在执行，而且只会执行一次<br>setTimeout(回调函数,时间)<br>clearTimeout(标识是哪一个定时器)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;BOM 浏览器对象模型，可以通过js代码操作浏览器&lt;/p&gt;
&lt;p&gt;BOM对象&lt;br&gt;window代表的是整个浏览器窗口，同时window也是网页中的全局对象&lt;br&gt;navigator代表的当前浏览器的信息，通过该对象识别不同的浏览器&lt;br&gt;location代表当前浏览器的地
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>DOM</title>
    <link href="http://yoursite.com/2020/07/18/DOM/"/>
    <id>http://yoursite.com/2020/07/18/DOM/</id>
    <published>2020-07-18T02:30:57.000Z</published>
    <updated>2020-08-21T05:42:18.861Z</updated>
    
    <content type="html"><![CDATA[<p>DOM全程Document Object Model文档对象模型。文档表示的是整个的HTML网页文档;对象表示将网页中的每一个部分都转换成了一个对象;模型来表示对象之间的关系,方便我们获取对象。</p><p>Document对象：实际上是window对象的属性。这个对象的独特之处是唯一一个既属于BOM又属于DOM的对象。在页面中可以直接使用，代表的是整个网页。</p><p><strong>注意点</strong></p><p>1.取消默认行为可以通过在响应函数的最后return false来取消默认行为，或者使用event.preventDefault()<br>2.如果需要读取元素节点属性，直接使用 元素.属性名，但是class属性不能采用这种方式，需要使用className。<br>3.window.onload = function(){<br>//页面加载完之后再执行，确保所有的DOM对象已经加载完毕<br>}</p><p>node.nodeType 得到节点类型</p><pre><code class="js">//比如:&lt;div id=&quot;test&quot;&gt;xxxx&lt;/div&gt;//标签节点const elementNode = ducument.getElementById(&quot;test&quot;)//属性节点const attrNode = elementNode.getAttributeNode(&quot;id&quot;)//textNode.textContent === xxxx//文本节点const textNode = elementNode.firstChild</code></pre><h2 id="DOM查询"><a href="#DOM查询" class="headerlink" title="DOM查询"></a>DOM查询</h2><p>innerText 获取到元素内部的文本内容，会自动将html标签去除<br>innerHTML 获取到元素内部的文本内容，会保存html标签</p><p><strong>获取元素节点，通过document对象调用</strong><br>document.getElementById() 通过id获取dom<br>document.getElementsByClassName() 通过类名获取dom<br>document.getElementsByName() 通过name属性获取dom<br>document.getElementsByTagName() 通过标签名获取dom<br>document.querySelector()  该方法总会返回唯一的一个元素document.querySelectorAll() 返回数组。</p><p><strong>获得元素节点的子节点，通过具体的元素节点调用</strong><br>getElementsByTagName() 方法，返回当前节点指定标签名的后代节点<br>childNodes 属性，表示当前节点的所有子节点,会获取包括文本节点在内的所有结点，DOM标签与标签之间的换行也会看成文本结点。<br>children 属性可以获取当前元素的所有子元素<br>firstChild 属性，表示当前节点的第一个子节点，包括空白文本结点<br>firstElementChild 属性获取当前元素的第一个子元素<br>lastChild  属性，表示当前节点的最后一个子节点</p><p><strong>获取父节点和兄弟结点,通过具体的节点调用</strong><br>parentNode 属性，表示当前节点的父节点<br>previousSibling 属性，表示当前节点的前一个兄弟节点，可能会获取到空白文本<br>previousElementSibling 属性，表示当前节点的前一个兄弟元素<br>nextSibling 属性，表示当前节点的后一个兄弟节点</p><p><strong>补充</strong><br>获取body,document中有一个属性body，它保存的就是body的引用<code>document.body</code></p><p>获取html,<code>document.documentElement</code></p><h2 id="DOM-增删改"><a href="#DOM-增删改" class="headerlink" title="DOM 增删改"></a>DOM 增删改</h2><p>document.createElement() 参数为标签名，用于创建一个元素节点对象，并返回创建好的对象<br>document.createTextNode() 参数为文本内容，根据内容创建文本节点，并返回新的节点<br>父节点.appendChild() 向一个父节点中添加新的子节点<br>父节点.insetBefore() 在指定的子节点前插入新的子节点,(新节点,旧节点)<br>父节点.replaceChild() 使用指定的子节点替换已有的子节点，(新节点,旧节点)<br>父节点.removeChild() 删除一个子节点</p><h2 id="DOM操作css"><a href="#DOM操作css" class="headerlink" title="DOM操作css"></a>DOM操作css</h2><p>js通常返回的是<strong>不带单位的数值</strong></p><p><strong>内联样式</strong></p><p>语法:元素.style.样式名 = 样式值</p><p>如果css的样式名中含有-,需要改成驼峰命名法。<br>通过style属性<strong>设置/读取</strong>的样式都是<strong>内联样式</strong>，内联样式有很高的优先级。</p><p>通过style属性来修改元素的样式，每修改一个样式，浏览器需要重新渲染一次页面</p><p>如果要同时修改多个样式，直接通过类名修改<br>对象.className = “”</p><p><strong>当前正在显示的样式</strong><br>语法:元素.currentStyle.样式名</p><p>只有ie浏览器支持,没设置的值获取默认值，其他浏览器可以使用<code>window.getComputedStyle()</code>来获取。</p><p>第一个参数是要获取样式的元素<br>第二个参数可以传递伪元素，一般都传null<br>返回值是当前元素对应的样式的对象,后接样式名获取样式<br>如果该样式没设置获取到的是真实值而不是默认值</p><p><strong>通过以上两种方式获取到的样式都是只读的,如果需要修改只能使用style属性</strong></p><p><strong>处理兼容性问题</strong></p><p>定义一个函数来获取指定元素当前的样式，参数obj要获取样式的元素，style要获取的样式名字符串</p><pre><code>function getStyle(obj,style){if(window.getComputedStyle){//正常浏览器有getComputedStyle方法return getComputedStyle(obj,null)[style]}else{//IE8浏览器没有定义getComputedStylereturn obj.currentStyle[style]}}</code></pre><p><strong>注意</strong>if里面用getComputedStyle不行，要用window.getComputedStyle<br>没使用window时getComputedStyle是一个变量需要去作用域中寻找，没定义就是用会报错，后续代码不会执行<br>使用window之后属于属性，没找到属性返回undefined</p><p><strong>其他样式相关属性</strong></p><p>element.clientWidth/clientHeight<br>这两个属性可以获取元素的<strong>可见(内容和内边距)</strong>宽度和高度,返回的是<strong>数字，不带px</strong>，因为包括的是可见区域所以设置起来无法分配,所以这两个属性都是只读属性。<br>element.offsetWidth/offsetHeight<br>获取元素的整个大小,包括内容、内边距、边框，其他特点与clientWidth/clientHeight属性相似。</p><p>element.offsetParent<br>可以获取当前元素的<strong>定位</strong>父元素,都没有定位返回body<br>element.offsetLeft/offsetTOP<br>当前元素相对于其定位的水平偏移量和垂直偏移量<br>element.scrollHeight/scrollLeft/scrollTop/scrollWidth<br>表示元素整个滚动区域的宽度/高度,可以获取滚动条滚动的距离<br>当满足下面等式的时候，说明滚动条滚动到最底，水平滚动条类似。<br>总长度 - 看不见的长度 = 可见的长度<br>element.scrollHeight - element.scrollTop = clientHeight </p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>当事件的响应函数被触发时，浏览器每次都会将一个<strong>事件对象</strong>(event)作为实参传递给响应函数，封装当前事件相关的一切信息，比如：鼠标坐标，键盘哪个键被按。但是IE8不会传,事件对象作为window对象的属性保存的window.event</p><p>可以使用 event = event || window.event 来解决兼容性问题</p><p><strong>事件对象</strong><br>event.clientX 可以获取鼠标指针的水平坐标，返回数值，不带单位<br>event.clientY 可以获取鼠标指针的垂直坐标，返回数值，不带单位<br>用于获取鼠标在当前的<strong>可见窗口</strong>的坐标<br>event.pageX/event.pageY获取鼠标相对于<strong>当前页面</strong>(document)的坐标,但是IE8不支持，可以通过对top = scrollTop + clientX实现<br>offsetX/offsetY  screenX/screenY<br><img src="/img/js/event.png"></p><p>补充:chrome认为浏览器的滚动条是body的，通过body.scrollTop获取，但是火狐等浏览器认为是html的，通过documentElement.scrollTop获取</p><blockquote><p>现在浏览器的滚动条都是html的了</p></blockquote><p>event.wheelDalta 获得滚轮的方向 正向上滚，负向下滚<br>event.target 触发事件的对象<br>event.keyCode 获取按键的编码 event.altKey/ctrlKey/shiftKey判断alt/ctrl/shift是否被按下</p><p>onscroll 该事件会在元素的滚动条滚动时触发<br>onmousemove 该事件会在鼠标在元素中移动时被触发<br>onmousedown 该事件会在鼠标按下被触发<br>onmouseup 该事件会在鼠标弹上被触发<br>onwheel 该事件会在鼠标滚轮滚动时被触发</p><p>onmouseenter/onmouseleave 与 onmouseover/onmouseout 区别是前面的一组移入子元素是不会触发的</p><p>键盘事件一般绑定给可以获取焦点的对象或者是document<br>onkeydown 键盘按下触发，一直按着不松手会连续触发，<strong>在文本框中输入内容，属于onkeydown的默认行为</strong>根据此性质可以限定文本框内容输入的类型<br>onkeyup  按键被松开，不会连续触发</p><p><strong>事件的冒泡</strong><br>所谓的冒泡指的是事件向上传递，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发。<br>在开发中大部分情况冒泡都是有用的，如果不希望发生事件冒泡可以通过事件对象取消冒泡<br>event.cancelBubble = true</p><p><strong>事件的委派</strong><br>需求场景：给a标签绑点点击事件，后添加的a标签也有该绑定事件。<br>解决:可以尝试把时间绑定到元素共有的祖先元素。<br>事件委派利用了冒泡，从父元素到子元素</p><p><strong>事件的绑定</strong></p><p>对象.事件 = 函数 的形式绑定响应函数，同时只能为一个事件绑定一个响应函数</p><p>addEventListener可以为一个事件同时绑定多个响应函数，后面的不会覆盖前面的<br>对象.addEventListener() 第一个参数事件的字符串，不要on，第二个参数时间触发时的回调函数，第三个参数是否在捕获阶段触发事件，一般都是false</p><p><strong>DocumentFragment</strong><br>文档片段接口，高效批量更新多个节点(只更新一次)<br>一个fragment对象就是内存中的节点容器(只存在于内存中、页面不显示)</p><p>用一个fragment对象包裹住需要更新的节点（原处的节点消失了，因为节点的父节点只能有一个），处理fragment的所有子节点，将fragment添加为div的子节点(fragment不会进入div,fragment的所有子节点进入div)</p><p>由于处理fragment的所有子节点都是在内存中进行的不更新界面，最后把fragment的所有子节点添加进div时才更新界面，所以实现了页面仅更新一次就批量操作多个节点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;DOM全程Document Object Model文档对象模型。文档表示的是整个的HTML网页文档;对象表示将网页中的每一个部分都转换成了一个对象;模型来表示对象之间的关系,方便我们获取对象。&lt;/p&gt;
&lt;p&gt;Document对象：实际上是window对象的属性。这个对象的
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://yoursite.com/2020/07/16/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/07/16/正则表达式/</id>
    <published>2020-07-16T13:56:06.000Z</published>
    <updated>2020-08-20T07:43:01.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>创建正则表达式的对象</p><p>构造函数方式<br>语法:let 变量 = new RegExp(“正则表达式”,”匹配模式”)<br>字面量方式<br>语法:let 变量 = /正则表达式/匹配模式</p><p><a href="https://www.w3school.com.cn/jsref/jsref_obj_regexp.asp" target="_blank" rel="noopener">具体用法</a></p><p><strong>匹配模式</strong><br>i 忽略大小写<br>g 全局匹配模式</p><p><strong>test()</strong><br>检查一个字符串是否符合正则表达式的规则<br>参数为被检查的字符串<br>返回值为布尔值</p><pre><code>//正则表达式规则:字符串是否含有alet reg = new RegExp(&quot;a&quot;)let str = &quot;a&quot;reg.test(str)</code></pre><p><strong>或</strong><br>|表示或 reg=/a|b/ -&gt; a或者b<br>[]里的内容也是或 reg=/a-z/ -&gt; 任意的小写字母<br>[^ ] 查找任何除了[]里的字符 reg=/[^ab]/ -&gt; 除了a或b的字符</p><pre><code>//以a开头c结尾中间是b或d或ereg = /a[bde]c///c是除了ab的字符，所以返回truereg = /[^ab]/reg.test(&#39;abc&#39;)</code></pre><p><strong>量词</strong><br>通过量词可以设置一个内容出现的次数，量词只对它前面的一个内容起作用，如果要对多个加括号。</p><p>a{n} 表示n个连续的a<br>a{1,3} 表示最少一个a最多3个连续a<br>a+ 表示至少一个a,{1,}<br>a* 表示0个或多个,{0,}<br>a? 表示0个会1个,{0,1}<br>^a 表示以a开头<br>a$ 表示以a结尾</p><p>注意: ^a$只表示a</p><p><strong>元字符</strong></p><p>.表示任意字符,如果要检查.需要转义/./,new RegExp(“\.”)<br><strong>使用构造函数时，它的参数是一个字符串，而\是字符串中转义字符，所以使用\需要转义成\使用</strong><br>\w 任意字母、数字、_ 相当于[A-z0-9_]<br>\W 除了字母、数字、_ 相当于[^A-z0-9_]<br>\d 任意的数字<br>\D 除了数字<br>\s 空格 \S除了空格<br>\b 单词边界，\bxxx\b独立的单词 \D 除了单词边界</p><h2 id="字符串和正则相关的方法"><a href="#字符串和正则相关的方法" class="headerlink" title="字符串和正则相关的方法"></a>字符串和正则相关的方法</h2><h3 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h3><p>语法：string.split(“,”)/string.split(/[0-9]/)<br>join()的功能相反,可以将一个字符串拆分为一个数组<br>参数为拆分规则,如例子的根据字符串里的逗号拆分数组,参数可以是正则表达式</p><p>默认全拆<br>不修改原字符串，返回值为数组</p><pre><code>let str=&quot;1a2b3c4d5e6f&quot;let result = str.split(/[0-9]/)//输出[a,b,c,d,e,f]</code></pre><h3 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h3><p>语法:string.search(搜索的内容)<br>搜索字符串中是否含有指定内容,返回<strong>第一次</strong>(g失效)出现的索引或者-1<br>参数是指定内容可以是正则表达式</p><h3 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h3><p>语法:string.match(条件)<br>根据正则表达式，从一个字符串中将符合条件的内容提取出来,返回值是<strong>数组</strong></p><p>默认返回符合条件的第一个内容<br>要找所有内容，开启全局匹配模式<br>可以为一个正则表达式设置多个匹配模式，顺序无所谓</p><pre><code>let str=&quot;1a2b3c4d5e6f&quot;let result = str.match(/[0-9]/g)//输出[1,2,3,4,5,6]</code></pre><h3 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h3><p>语法:string.search(被替换的内容，新的内容)<br>可以将字符串中指定内容替换为新内容，被替换的内容可以是正则表达式。</p><p>默认只替换第一个<br>不影响原来的字符串，返回新的字符串</p><p><strong>可以使用它去空格</strong></p><pre><code>//会去掉全部的空格str = str.replace(/\s/g,&quot;&quot;)//去掉开头的空格str = str.replace(/^\s*/,&quot;&quot;)//去掉结尾的空格str = str.replace(/\s*$/,&quot;&quot;)//去掉开头和结尾的空格str = str.replace(/^\s*|\s*$/g,&quot;&quot;)</code></pre><p>这里去掉字符串的头尾空格可以使用字符串的<strong>trim()</strong>方法</p><h2 id="常用正则"><a href="#常用正则" class="headerlink" title="常用正则"></a>常用正则</h2><p><strong>检查是否合法手机号</strong></p><p>手机号11位,以1开头,第二位3-9，三位以后任意数字9个</p><p>/^1[3-9][0-9]{9}$/</p><p><strong>电子邮件</strong></p><p><a href="mailto:hello.nihao@qbc.com.cn" target="_blank" rel="noopener">hello.nihao@qbc.com.cn</a></p><p>任意字母数字下划线 \w{3,}<br>.任意字母数字下划线 (.\w+)*<br>@<br>任意字母数字 [A-Za-z0-9]+<br>.任意字母(2-5位) .任意字母(2-5位)   (.[A-Za-z]{2,5}){1,2}</p><pre><code>let emailReg=/^\w{3,}(\.\w+)*@[A-Za-z0-9]+/ (\.[A-Za-z]{2,5}){1,2}$/</code></pre><h2 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h2><p>贪婪模式:匹配尽可能多的字符<br>懒惰模式:匹配尽可能少的字符，会不断的回溯</p><p>常用场景<code>.*</code>与<code>.*?</code>，使用?来表示使用懒惰模式匹配</p><h2 id="正则扩展"><a href="#正则扩展" class="headerlink" title="正则扩展"></a>正则扩展</h2><h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><p><strong>捕获()括号包裹的内容</strong></p><p>加了()表示子匹配，匹配外部大正则的情况下同时匹配()里的内容保存$1、$2…</p><p>语法:RegExpObject.exec(string)<br>方法用于检索字符串中的正则表达式的匹配。<br>如果 exec() 找到了匹配的文本，则返回一个结果数组。否则，返回 null。<br>不管是否/g开启全局，<strong>只返回匹配的第一个</strong>。<br>如果要返回匹配的多个可以使用while(reg.exec(str))或者使用String.prototype.matchAll()方法。</p><pre><code>let str = `&lt;ul&gt;          &lt;li&gt;            &lt;a&gt;ranan&lt;/a&gt;            &lt;p&gt;喜欢粉色&lt;/p&gt;         &lt;/li&gt;         &lt;li&gt;            &lt;a&gt;linin&lt;/a&gt;            &lt;p&gt;喜欢白色&lt;/p&gt;         &lt;/li&gt;         &lt;/ul&gt;         `const reg = /&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\/a&gt;.*?&lt;p&gt;(.*?)&lt;\/p&gt;/sconst result = reg.exec(str)console.log(result);//输出一个数组，第一个元素是匹配的文本，第二个值第一个(.*?)返回值，第三个值第二个(.*?)返回值</code></pre><p><strong>命名捕获分组</strong></p><p>通过?&lt;对捕获到的元素进行命名&gt;,返回的数组中有一个groups属性。</p><pre><code>let str = &#39;&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;&#39;const reg = /&lt;a href=&quot;(?&lt;url&gt;.*)&quot;&gt;(?&lt;text&gt;.*)&lt;\/a&gt;/const result = reg.exec(str)console.log(result)//数组前面3个返回值与上述方法相同，[....,goups:{url:http://www.baidu.com},text:&quot;尚硅谷&quot;]//result.groups使用。</code></pre><p><strong>反向断言</strong></p><p>判断匹配结果是否正确</p><p>正向断言,常用表示(?=pattern),从当前匹配位置开始测试后面(<strong>右边</strong>)匹配字符串是否成立。(?!patter)为其否定写法。</p><pre><code>//正向断言let str = &#39;JS51566哈哈哈11嗯嗯&#39;const reg = /\d+(?=嗯)/ const result = reg.exec(str) //输出[11]</code></pre><p>反向断言，常见表达式(?&lt; pattern)或者(?&lt;!pattern),表示当前位置<strong>左边</strong>将出现匹配字符</p><p><strong>dotAll模式</strong></p><p><code>.</code> 代表元字符查找单个字符，除了换行和行结束符。<br>dotAll /正则/s，新增修饰符s使<code>.</code>可以匹配任意字符。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h2&gt;&lt;p&gt;创建正则表达式的对象&lt;/p&gt;
&lt;p&gt;构造函数方式&lt;br&gt;语法:let 变量 = new RegExp(“正则表达式”
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>原型与原型链</title>
    <link href="http://yoursite.com/2020/07/15/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yoursite.com/2020/07/15/原型与原型链/</id>
    <published>2020-07-15T05:55:09.000Z</published>
    <updated>2020-07-24T03:56:02.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型(prototype)"></a>原型(prototype)</h2><p><img src="/img/js/原型.png"><br>此图中的实例对象也称为原型对象</p><p>我们所创建的每一个函数，解析器都会向函数中添加一个属性<code>prototype</code></p><p>函数的<code>prototype</code>属性，这个属性指向着一个对象(原型对象),<strong>原型对象相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，所以我们可以将对象中共有的内容，统一设置到原型对象中。</strong></p><p>如果函数作为普通函数调用<code>prototype</code>没有任何作用。<br>如果函数作为构造函数调用，它所创建的对象中都有一个属性<code>__proto__</code>指向构造函数的原型对象。</p><p><strong>注</strong><br>理解一定要把握对象的<strong>proto</strong>指向的是构造函数的prototype（原型）。</p><p><strong>显式原型与隐式原型</strong></p><p>每个对象都有隐式原型·<strong>proto</strong>·这个属性，而function既有隐式原型（<em>proto</em>）又有显式原型（prototype），因为函数在js里面既是函数也是对象。</p><p>prototype也是一个对象，只要是对象就有<strong>proto</strong>.</p><p><img src="/img/js/原型1.png"><br><img src="/img/js/原型2.png"></p><p><strong>对象的隐式原型的值为其对应构造函数的显式原型的值，<code>prototype</code>与<code>__proto__</code>里面保存一样的地址值。</strong></p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>当访问一个对象的属性时，先在自身属性中查找，找到返回。如果没有，则会去<strong>原型对象</strong>中寻找（根据元素本身的<strong>proto</strong>去找），找到返回，如果最终没有找到，返回undefined,所以Object的原型对象是原型链的尽头，Object的原型对象没有原型。(Object.prototype.<strong>ptoto</strong> === null)</p><p>注意函数的产生：所有函数都是Function的实例包括它本身，所以<strong>Function.<strong>proto</strong> === Function.prototype</strong></p><pre><code>function Foo(){}//实际上var Foo = new Function()//Function是它自身的实例Function = new Function()Function.__proto__ === Function.prototype //true//构造函数objectfuntion Object(){} let Object = new Function()//所以Object的__proto__指向Function.prototype</code></pre><p><strong>原型继承</strong><br>构造函数的实例对象自动拥有构造函数原型对象的属性(方法)，原理是利用原型链</p><h2 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a>补充知识点</h2><h3 id="1-静态成员与实例成员"><a href="#1-静态成员与实例成员" class="headerlink" title="1.静态成员与实例成员"></a>1.静态成员与实例成员</h3><p>实例成员就是构造函数内部通过this添加的成员。实例成员只能通过实例化的对象来访问。（不可以通过构造函数来访问实例成员）<br>静态成员在构造函数本身上添加的成员(<code>Fn.xxx=&quot;xxx&quot;</code>)。静态成员只能通过函数对象访问。（不可以通过实例对象来访问）</p><h3 id="2-构造函数、实例、原型对象三者之间的关系"><a href="#2-构造函数、实例、原型对象三者之间的关系" class="headerlink" title="2.构造函数、实例、原型对象三者之间的关系"></a>2.构造函数、实例、原型对象三者之间的关系</h3><p><code>__proto__</code>和原型对象中(xx.prototype)都有一个属性<code>constructor</code>，它指向函数对象（xx.prototype.constructor===xx）。主要用来记录该对象引用哪个构造函数</p><p><img src="/img/js/三者关系.png"></p><h3 id="3-继承-ES5"><a href="#3-继承-ES5" class="headerlink" title="3.继承(ES5)"></a>3.继承(ES5)</h3><p>补充：call()函数，调用这个函数并改变运行时this的指向，<code>调用函数.call(参数)</code>。</p><p>如：obj1.(method).call(obj2,argument1,argument2)<br>call的作用就是把obj1的方法放到obj2上使用，后面的argument1..这些做为参数传入。</p><p>ES6之前没有提供extends继承。可以通过构造函数+原型对象模拟实现继承，被称为组合继承。<br>核心原理:通过 call()把父类型的this指向子类型的this，这样就可以实现子类型继承父类型的属性，然后通过子类型的原型等于父类型的实例，看见父类型原型上的方法</p><pre><code>//父构造函数 this指向父构造函数的对象实例function Father(name,age){    this.name = name;    this.age = age;}Father.prototype.money= ()=&gt;{    console.log(&#39;父亲要上班&#39;);}//子构造函数 this指向子构造函数的对象实例function  Son(name,age) {  //把指向父构造函数的对象实例的this改变成指向子构造函数的对象实例的this，这样可以继承属性    Father.call(this,name,age)}//让Son的原型对象指向Father的实例对象，那么就可以访问到Father实例对象上的方法//这个new Father()是一个原型对象，相当于{}，这样写会覆盖掉Son的原型对象的constructorSon.prototype = new Father();//所以还需要constructor指回原来的构造函数Son.prototype.constructor = Son</code></pre><p><img src="/img/js/继承.png"></p><h3 id="4-Function和Object的关系"><a href="#4-Function和Object的关系" class="headerlink" title="4.Function和Object的关系"></a>4.Function和Object的关系</h3><p>1.Object, Function, Array等等这些都被称作是构造“函数”，他们都是函数。<br>2.所有的函数都是构造函数Function的实例。</p><p>3.原型链机制的的角度来说，那就是说所有的函数都能通过原型链找到创建他们的Function构造函数的Function.protorype原型对象</p><p>所以</p><pre><code>console.log(Object instanceof Function)//true</code></pre><p>4.Function.prototype是一个对象，所以他的构造函数是Object. 从原型链机制的的角度来说，那就是说所有的函数都能通过原型链找到创建他们的Object构造函数的构造原型Object.prototype对象</p><p>所以</p><pre><code>console.log(Function instanceof Object)//true</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原型-prototype&quot;&gt;&lt;a href=&quot;#原型-prototype&quot; class=&quot;headerlink&quot; title=&quot;原型(prototype)&quot;&gt;&lt;/a&gt;原型(prototype)&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/js/原型.png&quot;&gt;&lt;b
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>this指针</title>
    <link href="http://yoursite.com/2020/07/15/this%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2020/07/15/this指针/</id>
    <published>2020-07-15T04:35:06.000Z</published>
    <updated>2020-08-22T09:21:53.137Z</updated>
    
    <content type="html"><![CDATA[<p>解析器在调用函数时，每次都会向函数内部传递一个隐含的参数this，this指向的是一个对象。<br>根据函数的调用方式不同，this会指向不同的对象。</p><p>任何函数本质上都是通过某个对象来调用的。<br><strong>它的值是调用函数的当前对象，谁调用指向谁</strong>,如果没调用时，没有指明是哪个对象调用的则是window。</p><pre><code>function Person(color) {    console.log(this);    this.color = color;    this.getColor = function () {        console.log(this);        return this.color;    };    this.setColor = function (color) {        console.log(this);        this.color = color;    }}//this是谁Person(&quot;red&quot;); //windowlet p  = new Person(&quot;yello&quot;) //Person的实例，pp.getColor();//Plet obj= {};p.setColor.call(obj,&quot;black&quot;) //objlet test = p.setColor;test()//windowfunction fun1(){    function fun2() {        console.log(this);    }    fun2()}fun1()//window</code></pre><p>补充：</p><p><strong>new在执行时完成的4件事情：</strong><br>1.在内存中创造一个新的空对象,在堆内存中分配空间<br>2.让this指向这个新的对象<br>3.执行构造函数里面的代码，给这个新对象添加属性和方法<br>4.返回这个新对象(所以构造函数里面不需要return)</p><p><strong>最终this指向的是调用它的对象</strong>进行了更准确的描述</p><pre><code>var o = {    a:10,    b:{        a:12,        fn:function(){            console.log(this.a); //12        }    }}o.b.fn();</code></pre><p><strong>知识点1</strong>：这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象</p><pre><code>var o = {    a:10,    b:{        fn:function(){            console.log(this.a); //undefined        }    }}o.b.fn();</code></pre><p>尽管对象b中没有属性a，这个this指向的也是对象b，因为this只会指向它的上一级对象，不管这个对象中有没有this要的东西。</p><p><strong>知识点2</strong>：this永远指向的是最后调用它的对象，也就是看它执行的时候是谁调用的</p><pre><code>var o = {    a:10,    b:{        a:12,        fn:function(){            console.log(this.a); //undefined            console.log(this); //window        }    }}var j = o.b.fn;j();</code></pre><p>除此之外，文章还对this用法进行了补充，当this碰到return的时候</p><p><strong>知识点3</strong>当this遇见return时，如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。</p><pre><code>function fn(){    this.user = &#39;xx&#39;;    return function(){};}var a = new fn; console.log(a.user); //undefinedfunction fn(){    this.user = &#39;xx&#39;;    return 1;}var a = new fn;console.log(a.user); //xxfunction fn(){    this.user = &#39;xx&#39;;    return null;}var a = new fn;console.log(a.user); //xx</code></pre><p><strong>知识点4</strong><br>Dom事件回调的函数里this是发生事件的标签<br>undefined与null调用的this仍然指向window</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;解析器在调用函数时，每次都会向函数内部传递一个隐含的参数this，this指向的是一个对象。&lt;br&gt;根据函数的调用方式不同，this会指向不同的对象。&lt;/p&gt;
&lt;p&gt;任何函数本质上都是通过某个对象来调用的。&lt;br&gt;&lt;strong&gt;它的值是调用函数的当前对象，谁调用指向谁&lt;/
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>webpack5</title>
    <link href="http://yoursite.com/2020/07/13/webpack5/"/>
    <id>http://yoursite.com/2020/07/13/webpack5/</id>
    <published>2020-07-13T07:25:30.000Z</published>
    <updated>2020-08-11T15:01:40.367Z</updated>
    
    <content type="html"><![CDATA[<p>下载webpack5</p><p>npm i webpack@next webpack-cli -D</p><p>开发环境</p><pre><code>//---------webpack4写法const {resolve} = require(&quot;path&quot;)module.exports={    entry:&quot;./src/js/index.js&quot;,    output:{        //默认的chunk名称是main        filename:&quot;js/[name].js&quot;,        path:Resolve(__dirname,&quot;build&quot;)    },    mode:&quot;development&quot;,}//--------webpack5写法module.exports={         //其余值为默认值    mode:&quot;development&quot;,}</code></pre><p>生产环境</p><p>1.用了es6模块化<br>2.production模式</p><p>满足以上条件webpack4会自动tree shaking<br>但是在实际中依赖关系复杂时webpack4的tree shaking会失效<br>webpack5对此进行了优化tree shaking会更加强大</p><pre><code>//---------webpack4写法const {resolve} = require(&quot;path&quot;)module.exports={    entry:&quot;./src/js/index.js&quot;,    output:{        //默认的chunk名称是main        filename:&quot;js/[name].js&quot;,        path:Resolve(__dirname,&quot;build&quot;)    },    mode:&quot;production&quot;}//--------webpack5写法module.exports={         mode:&quot;production&quot;,}</code></pre><p>webpack5主要的关注内容：</p><ul><li>通过持久缓存提高构建性能</li><li>使用更好的算法和默认值来改善长期缓存</li><li>通过更好的tree shaking和代码生成来改善捆绑包的大小</li></ul><p><strong>Output</strong></p><p>webpack 4默认只能输出ES5代码<br>webpack 5设置<code>output.ecmaVersion:2015</code>来胜出ES6/ES2015的代码</p><p><strong>SplitChunk</strong></p><pre><code>//webpack4 统一设置minSize:30000//webpack5minSize:{    javascript:30000    style:5000}</code></pre><p><strong>cache</strong></p><p>可以通过配置cache实现长久缓存，让第二次打包性能更加高效</p><p>之前的webpack总是在第一次构建是输出全部文件，但是监视重新构造时只更新修改的文件。<br>webpack5在第一次构建时会找到输出文件看是否有变化，从而决定要不要输出全部文件。</p><p><strong>跨域</strong></p><p>解决开发环境ajax请求跨域问题 –&gt; webpack-devServer里面配置代理proxy</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下载webpack5&lt;/p&gt;
&lt;p&gt;npm i webpack@next webpack-cli -D&lt;/p&gt;
&lt;p&gt;开发环境&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//---------webpack4写法
const {resolve} = require(&amp;quot;path
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="构建工具" scheme="http://yoursite.com/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>webpack详细配置</title>
    <link href="http://yoursite.com/2020/07/12/webpack%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2020/07/12/webpack详细配置/</id>
    <published>2020-07-12T08:05:39.000Z</published>
    <updated>2020-08-04T09:41:16.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><p>entry入口起点，值有三种情况<br>1.string —–&gt;’./src/index.js’<br>打包形成一个chunk，输出一个bundle文件,此时的chunk默认名称是main</p><p>2.array  —–&gt;[‘./src/index.js’,’./src/add.js’]<br>所有入口文件最终只会形成一个chunk，输出一个bundle文件，此时的chunk默认名称是main<br>作用：HMR功能中html热更新生效</p><p>3.object  —–&gt;{index:’./src/index.js’,add:’./src/add.js’}<br>有几个入口文件就形成几个chunk，输出几个bundle，chunk的名称是key</p><p>特殊用法：2.3结合,value值为一个数组</p><pre><code>//----------stringmodule.exports={    entry:&quot;./src/js/index.js&quot;,    output:{        //默认的chunk名称是main        filename:&quot;js/[name].js&quot;,        path:Resolve(__dirname,&quot;build&quot;)    },    plugins:[new HtmlWebpackPlugin()],    mode:&quot;development&quot;,}</code></pre><h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><p>library一般结合DLL使用</p><pre><code>module.exports={    entry:&quot;./src/js/index.js&quot;,    output:{        //文件名称（指定名称+目录）        filename:&quot;js/[name].js&quot;,        //输出文件目录，将来所有资源输出的公共目录        path:Resolve(__dirname,&quot;build&quot;),        //所有资源引入公共路径前缀 --&gt;imgs/a.jpg --&gt; /imgs/a.jpg  默认不加一般用于生产环境         publicPath:&quot;/&quot;,        //非入口chunk的名称  import动态导入 optimization设置        chunkFilename:&quot;js/[name]_chunk.js&quot;,        //整个库向外暴露的变量名        //main.js  (function(modules){...} ---&gt; var main = (function(modules){...}        library:&#39;[name]&#39;        //变量名添加到哪个上，之后如何引入window-browser global-node conmmojs        //var main =... --&gt; window[&quot;main&quot;] = ...        libraryTarget:&#39;window&#39;    },    plugins:[new HtmlWebpackPlugin()],    mode:&quot;development&quot;,}</code></pre><h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><p>Loader让Webpack能够去处理那些非JavaScript文件（Webpack自身只理解JavaScript/json）</p><pre><code>module.exports={    entry:&quot;./src/js/index.js&quot;,    output:{        filename:&quot;js/[name].js&quot;,        path:Resolve(__dirname,&quot;build&quot;)    },    module:{        //loader配置        rules:[            {              test:/\.js$/,              //多个loader用use              use:[,]              //单个loeader用loader              //loader:&quot;&quot;              //排除node_modules下的js文件              exclude:/node_modules/,              //只检查src下的js文件              include:resolve(__dirname,&quot;src&quot;),              //优先执行 pre 延后执行 post 默认无顺序              enforce:&quot;post&quot;,              //配置属性              options:{}            },            {                //以下配置只会执行一个                oneOf:[]            }        ]    }    plugins:[new HtmlWebpackPlugin()],    mode:&quot;development&quot;,}</code></pre><h2 id="resolve-路径别名"><a href="#resolve-路径别名" class="headerlink" title="resolve 路径别名"></a>resolve 路径别名</h2><pre><code>module.exports={    entry:&quot;./src/js/index.js&quot;,    output:{        filename:&quot;js/[name].js&quot;,        path:Resolve(__dirname,&quot;build&quot;)    },    module:{        rules:[]    }    plugins:[new HtmlWebpackPlugin()],    mode:&quot;development&quot;,    //解析模块的规则    resolve:{        //配置解析模块路径别名，vue里面的@，避免使用../../../过多的情况        //优点 简写路径 缺点 路径没有提示        alias:{            @:resolve(__dirname,src/css)        },        //配置省略文件路径的后缀名        extensions:[&#39;.js&#39;,&#39;.json&#39;],        //告诉webpack解析模块是去找哪个目录        //可以直接写出找的路径，也可以仅写文件名一层一层去找        modules:[resolve(__dirname,&quot;../../node_modules&quot;),&#39;node_modules&#39;]    }}</code></pre><h2 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h2><p>dev是develop的简写，用于<strong>开发坏境</strong></p><p>利用devServer快速开启一个服务器。</p><p>只有在通过devServer启动webpack时，配置文件里的devServer才会生效，因为这些参数所对应的功能都是devServer提供的，webpack本事并不认识devServer的配置项。</p><pre><code>module.exports={    entry:&quot;./src/js/index.js&quot;,    output:{        filename:&quot;js/[name].js&quot;,        path:Resolve(__dirname,&quot;build&quot;)    },    module:{        rules:[]    }    plugins:[new HtmlWebpackPlugin()],    mode:&quot;development&quot;,    resolve:{},    devServer:{        //运行代码的目录        contentBase:resolve(__dirname,&#39;build&#39;),        //监视contentBase目录下的所有文件，一旦文件发生变化就会reload        watchContentBase:true,        //监视文件的一些配置        watchOptions:{        //忽略文件        ignored:/node_modules/,        },        //启动gzip的压缩        compress:true,        //端口,域名        port:5000,        host:&#39;localhost&#39;,        //自动打开浏览器        open:true,        //开启HMR功能        hot:true,        //不显示启动服务器日志信息        clientLogLevel:&quot;none&quot;,        //除了一些基本启动信息以外，其他内容都不显示        quiet:true,        //如果出错了，不要全屏提示        overlay:false,        //浏览器和代理服务器没有跨域问题，和服务器有跨域问题，通过代理服务器转发        //服务器代理 --&gt; 解决开放环境跨域问题        proxy:{            //一旦devServer(5000)接收到/api/xxx的请求，就会把请求转发到另外一个服务器(3000)            &#39;/api&#39;:{                target:&#39;http://localhost:3000&#39;,                //发送请求时，请求路径重写：将/api/xxx --&gt; /xxx                pathRewrite:{                    &quot;^/api&quot;:&#39;&#39;                }            }        }    }}</code></pre><h2 id="optimization"><a href="#optimization" class="headerlink" title="optimization"></a>optimization</h2><p>用于<strong>生产环境</strong></p><pre><code>module.exports={    entry:&quot;./src/js/index.js&quot;,    output:{        filename:&quot;js/[name].[contenthash:10].js&quot;,        path:Resolve(__dirname,&quot;build&quot;),        chunkFilename:&#39;js/[name].[contenthash:10]_chunk.js&#39;    },    module:{        rules:[]    }    plugins:[new HtmlWebpackPlugin()],    mode:&quot;production&quot;,    resolve:{ },    optimization:{        splitChunk:&#39;all&#39;,        //以下为默认值        //分割的chunk最小为30kb        minSize:30 * 1024,        maxSize:0, //最大没有限制        minChunks:1, //要提取的chunk最少被引用一次        maxAsyncRequests:5,//按需加载时并行加载的文件的最大数量        maxInitialRequests:3,//入口js文件最大并行请求数量        automaticNameDelimiter:&quot;~&quot;,//名称连接符        name:true, //可以使用命名规则        cacheGroups:{            //分割chunk的组            vendors:{                //node_modules文件会被打包到vendors组的chunk中 --&gt;vendors~xxx.js                //上面的规则对分组里的都生效                test:/[\\/]node_modules[\\/]/,                //优先级                priority:-10            },            default:{                //要提取的chunk最少被引用2次                minChunks:2,                priority:-20,                //如果当前要打包的模块，和之前已经被提取的模块是同一个，直接复用不用重新打包模块                reuseExistingChunk:true            }        },        //将当前模块记录其他模块的hash单独打包为一个文件runtime        //解决缓存失效的问题        runtimeChunk:{            name: entrypoint =&gt; `runtime-${entrypoint.name}`        },        //配置生成环境的压缩方案:js和css        minimizer:[            //需要下载引入        new TerserWebpackPlugin({            //开启缓存            cache:true,            //开启多进程打包            parallel:true,            //启动source-map            sourceMap:true        })        ]    }}</code></pre><p>存在问题使用contenthash，当index.js动态引入a.js打包成两个chunk，输出的main.js中记录了a.js的hash值，所以a变化时重新打包时hash变化，main.js也会变会重新打包。导致缓存失效。</p><p>解决办法：设置runtimeChunk</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;entry&quot;&gt;&lt;a href=&quot;#entry&quot; class=&quot;headerlink&quot; title=&quot;entry&quot;&gt;&lt;/a&gt;entry&lt;/h2&gt;&lt;p&gt;entry入口起点，值有三种情况&lt;br&gt;1.string —–&amp;gt;’./src/index.js’&lt;br&gt;打包形
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="构建工具" scheme="http://yoursite.com/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>webpack优化配置</title>
    <link href="http://yoursite.com/2020/07/10/webpack%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2020/07/10/webpack优化配置/</id>
    <published>2020-07-10T14:47:09.000Z</published>
    <updated>2020-07-13T07:08:04.830Z</updated>
    
    <content type="html"><![CDATA[<p><strong>开发环境性能优化</strong></p><p>优化打包构建速度</p><ul><li>HMR 只重新构建发生变化的模块</li></ul><p>优化代码调试（错误在哪里）</p><ul><li>source-map</li></ul><p><strong>生产环境优化</strong></p><p>优化打包构建速度 </p><ul><li>oneOf 找到一个loader就不会继续遍历了</li><li>babel缓存 第二次构建时，会读取之前的缓存，只重新构建变化的文件</li><li>多进程打包</li><li>externals 让某些库不打包，通过link引入</li><li>dll 让某些库不打包（把库单独先打包好），后面直接用</li></ul><p>代码分为node_modules别人的库，和源代码，源代码可以通过import拆分打包，node_modules可以通过dll拆分打包</p><p>优化代码运行的性能</p><ul><li>缓存（hash-chunkhash-contenthash）</li><li>tree shaking 去掉没有使用的代码</li><li>code split 代码分割</li><li>懒加载/预加载（js代码）</li><li>pwa 离线也可以访问</li></ul><h4 id="开发环境性能优化"><a href="#开发环境性能优化" class="headerlink" title="开发环境性能优化"></a>开发环境性能优化</h4><p>HMR：hot module replacement 热模块替换，作用：一块发生变化，只会重新打包这一个模块（而不是打包所有模块）<br>HTML文件：默认不使用HMR功能，同时会导致问题：html文件不能热更新了。解决办法:修改entry入口，将html文件引入之后html可以热更新了，但是仍然不能使用HMR功能。（html不用做HMR功能）<br>样式文件：可以使用HMR功能是因为style-loader内部实现了，所以在开发环境可以使用style-loader，而在生产环境为了把 css单独提取成一个文件就不使用了。<br>js文件：默认不能使用HMR功能–&gt;需要修改js代码，添加支持HMR功能的代码。（不适用过于麻烦）</p><pre><code>module.exports={   entry:[&quot;./src/js/index.js&quot;,&quot;./src/index.html&quot;]    ....    devServer:{     contentBase:resolve(__dirname,&quot;build&quot;),     compress:true,     port:3000,     open:true,     //开启HMR功能     //当修改webpack配置，新配置想要生效，必须重启服务器。     hot:true    }    }</code></pre><p>source-map：<strong>提供源代码到构建后代码映射的技术</strong>，如果构建后代码出错了，会通过映射追踪到源代码错误。</p><p>[inline-|hidden-|eval-][nosources-][cheap-[module]]source-map<br>source-map：外部，错误代码准确信息和可以追踪源代码的错误位置。<br>inline-source-map:内联，只生成一个内联的source-map，错误代码准确信息，可以追踪源代码的错误位置。<br>hidden-source-map:外部，错误代码错误原因，不能追踪到源代码的错误，只能提示到构建后代码的错误位置。<br>eval-source-map:内联，每一个文件都生成对应的source-map，错误代码准备信息和可以追踪源代码的错误位置。<br>nosources-source-map:外部，错误代码准确信息，但是查看不了源代码。<br>cheap-source-map：外部，错误代码准确信息可以追踪源代码的错误位置，只精确到行，精确不到列。<br>cheap-module-source-map：外部，错误代码准确信息可以追踪源代码的错误位置，module会将loader的source map加入<br>内联和外部的区别：1.外部生成了文件，内联没有（直接在生成的输出js中） 2.内联构建速度快3.内联会让体积变得非常大，所以在生成环境不适用内联。</p><p><strong>推荐</strong><br>开发坏境：速度快，调试更友好。<br>      速度快(eval&gt;inline&gt;cheap&gt;…)eval-cheap-source-map&gt;eval-source-map..<br>      调试友好 source-map cheap-module-source-map<br>      一般使用：eval-source-map</p><p>生成环境：源代码要不要隐藏？调试要不要更友好？<br>      源代码隐L藏：hidden-source-map（只隐藏源代码，会提示构建后代码的错误信息） nosources-source-map（全部隐藏）<br>      一般使用source-map </p><pre><code>module.exports = {.....//devtool:&quot;source-map&quot;devtool:&quot;inline-source-map&quot;}</code></pre><h4 id="生产环境性能优化"><a href="#生产环境性能优化" class="headerlink" title="生产环境性能优化"></a>生产环境性能优化</h4><p>oneOf：oneOf以下的loader只会匹配一个，一旦匹配到，则不会在继续匹配下面的loader了。不能有两个配置处理同一种类型的文件，所以之前的两个js处理loader需要有一个放在外部。</p><pre><code>module.exports = {module:{ rules:[ {eslint...}, {   oneOf:[{...},{另外一个js...}...] } ]}}</code></pre><p>babel缓存：第二次构建时，会读取之前的缓存，只重新构建变化的文件。<br>文件资源缓存：输出的文件(没使用hash)，缓存在浏览器，一定时间内不会重新获取。<br>1.hash:输出文件后面加上hash值（所有文件相同），这样在缓存期如果hash值变化（每次打包都会变化）都会重新获取。存在问题：重新打包就会改变hash，即使没有修改的文件。<br>2.chunkhash：根据chunk生成的hash值，如果打包来源于同一个chunk，那么hash就一样。存在问题css与js的hash值一样，因为css被打包进了js，所以同属于一个chunk。修改项目的文件，只有这个文件和于这个文件相关联的打包文件的hash码变化（css和js还是相同），其他的不变。<br>3.contenthash：根据文件的内容生成hash值，不同文件的hash值不一样。内容变化hash值才改变。</p><pre><code>output:{filename:&quot;js/built.[hash:10].js&quot;//filename:&quot;js/built.[chunkhash:10].js&quot;}//兼容性处理{test:/\.js$/,exclude:/node_modules/,loader: &quot;babel-loader&quot;,options: {presets:[&quot;@babel/preset-env&quot;, {useBuiltIns:&quot;usage&quot;,corejs:{version:3},  targets:{  chrome:&quot;60&quot;,   }   }    ], //开启babel缓存 cacheDirectory:true }},</code></pre><p>tree shaking：去除没有使用的代码，减少代码体积<br>前提：必须使用ES6模块化且开发环境</p><p>在package.json中配置”sideEffects”:false所有代码都可以进行tree shaking，但是有些版本可能会把css文件删掉，所以最好配置”sideEffects”:[“*.css”]</p><h4 id="code-split代码分割"><a href="#code-split代码分割" class="headerlink" title="code split代码分割"></a>code split代码分割</h4><p>拆分文件按需加载</p><pre><code>//第一种多入口页面module.exports={    entry:{        //多入口：有一个入口，输出就有一个bundle        main:&quot;./src/js/index.js&quot;,        test:&quot;./src/js/test.js&quot;    },    output:{        //[name]去入口文件的文件名        filename:&quot;js/[name].[contenthash:10].js&quot;,        path:Resolve(__dirname,&quot;build&quot;)    },    plugins:[...],    mode:&quot;production&quot;,}//第二种配置splitChunksmodule.exports={    entry:&quot;./src/js/index.js&quot;,    output:{...},    plugins:[...],    /*     1.可以将node——mudules中代码单独打包成一个chunk输出    2.会自动分析多入口chunk中，有没有公共的文件，如果有会打包成单独的一个chunk不会重复打包    */    optimization:{        splitChunks:{            chunks:&quot;all&quot;        }    },    mode:&quot;production&quot;,}//第三种通过js代码，让某个文件被单独打包成一个chunk//import动态导入语法能将某个文件单独打包,添加该注释可以设置打包的名字//单页面常用这种方法import(/* webpackChunkName:&quot;test&quot; */ &quot;./test&quot;).then().catch()</code></pre><h4 id="懒加载和预加载"><a href="#懒加载和预加载" class="headerlink" title="懒加载和预加载"></a>懒加载和预加载</h4><p>懒加载当文件需要用时才加载<br>预加载等其他资源加载完毕，浏览器空闲了，在偷偷加载资源，ie会有兼容性问题<br>正常加载可以认为是并行加载，同时加载多个文件</p><pre><code>//懒加载，当文件需要用时才加载//仅在点击按钮之后再加载，第二次加载直接从缓存中读取document.getElementById(&quot;btn&quot;).onclick=function(){import(&quot;./test&quot;).then().catch}//预加载,会提前加载在浏览器document.getElementById(&quot;btn&quot;).onclick=function(){import((/* webpackChunkName:&quot;test&quot;,webpackPrefetch:true */&quot;./test&quot;).then().catch}</code></pre><h4 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h4><p>PWA 逐进式网络开发应用程序，离线课访问<br>    workbox –&gt; workbox-weboack-plugin</p><pre><code>//安装npm i workbox-weboack-plugin//引入清除文件插件const WorkboxWeboackPlugin = require(&#39;workbox-weboack-plugin&#39;);plugins:[    new WorkboxWeboackPlugin.GenerateSW({        /*        1.帮助serviceworker快速启动        2.删除旧的serviceworker        生成一个serviceworker配置文件，        */        clientsClaim:true,        skipWaiting:true    })]//一般在index.js里面注册serviceworker//——————————indexjs//注册serviceworker//处理兼容性问题if(&quot;serviceWorker&quot; in navigator){    window.addEventListener(&quot;load&quot;,()=&gt;{        navigator.serviceWorker.register(&#39;/service-worker.js&#39;)        .then(()=&gt;{})        .catch(()=&gt;{})    })}</code></pre><p>可能出现的问题<br>1.eslit不认识window、navigator全局变量<br>解决：需要修改package.json中eslintConfig配置</p><pre><code>&quot;env&quot;:{    &quot;browser&quot;：true //支持浏览器端全局变量}</code></pre><p>2.sw代码必须运行在服务器上<br>npm i serve -g<br>serve -s build 启动服务器，将build目录下所有资源作为静态资源暴露出去</p><h4 id="externals"><a href="#externals" class="headerlink" title="externals"></a>externals</h4><p>externals拒绝打包某资源，自己手动引入</p><pre><code>module.exports={    entry:&quot;./src/js/index.js&quot;,    output:{...},    plugins:[...],    mode:&quot;production&quot;,    externals:{        //库名 -- npm包名        //想使用link在html中引入，拒绝jQuery被打包进来，拒绝被打包时需要手动引进来        jquery:&#39;jQuery&#39;    }}</code></pre><h4 id="DLL"><a href="#DLL" class="headerlink" title="DLL"></a>DLL</h4><p>使用dll技术，对某些库（第三方）进行单独打包<br>当运行webpack时，默认查找webpack.config.js 配置文件<br>需求：需要运行wbpack.dll.js文件<br>–&gt; webpack –config webpack.dll.js</p><pre><code>//————————webpack.dll.jsconst{ resolve } =require(&quot;path&quot;);const webpack = require(&quot;webpack&quot;);module.exports = {entry:{//最终打包生成的name为属性名，属性值为要打包的库 jquery:[&#39;jquery&#39;]},output:{    filename:&#39;[name].js&#39;,    path:resolve(__dirname),&#39;dll&#39;,    library:&quot;[name]_[hash]&quot;  //打包的库里面向外暴露出去的内容叫什么},//以上内容专门用于打包jqueryplugins:[    //打包生成一个 manifest.json --&gt; 提供和jquery映射 new webpack.DllPlugin(     name:&#39;[name]_[hash]&#39;,//映射库的暴露的内容名称     path:resolve(__dirname,&quot;dll/manifest.json&quot;) //输出文件的路径     })] ，mode:&quot;production&quot;}</code></pre><p>打包之后配置webpack.config.js,这样可以重复打包webpack.config.js时不再打包jquery库了</p><pre><code>//-----webpack.config.jsconst webpack = require(&quot;webpack&quot;);const AddAssetHtmlWebpackPlugin = require(&quot;add-asset-html-webpack-plugin&quot;)....//告诉webpack哪些库不参与打包，同时使用时的名称也要变new webpack.DllReferencePlugin({    manifest:resolve(__dirname,&quot;dll/manifest.json&quot;)}),//将某个文件打包输出去，并在html中自动引入该文件new AddAssetHtmlWebpackPlugin({filepath:resolve(__dirname,&quot;dll/jquery.js&quot;)})</code></pre><h4 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h4><p>clean-webpack-plugin:在打包时，先删除原来的再进行打包新的。</p><pre><code>//安装npm i clean-webpack-plugin -D//引入清除文件插件const CleanWebpackPlugin = require(&#39;clean-webpack-plugin&#39;);//使用plugins:[//匹配删除的文件new CleanWebpackPlugin([  &#39;dist&#39;,         //删除dist文件夹  &#39;build/*.*&#39;,    //删除build文件夹下的所有文件],{  //下面可以省略  root: __dirname,  //根目录  verbose:  true,  //开启在控制台输出信息  dry: false    //启用删除文件}),]</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;开发环境性能优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优化打包构建速度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HMR 只重新构建发生变化的模块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优化代码调试（错误在哪里）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;source-map&lt;/li&gt;
&lt;/ul&gt;
&lt;p
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="构建工具" scheme="http://yoursite.com/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript基础（7.15更新）</title>
    <link href="http://yoursite.com/2020/07/09/JavaScript%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/07/09/JavaScript基础/</id>
    <published>2020-07-09T09:17:03.000Z</published>
    <updated>2020-07-23T12:22:12.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>JavaScript（实现） = ECMAScript（标准） + DOM + BOM</p><p>BOM是浏览器对象模型，用来获取或设置浏览器的属性、行为，例如：新建窗口、获取屏幕分辨率、浏览器版本号等。简单的说：bom是浏览器可视窗口操作<br>DOM是文档对象模型，用来获取或设置文档中标签的属性，例如获取或者设置input表单的value值。 BOM的内容不多，主要还是DOM。 由于DOM的操作对象是文档（Document），所以dom和浏览器没有直接关系。</p><p>Window对象：是整个BOM的核心，所有对象和集合都以某种方式回接到window对象。Window对象表示整个浏览器窗口，但不必表示其中包含的内容。<br>Document对象：实际上是window对象的属性。这个对象的独特之处是唯一一个既属于BOM又属于DOM的对象。</p><p><strong>编写基本要求</strong><br>1.html不区别大小写，而JavaScript严格区别大小写<br>2.如果不写分号，浏览器会自动添加，但是会消耗系统资源，所以开发中必须写分号<br>3.JS中会忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化</p><p><strong>基本语法</strong></p><p>1.字面量与变量<br>字面量：一些不可改变的值，可直接使用，比如：1 2 3 4 5 ，一般不用<br>变量：变量可以保存字面量，且可以任意改变，所以一般用变量</p><p>2.标识符<br>在JS中所有可以由我们自主命名，比如：变量名、函数名、属性名<br>可以是字符、数字（不可开头）、__、$<br>不可以是ES中的关键字或保留字<br>标识符一般采用驼峰命名法</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>基本数据类型： Undefined、Null、Boolean、Number、String和Symbol(ES6)<br>引用数据类型： Object(Array, Date, RegExp, Function)</p><p>基本数据类型栈内存中保存的是值，引用数据类型栈内存中保存的是堆内存的地址。</p><p>字符串中可以使用\进行转义字符</p><p>数字的最大值：Number.MAX_VALUE,最小正值：Number.MIN_VALUE<br>超过最大值返回Infinity表示正无穷。<br>NAN（类型仍然是number）是一个特殊的数字，表示NOT A NUMBER。<br>JS进行浮点运算，可能得到一个不精确的结果（不要用JS进行对精确度比较高的运算）</p><p>注意：<br>Null类型的值只有一个null，null专门用来表示为空的对象，所以使用typeof会返回Object<br>Undefined类型的值只有一个undefined，当声明一个变量，但并不给变量赋值时返回undefined</p><p><strong>强制类型转化</strong><br>主要指其他数据类型转换成String，Number，Boolean</p><p>typeof 就是运算符，获得一个值的类型以字符串返回</p><p>转化成String：<br>1.<code>XXX.toString</code>返回转换结果(null,undefined没有该方法)。<br>2.调用String(需要转化的值)函数，对于Number和Boolean实际上调用的是toString方法，对于null/undefined直接转化为”null/undefined”。<br>3.所以非数字类型的运算都转化成数字类型再运算，但是加法中的字符串除外，所以可以利用字符串拼串<code>x+&quot;&quot;</code>（技巧），</p><p>转化成Number：<br>1.调用Number(需要转化的值)函数，如果有非数字类容/undefined转换NaN，空串/null/false转换成0,true转换成1<br>2.对于字符串，parseInt():把一个字符串转换成整数,第二个参数可以指定数字的进制。parseFloat():把一个字符串转化成浮点数。非字符串将其转化成字符串再操作，返回转化结果。<br>3.由于任何值做减法、乘法、除法运算时都会自动转化为Number，所以可以利用<code>x - 0</code></p><p>转化为布尔值：<br>1.调用Boolean(需要转化的值)函数：0、NaN、空串、null、undefined都是false<br>2.两个取反操作可以转化成布尔值。</p><p>布尔值运算：<br>&amp;&amp; js中的“与运算”属于短路的与，如果第一个值为false，则不会看第二个值。<br>|| js中的“或运算”属于短路的或，如果第一个值为true，则不会检查第二个值。</p><p>对于非布尔值进行与或运算时，会将其转化成布尔值运算后返回原数值，结合短路原则分析返回的数值。</p><p><strong>条件分支</strong></p><p>switch</p><pre><code>switch(值，不会转化){    case 值:  //switch判值,严格判等===        代码块;        break;    default:        代码块; //类似else}switch(true){ //case可以为表达式case score &gt;= 90 &amp;&amp; score &lt;100:    alert(&quot;a&quot;)    break;}</code></pre><p>break只会出现在switch和循环语句中，在switch中代表跳出switch语句，在循环中，会跳出离它最近的那一层循环。</p><p><strong>continue与break</strong></p><p>continue:立刻结束本次循环，执行下次循环<br>break:在循环中，跳出离它最近的<strong>整个循环</strong></p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p><strong>in 运算符</strong><br>“属性名” in 对象<br>通过该运算符可以检查一个对象中是否含有指定的属性<br>如果对象中没有但原型中有，也会返回true</p><p><strong>hasOwnProperty</strong><br>对象的hasOwnProperty来检查对象自身中是否含有该属性</p><p>比较两个引用数据类型时，比较的是<strong>内存地址</strong>。</p><pre><code>let obj = new Object();let obj2 = new Object();obj.name = &quot;ranan&quot;;obj2.name = &quot;ranan&quot;;console.log(obj.name == obj2.name)//输出false</code></pre><p>我们直接在页面中打印一个对象时，实际上是输出<strong>Object原型对象上的toString()</strong>的返回值。</p><p>在JS中拥有自动的垃圾回收机制，我们需要将不用的对象设置为null<br>局部变量:函数执行完自动释放<br>对象：成为垃圾对象，由垃圾回收器回收</p><p><strong>Date对象</strong></p><pre><code>//返回的当前代码执行的时间new Date() //需要在构造函数中传递一个表示时间的字符串作为参数let d = new Date(&quot;12/03/2016 11:10:30&quot;)//获得当前的日期d.getDate()//0表示周日d.getDay()//0表示1月d.getMonth()//获得当前对象的时间戳，从1970.1.1 0 0 0 到当前日期的毫秒数d.getTime()//获得当前的时间戳Date.new()</code></pre><p><strong>Math对象</strong><br>但是它不是构造函数，仅做工具使用</p><pre><code>Math.ceil(1.5) //2 向上取整Math.floor(1.5) //1 向下取整Math.round(1.4) //1 四舍五入//0~1的随机数//生成一个0-y之间的随机数 Math.round(Math.random()*y)//生成一个x-y之间的随机数Math.round(Math.random*(y-x)+x)Math.random() //获取多个数中的最大值Math.max(10,20,52) //返回值为最大值</code></pre><p><strong>包装类</strong><br>JS中提供让那个了三个包装类，通过三个包装类可以将基本数据类型转为对象</p><p>String() 可以将基本数据类型字符串转化成String对象<br>Number() 可以将基本数据类型数字转化成Number对象<br>Boolean() 可以将基本数据类型布尔值转化成Boolean对象</p><p>方法和属性只能添加给对象，不能添加给基本数据类型。<br>包装类的作用：当我们对一些基本数据类型的值去调用属性和方法时，浏览器会<strong>临时</strong>使用包装类将其转换成对象，调用完了在转化回来。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><strong>函数也是一个对象</strong></p><p>使用函数声明来创建一个函数，调用函数时解析器不会检查实参的类型与数量。<br>在调用函数时，浏览器每次都会传递进两个隐含的参数<br>1.函数的上下文对象 this<br>2.封装<strong>实参</strong>的对象 arguments 是一个类数组对象/有length、可以通过索引操作的对象</p><p>补充:arguments.callee()方法的意思是：调用函数本身。</p><pre><code>function fun(){    arguments.callee()//调用fun函数本身    return ;//返回值，执行了后面的代码将不会执行，默认返回undefined}//匿名函数赋值形式，最好叫上分号let fun = function{};//第一个括号是表示这个函数是一个整体 框起来，第二个括号表执行。(function(){})()</code></pre><p>return 可以结束整个函数，后面的代码将不会被执行。</p><p><strong>构造函数</strong></p><p>构造函数习惯首字母大写，构造函数通过new构造。构造函数也被成为类，通过构造函数创建的对象称为实例</p><p><strong>new在执行时完成的4件事情：</strong><br>1.在内存中创造一个新的空对象,在堆内存中分配空间<br>2.让this指向这个新的对象<br>3.执行构造函数里面的代码，给这个新对象添加属性和方法<br>4.返回这个新对象(所以构造函数里面不需要return)</p><p><strong>instanceof</strong><br>对象 instanceof Person<br>通过instanceof可以检查一个对象是否一个类的实例<br>所有的对象都是Object的后代</p><p><strong>构造函数使用的优化</strong><br>构造函数方法存在浪费内存的问题，在构造函数中的复杂数据类型（比如函数），实例化对象的时候，会专门开辟一个空间来存放。那么当实例对象过多的时候，就会开辟更多的空间来存放。<br>解决办法:将共享的方法在<strong>全局作用域</strong>中定义<br>存在的问题：将函数定义在全局作用域，污染了全局作用域的命名空间并且不安全。<br>解决办法:当我们希望所有的对象使用同一个函数时，最好使用<code>prototype</code>，这也是为什么方法一般定义在原型中，属性一般通过构造函数定义在对象本身。<br><a href="https://biubiuins.github.io/2020/02/18/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/" target="_blank" rel="noopener">原型</a></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><strong>数组也是一个对象</strong></p><pre><code>naw Array(10)//创建一个长度为10的数组arr = [[1,2,3],[4,5,6]] //二维数组]//向数组的末尾添加数据，返回值为新数组的长度arr.push(&quot;添加的元素&quot;,&quot;添加的元素2&quot;)//删除数组的最后一个元素，返回值为被删除的元素arr.pop()//向数组的开头添加一个或多个元素，返回值为新数组的长度arr.unshift(&quot;添加的元素&quot;,&quot;添加的元素2&quot;)//删除数组的第一个元素，返回值为被删除的元素arr.shift()</code></pre><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>js中的对象只有JS自己支持,其他的语言都不认识，可以转换成任何语言都认识的字符串。<br>JSON就是一个特殊格式的字符串，并可以转换成任意语言中的对象。<br>JSON分为对象、数组  ‘{“属性名”：”属性值”}’ ‘[“值”]’  对象的属性名一定要加引号<br>JSON允许的值字符串、数值、布尔值、null、普通对象、数组</p><p>JSON.parse(json字符串) JSON字符串转换为JS中的对象返回<br>JSON.stringify(js对象) JS对象转换为JSON字符串</p><p>eval() 这个函数可以用来执行一段字符串形式的JS代码，并将结果值返回，如果执行的字符串中含有{},它会将{}当成代码块，需要给字符串加()。<br>此方法常用于IE7以下JSON失效的情况，此方法不要使用性能比较差并且不安全。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h2&gt;&lt;p&gt;JavaScript（实现） = ECMAScript（标准） + DOM + BOM&lt;/p&gt;
&lt;p&gt;BOM是浏览器对象模型，用来获取或设置
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>webpack基本配置</title>
    <link href="http://yoursite.com/2020/07/09/webpack%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2020/07/09/webpack基本配置/</id>
    <published>2020-07-09T09:11:11.000Z</published>
    <updated>2020-08-04T08:52:50.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>Webpack是一种前端资源构建工具，一个静态模块打包器。将根据模块的依赖关系进行静态分析，打包生成对应的静态资源（bundle）</p><p><strong>Webpack五个核心概念</strong></p><ul><li>Entry:入口指示Webpack以哪个文件为入口起点开始打包，分析构建内部依赖图。</li><li>Output:输出指示Webpack打包后的资源bundles输出到哪里去，以及如何命名。</li><li>Loader:Loader让Webpack能够去处理那些非JavaScript文件（Webpack自身只理解JavaScript/json）</li><li>Plugins:插件可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等。</li><li>Mode:模式指示Webpack使用相应模式的配置<ul><li>development：能让代码本地调式运行的环境</li><li>production：能让代码优化上线运行的环境</li></ul></li></ul><p><strong>生产环境和开发环境</strong><br>使用生产环境:npm run build 实际用的webpack<br>在内存中进行编译打包，生成内存中的打包文件。<br>保存到本地，也就是在本地生成打包文件</p><p>使用开发环境:npm run dev 实际用的webpack-dev-server<br>在内存中进行编译打包，生成内存中的打包文件。<br>启动服务器，运行内存中的打包文件，可以通过浏览器虚拟地址访问</p><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>示例：webpack.config.js</p><p>webpack-dev-server 修改代码自动打包</p><pre><code>/*开发环境配置，能让代码运行起来*//*webpack.config.js webpack的配置文件作用：当运行webpack指令时，会加载里面的配置，打包结果会输出出去所有的构建工具都基于nodejs平台运行的，模块化默认采用commonjs *//*loader：1.下载 2.配置（使用）plugins：1.下载 2.引入  3.使用 *///resolve用来拼接绝对路径的方法const  {resolve} = require(&quot;path&quot;)//引用处理html的插件const HtmlWebpackPlugin =require(&quot;html-webpack-plugin&quot;);module.exports = {    //webpack配置    //入口起点    entry: {        filename:static/js/[name].js,        path:path.resolve(__dirname.&#39;dist&#39;)    },    //输出是对象    output:{        //输出文件名        filename: &quot;js/built.js&quot;,        //输出路径        //__dirname是nodejs的变量，代表当前文件的文件夹绝对路径        path:resolve(__dirname,&quot;build&quot;)    },    //loader配置    module:{        rules:[            //详细loader配置            //不同文件配置不同loader处理            {                //匹配哪些文件,以.css结尾的文件                test:/\.css$/,                //使用哪些loader进行处理                use:[                    //use数组中loader执行顺序：从后往前                    //创建style标签，将js中的样式资源插入进行，添加到head中生效                    &quot;style-loader&quot;,                    //将css文件变成commonjs模块加载js中，里面内容是样式字符串，所以css文件不会单独输出                    &quot;css-loader&quot;                ]            },            {               test:/\.less$/,               use:[&quot;style-loader&quot;,               &quot;css.loader&quot;,                   //将less文件编译成css文件                   //需要下载less-loader和less                   &#39;less-loader&#39;               ]            },            //打包其他资源（除了html/js/css资源以外的资源）            //字体不建议这种写法，因为需要排除的东西过多            {            //排除css、js、html以外的资源             exclude:/\.(css|js|html|less|jpg|png|gif)$/,             loader:&quot;file-loader&quot;            options:{             name:&quot;[hash:10].[ext]&quot;            }            }            //处理图片资源            {                //问题：处理html中的img图片                test:/\.(jpg|png|gif)$/,                //使用一个loader时，可直接用loader引用，不用use,                loader: &quot;url-loader&quot;,                options: {                    //图片大小小于8kb，就会被base64处理                    //优点：减少请求数量（减轻服务器压力）                    //缺点：图片体积会更大（文件请求速度更慢）                    limit:8*1024,                    //问题：因为url-loader默认使用es模块化解析，而html-loader引入图片是commonjs                    //解析时会出现问题：[object Module]                    //解决：关闭url-loader的es模块化，使用commonjs解析                    esModule:false,                    //打包之后文件名的hash值取10位，保持原来的后缀名                    name:&quot;[hash:10].[ext]&quot;,                    //设置图片的输出路径                    outputPath:&quot;imgs&quot;                }            },            { //处理html文件的img图片（负责引入img，从而能被url-loader进行处理）                test:/\.html$/,                loader:&quot;html-loader&quot;            }        ]    },    //plugins的配置    plugins: [        //html-webpack-plugin 处理html资源        //功能：默认会创建一个空的HTML，自动引入打包输出的所有资源（js/css）        //  new HtmlWebpackPlugin()        //需求：需要有结构的HTML文件        new HtmlWebpackPlugin({         //复制&quot;index.html&quot;,并自动引入打包输出的所有资源（js/css）            template:&quot;index.html&quot;            path:&quot;index.html&quot;        })        //详细pulgins的配置    ],    //模式    mode:&#39;development&#39;    // mode:&quot;production&quot;    //启动devServer指令为：npx webpack-dev-server（需要安装对应的包）    //localhost:3000本地服务器查看    devServer:{     //构建后的路径     contentBase:resolve(__dirname,&quot;build&quot;),     //启动gzip压缩，使代码体积更小，运行更快。     compress:true,     //指定开发服务器的端口号     port:3000,     //自动打开默认浏览器     open:true    }}</code></pre><p><strong>总结：</strong></p><ul><li>module-&gt;rules-&gt;use 数组(使用多个loader)是从后往前执行的，使用一个可以直接用loader</li><li>loader：①下载 ②配置（使用），plugins：①下载 ②引入 ③使用。</li><li>url-loader可以用于图片和字体</li><li>webpack需要实时打包，可使用开发服务器devServer实现自动化。</li><li>因为url-loader默认使用es模块化解析，而html-loader解析html中的图片的解析是commonjs。所以需要在url-loader中的选项配置中使用esModule:false关闭默认的es模块解析</li></ul><h3 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h3><p>开发服务器 devServer用来实现自动化，比如自动编译，自动打开浏览器，自动刷新浏览器。只会在内存中编译打包，不会有任何输出文件，比如删除build后，使用devServer不会输出新的build文件。相当于打包后放在本地服务器上运行。</p><h3 id="生产环境"><a href="#生产环境" class="headerlink" title="生产环境"></a>生产环境</h3><h4 id="mini-css-extract-plugin插件"><a href="#mini-css-extract-plugin插件" class="headerlink" title="mini-css-extract-plugin插件"></a>mini-css-extract-plugin插件</h4><p>打包过后的css在js文件里，通过下面的插件可以把css单独抽出来。</p><pre><code>//安装npm i mini-css-extract-plugin -D//引入const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;)//loader配置    module:{        rules:[            {                test:/\.css$/,                use:[                    //创建style标签，将js中的样式资源插入进行，添加到head中生效                    //&quot;style-loader&quot;,                    //作用：提取js中的css成单独文件                    MiniCssExtractPlugin.loader                    &quot;css-loader&quot;                ]            },            ]}plugins:[new MiniCssExtractPlugin({//输出的css文件重新命名  filename:&#39;css/built.css&#39;})]</code></pre><p>以上的写法有一个问题是css如果中有文件，需要在该插件的publicPath中重新配置文件路径。</p><pre><code>{loader:MiniCssExtractPlugin.loader,options:{// 这里可以指定一个 publicPath// 默认使用 webpackOptions.output中的publicPathpublicPath: &#39;../&#39; }</code></pre><h4 id="css兼容与压缩"><a href="#css兼容与压缩" class="headerlink" title="css兼容与压缩"></a>css兼容与压缩</h4><p>css兼容性处理：postcss –&gt; postcss-loader postcss-preset-env（在webpack中使用）</p><pre><code>//安装npm i postcss-loader postcss-preset-env -D//使用    module:{        rules:[            {                test:/\.css$/,                use:[                    MiniCssExtractPlugin.loader                    //使用loader的默认配置的写法                    &quot;css-loader&quot;                    //修改loader的配置写法                    {                    loader:&quot;postcsss-loader&quot;                    options:{                    ident:&quot;postcsss&quot;                    plugins:()=&gt;[                    //返回一个数组 postcss的插件                    //此插件帮助postcss找到package.json中browserslist里面的配置，通过配置加载指定的css兼容性样式，默认找的是browerslist里面的生产环境                    //如果要找开发环境的，就需要在webpack.config.js中设置node.js坏境变量process.env.NODE_ENV=&quot;development&quot;                    require(&quot;postcss-preset-env&quot;)()                    ]                    }                    }                ]            },            ]}//====================package.json&quot;browserslist&quot;:{&quot;development&quot;:[//兼容最近的chrome版本&quot;last 1 chrome version&quot;]&quot;production&quot;:[&quot;&gt;0.2%&quot;,//兼容98%的浏览器&quot;not dead&quot;,//已经死了的浏览器&quot;not op_mini all&quot;]}</code></pre><p>css压缩插件：optimize-css-assets-webpack-plugin</p><pre><code>//安装插件npm i optimize-css-assets-webpack-plugin -D//引用const OptimizeCssAssetsWebpackPlugin = require(&quot;optimize-css-assets-webpack-plugin&quot;)//使用plugins:[{//压缩css，默认配置已经可以解决问题了。new OptimizeCssAssetsWebpackPlugin()}]</code></pre><h4 id="js语法检查与兼容性"><a href="#js语法检查与兼容性" class="headerlink" title="js语法检查与兼容性"></a>js语法检查与兼容性</h4><p>语法检查：eslint-loader eslint<br>注意：只检查自己写的js源代码，第三方的库是不用检查的<br>设置检查规则：在package.json中eslintConfig中设置<br>推荐使用airbnb规则： eslint eslint-plugin-import eslint-config-airbnb-base</p><pre><code>//新版在根目录创建.eslintrc//老版本{test:/\.js$/,loader:&quot;eslint-loader&quot;,//一定要排除exclude:/node_modules/,options:{//自动修复eslint错误fix:true}}//===========package.json&quot;eslintConfig&quot;:{&quot;extends&quot;:&quot;airbnb-base&quot;}</code></pre><p>兼容性处理ES6：babel-loader @babel/preset-env @babel/core<br>基本的js兼容性处理 –&gt; @babel/preset-env 问题：只能转换基本语法，promise不能<br>全部js兼容性处理 –&gt; @babel/polyfill 被弃用，体积还会变大。<br>需要做兼容行处理的就做：按需加载 –&gt;corejs</p><pre><code>{test:/\.js$/,//一定要排除exclude:/node_modules/,loader:&quot;babel-loader&quot;,options:{//预设:指示babel做什么样的兼容性处理 presets:[&quot;@babel/preset-env&quot;]}}//========corejsnpm i core-js -D//配置presets:[[&quot;@babel/preset-env&quot;, //预设包:包含多个常用插件的包{//按需加载 useBuiltIns:&quot;usage&quot;, //指定core-js版本 corejs:{   version:3 }, //指定兼容性做到哪个版本浏览器 targets:{ chrome: &quot;60&quot;, firefox:&quot;60&quot;, ie:&quot;9&quot; }}]]</code></pre><p>js压缩与html压缩</p><pre><code>//生产坏境下自动压缩jsmode:&quot;production&quot;,new HtmlWebpackPlugin({ //复制&quot;./src/index.html&quot;,并自动引入打包输出的所有资源（js/css）template:&quot;./src/index.html&quot;//压缩html代码minify:{  //移除空格  collapseWhitespace:true,  //移除注释  removeComments:true}})</code></pre><h4 id="生产环境的基本配置"><a href="#生产环境的基本配置" class="headerlink" title="生产环境的基本配置"></a>生产环境的基本配置</h4><p>正常来讲，一个文件只能被一个loader处理，当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序:先执行eslint,在执行babel。</p><p>配置vue的相关信息可以在vue官网文档查看，注意vue.esm.js文件的设置</p><pre><code>const {resolve} = require(&quot;path&quot;)//用于将css从js中抽离成单独文件const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;)//css兼容const  OptimizeCssAssetsWebpackPlugin= requir(&quot;optimize-css-assets-webpack-plugin&quot;)const HtmlWebpackPlugin= require(&quot;html-webpack-plugin&quot;)//css兼容const commonCssLoader = [    {        loader:MiniCssExtractPlugin.loader,        options:{            publicPath: &#39;../&#39;        }    },    &quot;css-loader&quot;,    {  //兼容性,还需要在package.json中定义browserslist        loader: &quot;post-loader&quot;,        options: {            ident:&quot;postcss&quot;,            plugins:()=&gt;[                require(&quot;postcss-preset-env&quot;)()            ]        }    }]module.exports={    entry:&quot;./src/js/index.js&quot;,    output: {        filename: &quot;js/built.js&quot;,        path: resolve(__dirname,&quot;build&quot;)    },    module: {        rules: [            {                test:/\.css$/,                use:[...commonCssLoader]            },            {                test:/\.less$/,                use:[...commonCssLoader, &quot;less-loader&quot;]            },            //配置eslint            {                //在package.json中eslintCofig中配置--&gt;airbnb                //npm install -D eslint  eslint --init可以按需配置eslint                test:/\.js$/,                exclude:/node_modules/,                //设置优先执行。                enforce: &quot;pre&quot;,                loader: &quot;eslint-loader&quot;,                options: {                    fix:true                }            },            //兼容性处理            {                test:/\.js$/,                exclude:/node_modules/,                loader: &quot;babel-loader&quot;,                options: {                    presets:[                        &quot;@babel/preset-env&quot;,                        {                            useBuiltIns:&quot;usage&quot;,                            corejs:{version:3},                            targets:{                                chrome:&quot;60&quot;,                            }                        }                    ]                }            },            {                test:/\.(jpg|png|gif)/,                loader: &quot;url-loader&quot;,                options: {                    limit:8*1024,                    name:&quot;[name].[hash:10].[ext]&quot;,                    outputPath:&quot;imgs&quot;,                    esModule:false                }            },            {                test:/\.html$/,                loader: &quot;html-loader&quot;            },            {                exclude:/\.(js|css|less|html|jpg|png|gif)/,                loader: &quot;file-loader&quot;,                options: {                    outputPath:&quot;media&quot;                }            }        ]    },    plugins: [        new MiniCssExtractPlugin({            filename:&quot;css/built.css&quot;        }),        //只需要调用        new OptimizeCssAssetsWebpackPlugin(),        new HtmlWebpackPlugin({            template:&quot;./src/index.html&quot;,            minify:{                collapseWitespace:true,                removeComments:true            }        })    ],    mode: &quot;production&quot;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h2&gt;&lt;p&gt;Webpack是一种前端资源构建工具，一个静态模块打包器。将根据模块的依赖关系进行静态分析，打包生成对应的静态资源（bundle）&lt;/p&gt;

      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="构建工具" scheme="http://yoursite.com/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Less学习笔记</title>
    <link href="http://yoursite.com/2020/07/08/less%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/07/08/less学习笔记/</id>
    <published>2020-07-08T14:50:42.000Z</published>
    <updated>2020-07-08T11:05:18.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="less"><a href="#less" class="headerlink" title="less"></a>less</h1><p> less属于css的一种预处理器<strong>处理在浏览器运行前</strong>, 作为css的扩展、增强版，是一种动态样式语言。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p> //less中的单行注释，不会被编译到css文件中，以/<em> </em>/注释的内容会被编译到css文件</p><h2 id="less嵌套规则"><a href="#less嵌套规则" class="headerlink" title="less嵌套规则"></a>less嵌套规则</h2><p>  和html结构相似，层层嵌套<br><code>&amp;</code> 代表的上一层选择器的名字</p><pre><code>        /* Less */        #header{          &amp;:after{            content:&quot;Less is more!&quot;;          }          .title{            font-weight:bold;          }          &amp;_content{//理解方式：直接把 &amp; 替换成 #header            margin:20px;          }          &gt; .title{            font-weight:bold;          }        }        /* 生成的 CSS */        #header::after{          content:&quot;Less is more!&quot;;        }        #header .title{ //嵌套了          font-weight:bold;        }        #header_content{//没有嵌套！            margin:20px;        }           #header &gt; .title{ //嵌套了          font-weight:bold;        }</code></pre><h2 id="less的继承"><a href="#less的继承" class="headerlink" title="less的继承"></a>less的继承</h2><p>extend 是 Less 的一个伪类。它可继承 所匹配声明中的全部样式。<br>extend（这里放规则）是一个函数</p><pre><code>          /* Less */          //规则的定义，没有参数          .animation{              transition: all .3s ease-out;              .hide{                transform:scale(0);              }          }          #main{              &amp;:extend(.animation);          }          #con{              &amp;:extend(.animation .hide){                color:red;              }          }          /* 生成后的 CSS */          .animation,#main{            transition: all .3s ease-out;          }          .animation .hide , #con{              transform:scale(0);          }          #con{            color:red          }</code></pre><p>更简单的写法</p><pre><code>.p1 {  width:100px}.p2{  //相当于复制p1，性能不太好  p1();}</code></pre><h3 id="all全局搜索替换"><a href="#all全局搜索替换" class="headerlink" title="all全局搜索替换"></a>all全局搜索替换</h3><p>使用选择器匹配到的 全部声明。</p><pre><code>          /* Less */          #main{            width: 200px;          }          #main {            &amp;:after {              content:&quot;Less is good!&quot;;            }          }          #wrap:extend(#main all) {}          /* 生成的 CSS */          #main,#wrap{            width: 200px;          }          #main:after, #wrap:after {              content: &quot;Less is good!&quot;;          }</code></pre><ul><li>从表面 看来，extend 与 方法 最大的差别，就是 extend 是同个选择器共用同一个声明，而 方法 是使用自己的声明。</li><li>~”XXXXX” less之中避免编译，让浏览器编译</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p> 以 <code>@</code> 开头定义变量，使用是直接 @定义的名称</p><p> 变量做类名使用时必须在@后使用大括号包裹</p><p> 声明变量（类比于写好的css引用）类似于混合方法  结构: @name: { 属性: 值 ; }; 使用：@name(); </p><p> 使用@来申明一个变量: @pink:pink //不要添加引号</p><ol><li>作为普通属性值只是来使用：直接使用@pink</li><li>作为选择器和属性名: @{selector的值}的形式（不常用）</li><li>作为URL：@{url} （@images:’../img’ 注意要加引号）</li><li>变量的延迟加载（一个块级域解析完再加载变量）</li></ol><pre><code>       /* Less */       @color: #999;       @bgColor: skyblue;//不要添加引号       @width: 50%;       #wrap {         color: @color;         width: @width;       }       /* 选择器变量 */         @mySelector: #wrap;          @Wrap: wrap;          @{mySelector}{ //变量名 必须使用大括号包裹            color: #999;            width: 50%;            //如果继承width的值可以直接用$width            height: $width;           }          .@{Wrap}{            color:#ccc;          }          #@{Wrap}{            color:#666;          }        /* url 变量*/         @images: &quot;../img&quot;;//需要加引号              body {                background: url(&quot;@{images}/dog.png&quot;);//变量名 必须使用大括号包裹              }       /* 声明变量 */             @background: {background:red;};             #main{                 @background();             }             @Rules:{                 width: 200px;                 height: 200px;                 border: solid 1px red;             };             #con{               @Rules();             }             /* 生成的 CSS */             #main{               background:red;             }             #con{               width: 200px;               height: 200px;               border: solid 1px red;             }</code></pre><h3 id="变量的运算"><a href="#变量的运算" class="headerlink" title="变量的运算"></a>变量的运算</h3><p> 注意点：</p><ol><li>加减法时，以第一个数据的单位为基准</li><li>乘除法时，注意单位一定要统一</li></ol><h2 id="less中的混合"><a href="#less中的混合" class="headerlink" title="less中的混合"></a>less中的混合</h2><p>  混合：将一系列的规则集引入另一个规则集中。</p><p>  类名后面不添加括号，这个样式会在css编译出来并且作用到该类名上。</p><p>  类名后面添加了括号之后就不是一个选择器了，只是创建了一个mixins，专门给别人用的。</p><p>  混合使用 <code>.</code> 或 <code>#</code> 的形式来定义；声明变量使用的是 <code>@</code> 来定义，@变量名（）来使用</p><h3 id="普通混合"><a href="#普通混合" class="headerlink" title="普通混合"></a>普通混合</h3><pre><code>    /* Less */        .card { // 等价于 .card()            background: #f6f6f6;            -webkit-box-shadow: 0 1px 2px rgba(151, 151, 151, .58);            box-shadow: 0 1px 2px rgba(151, 151, 151, .58);        }        #wrap{          .card;//等价于.card();        }        //其中 .card 与 .card() 是等价的。</code></pre><h3 id="带参数的混合"><a href="#带参数的混合" class="headerlink" title="带参数的混合"></a>带参数的混合</h3><p> 注意点：</p><ol><li><p>Less 可以使用默认参数，如果没有传参数，那么将使用默认参数。冒号后面的是默认值</p></li><li><p>@arguments代表全部参数，实参列表</p></li><li><p>传的参数中必须带单位，且按顺序，如果不按顺序，需要在参数中带上参数名类似@width:100px</p></li></ol><pre><code>      /* Less */    .border(@a:10px,@b:50px,@c:30px,@color:#000){     border:solid 1px @color;     box-shadow: @arguments;//指代的是 全部参数      }      #main{       .border(0px,5px,30px,red);//必须带着单位       }      #wrap{               .border(0px);      }           /*  命名参数 */      #wrap{      .border(@color:black);               }      #content{       .border;//等价于 .border()       }           /* 生成的 CSS */    #main{               border:solid 1px red;               box-shadow:0px,5px,30px,red;           }    #wrap{               border:solid 1px #000;               box-shadow: 0px 50px 30px #000;           }    #content{               border:solid 1px #000;               box-shadow: 10px 50px 30px #000;           }</code></pre><h3 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h3><p>注意点：</p><ol><li><p>第一个参数 <code>left</code> 要会找到方法中匹配程度最高的，如果匹配程度相同，将全部选择，并存在着样式覆盖替换。</p></li><li><p>如果匹配的参数 是变量， <code>@_</code> 表示的会被调用任意标志的 。</p></li></ol><pre><code>    /* Less */          .triangle(top,@width:20px,@color:#000){              border-color:transparent  transparent @color transparent ;          }          .triangle(right,@width:20px,@color:#000){              border-color:transparent @color transparent  transparent ;          }          .triangle(bottom,@width:20px,@color:#000){              border-color:@color transparent  transparent  transparent ;          }          .triangle(left,@width:20px,@color:#000){              border-color:transparent  transparent  transparent @color;          }          .triangle(@_,@width:20px,@color:#000){              border-style: solid;              border-width: @width;          }          #main{              .triangle(left, 50px, #999)          }          /* 生成的 CSS */          #main{            border-color:transparent  transparent  transparent #999;            border-style: solid;            border-width: 50px;          }</code></pre><h2 id="方法的命名规范"><a href="#方法的命名规范" class="headerlink" title="方法的命名规范"></a>方法的命名规范</h2><p>注意点：</p><ul><li>在 CSS 中 <code>&gt;</code> 选择器，选择的是 儿子元素，就是 必须与父元素 有直接血源的元素。</li><li>在引入命令空间时，如使用 <code>&gt;</code> 选择器，父元素不能加 括号。</li><li>不得单独使用命名空间的方法 必须先引入命名空间，才能使用 其中方法。</li><li>子方法 可以使用上一层传进来的方法</li></ul><pre><code>           /* Less */           #card(){               background: #723232;               .d(@w:300px){                   width: @w;                   #a(@h:300px){                       height: @h;//可以使用上一层传进来的方法                       width: @w;                   }               }           }           #wrap{               #card &gt; .d &gt; #a(100px); // 父元素不能加 括号           }           #main{               #card .d();           }           #con{               //不得单独使用命名空间的方法               //.d() 如果前面没有引入命名空间 #card ，将会报错               #card; // 等价于 #card();               .d(20px); //必须先引入 #card           }           /* 生成的 CSS */           #wrap{             height:100px;             width:300px;           }           #main{             width:300px;           }           #con{             width:20px;           }//通过import引入其他的less文件@import &quot;&quot;;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;less&quot;&gt;&lt;a href=&quot;#less&quot; class=&quot;headerlink&quot; title=&quot;less&quot;&gt;&lt;/a&gt;less&lt;/h1&gt;&lt;p&gt; less属于css的一种预处理器&lt;strong&gt;处理在浏览器运行前&lt;/strong&gt;, 作为css的扩展、增强版，是一种动
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/CSS/"/>
    
    
      <category term="Less" scheme="http://yoursite.com/tags/Less/"/>
    
  </entry>
  
  <entry>
    <title>meta标签</title>
    <link href="http://yoursite.com/2020/07/08/meta%E6%A0%87%E7%AD%BE/"/>
    <id>http://yoursite.com/2020/07/08/meta标签/</id>
    <published>2020-07-08T11:03:45.000Z</published>
    <updated>2020-07-08T11:27:41.572Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>仅仅记录我已经使用过的，如果后续有使用过新的，会补充在文章中</p></blockquote><p>meta标签主要用于设置网页中的一些元数据，元数据不是给用户看的。</p><ul><li>charset 指定网页的字符集</li><li>name 指定数据的名称</li><li>content 指定的数据的内容</li><li>http-quiv 向浏览器传信息</li></ul><mata name="keywords" content="blog,HTML,购物网址"><p>keywords表示网站的关键字，搜索时用于识别。</p><mata name="description" content="这是一个非常不错的网站"><p>description用于指定网站的描述，网站的描述会显示在搜索引擎的搜索结果中</p><p>补充：title标签的内容会作为搜索结果的超链接的文字显示</p> <meta http-equiv="refresh" content="3;url=https://www.baidu.com"><p> 网页重定向，3秒后跳转到百度</p> <meta name="viewport" content="width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no"><p> viewport是HTML5新增的，常用于移动端。</p><p> width:可视区域的宽度，值可为数字或关键词device-width<br> intial-scale:页面首次被显示是可视区域的缩放级别，取值1.0则页面按实际尺寸显示，无任何缩放<br> maximum-scale=1.0, minimum-scale=1.0;可视区域的缩放级别，<br>user-scalable:是否可对页面进行缩放，no 禁止缩放</p></mata></mata>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;仅仅记录我已经使用过的，如果后续有使用过新的，会补充在文章中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;meta标签主要用于设置网页中的一些元数据，元数据不是给用户看的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;charset 指定网页的字符集&lt;/li&gt;
&lt;li
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="HTML" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/HTML/"/>
    
    
      <category term="HTML" scheme="http://yoursite.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>CSS学习笔记</title>
    <link href="http://yoursite.com/2020/06/20/CSS/"/>
    <id>http://yoursite.com/2020/06/20/CSS/</id>
    <published>2020-06-20T14:50:42.000Z</published>
    <updated>2020-07-20T08:19:47.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li>伪类选择器</li><li>单位<ul><li>移动端适配</li><li>媒体查询</li><li>省略</li><li>雪碧图</li></ul></li><li>CSS盒模型<ul><li>过渡约束</li><li>外边距折叠</li><li>轮廓和圆角</li></ul></li><li>浮动<ul><li>高度塌陷</li><li>BFC</li><li>清除浮动</li><li>外边距折叠的解决</li><li>clearfix</li></ul></li><li>定位<ul><li>层级</li></ul></li><li>居中<ul><li>垂直居中</li><li>水平居中</li></ul></li><li>动画<ul><li>过渡</li></ul></li><li>弹性盒子</li><li>其他<ul><li>三角形</li></ul></li></ul><h1 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h1><p>伪类带一个冒号，伪元素带两个冒号。</p><p><strong>常见伪类</strong></p><p>li:first-child<br>li:last-child<br>li:nth-child(n)  //n从1开始，2n/even选中偶数位，2n+1/odd奇数位</p><p>这三个 排序是根据所有的子元素进行的，并不是li中的第几个。</p><pre><code>li:first-child{    color: orange;}//第一个li元素并不会变色，因为在子元素中第一个元素是span&lt;span&gt;abc&lt;/span&gt;&lt;li&gt;ff&lt;/li&gt;&lt;li&gt;zz&lt;/li&gt;</code></pre><p>:first-of-type<br>:last-of-type<br>:nth-of-type()</p><p>这几个伪类与上述相似，不过是在同类型元素中选择排序。</p><p>:not()否定伪类</p><pre><code>ul&gt;li:not(li:nth-of-type(3))//当前后相同时，也可以写成ul&gt;li:not(:nth-of-type(3))</code></pre><p><strong>超链接的伪类</strong></p><p>:link 用来表示没访问过的链接（正常的链接）<br>:visited 用来表示访问过的链接，由于隐私的原因，该伪类只能改变颜色（所以不常用）<br>上述两个伪类只用于a标签<br>:hover 用来表示鼠标移入的状态<br>:active 用来鼠标点击</p><p>顺序:lvha</p><p><strong>伪元素</strong></p><p>伪元素表示页面中一些特殊的并不真实存在的元素</p><p>p::first- letter 表示标签p里的第一个字母<br>::first-line 表示第一行<br>::selection 表示选中的内容<br>div::before 表示div标签内的开始位置<br>div::after 表示div标签内的最后一个位置</p><p>before,after添加的文字不可以被选中</p><h1 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h1><p>在前端像素分为两种：css像素和物理像素。编写网页时，所用的像素是CSS像素。浏览器在加载网页时，会将CSS像素转化成物理像素。默认情况在pc端1个css像素=1个物理像素</p><p>视口(viewport)就是屏幕中用来网页显示的区域，可以通过html查看。物理像素是设备的宽度。</p><p>编写移动端的页面时，通过调整视口大小来调整像素比，meta标签设置，<code>content=&quot;width=device-width&quot;</code>可以将像素比设置为最佳像素比的视口大小。</p><p>em是相对于自身元素的字体大小来计算的，1 em = 1 font-size<br>rem是相对于根元素（html）的字体大小来计算的。<br>行高（line-height）指的是文字占有的实际高度，行高如果是整数，则是该元素字体大小的倍数</p><p>移动端不适用px来布局，常常使用vw来布局。<br>vw表示视口的宽度 100vw=1个视口的宽度</p><p>常用的vw适配方案</p><p>比如当前最佳视口大小375px,设计图宽度750px,100vw = 750px(<strong>这个750指的是设计图中的宽度</strong>),<br>那么设计图中的 1px = 0.1333 vw。</p><p>给font-size设置0.133vw对应的是设计图中的1px，所以设计图中的10px可以写成10rem。</p><p>但是一般浏览器对字体的大小有限制，所以会对font-size进行放大比如放大了40倍，那么使用的时候需要缩小40倍。</p><pre><code>html{    //100vw/750 = 0.1333vw    font-size:100vw/750 * 40}.box{    width:设计图中该元素的宽度/40 rem}</code></pre><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><pre><code>@media(min-width:xxx/max-width:xxx){}@media not (){}//除了@media(),(){} //两个条件满足一个就可以了@media()and(){} //两个条件全部满足</code></pre><p>样式切换的分界点称为断点，常用断点：</p><p>小于768 超小屏幕 max-width=768px<br>大于768 小屏幕 min-width=768ox<br>大于992 中型屏幕 min-width=992px<br>大于1200 大屏幕 min-width=1200px</p><p><strong>响应式设计的网站:移动端优先</strong></p><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>字体框就是字体存在的格子，设置font-size实际上就是在设置字体框的高度。<br>行高会在字体框的上下平均分配。<br>font属性：字体大小/行高 字体族，</p><pre><code>//可以将服务器中的字体直接提供给用户去使用//问题：1.加载速度 2.版权@font-face {//xx为你给该字体起的名font-family:&quot;xx&quot;;//服务器中字体的路径src:url();}</code></pre><p>图标字体<br>在使用图标时，可以将图标直接设置为字体，通过font-face的形式来字体进行引用。</p><pre><code>//使用iconfont的方式,本地引用icconfont.css//伪元素引用p::before{content:&quot;\xxxx&quot;; //字体图标的编码font-family:&quot;iconfont&quot;;font-size:xxx;}//类名引用&lt;i class=&quot;iconfont icon-qitalaji&quot;&gt;&lt;/i&gt;</code></pre><p>text-align文本的水平对齐<br>vertical-align 设置元素垂直对齐</p><p>图片默认的基线对齐，但是基线可能和外边框之间有缝隙，所以图片常常设置<code>vertical-align</code>的值来改变对齐方式。</p><p><strong>省略</strong></p><pre><code>width:xx;white-space:nowrap;  //white-space 设置网页如何处理空白 normal 正常 nowrap 不换行 pre 保留原格式overflow:hidden;text-overflow:ellipsis;</code></pre><p><strong>背景</strong></p><p>background-clip 背景范围<br>background-origin 背景图片的偏移量计算的源点，默认在内边距开始<br>可选值 border-box 默认值 padding-box，content-box</p><p>background-size  背景图片的大小 cover 图片比例不变，将元素铺满高度100% contain 图片比例不变，将图片在元素中完整显示，宽度100%<br>background-attachment 背景图片是否跟随元素移动 scroll默认移动，fixed背景会固定在页面中<br>background-image还可以设置渐变的背景色</p><p>解决图片闪烁问题（CSS-Sprite）：可以将多个小图片统一保存在一个大图片（雪碧图），通过图片背景定位来解决问题。</p><p><strong>隐藏文字</strong></p><p>常常使用<code>text-indext:-9999px</code>来隐藏文字,需配合overflow使用。</p><h1 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h1><p><strong>CSS将页面中的所有元素都设置为一个矩形的盒子，</strong>对页面的布局就变成了将不同的盒子摆放到不同的位置。</p><p>盒子 = 内容content + 内边距padding + 边框border + 外边距margin（看不见，其余为可见框）</p><p>由width和height决定的是content的大小。</p><h2 id="块级元素盒模型"><a href="#块级元素盒模型" class="headerlink" title="块级元素盒模型"></a>块级元素盒模型</h2><p>控制布局的时候最好对块级元素进行布局，块级元素占一行。</p><h3 id="过渡约束"><a href="#过渡约束" class="headerlink" title="过渡约束"></a>过渡约束</h3><p><strong>水平布局</strong></p><p>一个块级元素在其父元素中，水平布局必须满足<strong>margin-left + border-left + padding-left + width +  padding-right + border-right + margin-right =  其父元素内容的宽度，如果相加结果不相等，则称为过渡约束。</strong><br>这七个值中可以设置为auto：width，margin。<br>如果发生过渡约束，等式会自动调整，宽度优先，左右平分：<br>1.如果7个值无auto的情况，则浏览器会自动调整margin-right<br>2.如果某个值为auto，则会自动调整auto的值是等式成立。<br>3.如果一个宽度和一个外边距设置为auto，则优先把宽度调整到最大。<br>4.如果两个外边距设置为auto，宽度固定，则会将外边距设置为相同的值。<strong>利用这个特点实现一个元素在其父元素水平居中。</strong>  (width:xx;margin:xx auto）</p><p><strong>垂直布局</strong></p><p>若父元素没设置高度，则默认父元素的高度被内容撑开。<br>使用overflow属性来设置父元素如何处理溢出的子元素，设置在子元素。</p><pre><code>overflow:visible //默认值，子元素会从父元素中溢出overflow:hidden //溢出内同被裁剪不会显示overflow:scroll //生成双向滚动条overflow:auto //根据需要生成滚动条overflow-x/overflow-y</code></pre><h3 id="外边距的折叠"><a href="#外边距的折叠" class="headerlink" title="外边距的折叠"></a>外边距的折叠</h3><p>相邻的垂直方向外边距会发生重叠方向。<br>兄弟元素间的相邻垂直外边距会取两者之间的绝对值较大值，若一正一负取和。兄弟元素之间的外边距重叠对开发有利，不需要处理。</p><p>父子元素的相邻外边距，子元素会传递给父元素(上边距)。</p><h2 id="行内元素盒模型"><a href="#行内元素盒模型" class="headerlink" title="行内元素盒模型"></a>行内元素盒模型</h2><p>行内元素不支持设置宽度和高度，行内元素可以设置padding/border/margin，但是垂直方向padding/border/margin不会影响页面的布局。<br>垂直方向取最大，水平方向取和。</p><p>使用display来设置元素的类型，与display:none相似的还有visibility：hidden。区别是前者隐藏后不占据位置，后者仍然占据位置只是不可见。</p><pre><code>visibility：hidden  //元素隐藏不显示，但是仍然占据位置visibility：visible //元素可见display:inlinedisplay:block //块元素占一行display:inline-block //行内块元素，宽高生效但不占一行，尽量不用换行符会解析display:none //元素不显示display:table //将元素设置为一个表格</code></pre><h2 id="CSS3的盒模型"><a href="#CSS3的盒模型" class="headerlink" title="CSS3的盒模型"></a>CSS3的盒模型</h2><p>CSS3新增<code>box-sizing</code>属性，该属性设置width与height的作用范围。</p><pre><code>box-sizing: border-box //使用ie盒模型box-sizing: content-box //使用标准盒模型，默认box-sizing:padding-box  //width/height设置的是左右padding+content</code></pre><p>标准盒子模型的width/height设置的是content的高度与宽度。<br>IE盒子模型的width/height设置的是content+左右padding+左右border之和。</p><p><strong>可以记忆成属性值为什么从哪个地方开始到对应的地方结束</strong></p><h2 id="轮廓和圆角"><a href="#轮廓和圆角" class="headerlink" title="轮廓和圆角"></a>轮廓和圆角</h2><p><strong>outline</strong><br>轮廓<code>outline</code>与<code>border</code>用法相同，轮廓<code>outline</code>不会影响布局，不会撑大盒子。</p><p><strong>box-shadow</strong><br><code>box-shadow</code>用来设置元素的阴影，前两个值为左侧下侧偏移量，第三个值为模糊程度，第四个值为颜色，不会影响布局。</p><p><strong>border-radius</strong><br><code>border-radius</code>用来设置圆角，指定画圆的半径，值为50%则是一个圆。第一个值是x方向半径，第二个值是y方向半径。</p><h1 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h1><p>通过浮动<code>float</code>可以使一个元素相对于<strong>父元素</strong>进行向左向右浮动，默认不会从<strong>父元素</strong>中移动。<br>元素设置浮动以后，水平布局的等式<strong>margin-left + border-left + padding-left + width +  padding-right + border-right + margin-right =  其父元素内容的宽度</strong>失效并且<strong>脱离文档流</strong>不占用文档流的位置。<br>如果浮动元素上面是在文档流中的，则浮动元素从该位置后面进行排序，而不是上移。<br>浮动元素不会超过它<strong>上一个浮动的兄弟元素高度</strong>，最多就是一样高。<br><strong>浮动元素不会盖住文字</strong>，文字会自动环绕在图片的周围。<br>元素从文档流中脱离，会具有<strong>行内块元素</strong>的特性。</p><h2 id="高度塌陷"><a href="#高度塌陷" class="headerlink" title="高度塌陷"></a>高度塌陷</h2><p>一般父元素的高度不会写死，高度根据子元素高度决定。当子元素浮动后，完全脱离文档流，子元素将无法撑起父元素的高度，导致父元素的高度丢失。</p><pre><code>//style.box1{ border:10px red solid;}.box2{width:100px;height:100px;background-color:green;float:left}//html&lt;div class=&quot;box1&quot;&gt;   &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p><img src="/img/css/高度塌陷.png"></p><p>解决办法：BFC<br>Block Formatting Context 块级格式化环境，是CSS中的一个隐含的属性，可以为一个元素开启BFC，开启BFC该元素会变成一个独立的布局区域。</p><p><strong>元素开启BFC后的特点</strong><br>1.开启BFC的元素不会被浮动元素所覆盖。<br>2.开启BFC的元素子元素和父元素外边距不会重叠。（不会发生子元素设置外边距，父元素跟着动的情况）<br>3.开启BFC的元素可以包含浮动的子元素，使其不会发生高度塌陷。</p><p>启动特殊方式开启元素的BFC<br>方法一：设置元素的浮动（不推荐）<br>副作用：会从文档中脱离。<br>方法二：变成行内块元素（不推荐）<br><strong>方法三</strong>：将元素的<code>overflow</code>设置为一个非visible的值，一般用<code>hidden</code>（常用方式）</p><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>给<strong>受影响</strong>的盒子添加<code>clear</code>属性，<code>clear</code>元素的原理是设置清除浮动以后，浏览器会自动为元素添加上外边距，所以添加了clear的属性<strong>不可以手动添加margin-top</strong>。</p><pre><code>clear:left //清除左侧浮动元素对当前元素的影响clear:right //清除右侧浮动元素对当前元素的影响clear:both //清除两侧中最大影响的那侧</code></pre><p><strong>高度塌陷的最终解决方案：使用after伪类</strong></p><p>在父元素的后面添加一个空标签(行内元素)，清除浮动对其的影响并使其为块元素，浏览器自动改变margin-top使其可以撑开父元素。</p><p>因为行内元素【如span】的padding-top,padding-bottom,margin-top,margin-bottom（垂直方向）属性设置无效。</p><pre><code>//表示box1(父元素)盒子里面内容的最后.box1::after{content:&quot;&quot;;display:block;clear:both}</code></pre><p>使用这种思想同时可以解决外边距重叠的问题。</p><pre><code>&lt;style&gt;  .box1{      width: 200px;      height: 200px;      background: green;  }    .box2{        width: 100px;        height: 100px;        background: orange;        margin-top: 100px;    }&lt;/style&gt;&lt;body&gt;&lt;div class=&quot;box1&quot;&gt;    &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><p><img src="/img/css/外边距折叠.png"></p><p>解决办法：让其外边距不相邻</p><pre><code>//box1盒子内容的最前面.box1::before{content:&quot;&quot;;display:table;}</code></pre><p><strong>clearfix</strong>解决外边距重叠与高度塌陷的问题，谁塌陷这个类名加在谁的身上。</p><pre><code>.clearfix::before,.clearfix::aftee{content:&quot;&quot;;display:table;clear:both;}</code></pre><h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><p>可以通过定位将元素摆到页面的任意位置（一般使用在微小的地方，大布局使用浮动），当元素开启了定位以后，可以通过偏移量(top bottom left right 仅对开启定位的元素有用)来设置元素的位置。</p><p><code>positon</code>属性的值:</p><ul><li>static 默认值，元素是静止的没有开启定位</li><li>relative 相对定位 sticky 粘滞定位</li><li>absolute 绝对定位 fixed 固定定位</li></ul><p><strong>relative相对定位</strong></p><p>开启绝对定位后，如果不设置偏移量元素不会发生变化<br>relative是参照于开启相对定位的元素在文档流中的位置（<strong>元素本身</strong>）进行定位的。<br>相对定位会提升元素的层次<br><strong>相对定位不会让元素脱离文档流</strong>并且不会改变元素的性质。脱离文档流后，元素会变成行内块元素（不会独占一行，宽高属性生效）</p><p><strong>absolute绝对定位</strong></p><p>开启绝对定位后，如果不设置偏移量元素的位置不会发生变化。<strong>元素会从文档流中脱离</strong>，绝对定位的元素会提升层级。<br>absolute定位元素是相对与其包含块（块级元素）进行定位<br>正常情况下，包含块就是离当前元素最近的祖先块元素。<br>绝对定位的包含块就是离它最近的<strong>开启了定位</strong>的祖先元素。</p><p>注意：平时使用的width:100%是指的是相对于包含块的长度</p><p>absolute定位的特点是<strong>父相子绝</strong>，使用绝对定位的元素会向上寻找第一个使用相对定位的父元素。</p><p>水平布局等式<strong>margin-left + border-left + padding-left + width +  padding-right + border-right + margin-right =  其父元素内容的宽度</strong></p><p>当开启了绝对定位之后的水平布局等式变成了<strong>left + margin-left + border-left + padding-left + width +  padding-right + border-right + margin-right + right = 包含块的宽度</strong><br>这9个值中可以设置为auto：width，margin，left，right。<br>如果发生过渡约束，等式会自动调整，宽度优先，right/left其次，左右平分：<br>1.如果9个值无auto的情况，则浏览器会自动调整right<br>2.如果某个值为auto，则会自动调整auto的值是等式成立。<br>3.如果一个宽度和一个外边距设置为auto，则优先把宽度调整到最大。<br>4.如果两个外边距设置为auto，宽度固定，则会将外边距设置为相同的值。<strong>利用这个特点实现一个元素在其父元素水平居中。</strong>  (width:xx;margin:xx auto）</p><p><strong>注意</strong>left和right的默认值是auto，所以如果不知道left和right，则等式不满足会自动调整这两个值。所以以上4点要在left/right设置的情况下进行。</p><p>当我们开启绝对定位后，垂直方向也需要满足垂直方向的等式也需要满足（正常的不会）,其规则类似水平布局。</p><p>所以可以利用其特点，进行元素的垂直居中</p><pre><code>//垂直居中的元素width:xxx;height:xxx;position:absolute; //父相子绝,在谁中间就给谁相对定位margin:autoleft:0;right:0;top:0;bottom:0;</code></pre><p><strong>fixed固定定位</strong></p><p>固定定位也是绝对定位的一种，所以固定定位的大部分特点都和绝对定位一样。<br>不同点是固定定位永远参照与<strong>浏览器的视口（可视区域，固定不动）</strong>进行定位</p><p><strong>sticky粘滞定位</strong></p><p>粘滞定位和相对定位的特点基本一致，不同的是粘滞定位当元素到达一定高度的时候固定住，常常和<code>top</code>结合。<br>sticky定位的元素元素仅在其父元素内生效且父元素的高度不能低于sticky定位 元素的高度，所以如果滚动到父元素的高度低于sticky定位元素的高度，该定位失效。</p><h2 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h2><p>定位的层级大于浮动的层级</p><p><code>z-index</code>属性可以来指定元素的层级，数越大层级越高。</p><p><strong>如果优先级一样，优先显示结构上靠下的元素</strong></p><p>祖先元素的层级再高也不会盖住后代元素。</p><h1 id="居中"><a href="#居中" class="headerlink" title="居中"></a>居中</h1><h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><p>1.文字的垂直居中</p><p>要让文字在父元素中垂直居中，只需将父元素的<code>line-height</code>设置为和父元素的高度一样。</p><p>2.利用定位</p><pre><code>//垂直居中的元素width:xxx;height:xxx;position:absolute; //父相子绝,在谁中间就给谁相对定位，也可以实现垂直水平居中，原理是利用布局等式margin:autotop:0;bottom:0;</code></pre><p>3.利用tabel的性质（很少使用）</p><pre><code>//将元素设置为单元格tddisplay:table-cell;//元素类的子元素垂直居中vertical-align:middle;</code></pre><p>4.利用transform</p><p>当元素的大小并不明确的时候，以水平为例子，垂直类似。</p><pre><code>.box{position:absolute;left:50%;//相对与包含块的50%transform:translateX(-50%)//相对于元素自身的50%}</code></pre><h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><p>一个元素在父元素中水平居中,该代码写在<strong>该元素</strong>的样式中，该代码仅对块级元素有效。</p><pre><code>width:xx;margin:xx auto</code></pre><p>这种办法的原理是利用水平布局的<strong>margin-left + border-left + padding-left + width +  padding-right + border-right + margin-right =  其父元素内容的宽度</strong>等式。</p><p>所有元素也可以通过对<strong>父元素</strong>设置 text-align：center；的方式来实现居中。<br>而对于块元素来说，对要<strong>居中的元素自身</strong>进行设置text-align:center也能实现居中，而无需对其父元素进行设置。</p><h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><h2 id="过渡transition"><a href="#过渡transition" class="headerlink" title="过渡transition"></a>过渡transition</h2><p>过渡三要素:起始位置 过渡时间 终止位置</p><p>transition-property        表示执行过渡的属性<br>transition-duration        指定用于过渡的持续时间<br>transition-timing-function 指定过渡的时序函数<br>transition-delay           指定过渡效果的延迟</p><p>在简写中，如果有2个时间，则第一个为持续时间，第二个为延迟时间。</p><h2 id="动画animation"><a href="#动画animation" class="headerlink" title="动画animation"></a>动画animation</h2><p>动画可以自动触发动态效果。设置动画效果，必须先设置一个关键帧，关键帧设置了动画执行每一个步骤。</p><pre><code>//定义关键帧@keyframes name{//第一种from{}to{}//第二种0%{}5%{}}//使用动画animation-name...  //其余属性同transitionanimation-iteration-count //迭代次数animation-direction //动画方向animation-play-state //设置动画的执行状态 执行或者暂停animation-fill-mode //动画开始/停止的位置，默认动画执行完毕回到原来的位置</code></pre><p>使用图片实现动画的一些小技巧</p><pre><code>.box{background-image:url(&quot;&quot;); //开启平铺animation:name 1s steps(几个图片就几次) infinite;}@keyframes name{from{background-position:0 0;}to{background-position:-图片的长度 0;}}</code></pre><h2 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h2><p>变形不会影响页面的布局，只会改变元素的形状或位置。</p><p><strong>平移</strong></p><p>可以与定位结合实现居中的效果。</p><pre><code>//百分比是相对于自身计算的，并不是根据包含块transform:translateX()/translateY()/translateZ()</code></pre><p>Z轴平移，正常情况就是调整人和元素之间的距离，距离越大，元素离人越近。如果想要看见效果必须要设置网页的视距。一般设置在html，<code>perspective:1000px</code> 表示人眼距离网页的距离</p><p><strong>旋转与缩放</strong></p><p>通过旋转可以使元素<strong>沿轴旋转</strong>指定的角度<br>沿X轴转的时候，设置视距可以看见近大远小的效果。<br>转了轴也会跟着转。</p><pre><code>transform:rotateZ（45deg）/rotateZ(.5turn)//旋转的背面是否可以看见backface-visibility:hidden;transform:scaleX() //缩放的是轴</code></pre><p>即使设置了视距可以看见近大远小的效果，但是仍然仅仅是2D的效果，如果想看见3D的效果还需要设置<code>transform-style:preserve-3d</code></p><h1 id="弹性盒子"><a href="#弹性盒子" class="headerlink" title="弹性盒子"></a>弹性盒子</h1><p>flex是CSS3中新增的布局手段，它主要用来代替浮动来完成页面的布局。</p><p>弹性容器：要使用弹性盒，必须先将一个容器设置为弹性容器,display:flex设置为块级弹性容器，display:inline-flex设置为行内的弹性容器。<br>    主轴：弹性元素的排列方式为主轴<br>    侧轴：与主轴垂直方向为侧轴</p><pre><code>弹性容器的样式flex-direction 指定容器中弹性元素的排列方式flex-wrap 指定弹性元素是否在容器中按侧轴换行flex-flow是上述两个属性的简写属性justify-content 如果分配主轴的空白空间align-items 元素在侧轴如何对齐,控制元素间的对齐align-content 侧轴空白空间的分配</code></pre><p>弹性元素：弹性容器的子元素<br>    弹性元素的样式<br>    flex-grow 指定弹性元素的伸展的系数，当父元素有多余空间时，子元素如何分配。<br>    flex-shrink 指定弹性元素的收缩性，当父元素的空间无法容纳所有的子元素时，如何对子元素进行收缩。<br>    align-self 用来覆盖当前弹性元素上的align-items<br>    flex-basis 指定元素在主轴上的基础长度，如果主轴是横向的，那么指定的就是元素的宽度<br>    flex 是上述的三个属性的简写，顺序也是上述的顺序<br>    order决定弹性盒子的排列顺序</p><p>一个元素可以同时是弹性盒子和弹性元素。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h2><p><code>border</code>四个方向的边框实际是一个<strong>梯形</strong>并不是矩形。当内容区域的高度宽度为0时，边框就会变成小三角形。</p><pre><code> .box1{    width: 0;    height: 0;    border: 20px red solid;    border-color:  border-color: red orange greenyellow yellow;}//常常用伪类添加三角效果//把不需要的方向颜色换成transparent就可以了。或者为了防止占位，可以添加 border-top:none 等来设计。.xxx::before{width: 0;height: 0;content:&quot;&quot;;display:block;border:10px solid transparent;border-top:none;border-bottom-color:white//如果开始不显示设置为display:none}//那么hover的时候可以用下面的写法使其显示//xxxhover的时候他的伪元素怎么样.xxx:hover::after{display:block}</code></pre><p><img src="/img/css/三角形.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;伪类选择器&lt;/li&gt;
&lt;li&gt;单位&lt;ul&gt;
&lt;li&gt;移动端适配&lt;/li&gt;
&lt;li&gt;媒体查询&lt;/li&gt;
&lt;li&gt;省略&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>exports与module.exports的区别</title>
    <link href="http://yoursite.com/2020/05/26/exports/"/>
    <id>http://yoursite.com/2020/05/26/exports/</id>
    <published>2020-05-26T02:20:58.000Z</published>
    <updated>2020-07-06T08:04:33.927Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h2><p>CommonJS加载模块是<strong>同步</strong></p><p><strong>知识点1</strong> Node中，一个js文件就是一个模块</p><p>引入：require(路径)，<strong>使用相对路径，必须以<code>.</code>或<code>..</code>开头</strong><br>引入模块以后，该函数会<strong>返回一个对象</strong>，这个对象代表的是引入的模块。</p><p>模块分成两大类：<br>核心模块：由node引擎提供的模块，核心模块的标识就是模块的名字<br>文件模块：由用户自己创建的模块，文件模块的标识为路径</p><p><strong>知识点2</strong>在Node中，<strong>每一个js文件中的js代码都是独立运行在一个函数体中</strong>。所以如果想要其他文件访问，必须要将数据暴露出来<br>暴露：exports.x = “xxxx”</p><pre><code>//当node在执行模块中的代码时，它首先在代码的最顶部，添加如下代码function(exports,require,module,__filename,__dirname){//里面才是自己写的name=XX}</code></pre><p>形参中</p><ul><li>exports：将变量或函数暴露到外部</li><li>require：用来引入外部的模块</li><li>module：代表当前模块本身</li><li>__filename：当前模块的完整路径</li><li>__dirname：当前模块所在文件夹的完整路径</li></ul><h3 id="exports与module-exports的区别"><a href="#exports与module-exports的区别" class="headerlink" title="exports与module.exports的区别"></a>exports与module.exports的区别</h3><p>本质上exports就是module的属性，module.exports===exports</p><ul><li>exports只能用.的方式来向外暴露内部变量，比如：exports.name = XXX</li><li>module.exports即可以通过.，也可以直接赋值暴露</li></ul><pre><code>//可以这样写module.exports = {}//错误写法exports = {}</code></pre><p>首先无论用<code>module.exports</code>还是<code>exports</code>都是改变的module的exports属性。</p><p>本质是exports与module.exports指向的是同一个对象。</p><pre><code>//module指向a空间let module = {};//在a空间中分配一块空间b给exportsmodule.exports =  {};//引用类型赋值，exports变量指向空间blet exports = module.exports//使用.赋值是ok的，相当于修改b空间里给name分配的c空间exports.name = &quot;xxx&quot;//使用直接赋值是不行的，因为引用类型在内存中存放的是指向数据的地址指针//直接赋值相当于修改的指针使其不在指向b，让指针指向别处。exports = {}</code></pre><p><img src="/img/node/export.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CommonJS规范&quot;&gt;&lt;a href=&quot;#CommonJS规范&quot; class=&quot;headerlink&quot; title=&quot;CommonJS规范&quot;&gt;&lt;/a&gt;CommonJS规范&lt;/h2&gt;&lt;p&gt;CommonJS加载模块是&lt;strong&gt;同步&lt;/strong&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Node" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/Node/"/>
    
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>npm包管理</title>
    <link href="http://yoursite.com/2020/05/25/npm%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2020/05/25/npm包管理/</id>
    <published>2020-05-25T14:40:46.000Z</published>
    <updated>2020-08-04T07:38:15.233Z</updated>
    
    <content type="html"><![CDATA[<p>NPM（Node Package Manager）<br>CommonJS包规范是理论（CommonJS的包规范 = 包结构+包描述文件），NPM是其中一种实践。<br>npm是Node.js的软件包管理，对于Node而言，NPM帮助其完成了第三方模板的发布、安装、依赖等。借助NPM，Node与第三方模块之间形成了很好的一个生态系统。</p><p>基本的操作：<br>查看版本：npm -v<br>搜索模块包：npm search 包名<br>安装包：npm install 包名 安装包并添加到依赖  （最好在要安装包的位置创建package.json文件）<br>        npm install 包名 -g 全局安装</p><p>初始化package.json:npm init (名字不用大写)<br>删除包：npm remove 包名</p><p>通过npm下载的包都在node_mudules文件夹中，直接通过包名即可引用。<br>node在使用模块名字来引入模块时，它会首先在当前目录的node_modules中寻找是否含有该模块，如果没有去上一级目录的node_modules中寻找，直到找到磁盘的根目录。</p><h3 id="问题1：全局安装与本地安装"><a href="#问题1：全局安装与本地安装" class="headerlink" title="问题1：全局安装与本地安装"></a>问题1：全局安装与本地安装</h3><p>npm install xxx # 本地安装<br>npm install xxx -g # 全局安装</p><p>本地安装</p><ol><li>将安装包放在 ./node_modules 下（运行npm时所在的目录）</li><li>可以通过 require() 来引入本地安装的包</li></ol><p>全局安装</p><ol><li>将安装包放在 /usr/local 下</li><li>可以直接在命令行里使用</li></ol><h3 id="问题2：-d与-s的区别"><a href="#问题2：-d与-s的区别" class="headerlink" title="问题2：-d与-s的区别"></a>问题2：-d与-s的区别</h3><p>npm install -d 就是npm install –save-dev<br>npm insatll -s 就是npm install –save</p><p>我们在使用npm install 安装模块或插件的时候，上述两种命令都可以把他们写入到 package.json 文件里面去。<br>首先dev是develop的简写，-save-dev安装的插件，被写入到 devDependencies 域里面去，<br>而使用 –save 或者默认没写 安装的插件，则是被写入到 dependencies区块里面去。devDependencies 里面的插件只用于开发环境，不用于生产环境，而dependencies是生产环境也就是项目运行在服务器需要的插件。</p><p>例子：比如我们写一个项目要依赖于jQuery，没有这个包的依赖运行就会报错，这时候就把这个依赖写入dependencies ；而我们使用的一些<strong>构建工具比如glup、webpack这些只是在开发中使用的包</strong>，上线以后就和他们没关系了，所以将它写入devDependencies。</p><h3 id="问题3：什么是npx"><a href="#问题3：什么是npx" class="headerlink" title="问题3：什么是npx"></a>问题3：什么是npx</h3><p>npm从5.2版本，增加了npx命令。npx主要作用是调用项目内部安装的模块和方法。<br>现在的工具包一般都安装在局部，而不是全局。</p><pre><code>//安装在开发环境的webpack-dev-servernpm install webpack-dev-server -D//命令行中启动webpack-dev-servernpx webpack-dev-server</code></pre><p>npx的原理是运行的时候会到<strong>node_modules/.bin路径和path里面，查看命令是否存在</strong>。</p><p>注意：Bash内置的命令不在Path中，所以类似cd的Bash命令不可以使用npx。</p><p>npx还可以运行一些需要全局安装的依赖（但不安装该依赖），npx将会把该依赖下载到一个临时目录，使用以后再删除，<strong>所以可以避免全局安装模块。</strong></p><p>可以在package.json中scripts属性中配置命令如”build”:webpack ,npm run build 实现npx同样的效果。</p><p>–no-install与–ignore-existing参数</p><p>–no-install:可以时npx强制使用本地模块，不下载远程模块，所以如果本地不存在该模块，就会报错。<br>–ignore-existing:可以使npx强制安装使用远程模块，忽略本地的同名模块。</p><p>-p参数用于指定npx所要安装的模块。</p><pre><code>//-p也可以省略npx -p node@0.12.8</code></pre><p><strong>总结</strong></p><ul><li>利用npx可以下载模块使用过后再删除的特点，可以在某些场景切换版本。</li><li>使用npx可以不需要全局安装依赖，较少使用本机的存储空间。</li><li>使用本地已安装的可执行工具，而不需要配置scripts。</li><li>可以执行依赖包中的命令，安装完成自动运行。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;NPM（Node Package Manager）&lt;br&gt;CommonJS包规范是理论（CommonJS的包规范 = 包结构+包描述文件），NPM是其中一种实践。&lt;br&gt;npm是Node.js的软件包管理，对于Node而言，NPM帮助其完成了第三方模板的发布、安装、依赖等。
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Node" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/Node/"/>
    
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>unexpected-token&lt; 报错</title>
    <link href="http://yoursite.com/2020/03/22/unexpected-token/"/>
    <id>http://yoursite.com/2020/03/22/unexpected-token/</id>
    <published>2020-03-22T06:13:48.000Z</published>
    <updated>2020-08-22T10:33:57.574Z</updated>
    
    <content type="html"><![CDATA[<p>因为团队信息的后台返回数据格式发生了变化，前端字段应该做相应变化。<br>改完之后，本地是没有问题的，打包上线到服务器之后发现了报错了<code>Uncaught SyntaxError: Unexpected token &lt;</code></p><p><img src="\img\软件超市\报错图.png" alt="报错图"></p><p>所以原因要么在服务器，要么就是打包的问题。</p><p>首先进行排查的是文档类型，因为报错的三行都是与js相关。<br>点击控制台错误的代码提示，查看<code>network</code>对应的文件加载状态,发现返回的不是<code>js</code>形式。而是<code>doctype html</code>,那么很大概率是服务器把<code>js</code>文件当作<code>html</code>响应，导致解析错误。正常情况返回<code>content-type:applocation/javascript</code>，而现在的错误情况<code>js</code>文档的响应信息，变成了<code>text/html</code></p><p><img src="\img\软件超市\文档类型错误.png" alt="文档类型错误"><br><img src="\img\软件超市\文档类型错误1.png" alt="文档类型错误1"></p><p>把上一个版本部署上去，发现没问题。那么排除了服务器的问题，应该是打包的问题。</p><p>确定是打包的问题之后查看<code>config/index.js</code>,找到了原因。</p><p><img src="\img\软件超市\打包路径.png" alt="打包路径"></p><p>默认的是在路径前面添加/,但是此项目的路由设置了所有路径都会跳转到/manage/xx,所以需要在修改assetPublicPath属性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为团队信息的后台返回数据格式发生了变化，前端字段应该做相应变化。&lt;br&gt;改完之后，本地是没有问题的，打包上线到服务器之后发现了报错了&lt;code&gt;Uncaught SyntaxError: Unexpected token &amp;lt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img s
      
    
    </summary>
    
      <category term="questions" scheme="http://yoursite.com/categories/questions/"/>
    
      <category term="vue" scheme="http://yoursite.com/categories/questions/vue/"/>
    
    
      <category term="软件超市" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82/"/>
    
  </entry>
  
  <entry>
    <title>XHR的ajax封装(简单版本)</title>
    <link href="http://yoursite.com/2020/03/01/XHR%E7%9A%84ajax%E5%B0%81%E8%A3%85/"/>
    <id>http://yoursite.com/2020/03/01/XHR的ajax封装/</id>
    <published>2020-03-01T07:23:33.000Z</published>
    <updated>2020-07-09T08:16:05.302Z</updated>
    
    <content type="html"><![CDATA[<p>目的:熟练XHR的基本使用</p><p><strong>特点</strong><br>1.函数的返回值为promise，成功的结果为response，失败的结果为error<br>2.能处理多种类型的请求：GET/POST/PUT/DELETE<br>3.函数的参数为一个配置对象</p><pre><code>    {    url:&quot;&quot;,//请求地址    method:&quot;&quot;,//请求方式    params:{},//GRT/DELETE请求的query参数    data:{},//POST或DELETE请求的请求体参数    }</code></pre><p>4.响应json数据自动解析为js<br>5.response只实现了data，status，statusText<br>6.put请求提交的是请求体参数，delete提交query参数</p><p><strong>补充</strong><br>1.query，params，body<br>    req.params,req.query是用在get请求当中<br>    query参数<br>    返回值：对数据过滤产生一个新数组<br>    param参数:常用于REST API风格</p><pre><code>localhost:3000/posts?id=1</code></pre><p>  返回值：定位到对应的对象<br>  返回值：定位到对应的对象</p><pre><code>localhost:3000/posts/1</code></pre><p>  req.body是用在post请求中的，body 不是 nodejs 默认提供的，你需要载入 body-parser 中间件才可以使用，req.body此方法通常用来解析 POST 请求中的数据。</p><p>2.OPTIONS请求，预检查（get不需要）是否跨域等，没有响应体。</p><p><strong>注意</strong>:<br>1.axios的params是指定get或者delete请求的query参数（拼接在url后面）<br>2.发送json格式请求体参数，需要设置请求头</p><pre><code>function axios({    url,    method=&quot;GET&quot;, //设置默认值    parmas={},//默认空对象    data={}//设置默认值  }) {    //返回一个Promise对象    return new Promise((resolve, reject) =&gt; {        //处理query参数，拼接到url        let queryString=&#39;&#39;        for (key in params){            queryString+=`${key}=${parmas[key]}&amp;`        }        if (queryString){            //去掉最后的&amp;           queryString = queryString.substring(0,queryString.length-1)           //拼接           url += &quot;?&quot;+queryString        }        //处理method为大写        method = method.toUpperCase()    //1.执行异步ajax请求        //创建xhr对象        const request = new XMLHttpRequest();        //初始化请求(异步)        request.open(method,url,true)        //绑定状态改变的监听,send是异步的，所以绑定监听写在send后面也可以        request.onreadystatechange = function () {            //如果请求没有完成，直接结束            if (request.readyState!==4){                return            }        }        switch (method){            case &quot;GET&quot;||&quot;DELETE&quot; :                //get的参数通过url传                request.send();                break;            case &quot;POST&quot;||&quot;PUT&quot;:                //发送请求                // post请求的data不能是对象需要是字符串                //发送JSON格式，需要加请求头                request.setRequestHeader(&quot;Content-Type&quot;,&quot;application/json;charset=utf&quot;)//告诉服务器请求体的格式是json                request.send(JSON.stringify(data))                break;        }        //如果响应状态码在【200，300)之间代表成功，否则失败     const {status,statusText} = request     if (status&gt;=200&amp;&amp;status&lt;=299){         //2.1如果请求成功了，调用resolve()         //准备结果response对象         const response = {             //服务器返回的是JSON数据需要转换成对象             //响应json数据自动解析为js的对象/数组             data:JSON.parse(request.response),             status,             statusText,         }            resolve(response)     }else {         //2.2如果请求失败,调用reject()         reject(new Error(`request error status is ${status}`))     }    })}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目的:熟练XHR的基本使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;br&gt;1.函数的返回值为promise，成功的结果为response，失败的结果为error&lt;br&gt;2.能处理多种类型的请求：GET/POST/PUT/DELETE&lt;br&gt;3.函数的参数为一个
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="库" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E5%BA%93/"/>
    
    
      <category term="ajax" scheme="http://yoursite.com/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>axios</title>
    <link href="http://yoursite.com/2020/02/27/axios/"/>
    <id>http://yoursite.com/2020/02/27/axios/</id>
    <published>2020-02-27T13:34:38.000Z</published>
    <updated>2020-07-06T07:59:18.626Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP相关"><a href="#HTTP相关" class="headerlink" title="HTTP相关"></a>HTTP相关</h2><p>交互的基本过程</p><p>客户端 ===》（请求行，请求头，请求体）服务器<br>服务器 ===》（状态行，响应头，响应体）客户端</p><p><strong>请求报文</strong><br>请求行：method url<br>多个请求头：host主机，cookie，Content-Type(请求体的内容类型)application/json 或者 application/x-<a href="http://www.form.urlencoded" target="_blank" rel="noopener">www.form.urlencoded</a><br>请求体（get请求没有）：{“username”:”tom”,”pwd”:123} 或者 username=tom&amp;pwd=123</p><p><strong>响应报文</strong><br>状态行：status statusText<br>多个响应头：Content-Type(响应体的内容类型):text/html;charset=uft-8   Set-Cookie:BD_CK_SAM=1;path=/<br>响应体：html 文本/json 文本/js/css/图片…</p><p><strong>post请求体参数格式</strong><br>Content-Type:application/x-<a href="http://www.form.urlencoded" target="_blank" rel="noopener">www.form.urlencoded</a><br>例如：username=tom&amp;pwd=123</p><p>Content-Type:application/json<br>例如：{“username”:”tom”,”pwd”:123}</p><p>Content-Type:multipart/form-data<br>用于文件上传请求</p><p><strong>常见的响应状态码</strong><br>200 ok  请求成功，一般用于GET与POST请求<br>201 created 已创建。成功请求并创建了新的资源<br>401 Unauthorized 未到授权/请求要求用户的身份认证<br>404 Not Found 服务器无法根据客户端的请求找资源<br>500 Internal Serve Error 服务器内部错误，无法完成请求</p><p><strong>常用请求类型</strong></p><p>GET:从服务器端读取数据<br>POST:向服务器端添加新数据<br>PUT:更新服务器端已有数据<br>DELETE:删除服务器端数据</p><p><strong>API的分类</strong><br>1.REST API: restful</p><ul><li>发送请求进行操作由请求方式决定</li><li>同一个请求路径可以进行多个操作（如同一个路径的get、delete）</li><li>请求方式会用到GET/POST/PUT/DELETE<br>2.非REST API restless</li><li>请求方式不决定请求的操作</li><li>一个请求路径只能对用一个操作</li><li>一般只有GET/POST</li></ul><p>json-server工具包可快速搭建REST API</p><h2 id="XHR的理解和使用"><a href="#XHR的理解和使用" class="headerlink" title="XHR的理解和使用"></a>XHR的理解和使用</h2><p>XHR对象可以从URL获取数据，而<strong>无需让整个页面刷新</strong></p><p>一般的http请求与ajax请求<br>1.ajax请求是一种特别的http请求<br>2.对服务端来说，没有任何区别，区别在浏览器端<br>3.浏览器端发请求：只有XHR或fetch发出的才是ajax请求<br>4.浏览器端接收响应：<br>    一般请求：浏览器一般会直接显示响应体数据，也就是我们常说的刷新/跳转页面<br>    ajax请求：浏览器不会对界面进行任何更新操作，只是调用监视的回调函数并传入响应相关数据。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>XHR对象的属性：<br>XMLHttpRequest():创建XHR对象的构造函数<br>readyState（请求的状态）：<br>    0：初始<br>    1：open()之后<br>    2：send()之后<br>    3：请求中<br>    4：请求完成<br>onreadystatechange：绑定readyState改变的监听<br>responseType:指定响应数据类型，如果是’json’,得到响应后自动解析响应体数据<br>response：响应体数据，类型取决于responseType<br>open(method，url[,async]):初始化一个请求,默认async：true<br>send(data)：发送请求<br>abort()：中断请求<br>getResponseHeader(name)：获取指定名称的响应头值<br>getAllResponseHeaders():获取所有响应头组成的字符串<br>setResponseHeaders(name,value):设置请求头<br>status：由服务器返回的HTTP状态代码<br>statusText：由服务器返回的HTTP状态文本</p><h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><p>ajax技术的核心是XMLHttpRequest对象(简称XHR)，</p><blockquote><p><a href="https://biubiuins.github.io/2020/03/01/XHR%E7%9A%84ajax%E5%B0%81%E8%A3%85/" target="_blank" rel="noopener">XHR的ajax简单封装</a></p></blockquote><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p>axios的post请求头默认是<code>application/x-www-form-urlencoded</code>,如果data是对象,默认Json。<br>axios请求的方式可以通过函数axios(config)使用，也可以通过对象axios.get()使用</p><p><strong>特点</strong><br>1.基于promise的异步ajax请求库（基于promise的 HTTP 库）<br>2.浏览器端/node端都可以使用<br>3.支持请求/响应拦截器<br>4.支持请求取消<br>5.请求/响应数据转换<br>6.批量发送多个请求</p><h3 id="axios-create-config"><a href="#axios-create-config" class="headerlink" title="axios.create(config)"></a>axios.create(config)</h3><p>自定义配置新建一个新的axios实例，新axios只是没有取消请求和批量发请求的方法，其他所有语法都是一致的。</p><pre><code> const instance = axios.create({        baseURL:&quot;http://localhost:3000&quot;    })    //使用instance发请求    instance({        url:&quot;/posts&quot; //请求端口3000    })</code></pre><p>这个语法的用处：<br>    需求：项目中有部分接口需要的配置与另一部分接口需要的配置不太一样<br>    解决：创建2个新的axios，每个都有自己特有的配置，分别应用到不同要求的接口请求中</p><pre><code>   axios.default.baseURL = &quot;http://localhost:4000&quot;    axios({        url:&quot;/posts&quot; //请求的端口4000    })    const instance = axios.create({        baseURL:&quot;http://localhost:3000&quot;    })    //使用instance发请求    instance({        url:&quot;/posts&quot; //请求端口3000    })</code></pre><h3 id="axios的处理链流程"><a href="#axios的处理链流程" class="headerlink" title="axios的处理链流程"></a>axios的处理链流程</h3><p><strong>axios拦截器</strong></p><p>请求拦截器<br>axios.interceptor.request.use(callback)<br>响应拦截器<br>axios.interceptor.response.use(callback)</p><pre><code>   axios.interceptors.request.use(config=&gt;{        console.log(&quot;request interceptor1 &quot;);        //拦截请求，处理请求之后，必须要返回该配置，若不返回相当于axios请求没有添加配置        return config    },error=&gt;{        console.log(&quot;request interceptor1 err&quot;);        return Promise.reject(error)    })    axios.interceptors.request.use(config=&gt;{        console.log(&quot;request interceptor2 &quot;);        return config    },error=&gt;{        console.log(&quot;request interceptor2 err&quot;);        return Promise.reject(error)    })    axios.interceptors.response.use(response=&gt;{        console.log(&quot;response interceptor1 &quot;);        return response    },error=&gt;{        console.log(&quot;response interceptor1 err&quot;);        return Promise.reject(error)    })    axios.interceptors.response.use(response=&gt;{        console.log(&quot;response interceptor2 &quot;);        //拦截response结果处理之后，要返回结果        return response    },error=&gt;{        console.log(&quot;response interceptor2 err&quot;);        return Promise.reject(error)    }) axios.get(&quot;http://localhost:/posts&quot;).then(response =&gt;{     console.log(&quot;response data&quot;); }).catch(error=&gt;{     console.log(&quot;response error&quot;); }) /* 输出request interceptor2request interceptor1response interceptor1 errresponse interceptor2 errresponse error */</code></pre><p>注意点：<br>1.请求拦截器后添加先执行。<br>2.拦截请求，处理请求之后，必须要返回该配置，若不返回相当于axios请求没有添加配置<br>3.拦截response结果处理之后，要返回结果。</p><h3 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h3><p>应用场景:如果发送请求2的时候，发现请求1还没有完成则取消请求1</p><pre><code>let cancel //保存用于取消请求的函数function getProducts1(){    if (typeof cancel === &quot;function&quot;){        //需要使用取消请求时调用        //如果请求取消了，则该请求进入请求失败的流程，请求失败的error是Cancel对象类型，Cancel里面有message属性        cancel(&quot;这里可以传消息提示&quot;)    }    axios.get(&quot;/user&quot;,{        cancelToken:new axios.CancelToken(            //执行器回调，同步进行            c =&gt; {//c是用于取消当前请求的函数                cancel = c            }        )    }).then(response =&gt;{        cancel = null //如果请求完成就不要取消请求了    },error =&gt;{        if (axios.isCancel(error)){            // 取消请求            console.log(&quot;请求取消了&quot;,error.message);        }        else{            //请求本身出错            cancel = null            console.log(error);        }    })}function getProducts2(){    if (typeof cancel === &quot;function&quot;){  cancel(&quot;这里可以传消息提示&quot;)    }    axios.get(&quot;/user/1&quot;,{        cancelToken:new axios.CancelToken(            c =&gt; {cancel = c}        )    }).then(response =&gt;{        cancel = null    },error =&gt;{        if (axios.isCancel(error)){            console.log(&quot;请求取消了&quot;,error.message);        }        else{            cancel = null            console.log(error);        }    })}</code></pre><p>改进版本</p><pre><code> //添加请求拦截器 axios.interceptors.request.use(config=&gt;{     if (typeof cancel === &quot;function&quot;){         cancel(&quot;这里可以传消息提示&quot;)     }     config.cancelToken =new axios.CancelToken(         c =&gt; {             cancel = c         }     )     return config }) //添加响应拦截器axios.interceptors.response.use(    respose=&gt;{        cancel = null        return respose    },    error =&gt;{            if (axios.isCancel(error)){                console.log(&quot;请求取消了&quot;,error.message);                //中断promise链接                return new Promise(()=&gt;{})            }            else{                cancel = null                //将错误继续向下传递               // throw error                return Promise.reject(error)            }})let cancelfunction getProducts1(){    axios.get(&quot;/user&quot;).then(response =&gt;{         //其他数据响应    },error =&gt;{       //只需要处理请求失败    })}function getProducts2(){    axios.get(&quot;/user/1&quot;).then(response =&gt;{        //其他数据响应    },error =&gt;{        //只需要处理请求失败    })}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HTTP相关&quot;&gt;&lt;a href=&quot;#HTTP相关&quot; class=&quot;headerlink&quot; title=&quot;HTTP相关&quot;&gt;&lt;/a&gt;HTTP相关&lt;/h2&gt;&lt;p&gt;交互的基本过程&lt;/p&gt;
&lt;p&gt;客户端 ===》（请求行，请求头，请求体）服务器&lt;br&gt;服务器 ===》（状态
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="库" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E5%BA%93/"/>
    
    
      <category term="ajax" scheme="http://yoursite.com/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>Node.js（3.28更新）</title>
    <link href="http://yoursite.com/2020/02/25/node-js/"/>
    <id>http://yoursite.com/2020/02/25/node-js/</id>
    <published>2020-02-25T06:49:46.000Z</published>
    <updated>2020-07-09T08:13:55.752Z</updated>
    
    <content type="html"><![CDATA[<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>Node.js是能够在<strong>服务器端</strong>运行JavaScript的开放源代码、跨平台JavaScript<strong>运行环境</strong></p><ul><li>Node是对ES标准一个实现，Node也是一个JS引擎</li><li>通过Node可以使js代码在服务器端执行</li><li>Node仅仅对ES标准进行了实现，所以在Node中不包含DOM和BOM</li><li>Node中可以使用所有的内建对象（String Number Boolean Math Date RegExp Function Object Array）而BOM（操作浏览器）和DOM（文档对象模型）都不能使用，但是可以用console也可以用定时器</li><li>Node可以在后台来编写服务器，Node服务器都是单线程的服务器。</li></ul><p>补充：<br>1.node中有一个全局对象global，它的作用和网页中window类似，在全局创建的变量/方法都会作为global的属性/方法保存<br>2.代码风格：建议无论有分号代码或者无分号代码，都建议如果一<code>（</code>、<code>[</code>、<code>\`</code>开头，最好都在前面补上一个分号。</p><h2 id="Buffer（缓存区）"><a href="#Buffer（缓存区）" class="headerlink" title="Buffer（缓存区）"></a>Buffer（缓存区）</h2><p>Buffer的结构和数组很像，操作的方法也和数组类似。数组中不能存储二进制的文件，而Buffer专门用来存储二进制数据(图片/mp3/视频 二进制文件)</p><p>使用：buffer不需要引入模块，直接使用即可</p><p><strong>常用操作</strong><br>Buffer.from(str[,encoding])</p><ul><li>str 需要编码的字符串</li><li>encoding 默认’utf8’<br>把字符串转换成二进制,buffer中每个元素的范围从00-ff（8bit）,如果要转换成字符串用<code>toString()</code></li></ul><p>Buffer.length<br>Buffer占用的内存大小</p><p>Buffer.alloc(size[, fill[, encoding]])</p><ul><li>size，分配的内存长度</li><li>fill，用于预填充新Buffer的值，默认值：0</li><li>encoding，如果fill是一个字符串，则这是它的字符编码，默认’utf8’</li></ul><pre><code>//创建一个10个字节的bufferlet buf = Buffer.alloc(10)//通过索引，来操作buf中的元素buf[0] = 88</code></pre><p>注意：Buffer的大小一旦确定，则不能在修改，因为Buffer是对内存的直接操作<br>      只要数字在控制台或页面中输出一定是10进制<br>      如果要16进制输出，number的toString(进制)里面可以传参。</p><pre><code>  ```   let buf = Buffer.alloc(10)   buf[1]=0xaa;   console.log(buf[1].toString(16));   //输出aa  ```</code></pre><p> Buffer.allocUnsafe(size)<br> 创建一个指定大小的buffer，但是buffer中可能含有敏感数据（分配空间并没有预设默认值0）</p><h2 id="fs（文件系统）"><a href="#fs（文件系统）" class="headerlink" title="fs（文件系统）"></a>fs（文件系统）</h2><p>文件系统简单来说就是通过Node来操作系统的文件。服务器的本质就是将本地的文件发送给远程的客户端。<br>fs模块中所有的操作都有同步和异步两种形式选择，同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码，异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回。</p><p>使用：使用文件系统，需要先引入fs模块，fs是核心模块，直接用名字引入不需要下载。</p><h3 id="同步-异步文件写入"><a href="#同步-异步文件写入" class="headerlink" title="同步/异步文件写入"></a>同步/异步文件写入</h3><p>同步的文件的写入：<br>1.打开文件  fs.openSync(path[, flags, mode])</p><pre><code>- path 打开文件的路径- flags 打开文件要做的操作的类型 默认&#39;r&#39;- mode 设置文件的操作权限，一般不传返回值：该方法会返回一个文件的描述符作为结果，我们可以通过该描述符对文件进行各种操作</code></pre><p>2.向文件中写入内容 fs.writeSync(fd, buffer[, offset[, length[, position]]])</p><pre><code>- fd 文件的描述符，需要传递要写入的文件的描述符- buffer 要写入的内容- offset 写入的位置</code></pre><p>3.保存并关闭文件 fs.closeSync(fd)</p><pre><code>let fs = require(&quot;fs&quot;)//打开文件let fd = fs.openSync(&quot;hello.txt&quot;,&quot;w&quot;)//向文件中写入内容console.log(fd);fs.writeSync(fd,&quot;hello&quot;)//保存并关闭文件fs.closeSync(fd)</code></pre><p>异步方法(不可能有返回值):<br>1.打开文件  fs.open(path[, flags[, mode]], callback)</p><p>，结果是通过回调函数返回的,回调函数路两个参数。</p><pre><code>- err 错误对象，如果没有错误则为null（js的设计思想，错误优先）- fd 文件描述符</code></pre><p>2.向文件中写入内容 fs.write(fd, buffer[, offset[, length[, position]]], callback）<br>3.关闭文件 fs.close(fd, callback)</p><pre><code>let fs = require(&quot;fs&quot;)//打开文件fs.open(&quot;hello.txt&quot;,&quot;w&quot;,function (err,fd) {   if (!err) {       console.log(&quot;打开成功&quot;);        //向文件中写入内容        fs.write(fd,&quot;这是异步写入的内容&quot;,function (err) {        if (!err){           console.log(&quot;写入成功&quot;);       }       //关闭文件            fs.close(fd, function (err) {                console.log(&quot;文件关闭&quot;);            })   })   }    else console.log(err);})</code></pre><h3 id="常用-简单的文件写入"><a href="#常用-简单的文件写入" class="headerlink" title="(常用)简单的文件写入"></a>(常用)简单的文件写入</h3><p>fs.writeFile(file, data[, options], callback)</p><ul><li>file 要操作的文件的路径</li><li>data 要写入的数据</li><li>options 选项，可以对写入进行一些设置</li><li>callback 当写入完成以后执行的函数</li></ul><pre><code>const fs = require(&quot;fs&quot;)fs.writeFile(&quot;hello.text&quot;,&quot;这是通过writeFile写入的内容&quot;,function (err) {    if (!err){        console.log(&quot;写入成功&quot;);    }})</code></pre><p><strong>文件打开常用模式：</strong><br>w：写入文件，如果不存在则创建，文件写入默认从头开始写会覆盖文件。<br>r+:读写文件，写操作时会覆盖，文件不存在则出现异常。<br>w+:读写文件，文件不存在先创建，会覆盖。<br>a: 写入文件，打开文件用于追加，如果不存在则新建。<br>a+：读写文件，文件不存在先建立，追加<br>r：读取文件，文件不存在则出现异常<br>rb/wb：分别与r/w相似，但是用于读写二进制文件</p><h3 id="流式文件写入"><a href="#流式文件写入" class="headerlink" title="流式文件写入"></a>流式文件写入</h3><p>同步、异步、简单文件的写入都不适合大文件的写入（只要写一次），性能较差，容易导致内存溢出。<br>只要流存在，可以分多次写入。</p><p>创建一个可写流：fs.createWriteStream(path,[,options])</p><pre><code>  - path：文件路径  - options 配置的参数  - 有返回值，该方法会返回一个文件的描述符作为结果，我们可以通过该描述符对文件进行各种操作</code></pre><pre><code>const fs = require(&quot;fs&quot;)//流失文件写入//创建一个可写流let ws = fs.createWriteStream(&quot;hello.txt&quot;)//可以通过监听流的open和close事件来监听流的打开和关闭ws.once(&quot;open&quot;,function () {    //open只会触发一次，on绑定了事件会一直存在，所以用once绑定一次性事件。    console.log(&quot;已经打开流&quot;);})ws.once(&quot;close&quot;,function () {    console.log(&quot;流关闭&quot;);})ws.write(&quot;写入成功&quot;)ws.write(&quot;哈哈哈哈&quot;)ws.write(&quot;写入成功&quot;)ws.write(&quot;哈哈哈哈&quot;)//关闭流，关闭的接收方，ws.close()</code></pre><h3 id="文件的读取"><a href="#文件的读取" class="headerlink" title="文件的读取"></a>文件的读取</h3><p>操作基本上和文件的写入差不多，具体看API。<br>注意：<br>1.读取到的数据会返回一个Buffer<br>2.如果要读取一个可读流中的数据，必须要为可读流绑定一个data事件，data事件绑定完毕，它会自动开始读取数据，读取完毕后可读流自动关闭</p><pre><code>const fs = require(&quot;fs&quot;)//流失文件读取，可以分多次将文件读取到内存中//创建一个可读流let rs = fs.createReadStream(&quot;消息提醒.png&quot;)//创建一个可写流let ws = fs.createWriteStream(&quot;xxx.png&quot;)//可以通过监听流的open和close事件来监听流的打开和关闭rs.once(&quot;open&quot;,function () {    console.log(&quot;已经打开流&quot;);})rs.once(&quot;close&quot;,function () {    console.log(&quot;流关闭&quot;);    //读取完毕后可读流自动关闭，所以在这个时候关闭可写流    ws.close()})//如果要读取一个可读流中的数据，必须要为可读流绑定一个data事件，data事件绑定完毕，它会自动开始读取数据，读取完毕后自动关闭rs.on(&quot;data&quot;,function (data) {    console.log(data);    ws.write(data);    //ws.close()，可能导致只读了一条数据就关闭})</code></pre><p><strong>pipe()</strong><br>更简单的写法pipe(),<code>rs.pipe(ws)</code>在可读流rs与可写流ws之间架起一个管道，自动将可读流中的内容，直接输出可写流。</p><h3 id="fs其他常用方法"><a href="#fs其他常用方法" class="headerlink" title="fs其他常用方法"></a>fs其他常用方法</h3><p>验证路径是否存在  fs.existsSync(path)   返回值：存在true，不存在false<br>获取文件状态  fs.stat(path,callback)/fs.statSync(path) 返回对象：文件的状态<br>删除文件  fs.unlink(path,callback)/fs.unlinkSync(path)<br>读取一个目录的目录结构 fs.readdir(path[,options],callback)/fs.readdirSync(path[,options]) 返回一个字符串数组，每一个元素就是一个文件夹或文件的名字<br>截断文件  fs.truncate(path,len,callback)/fs.truncateSync(path,len)   将文件修改成指定的len大小（一个汉字3个字节）<br>创建文件夹  fs.mkdir(path[,mode],callbcak)/fs.mkdirSync(path[,mode])<br>删除文件夹  fs.rmdir(path,callbcak)/fs.rmdirSync(path)<br>重命名文件/剪贴文件 fs.rename(oldPath(oldName),newPath,callback)/fs.renameSync(oldPath,newPath)<br>监视文件的修改 fs.watchFile(filename[,options],listener)  listener回调函数，当文件发生变化时，回调函数会执行。</p><h2 id="ip地址和端口号"><a href="#ip地址和端口号" class="headerlink" title="ip地址和端口号"></a>ip地址和端口号</h2><ul><li>ip地址用来定位计算机</li><li>端口号用来定位具体的应用程序</li><li>一切需要联网通信的软件都会占用一个端口号</li><li>端口号的范围从0-65536</li><li>在计算中有写一些默认端口号，最好不要去使用。如：http服务的80</li></ul><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>request 请求事件处理函数，需要接收两个参数：request，response。</p><pre><code>const http = require(&quot;http&quot;)const server = http.createServer()server.on(&quot;request&quot;,function (request,response) {    console.log(&quot;请求路径是&quot; + request.url);    //在服务端默认发送的数据，其实是utf8编码的内容    //但是浏览器不知道是utf8的内容，在不知道服务器响应内容的编码的情况下会按照当前操作系统默认编码解析   //text/plain;普通文本    //response对象有一个方法：write可以用来给客服端发送响应数据；    //write可以使用多次，但最后一定要使用end来结束响应，否则客服端会一致等待    //响应的数据只能是二进制(默认)或字符串    fs.readFile(xxx,function(err,data){    response.setHeader(&#39;Content-type&#39;,&quot;text/html;charset=utf-8&quot;)    response.end(data)    })    }})server.listen(3000,function () {    console.log(&quot;服务器启动成功&quot;);})</code></pre><h2 id="url"><a href="#url" class="headerlink" title="url"></a>url</h2><p>url：统一资源定位符，url核心模块在为我们解析url地址时提供了非常方便的API<br>url.parse()方法可以解析一个url地址，通过传第二个参数(true)把包含有查询字符串的query转化成对象</p><pre><code>const url = require(&quot;url&quot;)let httpUrl = &quot;https://sale.vmall.com/hwmate.html#abc?cid=10602&quot;let urlObj = url.parse(httpUrl)console.log(urlObj);//Url {//   protocol: &#39;https:&#39;, 协议//   slashes: true,//   auth: null,//   host: &#39;sale.vmall.com&#39;,  主机//   port: null, 端口号//   hostname: &#39;sale.vmall.com&#39;,//   hash: &#39;#abc?cid=10602&#39;,//   search: &#39;?cid=10602&#39;, 查找的内容//   query: &#39;cid=10602&#39;,  query问号后面的内容//   pathname: &#39;/hwmate.html&#39;, 路径的名称//   path: &#39;/hwmate.html?cid=10602&#39;,//   href: &#39;https://sale.vmall.com/hwmate.html?cid=10602&#39; }</code></pre><p>url.resolve()方法合成url，第一个参数基url，第二个参数目标url</p><pre><code>const url = require(&quot;url&quot;)let targetUrl=&quot;http://www.taobao.com/&quot;let httpUrl = &quot;./xxx.html&quot;console.log(url.resolve(targetUrl, httpUrl));//自动去掉.///http://www.taobao.com/xxx.html</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h2&gt;&lt;p&gt;Node.js是能够在&lt;strong&gt;服务器端&lt;/strong&gt;运行JavaScript的开放源代码、跨平台JavaScript&lt;stron
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Node" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/Node/"/>
    
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>闭包</title>
    <link href="http://yoursite.com/2020/02/23/%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2020/02/23/闭包/</id>
    <published>2020-02-23T08:48:04.000Z</published>
    <updated>2020-07-30T10:43:48.167Z</updated>
    
    <content type="html"><![CDATA[<p>ES5时，有个经典的需求：点击某个按钮，提示”点击的是第n个按钮”</p><pre><code>//html&lt;button&gt;测试1&lt;/button&gt;&lt;button&gt;测试2&lt;/button&gt;&lt;button&gt;测试3&lt;/button&gt;//js  var btns = document.getElementsByTagName(&quot;button&quot;);   //遍历加监听   for (var i = 0;i&lt;btns.length;i++) {   var btn = btns[i];    btn.onclick =function () {      alert(i)        }</code></pre><p>这里有个关于效率的问题,btns是伪数组，for循环中btns.length每次都要计算一遍才能得到结果，这里循环就会计算多次。改进之后的代码:</p><pre><code>  var btns = document.getElementsByTagName(&quot;button&quot;);   //遍历加监听   for (var i = 0,length=btns.length;i&lt;length;i++) {   var btn = btns[i];    btn.onclick =function () {      alert(i)        }    }</code></pre><p>但是点击按钮之后发现每个按钮都打印的3。<strong>因为点击之后的函数是回调函数，需要放在宏队列中执行</strong>，而for循环已经执行结束(i已经等于3了)</p><p>ES6之前的解决办法：<br>解决办法1：将btn所对应的下标保存在btn上</p><pre><code> var btns = document.getElementsByTagName(&quot;button&quot;);   //遍历加监听   for (var i = 0,length=btns.length;i&lt;length;i++) {   var btn = btns[i];   btn.index = i    btn.onclick =function () {      alert(this.index)        }    }</code></pre><p>解决办法2:闭包 </p><pre><code>    var btns = document.getElementsByTagName(&quot;button&quot;);     for (var i = 0;i&lt;btns.length;i++) {         var btn = btns[i];         (function (i) {//这i是局部的             btn.onclick = function () {                 alert(i)             }         })(i)//这个i是全局i     }</code></pre><p>问题1:如何产生闭包？<br>当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时，就产生了闭包。</p><p>问题2：闭包到底是什么?<br>(用chrome调试查看)<br>闭包是嵌套的内部函数<br>注意:闭包存在于嵌套函数的内部函数中</p><p>问题3：产生闭包的条件<br>1.函数嵌套<br>2.内部函数引用了外部函数的数据</p><p>函数定义时就会产生闭包，调用一次外部函数产生一个新的闭包。做闭包的题的时候仔细分析哪个变量导致闭包且是否有新的闭包产生。</p><h2 id="常见的闭包"><a href="#常见的闭包" class="headerlink" title="常见的闭包"></a>常见的闭包</h2><p>1.将函数作为另一个函数的返回值</p><pre><code>function fn1() {    var a = 2  function fn2() {    a++;    console.log(a);  }//仅一个闭包  return fn2}//f指向了fn2的函数对象(局部变量fn2已经不在了，因为fn2不在闭包里面)，这也是闭包一直存在的原因var f = fn1()//已经产生了闭包，执行完后，a还在f()//3f()//4</code></pre><p>局部函数调用时存在，调用结束消失。<br>外部函数执行几次，就产生几个闭包。所以此例子只产生了一个闭包。</p><p>2.将函数作为实参传递给另一个函数调用</p><pre><code>function showDelay(msg,time) {    //setTimeout()是在执行这个函数    setTimeout(function () {//闭包是在定义内部函数时生成的        alert(msg)//回调函数是内部函数，且用了外部函数的msg值    },time)}showDelay(&quot;xxx&quot;,2000) //产生了闭包</code></pre><h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><p>(又想隐藏，又想使用)</p><ul><li>使用函数内部的变量在函数执行完后，仍然存活在内存中(延长了局部变量的生命周期)</li><li>让函数外部可以操作(读写)到函数内部的数据</li></ul><h2 id="闭包的生命周期"><a href="#闭包的生命周期" class="headerlink" title="闭包的生命周期"></a>闭包的生命周期</h2><p>产生：在嵌套内部函数定义执行完成时就产生了(不是在调用)<br>死亡：在嵌套的内部函数成为垃圾对象时</p><pre><code>function fn1() {    var a = 2//此时闭包就已经产生了(函数提升，内部函数对象已经创建了)  function fn2() {    a++;    console.log(a);  }  return fn2}var f = fn1()f = null //闭包死亡(包含闭包的函数对象成为垃圾对象)</code></pre><h2 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h2><p>1.定义JS模块</p><ul><li>具有特定功能的JS文件</li><li>将所有的数据和功能都封装在函数内部（私有的）//对象的属性外部直接可以见，所以封装在对象里不算私有</li><li>只向外暴露一个包含n个方法的对象或函数</li></ul><pre><code>//module.jsfunction myModule(){//私有数据var msg = &quot;xxx&quot;function doSomething(){ console.log(&quot;doSomething&quot;+msg.toUpperCase())}function doOtherthing(){ console.log(&quot;doOtherthing&quot;+msg.toLowerCase())}//向外暴露对象return{doSomething,doOtherthing}}}//其他界面调用时，需要一个函数来接收</code></pre><p>匿名函数自调用</p><pre><code>//module2.js(function myModule(window){//私有数据var msg = &quot;xxx&quot;function doSomething(){ console.log(&quot;doSomething&quot;+msg.toUpperCase())}function doOtherthing(){ console.log(&quot;doOtherthing&quot;+msg.toLowerCase())}//向外暴露对象window.module2 = {doSomething,doOtherthing}})(window)//其他界面调用时，直接module2.doSomethig</code></pre><h2 id="闭包的缺点及解决"><a href="#闭包的缺点及解决" class="headerlink" title="闭包的缺点及解决"></a>闭包的缺点及解决</h2><p>缺点：<br>函数执行完后，函数内的局部变量没有释放，占用内存时间会变长。(容易造成内存泄漏)<br>解决：<br>能不用闭包就不用，及时释放（让内部函数称为垃圾对象–&gt;回收闭包）</p><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p>一种程序运行出现的错误。<br>当程序运行需要的内存超过了剩余的内存时，就会抛出溢出的错误。</p><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>占用的内存没有及时释放就是内存泄露，内存泄漏积累多了就容易导致内存溢出。<br>常见的内存泄漏：意外的全局变量，没有及时清理的计时器（如启动循环定时器后不清理）或回调函数，闭包。</p><pre><code>let intervalId = setInterval(function(){//启动循环定时器后不清理 console.log(&quot;---&quot;)},1000)//清除定时器clearInterval(intervalId)</code></pre><p><strong>面试题</strong></p><pre><code>var name = &quot;The Window&quot;;var object = {    name:&quot;My object&quot;,    getNameFunc : function () {        return function () {            return this.name;        }    }}console.log(object.getNameFunc()());//The Window var name = &quot;The Window&quot;;var object = {    name:&quot;My object&quot;,    getNameFunc : function () {        var that = this        return function () {            return that.name; //that等于的this是 调用了getNameFunc的对象        }    }}console.log(object.getNameFunc()());//My object</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ES5时，有个经典的需求：点击某个按钮，提示”点击的是第n个按钮”&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//html
&amp;lt;button&amp;gt;测试1&amp;lt;/button&amp;gt;
&amp;lt;button&amp;gt;测试2&amp;lt;/button&amp;gt;
&amp;lt;button&amp;gt;测
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>回调函数</title>
    <link href="http://yoursite.com/2020/02/23/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2020/02/23/回调函数/</id>
    <published>2020-02-23T04:46:00.000Z</published>
    <updated>2020-07-22T14:42:57.115Z</updated>
    
    <content type="html"><![CDATA[<p>一直都知道回调函数这种说法，但是并不能很准确的回答什么是回调函数？</p><p>这个是知乎<a href="https://www.zhihu.com/question/19801131/answer/13005983" target="_blank" rel="noopener">常溪玲</a>的答案，非常的通俗易懂</p><blockquote><p>你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。</p></blockquote><p>或者说回调函数的特征:你定义的，你没有调，但它最终执行了。</p><p>常见回调函数</p><ul><li>dom事件回调函数</li><li>定时器回调函数</li><li>ajax请求回调函数</li><li>生命周期回调函数</li></ul><pre><code>document.getElementById(&quot;btn&quot;).onclick=function () {//dome事件回调函数    alert(this.innerHTML)}    //定时器    setTimeout(function () {  //定时器回调函数        alert(&quot;到点了&quot;)    },2000)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直都知道回调函数这种说法，但是并不能很准确的回答什么是回调函数？&lt;/p&gt;
&lt;p&gt;这个是知乎&lt;a href=&quot;https://www.zhihu.com/question/19801131/answer/13005983&quot; target=&quot;_blank&quot; rel=&quot;noop
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>git&amp;GitHub</title>
    <link href="http://yoursite.com/2020/02/14/git-1/"/>
    <id>http://yoursite.com/2020/02/14/git-1/</id>
    <published>2020-02-14T07:26:23.000Z</published>
    <updated>2020-07-28T07:37:32.628Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/git/Git&GitHub.bmp"></p><h2 id="git介绍"><a href="#git介绍" class="headerlink" title="git介绍"></a>git介绍</h2><p><strong>结构</strong></p><p>工作区（本身文件）：写代码   = git add =&gt;  暂存区：临时存储   = git commit =&gt;  本地库（.git）：存储历史版本</p><p><strong>Git和代码托管中心</strong></p><p>代码托管中心(如GitHub):帮忙维护远程库</p><p><strong>本地库和远程库</strong></p><p><strong>团队内部协作</strong></p><p><img src="/img/git/团队内协作.png"></p><p><strong>跨团队协作</strong></p><p>外团队人员<code>fork</code>该团队远程库A（复制新的远程库B），<code>clone</code>到本地修改后<code>push</code>到B，之后外团队人员<code>pull request</code> =&gt;  该团队人 审核 =&gt; <code>merge</code> 远程库A的内容更新成远程库B的内容。</p><h2 id="git命令行操作"><a href="#git命令行操作" class="headerlink" title="git命令行操作"></a>git命令行操作</h2><h3 id="本地库初始化"><a href="#本地库初始化" class="headerlink" title="本地库初始化"></a>本地库初始化</h3><p>命令：git init<br>效果：出现隐藏文件.git<br>注意：.git目录中存放的是本地库相关的子目录和文件，不要删除，也不要乱修改</p><h3 id="设置签名"><a href="#设置签名" class="headerlink" title="设置签名"></a>设置签名</h3><p>形式:<br>    用户名：XXX<br>    Email地址：XXXXX</p><p>作用：区分不同开发人员的身份<br>辨析：这里设置的签名和代码托管中心的账号、密码没有任何关系<br>命令:<br>    项目级别/仓库级别：仅在当前本地库起作用<br>        <code>git config user.name XX</code><br>        <code>git config user.email XX</code><br>    系统用户级别：登陆当前操作系统的用户范围， <code>git config --global</code><br>        <code>git config --global user.name XX</code><br>        <code>git config --global user.email XX</code><br>    级别优先级：项目级别优于系统用户级别</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="状态检查"><a href="#状态检查" class="headerlink" title="状态检查"></a>状态检查</h4><p>命令: git status<br>作用：查看工作区、暂存区状态</p><h4 id="移除暂存区"><a href="#移除暂存区" class="headerlink" title="移除暂存区"></a>移除暂存区</h4><p>命令: git rm –cached [filename]</p><h4 id="添加到暂存器"><a href="#添加到暂存器" class="headerlink" title="添加到暂存器"></a>添加到暂存器</h4><p>命令：git add[filename]   添加所有git add .   添加所有修改的git add -A</p><h4 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h4><p>命令：git commit -m”commit message”[filename]     提交所有git commit -m”版本留言描述”<br>作用：将暂存区的内容提交到本地库</p><h4 id="查看历史任务"><a href="#查看历史任务" class="headerlink" title="查看历史任务"></a>查看历史任务</h4><p>命令：<br>    完整形式 git log<br>        若多屏显示控制方式：空格向下翻页 b向上翻页 q退出<br>    以一个漂亮的格式显示 git log –pretty=oneline/git log–oneline(后面的更简洁)<br>    git reflog :索引值更简洁，其中HEAD@{移动到当前版本需要多少步}</p><pre><code>&lt;img src=&quot;/img/git/历史任务.png&quot; /&gt;</code></pre><h4 id="前进后退"><a href="#前进后退" class="headerlink" title="前进后退"></a>前进后退</h4><p>可以配合git reflog使用<br>本质:操作HEAD的指针，默认是指向最近的版本。<br>基于索引值操作（推荐）:<br>     git reset –hard [局部索引值]  例（上图）：git reset–hard a6ace91<br>使用^(异或)符号（只能后退）：<br>     git reset –hard HEAD^  注:一个^表示后退一步，n 个表示后退 n 步<br>使用~符号（只能后退）:<br>     git reset –hard HEAD~n  注:表示后退 n 步</p><h5 id="reset-命令的三个参数对比"><a href="#reset-命令的三个参数对比" class="headerlink" title="reset 命令的三个参数对比"></a>reset 命令的三个参数对比</h5><p>–soft参数：</p><ul><li>仅仅在本地库移动 HEAD 指针</li><li>只回退了commit的信息，如果还要提交，直接commit</li></ul><p>–mixed参数：① 在本地库移动 HEAD 指针 ② 重置暂存区</p><ul><li>默认方式</li><li>git reset –mixed <commit> + git add . = git reset –soft <commit></commit></commit></li></ul><p>–hard参数：①在本地库移动 HEAD 指针 ② 重置暂存区 ③ 重置工作区</p><ul><li>彻底回退到某个版本，本地的源码也会变成上一个版本的内容</li></ul><h5 id="删除文件与恢复"><a href="#删除文件与恢复" class="headerlink" title="删除文件与恢复"></a>删除文件与恢复</h5><p>前提：删除前，文件存在时的状态提交到了本地库。<br>操作：rm [filename]<br>注：rm之后通过 git add [filename] 可把文件再次添加到缓存区<br>    可利用 git reset –hard[指针位置] 回退到之前版本找回文件。</p><p>前提：删除的文件在暂存区，但还没有提交到本地库<br>命令: git reset –hard HEAD（刚刚创建时）</p><h5 id="比较文件差别"><a href="#比较文件差别" class="headerlink" title="比较文件差别"></a>比较文件差别</h5><p>命令：git diff[文件名]<br>作用：将工作区中的文件和暂存区进行比较</p><p>命令：git diff[本地库中历史版本][文件名]<br>作用：将工作区中的文件和本地库历史记录比较</p><p>注意:不带文件名比较多个文件</p><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>优势：</p><ul><li>同时并行推进多个功能开发，提高开发效率</li><li>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可</li></ul><h4 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h4><h5 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h5><p>命令：git branch[分支名]</p><h5 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h5><p>命令：git branch -v</p><h5 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h5><p>命令：git checkout[分支名]</p><h5 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h5><p>如把hot_fix上的修改合并到master上</p><p>第一步：切换到合并的分支上 git checkout[master]<br>第二步：执行 merge 命令 git merge[hot_fix]</p><p><strong>解决冲突</strong><br>合并时同时修改同一个文件的同一个地方</p><p><img src="/img/git/冲突.png"></p><p>第一步:自行修改冲突文件<br>第二步:git add[文件名]<br>第三步:git commit-m”日志信息”     注意：此时 commit 一定不能带具体文件名</p><h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><h4 id="连接远程库"><a href="#连接远程库" class="headerlink" title="连接远程库"></a>连接远程库</h4><p>命令：<br>    git remote-v 查看当前所有远程地址别名<br>    git remote add [别名] [远程地址]   (常用别名：origin)<br>作用：下次上传可以直接用别名上传</p><h4 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h4><p>命令：git push [别名][分支名]</p><h4 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h4><p>命令：git clone 仓库地址<br>作用；完整的把远程库下载到本地；创建origin远程地址别名；初始化本地库。</p><h4 id="团队成员邀请"><a href="#团队成员邀请" class="headerlink" title="团队成员邀请"></a>团队成员邀请</h4><p><img src="/img/git/邀请加入团队.png"></p><p>变成团队成员就可以把自己的修改推送进入远程仓库了。</p><h4 id="拉取pull"><a href="#拉取pull" class="headerlink" title="拉取pull"></a>拉取pull</h4><p>命令: git fetch[远程库地址别名][远程分支名]<br>      git merge[远程库地址别名/远程分支名]<br>      git pull[远程库地址别名][远程分支名]<br>作用: pull=fetch+merge。<br>      fetch 把远程库抓取下来，并没有修改本地文件。<br>      merge 把远程的master合并到本地的master，本地文件修改。</p><p><strong>解决冲突</strong><br>要点：<table><tr><td bgcolor="pink">如果不是基于GitHub远程库的最新版本所作的修改，不能推送，必须先拉取下来</td></tr></table>如<br>若pull下来之后进入冲突状态，其余同分支冲突处理办法一样。</p><h4 id="跨团队操作"><a href="#跨团队操作" class="headerlink" title="跨团队操作"></a>跨团队操作</h4><p>外团队人员<code>fork</code>该团队远程库A（复制新的远程库B、外团队人员的仓库），<code>clone</code>到本地修改后<code>push</code>到B，之后外团队人员<code>pull request</code> （GitHub远程库B操作）=&gt;  该团队人（GitHub远程库A） 审核 =&gt; <code>merge</code> 远程库A的内容更新成远程库B的内容。</p><h4 id="SSH登陆"><a href="#SSH登陆" class="headerlink" title="SSH登陆"></a>SSH登陆</h4><p>第一步：生成ssh（在家目录）<br>ssh-keygen ct rsa -C 邮箱账号         //注意C大写<br>注：在主目录下生成的密钥在 /c/Users/用户名/.ssh/id_rsa 里<br>第二步：查看并复制ssh（需在.ssh目录下执行 cd .ssh进入）<br>cat id_rsa.pub<br>第三步：复制密钥内容添加到 github 上</p><p>使用ssh协议上传文件到仓库</p><p>git init<br>git add .<br>git commit -m “ “<br>git remote add 别名 <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:…<br>git push -u 别名 master</p><h3 id="Git工作流"><a href="#Git工作流" class="headerlink" title="Git工作流"></a>Git工作流</h3><p>在项目开发过程中使用的Git的方式</p><h4 id="GitFlow工作流-常用"><a href="#GitFlow工作流-常用" class="headerlink" title="GitFlow工作流(常用)"></a>GitFlow工作流(常用)</h4><p>Gitflow 工作流通过为功能开发、发布准备和维护设立了独立的分支，让发布 迭代过程更流畅。严格的分支模型也为大型项目提供了一些非常必要的结构。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/img/git/Git&amp;GitHub.bmp&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;git介绍&quot;&gt;&lt;a href=&quot;#git介绍&quot; class=&quot;headerlink&quot; title=&quot;git介绍&quot;&gt;&lt;/a&gt;git介绍&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;结构&lt;/str
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>富文本tinymce</title>
    <link href="http://yoursite.com/2020/02/09/%E5%AF%8C%E6%96%87%E6%9C%ACtinymce/"/>
    <id>http://yoursite.com/2020/02/09/富文本tinymce/</id>
    <published>2020-02-09T03:58:33.000Z</published>
    <updated>2020-07-09T08:07:23.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>//安装tinymce-vuenpm install @tinymce/tinymce-vue -S//安装tinymce,版本为5.Xnpm install tinymce -S//引入中文语言包</code></pre><p><a href="https://www.tiny.cloud/get-tiny/language-packages/" target="_blank" rel="noopener">中文下载包</a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在 node_modules中找到 tinymce/skins目录，然后将skins目录拷贝到static目录下的tinymce</p><p> <img src="/img/富文本/富文本1.png" width="30%"></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>引入基本文件</p><pre><code>  //初始化tinymce  import tinymce from &#39;tinymce/tinymce&#39;  import Editor from &#39;@tinymce/tinymce-vue&#39;  import &#39;tinymce/themes/silver&#39;</code></pre><p>注册组件</p><pre><code class="bash">&lt;Editor&gt;&lt;/Editor&gt;//jscomponents: {Editor}</code></pre><p>初始化配置</p><pre><code class="bash">&lt;Editor :init=&quot;init&quot;&gt;&lt;/Editor&gt; data() { return {  init:{//语言language_url: &#39;/static/tinymce/zh_CN.js&#39;,language: &#39;zh_CN&#39;, //skin路径skin_url: &#39;/static/tinymce/skins/ui/oxide&#39;,}}}, mounted () { tinymce.init({}) },</code></pre><p>初始化配置之后最基本的符文就有了，接下来丰富它的功能</p><p><img src="/img/富文本/富文本2.png"></p><p>数据同步</p><pre><code class="bash">//子组件  &lt;Editor  v-model=&quot;myValue&quot;&gt;&lt;/Editor&gt;   data() {              return {                myValue: this.value                }   },     props: {      value: {               default: &#39;&#39;,               type: String             },     }      watch: {           value(newValue) {             this.myValue = newValue           },           myValue(newValue) {             this.$emit(&#39;input&#39;, newValue)           }         },//父组件  onEditorUploadSuccess为图片上传成功的回调    &lt;editor v-model=&quot;value&quot; @on-upload-success=&quot;onEditorUploadSuccess&quot;        &gt;&lt;/editor&gt;</code></pre><p>完整代码</p><pre><code class="bash">&lt;template&gt;  &lt;div&gt;      &lt;Editor :init=&quot;init&quot; v-model=&quot;myValue&quot;&gt;&lt;/Editor&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  //这个是接口文件  import {ImgUpload} from &#39;@/api/notice&#39;  //初始化tinymce  import tinymce from &#39;tinymce/tinymce&#39;  import Editor from &#39;@tinymce/tinymce-vue&#39;  //引入主题  import &#39;tinymce/themes/silver&#39;  /*  引入插件   */  import &#39;tinymce/plugins/image&#39;  import &#39;tinymce/plugins/table&#39;  import &#39;tinymce/plugins/preview&#39;  import &#39;tinymce/plugins/fullscreen&#39;  import &#39;tinymce/plugins/link&#39;  import &#39;tinymce/plugins/code&#39;  import &#39;tinymce/plugins/lists&#39;  import &#39;tinymce/plugins/hr&#39;  import &#39;tinymce/plugins/advlist&#39;  import &#39;tinymce/plugins/paste&#39;  import &#39;tinymce/plugins/importcss&#39;  import &#39;tinymce/plugins/media&#39;  export default {        data() {            return {              myValue: this.value,              init:{                //语言                language_url: &#39;/static/tinymce/zh_CN.js&#39;,                language: &#39;zh_CN&#39;,                //设置皮肤                skin_url: &#39;/static/tinymce/skins/ui/oxide&#39;,                //高度                height: 400,                //菜单栏                menubar: false,                //隐藏商标                // branding: false,                //工具栏|分类 配置插件                toolbar: `styleselect | fontselect | formatselect | fontsizeselect | forecolor backcolor | bold italic underline strikethrough | image   | table | alignleft aligncenter alignright alignjustify | outdent indent | numlist bullist | preview removeformat  hr |  code  link | undo redo | fullscreen `,                //自动聚焦                auto_focus: true,                //引入插件                plugins: ` paste importcss image code table advlist fullscreen link media lists   hr preview`,                //图片标题                image_caption: true,                //上传本地图片                image_uploadtab:true,                // Image                imagetools_toolbar: &#39;rotateleft rotateright | flipv fliph | editimage imageoptions&#39;,              // 设置Tab             // tabfocus_elements: &#39;:prev,:next&#39;,             //  object_resizing: true,             //设置可选段落样式             style_formats: [                  {                    title: &#39;首行缩进&#39;,                    block: &#39;p&#39;,                    styles: { &#39;text-indent&#39;: &#39;2em&#39; }                  },                  {                    title: &#39;行高&#39;,                    items: [                      { title: &#39;1&#39;, styles: { &#39;line-height&#39;: &#39;1&#39; }, inline: &#39;span&#39; },                      { title: &#39;1.5&#39;, styles: { &#39;line-height&#39;: &#39;1.5&#39; }, inline: &#39;span&#39; },                      { title: &#39;2&#39;, styles: { &#39;line-height&#39;: &#39;2&#39; }, inline: &#39;span&#39; },                      { title: &#39;2.5&#39;, styles: { &#39;line-height&#39;: &#39;2.5&#39; }, inline: &#39;span&#39; },                      { title: &#39;3&#39;, styles: { &#39;line-height&#39;: &#39;3&#39; }, inline: &#39;span&#39; }                    ]                  }                ],             //字体列表              font_formats: `            微软雅黑=微软雅黑;            宋体=宋体;            黑体=黑体;            仿宋=仿宋;            楷体=楷体;            隶书=隶书;            幼圆=幼圆;            Andale Mono=andale mono,times;            Arial=arial, helvetica,            sans-serif;            Arial Black=arial black, avant garde;            Book Antiqua=book antiqua,palatino;            Comic Sans MS=comic sans ms,sans-serif;            Courier New=courier new,courier;            Georgia=georgia,palatino;            Helvetica=helvetica;            Impact=impact,chicago;            Symbol=symbol;            Tahoma=tahoma,arial,helvetica,sans-serif;            Terminal=terminal,monaco;            Times New Roman=times new roman,times;            Trebuchet MS=trebuchet ms,geneva;            Verdana=verdana,geneva;            Webdings=webdings;            Wingdings=wingdings,zapf dingbats`,              //内容样式, 在最后呈现的页面也要写入这个基本样式保证前后一致                content_style: `            *                         { padding:0; margin:0; }            html, body                { height:100%; }            img                       { max-width:100%; display:block;height:auto; }            a                         { text-decoration: none; }            iframe                    { width: 100%; }            p                         { line-height:1.6; margin: 0px; font-family:&quot;宋体&quot;; }            table                     { word-wrap:break-word; word-break:break-all; max-width:100%; border:none; border-color:#999; }            .mce-object-iframe        { width:100%; box-sizing:border-box; margin:0; padding:0; }            ul,ol                     { list-style-position:inside; }          `,                insert_button_items: &#39;image link | inserttable&#39;,                //回车添加的标签                forced_root_block:&quot;p&quot;,                //强制每行添加&lt;p&gt;标签                force_p_newlines: true,                importcss_append: true,                //字体大小栏选项                fontsize_formats: &#39;10px 11px 12px 14px 16px 18px 20px 24px&#39;,                // paste设置                paste_data_images: true,//可以粘贴图片                paste_word_valid_elements: &#39;*[*]&#39;,//word过滤                paste_retain_style_properties:&#39;all&#39;, //允许保留word粘贴过来的格式                paste_convert_word_fake_lists: false,//禁止word的列表内容转换html的ul和ol格式                paste_merge_formats: true,//合并相似格式                nonbreaking_force_tab: false,                paste_auto_cleanup_on_paste: false,                statusbar: false, // 隐藏编辑器底部的状态栏                images_upload_handler: this.uploadImg//图片上传              },            }        },      props: {          //图片最大大小        maxSize: {          default: 2097152,          type: Number        },        //图片可接收类型        accept: {          default: &#39;image/jpeg, image/png, image/jpg, image/svg, image/gif&#39;,          type: String        },        //上传地址        url: {          default: &#39;&#39;,          type: String        },        //数据        value: {          default: &#39;&#39;,          type: String        },      },        methods: {        //上传图片          uploadImg(blobInfo, success, failure)  {            const that = this            //符合大小            if (blobInfo.blob().size &gt; this.maxSize) {      failure(&#39;文件体积过大&#39;);    }            //符合类型            if (this.accept.indexOf(blobInfo.blob().type) &gt; -1) {              let form = new FormData();    form.append(&#39;file&#39;, blobInfo.blob(), blobInfo.filename());              ImgUpload(form).then(res=&gt;{                //给父组件传值                that.$emit(&#39;on-upload-success&#39;, {                  res, success, failure                })              }).catch(err =&gt; {                failure(&#39;上传失败: &#39; + err);              })            }            else failure(&#39;图片格式错误&#39;);  },        },     watch: {      value(newValue) {        this.myValue = newValue      },      myValue(newValue) {        this.$emit(&#39;input&#39;, newValue)      }    },        components: {Editor},      mounted () {        tinymce.init({})      },    }&lt;/script&gt;&lt;!--scoped 样式仅仅在当前组件使用--&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;//安装tinymce-vue
npm install @tinymce/tinymce-vue -S
//安装tinymc
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="库" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E5%BA%93/"/>
    
    
      <category term="富文本" scheme="http://yoursite.com/tags/%E5%AF%8C%E6%96%87%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>软件超市项目后台管理界面开发流程3</title>
    <link href="http://yoursite.com/2020/02/06/%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82%E9%A1%B9%E7%9B%AE%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B3/"/>
    <id>http://yoursite.com/2020/02/06/软件超市项目后台管理界面开发流程3/</id>
    <published>2020-02-06T06:42:08.000Z</published>
    <updated>2020-07-09T08:08:33.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue全局配置"><a href="#vue全局配置" class="headerlink" title="vue全局配置"></a>vue全局配置</h2><p>项目有很多重复用到的变量和方法，新建一个global/index.js来存放。具体的实现是通过在Vue的原型上添加方法和属性，也就是使用<code>Vue.prototype</code>，最后要在main.js引入文件`import “./global”;</p><h2 id="Messsage-vue"><a href="#Messsage-vue" class="headerlink" title="Messsage.vue"></a>Messsage.vue</h2><p>一级导航用于显示消息通知,里面包含了两个组件，一个用于分页的ProjectPagination，一个是用于消息提醒的MessageRemind。<br>这里实现了流程1提到的:如果有未读消息，进入管理页面后直接显示消息通知，如果没有未读消息，则显示第一个路由。</p><pre><code class="bash">    //登陆之后是先跳转到message，此时的pageEnterStatetrue=true。    if (this.pageEnterState) {      //如果没有消息就跳到第一个路由      if (this.msgLen === 0) {        const route = this.$store.getters.addRouter;        this.$router.push(route[0].path);      } else {        //如果有消息就显示，tableData就是登陆时传给state的消息        this.data = this.tableData;        this.isLoading = false;      }      this.$store.commit(&quot;SET_PAGE_ENTER_STATE&quot;, false);    } else {      this.loadData();    }  }</code></pre><h3 id="分页ProjectPagination"><a href="#分页ProjectPagination" class="headerlink" title="分页ProjectPagination"></a>分页ProjectPagination</h3><p>结合element-ui的pagination加上一些修改。前一篇博客中提到了父组件向子组件传值的方法，这里同时也用到了子组件向父组件传值的方法</p><pre><code>&lt;!-- 分页器 --&gt;&lt;template&gt;  &lt;el-pagination class=&quot;x-page&quot; layout=&quot;total,sizes, prev, pager, next, jumper&quot; @current-change=&quot;handleCurrentChange&quot; @size-change=&quot;handleSizeChange&quot; :current-page.sync=&quot;currentPage&quot; :page-sizes=&quot;pageSizes&quot; :page-size=&quot;pageSize&quot; :total=&quot;total&quot;&gt;&lt;/el-pagination&gt;&lt;/template&gt;&lt;script&gt;export default {  name: &quot;ProjectPagination&quot;,  //接收父组件传来的值  props: {    //data为所有数据    data: Array,    //filterData做为一个筛选容器    filterData: Array  },  data() {    return {      //当前页数      currentPage: 1,      //默认的一页显示条数      pageBase: 10    };  },  computed: {    // 数据总数目    total() {      return this.data.length;    },    // 一页有多少条数据    pageSize() {      //如果基础数据大于总数，则显示总数      let size = this.total &gt;= this.pageBase ? this.pageBase : this.total;      return size;    },    // 提供每页条数的选择，返回值为一个数组    pageSizes() {      let count = Math.ceil(this.total / this.pageSize);      let sizes = [];      for (let i = 1; i &lt;= count; i++) {        sizes.push(this.pageSize * i);      }      return sizes;    }  },  methods: {  //pageSize改变执行，回调参数:每页条数    handleSizeChange(val) {      // 获取项目条数      //子组件像父组件传值，更新filterData。      this.$emit(&quot;update:filterData&quot;, this.data.slice(0, val));    },    // 页面页数改变    handleCurrentChange(val) {      // 获取下一页数据      this.$emit(        &quot;update:filterData&quot;,        this.data.slice((val - 1) * this.pageSize, val * this.pageSize)      );    }  },  created() {    //发送一个update:filterData，显示pageSize个数据    this.$emit(&quot;update:filterData&quot;, this.data.slice(0, this.pageSize));  },  watch: {    // 监控数据变化时获取数据    data() {      this.$emit(&quot;update:filterData&quot;, this.data.slice(0, this.pageSize));    }  },  //路由要求刷新  activated() {    if (this.$route.meta.isRefresh) {      this.currentPage = 1;    }  }};&lt;/script&gt;&lt;style scoped&gt;.x-page {  margin-top: 10px;  float: right;}&lt;/style&gt;</code></pre><h4 id="emit-update-prop-“newPropVulue”"><a href="#emit-update-prop-“newPropVulue”" class="headerlink" title="$emit(update: prop, “newPropVulue”)"></a>$emit(update: prop, “newPropVulue”)</h4><p>$emit(update: prop, “newPropVulue”)  这个模式，使子组件向父组件传达：更新属性，并抛出新的属性值。</p><p>从上述代码中可以看出首先更新的值要是从父组件中接收的，也就是props里面的值。其次父组件该值需要写成</p><pre><code>  &lt;ProjectPagination :data=&quot;data&quot; :filter-data=&quot;filterData&quot; @update:filter-data=&quot;filterData=$event&quot;&gt;&lt;/ProjectPagination&gt;</code></pre><p>更简单的写法是<code>.sync</code>修饰符</p><pre><code> &lt;ProjectPagination  :filter-data=&quot;filterData&quot; :filter-data.sync=&quot;filterData&quot;&gt;&lt;/ProjectPagination&gt;</code></pre><p><strong>注意:</strong>这里有一个Vue.sync修饰符与$emit(update:xxx)写法的坑<br>使用.sync修饰符</p><pre><code>//有效this.$emit(&quot;update:filterData&quot;, this.data.slice(0, val));//无效this.$emit(&quot;update:filter-Data&quot;, this.data.slice(0, val));</code></pre><p>不使用.sync修饰符</p><pre><code>//无效this.$emit(&quot;update:filterData&quot;, this.data.slice(0, val));//有效this.$emit(&quot;update:filter-Data&quot;, this.data.slice(0, val));</code></pre><h3 id="MessageRemind"><a href="#MessageRemind" class="headerlink" title="MessageRemind"></a>MessageRemind</h3><p>消息提醒的MessageRemind使用了element-ui的消息提醒，这里最后的实现比较容易，但是在实现的过程中遇到了一个关于路由监控的坑。</p><p>路由监听失效：需要在父路由的组件内才可以监听到子路由的信息。</p><h2 id="Notice-vue"><a href="#Notice-vue" class="headerlink" title="Notice.vue"></a>Notice.vue</h2><p>仅管理员拥有的组件。主要有左边的导航和中间显示部分组成。显示公告列表，增删改查等实现比较容易就没有记录下来。</p><p>这里记录一个文章显示的css，超出部分滚动，但不显示滚轮</p><pre><code class="bash">  .article{    height: 100%;    overflow-x:hidden;    overflow-y: scroll;  }  //  -webkit-scrollbar css3新特性  .article::-webkit-scrollbar {    display: none;  }</code></pre><p><strong>框架</strong></p><pre><code class="bash"> &lt;template&gt;     &lt;div  class=&quot;notice&quot;&gt;       &lt;div class=&quot;nav&quot;&gt;       &lt;el-menu         default-active=&quot;publish&quot;         class=&quot;el-menu-vertical-demo&quot;         @select=&quot;handleSelect&quot;       &gt;         &lt;el-menu-item index=&quot;publish&quot; &gt;           &lt;i class=&quot;el-icon-edit-outline&quot;&gt;&lt;/i&gt;           &lt;span slot=&quot;title&quot;&gt;发布公告&lt;/span&gt;         &lt;/el-menu-item&gt;         &lt;el-menu-item index=&quot;allNotice&quot;&gt;           &lt;i class=&quot;el-icon-document&quot;&gt;&lt;/i&gt;           &lt;span slot=&quot;title&quot;&gt;所有公告&lt;/span&gt;         &lt;/el-menu-item&gt;         &lt;el-menu-item index=&quot;dustbin&quot;&gt;           &lt;i class=&quot;el-icon-delete&quot;&gt;&lt;/i&gt;           &lt;span slot=&quot;title&quot;&gt;回收站&lt;/span&gt;         &lt;/el-menu-item&gt;       &lt;/el-menu&gt;     &lt;/div&gt;       &lt;router-view class=&quot;view&quot;&gt;&lt;/router-view&gt;     &lt;/div&gt; &lt;/template&gt;handleSelect(key) {let path=&#39;/notice/&#39;+key;this.$router.push({path:path})}</code></pre><h3 id="富文本tinymce"><a href="#富文本tinymce" class="headerlink" title="富文本tinymce"></a>富文本tinymce</h3><p>默认显示的是发布公告,选用的是tinymce这款富文本。</p><blockquote><p><a href="https://biubiuins.github.io/2020/02/09/%E5%AF%8C%E6%96%87%E6%9C%ACtinymce/" target="_blank" rel="noopener">学习笔记</a></p></blockquote><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p><strong>问题1</strong>表单规则验证</p><pre><code class="bash"> &lt;el-form-item label=&quot;学/工号&quot; prop=&quot;captainInformation.studentId&quot; &gt;    &lt;el-input v-model.number=&quot;form.captainInformation.studentId&quot; &gt;&lt;/el-input&gt;  &lt;/el-form-item&gt;   data() {        return {    form:{          teamName:&quot;&quot;,          captainInformation:{            name:&quot;&quot;,            studentId:&quot;&quot;,          },        },        rules: {          teamName: [            { required: true, message: &#39;请输入团队名称&#39;, trigger: &#39;blur&#39; },            { min: 3, max: 10, message: &#39;长度在 3 到 10 个字符&#39;, trigger: &#39;blur&#39; }          ],          //这个位置注意一定要加引号           &quot;captainInformation.studentId&quot;: [                      { required: true, message: &#39;请输入学号&#39;, trigger: &#39;blur&#39; },                       {type: &#39;integer&#39;, message: &#39;格式错误&#39;, trigger: &#39;blur&#39;}                    ],  }</code></pre><p><strong>问题二</strong>过滤器</p><p>后台传来的数据只有分数，未评分的分数为-1，这里需要将其显示成状态已完成或未评分，并且可以根据状态筛选数据。</p><pre><code class="bash"> &lt;el-table-column prop=&quot;score&quot; sortable label=&quot;状态&quot; :filters=&quot;tags&quot; :filter-method=&quot;filterTag&quot;&gt;          &lt;template slot-scope=&quot;scope&quot;&gt;            &lt;el-tag disable-transitions style=&quot;font-size:12px&quot; :type=&quot;stateColor(scope.row.score)&quot;&gt;{{scope.row.score| filterState}}&lt;/el-tag&gt;          &lt;/template&gt;        &lt;/el-table-column&gt;//js //筛选标签          filterTag(value, row) {            if (value === -1) {              return row.score === -1;            } else {              return row.score &gt;= value;            }        },   //过滤器      filters: {        filterState(val) {          return val === -1 ? &quot;未评分&quot; : &quot;已完成&quot;;        }      },</code></pre><p><strong>问题三</strong>返回刷新问题<br>从详情返回列表，列表不需要刷新，而从其他页面进入列表，列表需要刷新。<br>首先需要了解两个生命周期：<br><img src="/img/软件超市/created与activated.png"></p><pre><code>      // 数据缓存      beforeRouteEnter(to, from, next) {        //如果不是从teamDetail来的界面需要刷新        if (![&quot;teamDetail&quot;].includes(from.name)) {          to.meta.isRefresh = true;        }        next()      },      activated() {          //需要刷新的界面        if (this.$route.meta.isRefresh) {          // 先重置          this.$route.meta.isRefresh = false;          //重新获取数据          this.isLoading = true;          this.getLoadData();        }      },</code></pre><blockquote><p>后面重复的操作比较多，多为增删查改，重复的东西将不在记录了。有关于vue我不熟悉的知识点，会重新学习了解之后更新博客。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;vue全局配置&quot;&gt;&lt;a href=&quot;#vue全局配置&quot; class=&quot;headerlink&quot; title=&quot;vue全局配置&quot;&gt;&lt;/a&gt;vue全局配置&lt;/h2&gt;&lt;p&gt;项目有很多重复用到的变量和方法，新建一个global/index.js来存放。具体的实现是通过在Vu
      
    
    </summary>
    
      <category term="project" scheme="http://yoursite.com/categories/project/"/>
    
    
      <category term="软件超市" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82/"/>
    
  </entry>
  
  <entry>
    <title>软件超市项目后台管理界面开发流程2</title>
    <link href="http://yoursite.com/2020/01/31/%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82%E9%A1%B9%E7%9B%AE%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B2/"/>
    <id>http://yoursite.com/2020/01/31/软件超市项目后台管理界面开发流程2/</id>
    <published>2020-01-31T13:53:41.000Z</published>
    <updated>2020-03-02T09:33:54.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设置权限时动态加载路由"><a href="#设置权限时动态加载路由" class="headerlink" title="设置权限时动态加载路由"></a>设置权限时动态加载路由</h2><ol><li>路由分为两类，一类是静态路由（不需要登陆验证），一类是动态路由（需要登陆验证）</li><li>当用户登陆后，获取用role（权限），将role和路由表每个页面的需要的权限作比较，生成用户可访问的路由表</li><li>调用router.addRoutes(store.getters.addRouters)添加用户可访问的路由。</li><li>使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。</li></ol><h3 id="permission-js"><a href="#permission-js" class="headerlink" title="permission.js"></a>permission.js</h3><p>首先新建store/permission.js，用来控制生成的路由表。</p><pre><code>//是否有权限访问，role为当前权限function hasPermission(role, route) {  if (route.meta &amp;&amp; route.meta.roles) {    //如果该路由的meta存在，并且有要求权限    const roles = route.meta.roles;    //如果路由要求的权限有当前权限，返回成功    return roles.includes(role);  } else {    //如果不存在说明不需要权限    return true;  }}const permission ={  state: {    //默认路由    routers: constantRouterMap,    //添加的路由    addRouters: []  },  mutations: {    SET_ROUTERS: (state, routers) =&gt; {      //往数组中添加符合条件的路由      state.addRouters = routers;      //符合权限的路由变成默认路由可访问。      state.routers = constantRouterMap.concat(routers);    }  },  actions: {    //定义产生路由的方法    async GenerateRoutes({ commit }, { role }) {      //返回符合权限的异步路由      const accessedRouters = await asyncRouterMap.filter(route =&gt;        hasPermission(role, route)      );      commit(&quot;SET_ROUTERS&quot;, accessedRouters);      return accessedRouters;    }  }}export default permission;</code></pre><p>这里可以把permission.js看成一个模块，因为它拥有自己的state,mutation,action。所以还需要把permission挂载在vuex里。</p><pre><code>export default new Vuex.Store({  modules:{    permission  },  state,  actions,  mutations,  getters});</code></pre><p><strong>问题一</strong>addRoutes在哪里调用<br>登录后，获取用户的权限信息，然后筛选有权限访问的路由，再调用addRoutes添加路由。这个方法是可行的。但是不可能每次进入应用都需要登录，用户刷新浏览器又要登陆一次。所以addRoutes还是要在全局路由守卫里进行调用。</p><pre><code class="bash">if(token){//已经登陆了if (to.path ===&quot;/login&quot;) next({path:&quot;/&quot;})//else{if (!store.getters.role){ //如果没有当前权限信息,role仅getUserInfor后可以获得//用户登陆之后，根据缓存获取登陆信息  store.dispatch(&quot;getUserInfor&quot;).then(role=&gt;{ //产生符合权限路由的方法   store.dispatch(&quot;GenerateRoutes&quot;, { role })     .then(                   data =&gt; {                     // 生成可访问的路由表                     router.addRoutes(data);                    next({ ...to, replace: true });  }).....}}}</code></pre><p><strong>问题一</strong> next()的使用</p><ol><li><p>首先调用next()时会直接进入to路由，不会再调用beforeEach(),所以刷新页面可能会进入无限循环，调用next(‘xxx’)后会拦截路由使得路由重定向xxx，并再次调用beforeEach()。</p></li><li><p>如果把replace设置为true，那么导航不会留下history记录，点击浏览器回退按钮不会再回到这个路由。router.addRoutes之后的next()可能会失效，因为可能next()的时候路由并没有完全add完成，next({…to}) 的时候重新指定以下刷新前的路径。</p></li></ol><p><strong>问题二</strong> 404页面<br>404路由写在动态路由中，否则可能会有闪屏和路由为空时加载的404页面。<br>原因是：当页面刷新，会导致vue重新实例化，路由也恢复了初始路,addRoutes 还没有添加上路由就开始跳转， 所以找不到路由就跳转到404页面了。</p><h2 id="Layout页面"><a href="#Layout页面" class="headerlink" title="Layout页面"></a>Layout页面</h2><p>Layout作为整个后台管理页面的框架，主要有Header、根据权限生成的Sidebar和中间的显示界面组成。</p><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><pre><code class="bash">//Layout组件   &lt;div id=&quot;manage&quot;&gt;      &lt;Header&gt;&lt;/Header&gt;      &lt;div class=&quot;container&quot;&gt;      &lt;Sidebar&gt;&lt;/Sidebar&gt;        &lt;router-view class=&quot;content&quot; &gt;&lt;/router-view&gt;      &lt;/div&gt;    &lt;/div&gt;</code></pre><p>通过把一级路由与二级路由的path设置成同一个，来同时加载Header组件、Sidebar组件和中间对应的显示界面</p><pre><code class="bash">//仅用其中一个举列子const project ={  path: {    path: &quot;/projectManage&quot;,    name: &quot;projectManage&quot;,    component: Layout  },  check: [    {      path: &quot;check&quot;,      name: &quot;projectCheck&quot;,      component: () =&gt;        import(          /* webpackChunkName: &quot;ProjectCheck&quot; */ &quot;../views/projectManage/components/ProjectCheck&quot;          )    },  ],  }export const asyncRouterMap = [{    ...project.path,  children: [      {        path: project.path.path,        redirect: &quot;/projectManage/check&quot;,        component: () =&gt; import(/* webpackChunkName: &quot;ProjectDeveloper&quot; */ &quot;../views/projectManage/ProjectDeveloper&quot;),        children: [...project.check]      },]}]</code></pre><p><strong>注意:</strong>这里有个简单的重定向问题我晕了好久QAQ</p><p>首先是path加/和不加/有什么区别。/xx就是根路径。下面代码去到children是/#/child而不是/#/fa/child。而不以斜杠开头的，都会被当成普通的字符串拼到当前路径的后面。</p><pre><code class="bash">path: /fachildren: {    path: /child}</code></pre><p>然后这里重新定向之后<code>projectManage/check</code>路由到底算几级路由？通过把redirect注释之后终于弄懂了。这里是因为<strong>children控制的是第几个router-view</strong>,第一个children控制的是第二个router-view，即使它重定向<code>/projectManage/check</code>,第二个router-view显示的还是ProjectDeveloper组件。</p><h3 id="Siderbar"><a href="#Siderbar" class="headerlink" title="Siderbar"></a>Siderbar</h3><h4 id="导航图标上显示未读消息数量"><a href="#导航图标上显示未读消息数量" class="headerlink" title="导航图标上显示未读消息数量"></a>导航图标上显示未读消息数量</h4><p>   <img src="/img/软件超市/消息提醒.png" width="30%"></p><p>主要实现是使用element-ui里面的badge组件+父子间传值实现的。这里以导航图标上显示未读消息数量为例子，后续类似操作将不做记录。</p><p>新建一个MessageNue.vue记录未处理的消息数量，作为子组件，接收父组件传来的值。这里接收两个值：customClass样式，因为这个组件会重复使用，并且不同消息显示的位置可能不同，所以关于定位的信息要单独接收。menu接收的是显示的哪一个消息。</p><pre><code class="bash">&lt;template&gt;  &lt;span class=&quot;badgebox&quot;&gt;    &lt;slot&gt;&lt;/slot&gt;    &lt;el-badge :value=&quot;getMsgN(menu)&quot; :style=&quot;customClass&quot; class=&quot;item&quot; :max=&quot;99&quot; :hidden=&quot;!getMsgN(menu)&quot;&gt;&lt;/el-badge&gt;  &lt;/span&gt;&lt;/template&gt;&lt;script&gt;export default {  name: &quot;MessageNum&quot;,  props: {    menu: Object,    customClass: String  },  methods: {    getMsgN(menu) {      return this.count[menu.path];    }  },  computed: {    count() {      return this.$store.state.msgNum;    }  }};&lt;/script&gt;//state.js  //需要显示的消息数量  msgNum: {    publishExamine: 0,    delayExamine: 0,    alterExamine: 0,    undertakeExamine: 0,    projectExamine: 0,    porjectRun: 0,    projectCheck: 0,    projectFinish: 0,    projectManage: 0  },</code></pre><p>Sidebar.vue 作为父组件，把组件挂载好之后。menu值是传的动态值所以用<code>v-bind:</code>绑定，而customClass是一个静态值所以直接传值就行。</p><p><strong>这里有一个命名的坑:</strong><br>props属性支持驼峰命名,不支持连接线命名。HTML特性是不区分大小写的，所以在HTML之中的驼峰写法要变成连接线写法。</p><pre><code>      &lt;message-num :menu=&quot;{path:router.name}&quot; custom-class=&quot;top:-12px;right:-12px&quot;&gt;        &lt;i class=&quot;iconfont&quot; :class=&quot;&#39;icon-&#39;+router.meta.icon&quot;&gt;&lt;/i&gt;      &lt;/message-num&gt;</code></pre><h4 id="Header-vue"><a href="#Header-vue" class="headerlink" title="Header.vue"></a>Header.vue</h4><p>主要功能有：</p><p>1.显示用户名，可退出<br>2.如果身份是开发团队的队长，且同时有几个团队，显示当前团队，并可切换其他团队。<br>3.点击logo的时候，可以操作侧边栏展开</p><p>①下拉框用的是Element-ui的el-dropdown组件,下拉的时候出现退出键。</p><pre><code class="bash">// @command=&quot;handleCommand&quot;为绑定下拉框点击事件，command为值    &lt;el-dropdown class=&quot;exit&quot;  @command=&quot;handleCommand&quot;  trigger=&quot;click&quot;&gt;      &lt;span class=&quot;el-dropdown-link&quot;&gt;        {{ username }}        &lt;i class=&quot;el-icon-arrow-down el-icon--right&quot;&gt;&lt;/i&gt;      &lt;/span&gt;      &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt;        &lt;el-dropdown-item command=&quot;exit&quot;&gt;退出&lt;/el-dropdown-item&gt;      &lt;/el-dropdown-menu&gt;    &lt;/el-dropdown&gt;   // 退出登录或者切换用户管理界面      handleCommand(command) {        console.log(command);        if (command === &quot;exit&quot;) {        //退出之后清除          this.exit();        }，      exit() {      // 退出清除缓存和登录      //登录成功之后重定向到登录页      this.$store.dispatch(&quot;Logout&quot;);      }</code></pre><p>②做第二个功能的时候，首先团队名称是通过axios获取的，并且刷新的时候还要在。所以应该把数据存在session中，同时要解决数据渲染的问题,采用了在state里面设置get和set的方法。</p><pre><code class="bash">//state.js  get teams() {    let vlaue = sessionStorage.getItem(&quot;teams&quot;);    return typeof vlaue === &quot;string&quot; ? JSON.parse(vlaue) : [];  },  set teams(vlaue) {    sessionStorage.setItem(&quot;teams&quot;, JSON.stringify(vlaue));  },  get teamId() {    return sessionStorage.getItem(&quot;teamId&quot;);  },  set teamId(vlaue) {    sessionStorage.setItem(&quot;teamId&quot;, vlaue);  },</code></pre><p>这里切换团队之后页面刷新用了上一篇博客提到的provide/inject组合刷新的办法。</p><p>③第三个功能是兄弟Header和Sidebar组件的通讯，因为做这个项目主要是学习为主，所以选择了借助中央事件总线：在外部新建一个utils/eventBus.js文件。</p><pre><code class="bash">//eventBus.jsimport Vue from &#39;vue&#39;export default new Vue();//Header.vueimport eventBus from &quot;../../utils/eventBus.js&quot;;extendNav() {//通过eventBus中央事件总线用$emit发送一个showNav事件eventBus.$emit(&quot;showNav&quot;); } //Sidebar.vuemounted() {//通过eventBus中央事件总线用$on监听组件1中发送的showNav事件，第二个参数为回调函数。 eventBus.$on(&quot;showNav&quot;, this.change);},</code></pre><p>上述是最开始的做法，后面发现更简便的方法。<br>主要是省略了外部的js文件，把总线放在main.js里的vue实例中</p><pre><code>new Vue({data:{eventBus:new Vue()}})</code></pre><p>兄弟组件调用的时候,用<code>this.$root.eventBus.$on</code>代替<code>eventBus.$on</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;设置权限时动态加载路由&quot;&gt;&lt;a href=&quot;#设置权限时动态加载路由&quot; class=&quot;headerlink&quot; title=&quot;设置权限时动态加载路由&quot;&gt;&lt;/a&gt;设置权限时动态加载路由&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;路由分为两类，一类是静态路由（不需要登陆验证），一类是动
      
    
    </summary>
    
      <category term="project" scheme="http://yoursite.com/categories/project/"/>
    
    
      <category term="软件超市" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82/"/>
    
  </entry>
  
  <entry>
    <title>软件超市项目后台管理界面开发流程1</title>
    <link href="http://yoursite.com/2020/01/29/%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82%E9%A1%B9%E7%9B%AE%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/01/29/软件超市项目后台管理界面开发流程/</id>
    <published>2020-01-29T13:53:41.000Z</published>
    <updated>2020-03-02T09:33:54.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-3-组件编写"><a href="#3-3-组件编写" class="headerlink" title="3.3 组件编写"></a>3.3 组件编写</h1><h2 id="3-3-1-Manage-vue"><a href="#3-3-1-Manage-vue" class="headerlink" title="3.3.1 Manage.vue"></a>3.3.1 Manage.vue</h2><ul><li>存放目录：src/views/Manage.vue</li><li>作用：作为Layout容器</li><li>详情：包含了Header组件与Sidebar组件</li></ul><h2 id="3-3-2-Login-vue"><a href="#3-3-2-Login-vue" class="headerlink" title="3.3.2 Login.vue"></a>3.3.2 Login.vue</h2><ul><li>存放目录：src/views/login/Login</li><li>作用：登陆界面</li><li>详情：通过前台展示界面进入，进入时选择身份，ID的不同身份权限不一样。</li></ul><p><img src="\img\软件超市\后台管理界面login.png" alt="后台管理界面"></p><p><strong>具体实现</strong></p><p>需要根据前台显示的页面获取信息：</p><ol><li>getStudentIdByRequest get请求获取登陆的学号ID</li><li>getUserId?studentId= 通过登陆的studentId获取userId</li><li>getRole?userId= 通过userId获取角色权限，通过不用的权限生成不同的导航栏。</li><li><p>getMessageByUserGet?userGet=userId 通过userId获取消息，如果有未读消息，进入管理页面后直接显示消息通知，如果没有未读消息，则显示第一个路由。<br><img src="/img/软件超市/软件超市项目后台管理界面开发流程2.png" width="50%"></p></li><li><p>权限、登陆时效等相关（重要）</p></li></ol><h3 id="问题一：跨域问题"><a href="#问题一：跨域问题" class="headerlink" title="问题一：跨域问题"></a>问题一：跨域问题</h3><p>由于vue-cli脚手架工具开发时，由于项目本身启动本地服务是需要占用一个端口的，所以必然会有跨域问题。<br>解决办法：config/index（webpack构建下），更改开发环境下(在dev里配置)的proxyTable。将请求代理到目标域名</p><pre><code>proxyTable: {  &quot;/v1&quot;:{    target:&quot;http://software.sicau.edu.cn:8080&quot;,    changeOrigin: true//是否开启代理  }},</code></pre><h3 id="问题二：axios的cookie问题"><a href="#问题二：axios的cookie问题" class="headerlink" title="问题二：axios的cookie问题"></a>问题二：axios的cookie问题</h3><p>由于用的是学校的统一认证平台，采用的是cookie，在使用axios的时候，发现http响应头中少了Set-Cookie属性（axios隐藏了这部分）。<br>解决办法：axios.defaults.withCredentials = true。withCredentials属性主要功能是指定跨域的请求是否应该使用证书（如cookie或授权头header）</p><h3 id="问题三：vue组件刷新问题。（这个方法在添加删除之中比较好用，最后虽然没有采用但还是把记录下来）"><a href="#问题三：vue组件刷新问题。（这个方法在添加删除之中比较好用，最后虽然没有采用但还是把记录下来）" class="headerlink" title="问题三：vue组件刷新问题。（这个方法在添加删除之中比较好用，最后虽然没有采用但还是把记录下来）"></a>问题三：vue组件刷新问题。（这个方法在添加删除之中比较好用，最后虽然没有采用但还是把记录下来）</h3><p>用vue-router重新路由到当前页面，页面是不进行刷新的。采用window.reload,或者router.go(0)刷新时，整个浏览器进行了重新加载，闪烁，体验感不好。<br>解决办法：provide/inject组合<br>provide：选项应该是一个对象或返回一个对象的函数。该对象包含可传递其子孙的属性。<br>inject：一个字符串数组，或一个对象，对象的 key 是本地的绑定名</p><ol><li><p>app.vue 中通过provide将父组件中的数据传给子组件</p><pre><code class="bash"> &lt;router-view v-if=&quot;isRouterAlive&quot;&gt;&lt;/router-view&gt; &lt;script&gt; export default {   name: &quot;App&quot;,   provide() {     return {       reload: this.reload     }   },   data() {     return {       isRouterAlive: true     }   },   methods: {     reload() {       this.isRouterAlive = false       this.$nextTick( ()=&gt;         this.isRouterAlive = true       )     }   } }; &lt;/script&gt;</code></pre></li><li>在要使用的组件中inject:[‘reload’],调用this.reload()既可实现刷新。</li></ol><h3 id="问题4：错误捕获问题"><a href="#问题4：错误捕获问题" class="headerlink" title="问题4：错误捕获问题"></a>问题4：错误捕获问题</h3><p>由于前端要根据返回的不同错误类型，进行不同的处理，在抛出问题时，不知道用async/await的错误如何捕获。<br>解决办法：try catch只能捕获同步代码，不能捕获异步代码，在async函数内，使用await可以捕获异步代码，这里实际上是异步代码变成了同步代码。</p><ul><li>在 async 函数内部使用 try catch 捕获异步错误</li><li>promise 内部使用 .catch 方法来捕获 promise 内部代码错误</li></ul><pre><code>async getRequest({commit,dispatch}){  try{    let  resGetStudentIdByRequest = await getStudentIdByRequest();    if (resGetStudentIdByRequest.status==0){     ...    }    else throw resGetStudentIdByRequest.msg;  }catch(err){    throw {err, msg: &quot;无效登录&quot;, code: 1 }  }},</code></pre><h3 id="问题5：token验证-——————————————————待补充"><a href="#问题5：token验证-——————————————————待补充" class="headerlink" title="问题5：token验证 ——————————————————待补充"></a>问题5：token验证 ——————————————————待补充</h3><blockquote><p>之前的项目用的是session，偶然见看见一篇关于token的文章。<a href="https://blog.csdn.net/mydistance/article/details/84545768" target="_blank" rel="noopener">https://blog.csdn.net/mydistance/article/details/84545768</a></p></blockquote><p>点击进入管理界面时，先根据选择的不同身份，设置不同的不同的角色信息，在进加密。</p><p>进行路由拦截</p><pre><code class="bash">//main.jsrouter.beforeEach((to, from, next) =&gt; {let token = sessionStorage.getItem(&quot;token&quot;);if(token){...}else{  //如果没有token ,如果to.path在白名单中,则免登陆。如果不在白名单中，定向去登陆页面    (whiteList.includes(to.path)) == true ? next(): next(&quot;/login&quot;)}}</code></pre><p>登陆时设置token</p><pre><code class="bash">//action.js//设置角色async setRole({commit,dispatch},roleId){  //给身份加密  setRole(roleId);  //设置token  setToken();},//auth.jsconst verify = 45416289438485;//给角色权限加密export const setRole = roleId =&gt; {  let token = verify * roleId;  sessionStorage.setItem(&quot;xxx&quot;, token);};//设置登陆tokenexport const setToken = () =&gt; {  let token = randomString(32);  sessionStorage.setItem(&quot;token&quot;, token);};//产生随机数function randomString(len) {  len = len || 32;  /****默认去掉了容易混淆的字符oOLl,9gq,Vv,Uu,I1****/  const $chars =    &quot;ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678&quot;;  const maxPos= $chars.length;  let pwd = &quot;&quot;;  for (let i = 0; i &lt; len; i++) {    pwd += $chars.charAt(Math.floor(Math.random() * maxPos));  }  return pwd;}</code></pre><p>然后为了防止用户直接手动按f5刷新页面，这个时候会重新构建vue实例，而又没有重新登录，所以vuex里面的东西会清空，所以将登录后的数据存放在sessionStroage中，在刷新页面，重新构建vue实例的时候，会有判断。</p><h3 id="问题6：button按钮添加回车事件"><a href="#问题6：button按钮添加回车事件" class="headerlink" title="问题6：button按钮添加回车事件"></a>问题6：button按钮添加回车事件</h3><p>最开始的写法，发现login方法根本没有执行，开始以为是@keyup.enter.native的问题，但是写在封装好的组件中的时候加.native才能监听原生的事件。后面发现是输入框事件，在button上面不起效果。</p><pre><code class="bash">&lt;el-button @click=&quot;login&quot;  @keyup.enter.native=&quot;login&quot; class=&quot;btn&quot; :loading=&quot;btnLoading&quot;&gt;进入管理页面&lt;/el-button&gt;</code></pre><p>修改后，用了自定义指令的办法。</p><pre><code> &lt;el-button @click=&quot;login&quot;   v-enter=&quot;this&quot; class=&quot;btn&quot; :loading=&quot;btnLoading&quot;&gt;进入管理页面&lt;/el-button&gt;  directives: {    // 按enter键登录    enter(el, { value }) {      document.onkeydown = e =&gt; {        e = e || window.event;        if (e.keyCode === 13) {          value.login();        }      };    }  },</code></pre><h3 id="问题7：封装好外部链接"><a href="#问题7：封装好外部链接" class="headerlink" title="问题7：封装好外部链接"></a>问题7：封装好外部链接</h3><p>通过新建一个元素a，调用函数时点击a来实现外部跳转</p><pre><code class="bash">const HOME_URL = &quot;主页&quot;;const LOGIN_URL = &quot;统一认证界面&quot;;//新建aexport const goto = url =&gt; {  const link = document.createElement(&quot;a&quot;);  link.href = url;  link.click();};goto.home = () =&gt; goto(HOME_URL);goto.login = () =&gt; goto(LOGIN_URL);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;3-3-组件编写&quot;&gt;&lt;a href=&quot;#3-3-组件编写&quot; class=&quot;headerlink&quot; title=&quot;3.3 组件编写&quot;&gt;&lt;/a&gt;3.3 组件编写&lt;/h1&gt;&lt;h2 id=&quot;3-3-1-Manage-vue&quot;&gt;&lt;a href=&quot;#3-3-1-Manage-
      
    
    </summary>
    
      <category term="project" scheme="http://yoursite.com/categories/project/"/>
    
    
      <category term="软件超市" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82/"/>
    
  </entry>
  
  <entry>
    <title>Cookie、LocalStorage、sessionStorage的区别</title>
    <link href="http://yoursite.com/2020/01/29/Cookie%E3%80%81LocalStorage%E3%80%81sessionStorage/"/>
    <id>http://yoursite.com/2020/01/29/Cookie、LocalStorage、sessionStorage/</id>
    <published>2020-01-29T08:36:10.000Z</published>
    <updated>2020-08-08T02:37:59.767Z</updated>
    
    <content type="html"><![CDATA[<p>注意数组和对象要转化成JSON格式</p><p><strong>主要区别</strong></p><p><img src="/img/js/Cookie.png" width="70%"></p><p><strong>方法</strong></p><p>localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等</p><p>setItem存储value</p><pre><code class="bash">sessionStorage.setItem(&quot;key&quot;, &quot;value&quot;);localStorage.setItem(&quot;key&quot;, &quot;value&quot;);</code></pre><p>getItem获取value</p><pre><code class="bash">let value = sessionStorage.getItem(&quot;key&quot;);let key = localStorage.getItem(&quot;key&quot;);</code></pre><p>removeItem删除key</p><pre><code class="bash">sessionStorage.removeItem(&quot;key&quot;);localStorage.removeItem(&quot;key&quot;);</code></pre><p>clear清除所有的key/value</p><pre><code class="bash">sessionStorage.clear();localStorage.clear();</code></pre><p>localStorage和sessionStorage的key和length属性实现遍历</p><pre><code class="bash">let storage = window.localStorage;for(var i=0, len=storage.length; i&lt;len;i++){    var key = storage.key(i);    var value = storage.getItem(key);    console.log(key + &quot;=&quot; + value);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;注意数组和对象要转化成JSON格式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/js/Cookie.png&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;localS
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>软件超市-返回刷新问题</title>
    <link href="http://yoursite.com/2019/06/28/%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82-%E8%BF%94%E5%9B%9E/"/>
    <id>http://yoursite.com/2019/06/28/软件超市-返回/</id>
    <published>2019-06-28T13:59:03.000Z</published>
    <updated>2020-08-22T10:33:50.313Z</updated>
    
    <content type="html"><![CDATA[<p>在对项目进行优化的时候，发现返回上一页的函数很多组件都会使用，于是打算把这个函数抽离出来。</p><p>在此之前需要先解决<strong>首页进入列表页面刷新，而详情页返回列表页面不刷新的问题</strong>的问题</p><h3 id="方法一：keep-alive与vue-router配合使用"><a href="#方法一：keep-alive与vue-router配合使用" class="headerlink" title="方法一：keep-alive与vue-router配合使用"></a>方法一：keep-alive与vue-router配合使用</h3><p>实现在定义了两个字段 <code>keepAlive:true</code> 标识是否使用keep-alive组件字段,<code>ifDoFresh:false</code>标识是否刷新数据字符</p><pre><code class="bash">/*------router/index-----*/    {      path: &#39;/project&#39;,      name:&#39;项目列表&#39;      component:resolve =&gt; require([&quot;@/pages/Project/Project&quot;],resolve),      meta: {        keepAlive:true,        ifDoFresh:false,        showNav: true      }    },</code></pre><p>在根组件中根据<code>keepAlive</code> 字符判断是否使用keep-alive组件</p><pre><code class="bash">/*------app.vue----*/&lt;div class=&quot;main&quot;&gt;    &lt;keep-alive&gt;       &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;/&gt;    &lt;/keep-alive&gt;    &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;/&gt;&lt;/div&gt;</code></pre><p>在目标列表页的beforeRouteEnter判断从哪个页面进入的，根据需求更改<code>ifDoFresh</code>变量。这里与<code>activated</code>联合用。</p><pre><code class="bash">beforeRouteEnter(to,from,next){        //需要刷新的页面        if (from.name!=&quot;团队详情&quot;) {          to.meta.ifDoFresh = true;        }        next()      },activated(){       if (this.$route.meta.ifDoFresh){          // 先重置          this.selected=0        this.$route.meta.ifDoFresh=false         this.$store.dispatch(&#39;getTeam&#39;,{teamId:0})        }      }</code></pre><p>按逻辑来说这样就可以了，但是有个的问题出现了！！！！</p><p><img src="\img\软件超市\图3.png" alt="视图3"><br><img src="\img\软件超市\图4.png" alt="视图4"></p><p>返回只显示一个团队了！！好气啊，不断调试中发现我团队详情的团队信息居然和我列表的团队信息存储在同一个变量里！！！！所以点进详情页后，改变了team，而keep-alive缓存的是team里的数据。我是白痴吗？？？？</p><p>还有一个问题就是从列表到首页，在从首页到列表页，分页的缓存仍然存在。</p><p>解决办法：在分页器组件内提前判断（因为使用分页器组件时并没有传当前页码）</p><pre><code class="bash">  activated(){    if (this.$route.meta.ifDoFresh) {      this.currentPage = 1    }  },</code></pre><h3 id="方法二：keep-alive标签内部添加"><a href="#方法二：keep-alive标签内部添加" class="headerlink" title="方法二：keep-alive标签内部添加"></a>方法二：keep-alive标签内部添加</h3><blockquote><p><a href="/2019/06/29/keep-alive">keep-alive的总结</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在对项目进行优化的时候，发现返回上一页的函数很多组件都会使用，于是打算把这个函数抽离出来。&lt;/p&gt;
&lt;p&gt;在此之前需要先解决&lt;strong&gt;首页进入列表页面刷新，而详情页返回列表页面不刷新的问题&lt;/strong&gt;的问题&lt;/p&gt;
&lt;h3 id=&quot;方法一：keep-alive与
      
    
    </summary>
    
      <category term="questions" scheme="http://yoursite.com/categories/questions/"/>
    
      <category term="vue" scheme="http://yoursite.com/categories/questions/vue/"/>
    
    
      <category term="软件超市" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82/"/>
    
  </entry>
  
  <entry>
    <title>软件超市-改变v-html内容的图片样式</title>
    <link href="http://yoursite.com/2019/06/26/%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82-%E9%97%AE%E9%A2%98v-if%E6%A0%B7%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/06/26/软件超市-问题v-if样式/</id>
    <published>2019-06-26T11:13:48.000Z</published>
    <updated>2020-08-22T10:33:41.324Z</updated>
    
    <content type="html"><![CDATA[<p>在通过v-html把后台传过来的内容渲染到页面之后，发现后台传来的图片是限制了宽和高的。</p><p><img src="\img\软件超市\图1.png" alt="视图1"></p><p>通过查资料发现，这里解析是把v-html传来的数据作为了一个新的组件，所以在scoped下的style里面设置样式不起作用。那么根据原理，或许可以把scoped直接去掉，但是为了防止组件之间的样式污染，使用了其他办法。</p><p><strong>方法一</strong></p><p> <code>&gt;&gt;&gt;</code>(深度作用选择器) 或者 有些sass类的预处理器无法正确解析可以使用 /deep/</p><pre><code class="bash">/*----html----*/&lt;div class=&quot;announcement_img&quot; v-html=&quot;announcement.content&quot;&gt;&lt;/div&gt;/*----style----*/.announcement_img&gt;&gt;&gt;img{width: 100%;display: block;height: auto;}</code></pre><p><strong>方法二</strong></p><p>updated周期函数中，js动态配置样式。</p><p>首先需要清楚updated周期函数在什么时候起作用，①data里面需要有该数据变量如arr ②在页面重新渲染arr完成后才进入updated。更深入的会在以后学习。</p><pre><code>updated:function(){console.log(&quot;1==我会先执行&quot;);this.$nextTick(function(){//在下次 DOM 更新循环结束之后执行这个回调。在修改数据之后立即使用这个方法，获取更新后的DOM.console.log(&quot;3==我只能等页面渲染完了才会立即执行&quot;);})console.log(&quot;2==我虽然在最后但会比$nextTick先执行&quot;)}</code></pre><p><img src="\img\软件超市\图2.png" alt="视图2"></p><p>如果后期发现更好的或者更多的办法会重新更新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在通过v-html把后台传过来的内容渲染到页面之后，发现后台传来的图片是限制了宽和高的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;\img\软件超市\图1.png&quot; alt=&quot;视图1&quot;&gt;&lt;/p&gt;
&lt;p&gt;通过查资料发现，这里解析是把v-html传来的数据作为了一个新的组件，所以在s
      
    
    </summary>
    
      <category term="questions" scheme="http://yoursite.com/categories/questions/"/>
    
      <category term="vue" scheme="http://yoursite.com/categories/questions/vue/"/>
    
    
      <category term="软件超市" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82/"/>
    
  </entry>
  
  <entry>
    <title>markdown</title>
    <link href="http://yoursite.com/2019/05/15/markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/05/15/markdown学习笔记/</id>
    <published>2019-05-15T14:19:13.000Z</published>
    <updated>2020-11-03T10:32:58.413Z</updated>
    
    <content type="html"><![CDATA[<p>写博客的时候有些不常用的语法会有遗漏，今天重新学习markdown常用语法并把记录下来。</p><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>   兼容HTML。不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。<br>   <span id="jump">用于瞄点测试</span></p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>方法一：</p><pre><code>```# 第一级标题 `&lt;h1&gt;`## 第二级标题 `&lt;h2&gt;`### 第三级标题 `&lt;h3&gt;`#### 第二四级标题 `&lt;h4&gt;`##### 第五级标题 `&lt;h5&gt;`###### 第六级标题 `&lt;h6&gt;````</code></pre><p>方法二：</p><p>任何数量的 = 和 - 都可以有效果。</p><pre><code>```一级标题=二级标题-```</code></pre><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p><strong>如果* 和 _ 两边都有空白的话，它们就只会被当成普通的符号</strong><br>如果要在文字前后直接插入普通的星号或底线，可以用反斜线。</p><p>斜体 <code>*内容*</code>或者<code>_内容_</code>   （em）<br>加粗 <code>**内容**</code>或者<code>__内容__</code>   （strong）<br>倾斜加粗 <code>***内容***</code><br>删除线 <code>~~内容~~</code></p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>行内式</p><pre><code>```[我的博客](https://biubiuins.github.io/)自动生成连接  &lt;https://biubiuins.github.io/&gt;```</code></pre><p>效果：<br><a href="https://biubiuins.github.io/" target="_blank" rel="noopener">我的博客</a><br>自动生成连接  <a href="https://biubiuins.github.io/" target="_blank" rel="noopener">https://biubiuins.github.io/</a></p><p>添加图片形式和链接类似。</p><pre><code>```格式：![图片描述](url)![GitHub set up](http://zh.mweb.im/asset/img/set-up-git.gif)```</code></pre><p>效果：</p><p><img src="http://zh.mweb.im/asset/img/set-up-git.gif" alt="GitHub set up"></p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。</p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><ol><li>只要简单地缩进 4 个空格或是 1 个制表符就可以。 <strong>需要和普通段落之间存在空行！</strong></li><li>`内容`</li><li>多行代码块与语法高亮：在需要高亮的代码块的前一行及后一行使用三个单反引号`包裹，就可以了。</li><li>代码块中包含html代码。在代码区块里面， &amp; 、&lt; 和 > 会自动转成 HTML 实体</li></ol><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ol><li>在被引用的文本前加上&gt;符号，以及一个空格就可以了，如果只输入了一个&gt;符号会产生一个空白的引用。</li><li>引用可以嵌套</li><li>引用的区块内也可以使用其他的Markdown 语法</li></ol><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p><strong>符号后面一定要有一个空格，起到缩进的作用。</strong><br>还需要注意的是在使用列表时，只要是数字后面加上英文的点，就会无意间产生列表，比如2017.12.30 这时候想表达的是日期，有些软件把它被误认为是列表。解决方式：在每个点前面加上\就可以了。</p><ol><li>无序列表<br>使用 *，+，- 表示无序列表。</li><li>有序列表<br>使用数字和一个英文句点表示有序列表。</li></ol><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><pre><code class="html">姓名|分数-|-张三|50李四|80</code></pre><p>效果：</p><table><thead><tr><th>姓名</th><th>分数</th></tr></thead><tbody><tr><td>张三</td><td>50</td></tr><tr><td>李四</td><td>80</td></tr></tbody></table><p>表格对齐方式：我们可以指定表格单元格的对齐方式，冒号在左边表示左对齐，右边表示有对齐，两边都有表示居中。</p><pre><code class="html">姓名|分数:-|-:张三|50李四|80</code></pre><p>效果：</p><table><thead><tr><th style="text-align:left">姓名</th><th style="text-align:right">分数</th></tr></thead><tbody><tr><td style="text-align:left">张三</td><td style="text-align:right">50</td></tr><tr><td style="text-align:left">李四</td><td style="text-align:right">80</td></tr></tbody></table><h3 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h3><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><pre><code>\   反斜线`   反引号*   星号_   底线{}  花括号[]  方括号()  括弧#   井字号+   加号-   减号.   英文句点!   惊叹号</code></pre><h2 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h2><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>方法1: 连续两个以上空格+回车<br>方法2：使用html语言换行标签</p><h3 id="其他特殊字符"><a href="#其他特殊字符" class="headerlink" title="其他特殊字符"></a>其他特殊字符</h3><p><a href="https://unicode-table.com/cn/" target="_blank" rel="noopener">unicode字符编码</a></p><h3 id="内容目录"><a href="#内容目录" class="headerlink" title="内容目录"></a>内容目录</h3><p>在段落中填写 <code>[TOC]</code> 以显示全文内容的目录结构，需要独占一行才能生效。</p><h3 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h3><p>Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3。</p><pre><code class="html">&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;&lt;font color=gray size=5&gt;color=gray&lt;/font&gt;&lt;font color=#0099ff size=5 face=&quot;黑体&quot;&gt;color=#0099ff size=5 face=&quot;黑体&quot;&lt;/font&gt;</code></pre><p>背景色需要借助 table, tr, td 等表格标签的 bgcolor 属性来实现背景色的功能。</p><pre><code class="html">&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=pink&gt;背景色是：pink&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</code></pre><p>效果：</p><table><tr><td bgcolor="pink">背景色是：pink</td></tr></table><h3 id="瞄点"><a href="#瞄点" class="headerlink" title="瞄点"></a>瞄点</h3><p>自定义瞄点</p><p>标签形式的锚点目标的id特性值中是不能含有中文字符；</p><pre><code>//建立一个跳转链接[说明文字](#jump)//需要跳转到的位置&lt;span id = &quot;jump&quot;&gt;跳转到的位置&lt;/span&gt;</code></pre><p>效果：<a href="#jump">瞄点</a></p><p>Markdown会自动给每一个h1~h6标题生成一个锚，其id就是标题内容。如<a href="#表格">表格</a></p><h3 id="单选框"><a href="#单选框" class="headerlink" title="单选框"></a>单选框</h3><pre><code>- [ ] ranan- [x] ranan</code></pre><p>效果:</p><ul><li style="list-style: none"><input type="checkbox"> ranan</li><li style="list-style: none"><input type="checkbox" checked> ranan</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写博客的时候有些不常用的语法会有遗漏，今天重新学习markdown常用语法并把记录下来。&lt;/p&gt;
&lt;h2 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h2&gt;&lt;p&gt;   兼容HTML。不在 Markd
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>element-ui总结</title>
    <link href="http://yoursite.com/2019/04/19/element-ui%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/04/19/element-ui总结/</id>
    <published>2019-04-19T07:37:38.000Z</published>
    <updated>2020-07-06T07:59:18.584Z</updated>
    
    <content type="html"><![CDATA[<p>在一次项目中用到了element-ui框架，对在使用过程中遇见的问题进行总结（持续更新）。</p><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><h3 id="1-数据为二级对象时"><a href="#1-数据为二级对象时" class="headerlink" title="1.数据为二级对象时"></a>1.数据为二级对象时</h3><p>数据为二级对象时，验证的数据要用字符串形式。</p><pre><code class="js">rules:{   &quot;captainInformation.name&quot;: [     { required: true, message: &#39;请输入姓名&#39;, trigger: &#39;blur&#39; },     ],    }</code></pre><h3 id="2-动态添加的数据"><a href="#2-动态添加的数据" class="headerlink" title="2.动态添加的数据"></a>2.动态添加的数据</h3><p>动态添加的输入框或表单绑定数据时注意 <code>:prop=&quot;&#39;v-for绑定的数组.&#39; + index + &#39;.v-model绑定的变量&#39;&quot;</code><br>   我是直接把验证写在标签里面的</p><pre><code>    &lt;el-form-item label=&quot;姓名&quot; :prop=&quot;&#39;memberInformation.&#39;+index+&#39;.name&#39;&quot; :rules=&quot;[ { required: true, message: &#39;请输入姓名&#39;, trigger: &#39;blur&#39; }]&quot;&gt;</code></pre><p>   增加与减少成员</p><pre><code>   //增加成员    addmember() {      let newmember = {            name: &quot;&quot;,            studentId: &quot;&quot;,           }           this.form.memberInformation.push(newmember)         },         //减少成员         reducemember(index) {           this.form.memberInformation.splice(index, 1)         },</code></pre><blockquote><p>这个是我在项目中用到的办法，在阅读时发现了另一种情况的解决办法：<a href="https://blog.csdn.net/weixin_41041379/article/details/81908788" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41041379/article/details/81908788</a></p></blockquote><h3 id="3-普通输入验证"><a href="#3-普通输入验证" class="headerlink" title="3.普通输入验证"></a>3.普通输入验证</h3><pre><code>```jsrules:{data1:[//必填，trigger是触发类型{ required: true, message: &#39;请输入学号&#39;, trigger: &#39;blur&#39; },//数字类型 &#39;number&#39;, 整数: &#39;integer&#39;, 浮点数: &#39;float&#39;//使用整数的时候，首先要保证数据类型为数字，可以v-model.number绑定数据{type: &#39;integer&#39;, message: &#39;格式错误&#39;, trigger: &#39;blur&#39;},//长度限制{ min: 2, max: 4, message: &#39;长度在 2 到 4 个字符&#39;, trigger: &#39;blur&#39; }]}```</code></pre><h3 id="4-手动验证"><a href="#4-手动验证" class="headerlink" title="4.手动验证"></a>4.手动验证</h3><p>   第一种是直接写在rules的里面</p><pre><code>    rules:{    data1:[         { validator:(rule,value,callback)=&gt;{                    if(/^\d+$/.test(value) == false){                      callback(new Error(&quot;只能输入数字&quot;));                    }else{                      callback();                    }                  }, trigger: &#39;blur&#39; }    }    ]</code></pre><p>   第二种写法是抽离出来</p><pre><code>   //注意书写位置    data(){     let checkAge = (rule, value, callback) =&gt; {        if (!value) {          return callback(new Error(&#39;年龄不能为空&#39;));        }         if (!Number.isInteger(value)) {            callback(new Error(&#39;请输入数字值&#39;));          } else {            if (value &lt; 18) {              callback(new Error(&#39;必须年满18岁&#39;));            } else {              callback();            }          }      }    return {    rules:{        age: [       { trigger: &#39;blur&#39;, validator: checkAge }              ]        }    }</code></pre><h3 id="5-手动上传文件"><a href="#5-手动上传文件" class="headerlink" title="5.手动上传文件"></a>5.手动上传文件</h3><pre><code>```html//html     &lt;el-upload          action          ref=&quot;upload&quot;          //覆盖默认的上传行为，自定义上传的实现          :http-request=&quot;finish&quot;          //取消自动上传          :auto-upload=&quot;false&quot;        &gt;          &lt;el-button slot=&quot;trigger&quot; size=&quot;small&quot; type=&quot;primary&quot;&gt;选取文件&lt;/el-button&gt;          &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;请上传您的项目功能清单&lt;/div&gt;        &lt;/el-upload&gt;//js finish() {  this.$refs.form.validate(valid =&gt; {         // 验证成功         if (valid) {         //这里的需求是必须上传文件           const file = this.$refs.upload.uploadFiles[0];           if (!file) {                     this.$message({                       type: &quot;warning&quot;,                       message: &quot;请选择文件&quot;                     });                     return;                   }           //数据处理           let formData = new FormData();           formData.append(&quot;projectId&quot;, this.runId);           formData.append(&quot;timeNode&quot;,JSON.stringify(this.form.timeNode));           formData.append(&quot;teamId&quot;, 1);           formData.append(&quot;functionFile&quot;,file.raw );           //....中间的弹框确定等省略           submitApply(formData)         } } }```</code></pre><h3 id="6-动态获取选项-模糊查询"><a href="#6-动态获取选项-模糊查询" class="headerlink" title="6.动态获取选项+模糊查询"></a>6.动态获取选项+模糊查询</h3><p><img src="/img/element-ui/element-ui.png" alt="演示图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在一次项目中用到了element-ui框架，对在使用过程中遇见的问题进行总结（持续更新）。&lt;/p&gt;
&lt;h2 id=&quot;表单&quot;&gt;&lt;a href=&quot;#表单&quot; class=&quot;headerlink&quot; title=&quot;表单&quot;&gt;&lt;/a&gt;表单&lt;/h2&gt;&lt;h3 id=&quot;1-数据为二级对象时&quot;&gt;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="库" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E5%BA%93/"/>
    
    
      <category term="UI" scheme="http://yoursite.com/tags/UI/"/>
    
  </entry>
  
</feed>
