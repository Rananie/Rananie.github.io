<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ranan的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-18T15:54:04.862Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ranan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vuex学习笔记</title>
    <link href="http://yoursite.com/2020/08/18/vuex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/08/18/vuex学习笔记/</id>
    <published>2020-08-18T15:00:13.000Z</published>
    <updated>2020-08-18T15:54:04.862Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/img/vue/liucheng.jpg">流程图</a></p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><pre><code class="js">//store/index.js/*vuex最核心的管理对象模块*/import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;Vue.use(Vuex)//这部分可以单独写成一个文件，然后通过import引入const state = {}const mutations = {    FN(state){      //state状态更新      }}const actions = {    fn({commit,state}){        commit(&quot;FN&quot;)    }}//依赖state里面的属性，计算生成的属性写在getters里面const getters = {    xxx(state){        //计算    }}//建立统一数据容器，唯一的容器let store = new Vuex.Store({    state,    mutations,    actions,    getters})</code></pre><ul><li>stat:状态对象 </li><li>mutations:<ul><li>操作state,直接更新state的多个方法对象</li><li>只操作state,若组件中只需要修改state无异步无逻辑操作，可以直接操作mutations</li></ul></li><li>actions<ul><li>commit–&gt; 操作mutations 间接更新state的多个方法对象</li><li>异步操作、逻辑代码处理、发送请求 </li></ul></li><li>getters:包含多个基于state的getter计算属性的对象 </li><li>mutations-type:包含n个mutations的type名称常量 </li></ul><p>store 对象中的属性<br>1.state 包含所有state数据的对象<br>2.getters 包含所有getter计算属性的对象<br>3.dispatch(actionName,data) 触发action调用<br>4.commit(mutationName,data) 触发mutation调用</p><p>store(容器)注册到实例上，main.js里面，所有的组件都会有一个属性$store</p><pre><code class="js">import store from &#39;&#39;new Vue({store,})//----------组件对象中//在组件中使用{{$store.state.XXX}}//在js中使用this.$store.xxx</code></pre><h2 id="state-单向数据流"><a href="#state-单向数据流" class="headerlink" title="state(单向数据流)"></a>state(单向数据流)</h2><p> 注意,在组件中最好不要直接更改共享的数据，共享的数据仅仅给组件染</p><h2 id="mutation"><a href="#mutation" class="headerlink" title="mutation"></a>mutation</h2><p> 通过mutation(管理员)来更改状态，可以在store里面设置成严格模式<br> <code>strict：true</code>，mutation不支持异步</p><ol><li>告诉mutations需要更改,mutations相当于methods<pre><code class="js">const mutations={    add(state,count){        //state是自动放入的，默认指的就是当前的state        //操作state的属性        state.XXX +=count    }}let store = new Vuex.Store({state，mutations,strict：true})</code></pre></li><li>组件通过mutations提交,第一个参数是与mutatioons里面的方法绑定，第二个参数是自定义参数<pre><code>this.$store.commit(&#39;add&#39;,2)</code></pre></li></ol><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>打印日志</p><pre><code>import logger from &#39;vuex/dist/logger&#39;const store = new Vuex.store({    plugins:[logger()]})</code></pre><h2 id="整理"><a href="#整理" class="headerlink" title="整理"></a>整理</h2><p>src下面创建一个store文件\index.js</p><pre><code class="js">import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;Vue.use(Vuex)import logger from &#39;vuex/dist/logger&#39;const state={};import mutations from &#39;./mutations&#39;export default new Vuex.Store({    state，    mutations,    strict：true,    plugins:[logger()]    })</code></pre><p>store下面再创建一个mutations.js,里面存放mutations的相关</p><pre><code>import * as Types from &#39;mutations.types.js&#39;const mutations = { // [方法名](state,{param}){}[Types.INCREMENT](state){   state.count+=1},[Types.DECREMENT](state){    state.count-=1}};export default mutations;</code></pre><p>宏(一般大写)<br>store下面再创建一个mutations.types.js里面存放mutations的方法的名字，方便查找</p><pre><code>//增加export const INCREMENT=&#39;INCREMENT&#39;//减少export const DECREMENT=&#39;DECREMENT&#39;</code></pre><p>组件中引入同mutations.js中引入一样,只不过不加中括号<br>import * as Types from ‘mutations.types.js’</p><p>Types.INCREMENT<br>Types.DECREMENT</p><h2 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h2><p>相当于computed,如果数据多了可以模仿mutations的抽离</p><pre><code>const getters={ val(state){ state.count%2?&#39;奇数&#39;:&#39;偶数&#39; }};export default new Vuex.store({getters,})//引用时{{$store.getters.val}}</code></pre><h2 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h2><ul><li>和后台交互的异步action，后台数据也需要修改</li></ul><p>Action 类似于 mutation，不同在于：</p><ul><li>Action 提交的是 mutation，而不是直接变更状态。</li><li>Action 可以包含任意异步操作。</li></ul><ol><li>引入api以及mutation-types</li><li><p>异步获取数据</p><ul><li>异步获取地址</li><li>发送异步ajax请求</li><li><p>提交一个mutation</p><pre><code>//async 方法名({commit,参数可选}{})// 异步获取地址async getAddress ({commit, state}) {// 从state状态中获取到经纬度用来设置reqAddress的参数（看接口文档）const geohash = state.latitude + &#39;,&#39; + state.longitude// 1. 发送异步ajax请求const result = await reqAddress(geohash)// 2. 根据结果提交一个mutationcommit(RECEIVE_ADDRESS, {address: result.data})},</code></pre></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;/img/vue/liucheng.jpg&quot;&gt;流程图&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;基本使用&quot;&gt;&lt;a href=&quot;#基本使用&quot; class=&quot;headerlink&quot; title=&quot;基本使用&quot;&gt;&lt;/a&gt;基本使用&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>JS常用操作总结</title>
    <link href="http://yoursite.com/2020/08/13/js%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/08/13/js常用操作总结/</id>
    <published>2020-08-13T09:03:39.000Z</published>
    <updated>2020-08-13T09:14:38.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="判断对象是否是数组-对象的元素-属性"><a href="#判断对象是否是数组-对象的元素-属性" class="headerlink" title="判断对象是否是数组/对象的元素/属性"></a>判断对象是否是数组/对象的元素/属性</h2><p><strong>(常用于对象) in</strong></p><p>格式： 变量 in 对象/数组<br>当是数组时，变量指的是索引(不常用)<br>当是对象时，变量指的是对象的属性名</p><p><strong>(对象)Object.prototype.hasOwnProperty(value)</strong></p><p>格式:object.hasOwnProperty(value)<br>该方法只能判断字右属性是否存在，对于继承属性会返回false</p><p><strong>(常用于数组和字符串) Array.prototype.includes(value)</strong></p><p>格式:array/string.includes(value)</p><p>返回值为布尔值。<br>以前判断用indexOf返回的是数字。</p><p><strong>(常用于数组和字符串) Array.prototype.indexOf(value)/lastIndexOf(value)</strong></p><p>返回value在数组中出现的第一个下标和最后一下下标，没有出现则返回-1<br>应用场景：<br>两个方法结合判断下标是否相等，可以用来判断数组中唯一出现的值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;判断对象是否是数组-对象的元素-属性&quot;&gt;&lt;a href=&quot;#判断对象是否是数组-对象的元素-属性&quot; class=&quot;headerlink&quot; title=&quot;判断对象是否是数组/对象的元素/属性&quot;&gt;&lt;/a&gt;判断对象是否是数组/对象的元素/属性&lt;/h2&gt;&lt;p&gt;&lt;stron
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>vue-router学习笔记</title>
    <link href="http://yoursite.com/2020/08/12/vue-router%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/08/12/vue-router学习笔记/</id>
    <published>2020-08-12T05:59:22.000Z</published>
    <updated>2020-08-18T15:02:15.113Z</updated>
    
    <content type="html"><![CDATA[<p>Vue Router 是 Vue.js官方的路由管理器</p><pre><code>import Vue from &#39;vue&#39;impor VueRouter from &#39;vue-router&#39;//使用Vue插件Vue.use(VueRouter)//创建路由器的构建函数new VueRouter({    //应用中所有路由    routes:[    ]}),//路由配置routes:[    {        path:&quot;&quot;,        component:    },]//注册路由器import....  //引入路由new Vue({    router //所有组件都能通过$router属性看到router对象,所有组件都有一个代表当前路由的$route数据})//使用//用来生成路由链接&lt;router-link to=&quot;&quot;&gt;&lt;/router-link&gt;//用来显示当前路由组件界面&lt;router-view&gt;&lt;/router-view&gt;</code></pre><h2 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h2><p>通过$route可以获取到当前的路由数据。</p><pre><code>routes:[    {    path:&quot;/home&quot;,    component:    redirect: //重定向路由    children:[//注册子路由        path:&quot;/home/news&quot;        component:        children:[            {   //动态路由                path:&quot;/home/news/detail/:id&quot;            },            {                   //进入/home后自动显示当前的子路由                path:&quot;&quot;,                redirect:&quot;/home/news&quot;            }        ]    ]      }</code></pre><p><strong>path加/和不加/有什么区别</strong></p><p>/xx就是根路径。下面代码去到children是/#/child而不是/#/fa/child。而不以斜杠开头的，都会被当成普通的字符串拼到当前路径的后面。</p><pre><code>path: &quot;/fa&quot;children: {    path: &quot;/child&quot;}</code></pre><p><strong>路径参数</strong><br>1.query参数，跟在路径?后面<br>2.params参数</p><p><strong>动态路由及监视</strong></p><p>路由组件对象是在第一次请求对应路径时才创建，从一个路由组件离开、路由组件死亡，再进入需要重新创建。<br>当在同一个路由路径上做切换(只是改了参数),当前路由组件对象被直接复用,也就是说<strong>组件的生命周期钩子不会再被调用</strong>。</p><p>解决办法:<br>1.监视<code>$route</code></p><pre><code>watch:{    &#39;$route&#39;(to,from){        //当请求参数发生改变时，内部指定了新的$route属性，所以一般监视就可以了    }}</code></pre><p>2.路由导航</p><p><strong>编程式路由导航</strong></p><p>声明式:router-link<br>编程式:$router.push()/replace()</p><p>push往栈中放元素，repalce是替换栈顶元素。</p><p><strong>命名路由</strong></p><pre><code> path:&quot;/home&quot;, component: redirect: //重定向路由 name:&quot;home&quot;</code></pre><p>通过name关键字对该路由进行命名，在<code>router-link</code>中的路径可以直接使用命名路由<code>:to:&quot;{name:home,params:{id}}&quot;</code>来使用,第一个表示跳转之后的路由，第二个表示传递该路由的参数，这种写法也可以使用在编程式路由导航之中。</p><p><strong>props</strong></p><p>可以将路由参数映射成props<br>在路径配置中设置props之后，会自动把接收的parmas参数以标签属性传入路由组件</p><pre><code>// 之前通过$route来获取参数ID：{{$route.params.id}}//将路由参数映射成propsprops:[&quot;id&quot;]routes:[    // 在路径中设置props之后，会自动把接收的parmas参数以标签属性传入路由组件    //布尔写法    {path:&#39;/user/:id&#39;,props:true}    //函数写法,可以获取query参数    {     path:&#39;/user/:id&#39;,     //函数返回的对象中的所有属性都会以标签属性传入组件中     props:(route) =&gt; ({         id:route.params.id,         name:route.query.name     })    }]</code></pre><p><strong>router-link</strong></p><p>router-link-active 表示当前被选中的link的类名</p><p><strong>router-link与a标签的区别</strong><br><code>a</code>点击之后，会发送普通的HTTP请求,刷新页面。<br>路由链接点击后不会发送请求，不会刷新页面会局部更新组件。</p><h3 id="HTML5-history模式"><a href="#HTML5-history模式" class="headerlink" title="HTML5 history模式"></a>HTML5 history模式</h3><pre><code>const router = new VueRouter({    mode:&quot;history&quot;,    //应用中所有路由    routes:[...]})</code></pre><p><strong>history模式与history模式</strong></p><p>hash模式<br>    路径:<a href="http://localhost:8000/#/home" target="_blank" rel="noopener">http://localhost:8000/#/home</a><br>    发送请求的路径:<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a><br>    响应:返回index页面 -&gt; path(/home)被解析为前台路由路径</p><p>hash模式无论在什么路径下请求的都是根路径，#之后的路径发请求的时候<strong>不会携带</strong>。</p><p>history模式<br>    路径:<a href="http://localhost:8000/home" target="_blank" rel="noopener">http://localhost:8000/home</a><br>    发送请求的路径:<a href="http://localhost:8000/home" target="_blank" rel="noopener">http://localhost:8000/home</a><br>    响应: 404错误<br>    希望: 如果没有对应的资源，返回index页面 -&gt; path(/home)被解析为前台路由路径<br>    解决办法:添加配置<br>            devServer:true,<br>            output:publicPath:”/“</p><pre><code>//webpack.config.jsmodule.exports = {    //开发服务器配置    devServer:{        //更详细的可以看文档        //fallback：planB的意思        histortApiFallback:true    }    //可能还需要配置出口的publicPath:&quot;/&quot;，引入打包文件的路径左侧以/开头}</code></pre><h3 id="缓存路由组件keep-alive"><a href="#缓存路由组件keep-alive" class="headerlink" title="缓存路由组件keep-alive"></a>缓存路由组件keep-alive</h3><p>路由组件对象在访问对应路径的时候创建，默认情况下，切换到其他路由对象会死亡释放，再切换回来是重新创建的组件对象</p><p><code>&lt;keep-alive&gt;</code>能在组件切换的过程中将状态保留在内存中，防止重复渲染DOM。</p><p>设置了keepAlive缓存的组件：</p><ol><li>第一次进入：beforeRouterEnter -&gt;created-&gt;…-&gt;activated-&gt;…-&gt;deactivated</li><li>后续进入时：beforeRouterEnter -&gt;activated-&gt;deactivated</li><li><code>activated</code>和<code>deactivated</code>仅在keepAlive缓存的组件里被激活<br>只有第一次进入该组件时，才会走created钩子，而需要缓存的组件中activated是每次都会走的钩子函数。</li></ol><p>属性<br>1.include: 字符串或正则表达式。只有匹配的组件会被缓存。<br>2.exclude: 字符串或正则表达式。任何匹配的组件都不会被缓存。</p><pre><code>// 需要对组件对象进行name命名&lt;keepAlive exclude=&quot;组件的name名&quot;&gt;&lt;/keepAlive&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vue Router 是 Vue.js官方的路由管理器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import Vue from &amp;#39;vue&amp;#39;
impor VueRouter from &amp;#39;vue-router&amp;#39;
//使用Vue插件
Vue.use(VueR
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vue组件通信</title>
    <link href="http://yoursite.com/2020/08/06/vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2020/08/06/vue组件通信/</id>
    <published>2020-08-06T07:48:58.000Z</published>
    <updated>2020-08-11T15:01:04.089Z</updated>
    
    <content type="html"><![CDATA[<p>一个组件接收属性数据不是用来直接修改，只是用来读取显示的，所以子组件最好不要直接修改父组件的值，通常通过set来设置。</p><h2 id="父子组件传值"><a href="#父子组件传值" class="headerlink" title="父子组件传值"></a>父子组件传值</h2><h3 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h3><p>父组件传值</p><p>通过动态绑定数据传值</p><pre><code>&lt;Person :age =&quot;age&quot; /&gt;</code></pre><p>子组件接收<br>语法:props:[]/{}</p><pre><code>//更详细的查看文档props:{    //简单的检测类型    height:Number,    //检测类型+其他验证    age:{        typr:Number,        default:0,        required:true    }}</code></pre><h4 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h4><p>父组件 -&gt; 子组件  <strong>带数据的标签结构</strong></p><p>插槽相当于占位,本身不显示。<br>传给插槽的是静态页面,相关的数据等解析是在父组件解析好了再传给子组件的,所以需要的数据和方法都定义在父组件。</p><pre><code>//子组件&lt;slot name=&quot;slotName&quot;&gt;如果父组件没传默认显示的内容&lt;/slot&gt;//父组件在子组件的标签体内传值&lt;Son&gt;    &lt;h1 slot=&quot;slotName&quot;&gt;    如果子组件有多个插槽，可以指定传给哪个插槽    &lt;/h1&gt;&lt;/Son&gt;</code></pre><h3 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h3><p>1.如果子组件要更新父组件的数据，调用父组件的更新函数来更新父组件的数据。</p><p>自定义vue事件</p><p>this.$emit(“myEvent”,value) 表示子组件向父组件分发myEvent事件</p><p>父组件监听(以-命名)myEvent事件后，触发doSomething回调函数调用</p><pre><code>//@ 绑定事件监听&lt;my-component @my-event=&quot;doSomething&quot;&gt;&lt;/my-component&gt;</code></pre><p>2.this.$emit(update: prop, “newPropVulue”)  </p><p>使子组件向父组件传达：更新属性，并抛出新的属性值。</p><p>从上述代码中可以看出首先更新的值要是从父组件中接收的，也就是props里面的值。其次父组件该值需要写成</p><pre><code>  &lt;ProjectPagination :filter-data=&quot;filterData&quot; @update:filter-data=&quot;filterData=$event&quot;&gt;&lt;/ProjectPagination&gt;</code></pre><p>更简单的写法是<code>.sync</code>修饰符</p><pre><code> &lt;ProjectPagination  :filter-data=&quot;filterData&quot; :filter-data.sync=&quot;filterData&quot;&gt;&lt;/ProjectPagination&gt;</code></pre><p><strong>注意:</strong><br>这里有一个Vue.sync修饰符与$emit(update:xxx)写法的坑</p><p>使用.sync修饰符</p><pre><code>//有效this.$emit(&quot;update:filterData&quot;, this.data.slice(0, val));//无效this.$emit(&quot;update:filter-Data&quot;, this.data.slice(0, val));</code></pre><p>不使用.sync修饰符</p><pre><code>//无效this.$emit(&quot;update:filterData&quot;, this.data.slice(0, val));//有效this.$emit(&quot;update:filter-Data&quot;, this.data.slice(0, val));</code></pre><h2 id="兄弟组件传值"><a href="#兄弟组件传值" class="headerlink" title="兄弟组件传值"></a>兄弟组件传值</h2><p>所有组件对象的原型对象都是不同的vm,所有的vm都是Vue的实例、都有一个共同的原型对象。</p><p>又根据这个特点，利用原型链实现子孙组件通信与兄弟组件通信</p><p>用来分发事件以及绑定事件监听的全局对象被称为全局事件总线(Global Event Bus)</p><pre><code>//在vue原型上创建一个全局事件总线对象，所有的组件都可以看见这个事件总线Vue.prototype.$globalEventBus = new Vue()//可以优化，不用再创建一个vue实例new Vue({   beforeCreate(){    Vue.prototype.$globalEventBus = this  }})//一个组件分发事件this.$globalEventBus.$emit(&quot;分发事件名&quot;,value)//一个组件进行事件监听this.$globalEventBus.$on(&quot;监听的事件名&quot;,function触发的回调函数)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个组件接收属性数据不是用来直接修改，只是用来读取显示的，所以子组件最好不要直接修改父组件的值，通常通过set来设置。&lt;/p&gt;
&lt;h2 id=&quot;父子组件传值&quot;&gt;&lt;a href=&quot;#父子组件传值&quot; class=&quot;headerlink&quot; title=&quot;父子组件传值&quot;&gt;&lt;/a&gt;父
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>python基础</title>
    <link href="http://yoursite.com/2020/07/31/python/"/>
    <id>http://yoursite.com/2020/07/31/python/</id>
    <published>2020-07-31T13:06:53.000Z</published>
    <updated>2020-08-18T13:07:29.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>Python是解释型语言，用途有Web应用、爬虫程序、科学计算、自动化运维、大数据、云计算、人工智能等。</p><p>补充:解释型语言:不会在执行前对代码进行编译，而是在执行的同时一边执行一边编译。</p><p><strong>Python开发环境搭建</strong><br>开发环境搭建就是安装Python的解释器<br>安装解释器的同时会安装python开发工具IDLE，在IDLE中可以通过TAB键来查看代码的提示。交互模式写一行执行一行，并不适用于我们日常的开发。</p><p><strong>基本语言</strong><br>1.Python中严格区分大小写<br>2.Python中的每一行就是一条语句，每条语句以换行结束<br>3.Pyhton中每一行语句不要太长<br>4.一条语句可以分多行编写，以<code>\</code>结尾<br>5.Python是缩进严格的语言<br>6.注释符<code>#</code>，习惯上注释符后跟一个空格</p><p><strong>字面量和变量</strong><br>字面量表示的意思就是它的字面的值，在程序中可以直接使用，比如:1,2,’hello’<br>变量可以用来保存字面量</p><p>Python中使用变量，不需要声明，直接变量赋值，但不能使用没有赋值的变量。<br>Python是一个动态类型的语言，可以为变量赋任意类型的值。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><strong>数值</strong><br>Python数值分成了整数、浮点数、复数。<br>在python中所有的整数都是int类型，如果数字的长度过大，可以使用下划线作为分隔符，比如123456可以写成123_456</p><p>其他进制的整数<br>二进制0b  八进制0o 十六进制0x</p><p>在python中所有小数都是float类型，对浮点数进行运算时，可能得到一个不精确的结果。</p><p><strong>字符串</strong></p><p>大部分同JS类似。<br>1.用三重引号来表示JS中的模板字符串。<br>2.字符串不能和其他类型进行加法运算<br>3.在创建字符串时，可以在字符串中指定占位符,%s在字符串中表示任意字符<br>4.格式化字符串，可以通过在字符串引号外面添加f来创建一个格式化字符串,在格式化字符串中可以直接嵌入变量,该变量必须已经赋值。</p><pre><code># 表示用孙悟空替换%sb = &#39;Hello %s&#39;%&#39;孙悟空&#39;b = &#39;Hello %s 你好%s&#39;%(&#39;tom&#39;,&#39;孙悟空&#39;)# 还可以限制位数，不够就补空格b = &#39;Hello %2s&#39;%&#39;孙悟空&#39;# 表示限制在3-5之间b = &#39;Hello %3.5s&#39;%&#39;孙悟空&#39;# %f 浮点数占位符,会四舍五入 # %d 整数占位符，不会四舍五入b = &#39;Hello %.5f&#39;%123.123# 打印print(&quot;a=&quot;,a)print(&quot;a=%s&quot;%a)print(f&#39;a={a}&#39;)# 格式化字符串c = f&#39;hello{a}&#39;</code></pre><p><strong>字符串的复制</strong></p><p>字符串和数字相乘，则解释器会将字符串重复指定的次数并返回。</p><pre><code>a=&#39;abc&#39;a= a*2print(a) abcabc</code></pre><p><strong>布尔值和空值</strong></p><p>True表真，False表假，注意开头大写，<strong>布尔值实际上也属于整型</strong>，True相当于1，False相当于0。</p><p>None空值专门表示不存在</p><p><strong>类型检查type</strong></p><p>type()用来检查值的类型，返回值为其类型</p><p><strong>对象object</strong></p><p><strong>一切皆对象</strong>,上面的数据类型都是对象，程序运行当中，所有的数据都是存储到内存中然后再运行，对象是内存中专门用来存储指定数据的一块区域，对象实际上就是一个存储数据的容器。</p><p>每个对象都要保存三种数据</p><ul><li>id 标识 通过id()来查看对象的id，在CPython中,id就是对象的内存地址，id一旦创建就不能改变。</li><li>type 类型 用来表示对象所属的类型，如int str float bool等，通过type()查看类型，Python是一门强类型语言，类型创建后不可以改变。</li><li>value 值  值就是对象中存储的数据，可变对象的值可以改变，不可变对象的值不可以改变。</li></ul><p>在python中，对象并没有直接存储到变量中，变量更像是给对象起的别名，变量中存储的是对象的id(地址)。</p><p><strong>变量中保存的对象id，只有在为变量重新赋值才会改变。</strong></p><p><strong>类型转换</strong>将一个类型的对象转换为其他对象，并不是改变对象本身的类型，而是根据当前对象的值创建一个新对象<br>int()  浮点数直接取整，整数字符串直接转整数，其他类型字符串报错，None也会报错。<br>float() float和int基本一致<br>str()/bool() 表空的都会转化成False</p><h2 id="运算符-操作符"><a href="#运算符-操作符" class="headerlink" title="运算符(操作符)"></a>运算符(操作符)</h2><p><strong>算术运算符</strong></p><p>两个不同类型不能进行加法<br>字符串和数字相乘，会对字符串指定重复次数<br><code>/</code>除法运算结果总会返回一个浮点类型<br><code>//</code>整除，只保留计算后的整数位。对浮点数运算时，结果也是浮点数即使是整除运算。</p><p><strong>关系运算符</strong></p><p>关系运算符用来比较两个<strong>值</strong>之间的关系，总会返回一个布尔值</p><p>可以对两个字符串进行大于/小于的运算，当对字符串进行逐位比较时，比较的是字符串的Unicode编码，比出大小后直接返回后面的字符串将不会进行比较了。</p><p><code>==</code>与<code>!=</code>比较的是对象的值<br><code>is</code>比较两个对象是否是同一个对象，比较的是ID<br><code>is not</code> 比较两个对象是否不是同一个对象，比较的是ID</p><p>逻辑运算符可以连着用,表示关系成立，以中间的数为基准比较</p><pre><code># 相当于 1&lt;2 and 2&lt;3 和中间数进行比较 Python独有1&lt;2&lt;3</code></pre><p><strong>逻辑运算符</strong></p><p>not 逻辑非  对非布尔值，非运算符会将其转换为布尔值，再取反<br>and 逻辑与  Python中的逻辑与和JS一样，也是短路的与，对非布尔值会先转化为布尔值运算，<strong>最终返回原值</strong><br>or 逻辑或   短路的或</p><pre><code># 与运算找false 21 and 2 # 或运算找true 1 1 or 2 </code></pre><p><strong>条件运算符(三元运算符)</strong></p><p>语法: 语句1 if 条件表达式 else 语句2</p><p>条件运算符在执行时，先对条件表达式进行求值判断，执行相应语句并返回执行结果。</p><h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><p><strong>条件判断语句(if)</strong></p><p>语法: if 条件表达式 : 语句 </p><p>Python是通过<strong>缩进</strong>表达代码块的,Python代码中使用的缩进方式必须统一，要么全缩进要么全空格</p><p>依次判断找到表达式结果为True的，执行代码块，然后语句结束。所以if-elif中只有一个代码块被执行。</p><pre><code>    if True：        # Tab缩进 或者 4个空格        # end=&quot;&quot; 可以控制打印之后不换行        print(123,end=&quot;&quot;)    # else:        # else的代码块    elif 条件表达式 :        # 代码块  </code></pre><p><strong>input函数</strong></p><p>input()函数用来获取用户的输入，调用后程序会立即暂停，等待用户输入，点击回车程序才会继续向下执行。</p><p>输入的内容会作为返回值返回，返回值为字符串<br>参数为字符串，作为提示文字显示</p><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>while 条件表达式:<br>    代码块<br>else:<br>    代码块，仅跳出循环后执行一次</p><p><strong>break与continue</strong></p><p>break 可以用来立即退出循环语句,后面与循环一套的else<br>continue 可以退出本次循环，本次循环continue后面的语句将不会被执行，执行下一次循环，不会影响循环一套的else</p><p>pass 用于在判断或循环语句中占位</p><h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表(list)是Python中的一个对象，列表中可以保存多个有序的数据<br>列表存储的数据，称为元素<br>列表的索引可以是负数，如果是负数从后向前获取元素</p><p><strong>切片</strong></p><p>切片指从现有列表中，获取一个子列表，索引传<br>个值，起始位置包括，结束位置不包括。或者可以理解为从索引的左边切下。<br>语法: 列表[起始:结束]   列表[起始:结束:步长]<br>步长表示每次获取元素的间隔，默认值是1，不能是0但是可以是负数，负数则会从列表的后面像前面取<br>切片操作不会影响原来的列表，会返回一个新的列表<br>起始位置和结束位置的索引可以省略不写</p><p>通过切片来修改列表，进行赋值时，只能使用序列中元素的个数没有要求。<br>当设置了步长时，序列中元素的个数必须和切片中元素的个数一致。</p><pre><code># 列表的创建my_list = [1,2,3]# 列表的使用，通过索引使用my_list[0:0] = [9] //[9 1 2 3]# 删除元素del list[0]# 通过len()函数获取列表的长度,列表的最大索引+1len(my_list)</code></pre><p><strong>列表的方法</strong></p><p><strong>都是直接修改原列表</strong></p><p>插入：<br>s.append(value) 序列的最后添加value，不可以使用直接赋值的办法是因为索引超过最大值了会保存<br>s.insert(i,value) 想列表的指定位置插入一个元素，参数1要插入的位置，参数2插入的元素<br>s.extend(list) 使用新的序列来扩展当前序列，会将当前序列中的元素添加到当前列表中，相当于<code>+ =</code></p><p>删除:</p><p>s.clear() 清空序列<br>s.pop() 根据索引删除并返回指定元素<br>s.remove() 删除指定值的一个元素<br>s.reverse() 序列反转<br>s.sort() 用来对列表中的元素进行排序，默认升序排列，如果需要降序，则需要传递一个reverse = True作为参数</p><p><strong>range()函数</strong></p><p>range() 可以生成一个自然数序列,可以创建一个指定执行次数的for循环。</p><p>该函数需要三个参数<br>1.起始位置，可以省略，默认是1<br>2.结束位置<br>3.步长，可以省略，默认是1</p><pre><code>range(5) # 生成一个序列[0,1,2,3,4]for i in range(30):    print(i)</code></pre><p><strong>列表的常用操作/序列通用操作</strong></p><p><code>+</code> 两个列表拼接为一个列表<br><code>*</code> 可以将列表重复指定的次数<br><code>in</code> 用来检查指定元素是否存在列表中，语法：元素 in 列表 ，返回布尔值<br><code>not in</code> 用来检查指定元素是否不在列表中</p><p>函数:<br>len(list) 获取列表中的元素个数<br>min(list) 获取列表中的最小值<br>max(list) 获取列表中的最大值</p><p>两个方法:方法和函数基本是一致的，只不过方法必须通过对象.方法()的形式调用<br>s.index() 获取指定元素在列表中的位置,如果列表中没有会报错，仅返回第一次出现的索引。第一次参数表示查找的元素，第二个参数表示查找的起始位置，第三个参数表示查找的结束位置<br>s.count() 统计指定元素在列表中出现的次数</p><h3 id="序列-sequence"><a href="#序列-sequence" class="headerlink" title="序列(sequence)"></a>序列(sequence)</h3><p>序列是Python中最基本的一种数据结构，数据结构指计算机中数据存储的方式</p><p>序列用于保存一组有序的数据，所有的数据在序列当中都有一个唯一的位置(索引)</p><p>序列的分类<br>    可变序列:序列中的元素可以改变<br>        列表(list)<br>    不可变序列:序列中的元素不可以改变<br>        字符串(str)<br>        元组(tuple)</p><p>可以通过<code>list()</code>函数将其他的序列转换为list</p><p>所有的序列都可以进行解包。</p><p><strong>遍历序列</strong></p><p><code>for-in</code>循环将序列中的所有元素取出来,每执行一次会将序列中的一个元素赋值给变量，变量指的是<strong>键值</strong>,这里是和JS不同的地方</p><p>for 变量 in 序列:<br>    代码块</p><h3 id="元组tuple"><a href="#元组tuple" class="headerlink" title="元组tuple"></a>元组tuple</h3><p>把元组当成是一个不可变的列表，一般当我们希望数据不改变时，就是用元组，其余情况都使用列表。</p><p>创建元组，使用小括号<code>()</code>，当元组不是空元组时，可以省略括号,<strong>至少有一个逗号</strong>(可以看成元组的信号)</p><p>元组的特殊用法类似JS的解构赋值，在对一个元组进行解包时，变量的数量必须和元组中的元素的数量一致，也可以在变量前面添加<code>*</code>,这样变量将会获取元组中所有的剩余元素，变量为一个列表</p><pre><code>my_tuple = 10,20,30,40# 元组的解构赋值（解构）a,b,c,d = my_tuple# c=[30,40]a,b,*c = my_tuple</code></pre><h3 id="字典-dict"><a href="#字典-dict" class="headerlink" title="字典 dict"></a>字典 dict</h3><p>字典属于一种新的数据结构，称为映射。字典的作用和列表类似，都是用来存储对象的容器。</p><p>列表存储数据的性能很好，但是查询数据的性能很差</p><p>在字典中每一个元素都有一个唯一的名字(键名)，通过这个唯一的名字就可以快速的查找到指定的元素(键值)</p><p>字典的键是任意的不可变对象，一般为字符串，不可以重复，如果重复，后面的会替换前面的；值可以是任意对象。</p><pre><code># 创建字典,类似JSON格式d = {&#39;age&#39;:18}d[&#39;age&#39;]</code></pre><p><strong>字典的操作</strong><br>函数:<br>dict() 来创建字典,这种方式 创建的字典，key都是字符串<br>    也可以将一个包含双值(仅两个值如’ab’)子序列的序列转换为字典。<br>len() 获取字典中键值对的个数<br>in 检查字典中是否包含指定的<strong>键</strong><br>not in 检查字典中是否不包含指定的<strong>键</strong></p><p>方法:<br>d.get(key[,default]) 根据键来获取字典中的值，如果键不存在，会返回None;通过[]来获取值时，如果键不存在，会抛出异常。<br>d.setdefault(key[,default]) 可以用来向字典中添加key-value，如果key存在，则返回key的值不会对字典做任何操作，如果key不存在，则向字典中添加这个key，并设置value<br>d.updata(other d) 将其他字典中的key-value添加到当前字典中<br>d.popitem() 随机删除字典中的一个键值对，一般都会删除最后一个键值对并以元组形式返回，删除空字典时报错<br>d.pop(key[,default]) 根据key删除字典中的key-value，返回值是删除的value。删除不存在的key会报错，如果指定了默认值就不会报错并直接返回默认值<br>d.clear() 用来清空字典<br><strong>copy()</strong><br>d.copy() 该方法用于对字典进行<strong>浅复制</strong></p><p>复制以后的对象和原对象是独立的，修改一个不会另外一个，浅复制仅是简单的复制对象内部的值，如果值是一个可变对象，这个可变对象不会被复制(会影响原来的值)</p><pre><code>d = dict(name=&#39;孙悟空&#39;,age=18)# {&quot;name&quot;:&quot;孙悟空&quot;，&quot;age&quot;:18}d = dict([(name,&#39;孙悟空&#39;),(age,18)])# 获取字典中的值,注意引号,有引号为字符串，没有引号为变量，d[&#39;name&#39;] = &quot;value&quot; # key存在修改，不存在添加# 删除字典中的key-value，key不存在报错del d[&#39;name&#39;]</code></pre><p><strong>字典的遍历</strong><br>d.keys()该方法会返回字典的所有key的序列<br>d.values()该方法会返回字典的所有value的序列<br>d.items(k,v)该方法会返回字典中所有项的序列<code>[(k,v),(k,v)]</code></p><h3 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h3><p>集合和列表非常相似，类似JS的Set</p><p>不同点</p><pre><code>- 集合中只能存储不可变对象- 集合中存储的对象是无序- 集合中不能出现重复的元素</code></pre><p>集合的创建使用<code>{}</code>或使用<code>set()</code>,创造空集合只能使用<code>set()</code>,使用<code>{}</code>默认是创建的字典。</p><p>set可以将序列和字典(的键)转换为集合，<strong>利用这点可以去重</strong>，</p><p>in 检查集合中的元素<br>len()来获取集合中元素的数量</p><p>s.add() 向集合中添加元素<br>s.update() 将一个集合/元组/字典(key<br>)中的元素添加到当前集合中<br>s.pop() 随机删除集合中的元素并返回<br>s.remove(value) 删除集合中的指定元素<br>s.clear()清空集合<br>s.copy() 对集合进行浅复制</p><p><strong>集合的运算</strong></p><pre><code># 在对集合做运算时，不会影响原来的集合，而是将运算结果返回# 创建两个集合s = {1,2,3,5,9}s2 = {4,6,7,8,9}# &amp; 交集运算result = s &amp; s2# | 并集运算result = s | s2# - 差集result = s - s2# ^ 异或集(除去交集的剩余部分，只在一个集合中出现的元素)result = s ^ s2# &lt;= 检查一个集合是否是另外一个集合的子集 # &lt; 检查一个集合是否是另外一个集合的真子集</code></pre><h2 id="函数-function"><a href="#函数-function" class="headerlink" title="函数 function"></a>函数 function</h2><p>函数也是一个对象<br>def 函数名([形参1=默认值,形参2]):<br>    代码块</p><p>位置参数:将对应位置的参数复制给对应位置的形参<br>关键字参数:通过参数名直接传递参数，可以不按照形参定义的顺序去传递<br>混合使用关键字和位置参数时，必须将位置参数写到前面</p><p>函数在调用时，解析器不会检查实参的类型，实参可以传递任意类型的对象</p><p>当传的参数是可变参数时，不想形参影响实参，传参可以通过<code>x.copy()</code>或<code>x[:]</code>传副本，这样形参和实参之间互不影响</p><p><strong>不定长参数</strong></p><p>在定义函数时，可以在形参前边加上<code>*</code>,这个形参将会获取到所有的实参，它会将所有的实参保存到一个<strong>元组</strong>,带<code>*</code>的参数后的所有的参数，必须以关键字参数的形式传递必须按形参顺序。</p><pre><code># 如果*后没跟变量，可以使用这种写法要求调用函数时必须使用关键字参数的形式传值def fn(*,a,b,c):    代码块# * 形参只能接收位置参数，而不能接收关键字参数def fn(*a):    代码块# **形参可以接收其他的关键字参数，将这些参数统一保存到字典中，字典的key就是参数的名字，字典value就是参数的值# **只能有一个且写在参数的最后    def fn(**a):    代码块    </code></pre><p><strong>参数的解包</strong><br>通过一个星号，对序列进行参数的解包。<br>通过两个星号，对字典进行参数的解包</p><pre><code>def fn(a,b,c):    代码块# 传递实参时，也可以在序列类型的参数前添加星号，这样会依次将序列中的元素作为参数传递。# 序列中元素的个数必须和形参的个数一致t = (10,20,30)fn(*t)d = {&#39;a&#39;:100,&#39;b&#39;:200,&#39;c&#39;:300}# 通过**来对字典进行解包操作,相当于关键字参数，所以key要和参数名一致fn(**d)</code></pre><p><strong>help()</strong></p><p>help()是python的内置函数，通过help(函数对象)函数可以查询python中的函数的用法</p><p>文档字符串(doc str)<br>在定义函数时，可以在函数内部第一行用<code>&#39;&#39;&#39;文档字符串&#39;&#39;&#39;</code>编写文档字符串，文档字符串就是函数的说明，可以通过help()函数来查看函数的说明。</p><p><strong>作用域</strong></p><p>作用域分两种</p><ul><li><p>全局作用域:在程序执行时创建，在程序执行结束时销毁</p></li><li><p>函数作用域:在函数调用时创建，在调用结束时销毁，每调用一次就会产生一个新的函数作用域</p></li></ul><p>如果希望在函数内部修改全局变量，可以通过global关键字来声明变量，表示这个变量不是函数内部的而是全局的。</p><p><strong>命名空间</strong><br>命名空间指的是变量存储的位置，每一个变量都需要存储到指定的命名空间中。<br>每一个作用域都会有一个它对应的命名空间，命名空间实际上就是一个字典，是一个专门用来储存变量的字典。</p><p>locals() 用来获取当前作用域的命名空间，返回当前作用域的命名空间<br>globals() 用来获取全局命名空间</p><p><strong>递归</strong></p><p>基线条件,问题可以被分解为的最小问题，当满足基线条件时，递归就不在执行了<br>递归条件，将问题继续分解的条件</p><p><strong>函数式编程</strong></p><p>在Python中，函数是一等对象<br>一等对象一般特点：<br>1.对象是在运行时创建的<br>2.能赋值给变量或作为数据结构中的元素<br>3.能作为参数传递<br>4.能作为返回值返回</p><p>高阶函数至少符合以下两个特点的一个:<br>1.接收一个或多个函数作为参数<br>2.将函数作为返回值返回</p><p><strong>filer()函数</strong><br>可迭代结构中过滤出符合条件的元素，保存到新的序列中<br>参数:<br>1.函数，根据函数来过过滤课迭代结构(需要返回bool值)<br>2.需要过滤的可迭代结构<br>返回值：<br>过滤后的新可迭代的结构</p><p>这个的函数可以传匿名函数,也可以将匿名函数赋值给一个变量，这里的返回值直接返回不需要使用<code>return</code></p><p>语法:lambda 参数列表 : 返回值</p><p><strong>map()函数</strong></p><p>map()函数可以对可迭代对象中的所有元素做指定的操作，然后将其添加到一个新的对象中返回。<br>语法:map(函数,可迭代对象)</p><p><strong>sort()方法/sorted()函数</strong></p><p>sort()方法用来对列表中的元素进行排序，会影响原列表。<br>该方法是直接比较列表中元素的大小。</p><p>在sort()可以接收一个关键字参数key，key需要一个函数作为参数，当设置了函数作为 参数，每次都会以列表中的一个元素作为参数来调用函数，并且使用函数的返回值来比较元素的大小。<br>如:<code>l.sort(key=len)</code>利用列表元素的长度排序。<br>key = int 每个元素转换成int类型排序<br>key = string 每个元素转换成string类型排序</p><p>这种用法只在比较的时候转换，不影响原来列表的类型</p><p>sorted()可以对任意的序列进行排序,不会影响原来的序列，返回一个新的对象。<br>第一个参数为序列，第二个参数为key</p><p><strong>闭包</strong></p><p>将函数作为返回值返回</p><p>产生闭包的条件<br>1.函数嵌套<br>2.内部函数引用了外部函数的数据</p><p><strong>装饰器</strong></p><p>开闭原则，程序的设计要求开发对程序的扩展，要关闭对程序的修改</p><p>在希望不修改原函数的情况下，对函数进行扩展</p><p>只需要在现在的函数，创建一个新的函数，把原来的函数在新的函数中运行。这种方式要求每扩展一个函数就要手动创建一个新函数，为了避免麻烦，我们创建一个函数，让这个函数可以自动帮助我们生产函数</p><pre><code>def begin_end(old_function):    &#39;&#39;&#39;    用来对其他函数进行扩展，使其他函数可以在执行前打印开始执行，执行后打印执行结束    参数：要扩展的函数对象    &#39;&#39;&#39;    # 打包    def new_function(*args,**kwargs):        print(&quot;开始执行&quot;)        # 解包        old_function(*args,**kwargs)        print(&quot;执行结束&quot;)    return new_function</code></pre><p>像begin_end()这种函数就被称为装饰器，在开发中使用装饰器扩展函数的功能。<br>在定义函数时，可以通过@装饰器来指定装饰器，可以同时为一个函数指定多个装饰器，函数将会被由内到外的装饰</p><pre><code># 在函数前面@装饰器，表示下面的函数被该装饰器装饰@begin_end@装饰器2def say_hello():    代码块# 执行的结果是被装饰器装饰后的结果  say_hello()    </code></pre><h2 id="可变对象"><a href="#可变对象" class="headerlink" title="可变对象"></a>可变对象</h2><p>变量中保存的对象id，只有在为变量重新赋值才会改变。<br>可变对象指的是对象的值可变<br>列表中的对象改变，该改变的是值，并没有重新给列表赋值</p><pre><code># 改对象a[0] = 10# 改变量a = [1,2,3]</code></pre><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>time()可以用来获取当前的时间，返回的单位是秒</p><pre><code>from time import *begin = time()  </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;p&gt;Python是解释型语言，用途有Web应用、爬虫程序、科学计算、自动化运维、大数据、云计算、人工智能等。&lt;/p&gt;
&lt;p&gt;补充:解释型语言:不
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>vue基础</title>
    <link href="http://yoursite.com/2020/07/31/vue%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/07/31/vue基础/</id>
    <published>2020-07-31T08:01:12.000Z</published>
    <updated>2020-08-12T10:17:56.702Z</updated>
    
    <content type="html"><![CDATA[<p><strong>创建vue实例</strong></p><pre><code class="bash">//————html&lt;div id=&quot;app&quot;&gt;&lt;a href = &quot;msg&quot;&gt;&lt;/a&gt;&lt;button v-on:click=&quot;test&quot;&gt;test&lt;/button&gt;&lt;/div&gt;//——————jsconst vm =new Vue({  //配置对象:属性名是一些特定的名称  el:&quot;#app&quot; ,   //值是选择器 element 用来查找根元素 该根元素所覆盖的htlm+js为模板页面  data:{  //包含多个可变数据的对象,为模板页面提供数据    msg:&quot;xxx&quot;  },  //data还可以是函数，一定要有返回值  //data(){return{}}  methods:{ //包含n个事件回调函数    test(event){      event.target.innerHTML    }  }})</code></pre><p>vm会自动拥有data中所有属性，页面中可以直接访问使用不用使用this<br>数据代理:由vm对象来<strong>代理</strong>对data中所有属性的操作</p><p><strong>问题1：js以什么形式存在</strong><br>    指令:vue自定义标签属性 例子:v-model<br>    插值:动态显示数据，可以写表达式</p><p>知识点1:强制数据绑定v-bind:<br>  为某个标签属性绑定动态data时，要在属性前面添加:</p><p>知识点2:绑定事件监听v-on:<br>  简写@事件名=”回调函数” 也可以写成@事件名=”回调函数(参数)” methods里面常常放回调函数</p><p><strong>Object.definePropertiy</strong></p><p>该方法的存储器属性(setter,getter)可以实现简单的数据双向绑定</p><pre><code>const p = {    firstName:&quot;A&quot;,    lastName:&quot;B&quot;    //还可以在这直接写get/set    //get fullName(){}}Object.defineProperty(p,&quot;fullName&quot;,{   //当读取属性值时自动调用(回调)，函数返回值作为属性值   get(){     //this是对象p        return this.firstName +&#39;-&#39;+ this.lastName       },   //当设置属性时自动调取,监视属性值的变化   set(value){        const names = value.split(&quot;-&quot;)        this.firstName = names[0]        this.lastName = name[1]   }})console.log(p.fullName);</code></pre><p><strong>computed</strong></p><p>计算属性，通过已有数据(依赖数据)计算动态产生一个要显示的结果数据，相当于使用了属性的get方法。<br>执行的时机：<br>  1.初始显示第一次执行，得到初始值显示<br>  2.依赖数据发生改变就会再次调用。</p><p>注意：所有vue控制的回调函数的this都是vm或者组件对象。</p><pre><code>computed：{  //计算属性的套路 filterPersons(){    //1.得到依赖的数据    const {searchName,persons} = this    //2.进行计算处理，产生结果数据并返回    const newPersons = persons.filter(p =&gt; p.name.includes(searchName))    return newPersons    }}</code></pre><p><strong>问题2:如果页面中需要fullName多次渲染，是否computed里的fullName函数会执行多次？</strong></p><p>答：不会执行多次，计算属性会先去缓存取，取不到在执行一次getter计算，计算的结果放入缓存。</p><p><strong>问题3:用什么结构来缓存计算属性？</strong><br>用对象来缓存计算属性，对象的属性名永远是<strong>字符串</strong>。</p><p><strong>getter和setter</strong><br>属性的set方法称为setter、属性的get方法称为getter,如果要自己设置get与set，那么该计算属性后面接对象。</p><pre><code>computed：{  fulllName:{      get(){      return this.firstName +&#39;-&#39;+ this.lastName        }      set(value){       const names = value.split(&quot;-&quot;)        this.firstName = names[0]        this.lastName = name[1]      }  }}</code></pre><p><strong>总结</strong><br>1.只用getter，计算属性就是一个函数<br>2.使用getter/setter，计算属性是一个包含geeter的setter的对象</p><p><strong>watch监视</strong></p><p>当监视的属性变化时自动调用，<strong>初始显示的时候不调用。</strong></p><pre><code>//用于监视vm的哪个属性的变化watch:{firstName(newValue,oldValue)=&gt;{//当firstName发生改变时自动调用},//一般监视todos(){}}</code></pre><p>假设监视的todos是一个数组，数组内部发生变化，但todos数组在内存中存的是地址，地址并没有改变，这种监视叫做一般监视。<br>如果想要监视todos以及todos里面的数据变化，可以使用深度监视。</p><p>深度监视:</p><pre><code>watch:{todos:{  deep:true,  //深度监视  handler(value){    //监视的回调函数，value最新的todos值  }}}</code></pre><p><strong>class动态绑定/style动态绑定</strong></p><p>动态绑定的class会和静态绑定的class合并。</p><pre><code>//值为字符串 &lt;p :class=&quot;classA&quot;&gt;//动态绑定多个class&lt;p :class=&quot;{classA:true,classB:false}&quot;&gt;//hasA，hasB是data里面的变量，通常操作hasA，hasB变量的改变改变样式&lt;p :class=&quot;{classA:hasA,classB:hsaB}&quot;&gt;//style的值为对象&lt;p :style = &quot;{color:myColor,fontSize:mySize+&#39;px&#39;}&quot;&gt;</code></pre><p>使用场景:<br>值为字符串 –&gt; 类名不确定时使用<br>值为对象 –&gt; 类名确定，不确定是否有该类的样式</p><p><strong>重点:HTML不区分大小写，所以HTML之中用连接线写法，而Js之中用驼峰写法</strong></p><p><strong>条件渲染</strong></p><p>v-if/v-else的标签二选一，</p><p>v-show是通过改变标签的样式实现显示与隐藏的</p><p><strong>v-for遍历</strong></p><pre><code>&lt;li v-for = &quot;(p,index) in persons&quot; :key=&quot;p.id&quot;&gt;&lt;/li&gt;data:{  persons:[]},methods:{  updataP(index,newP){    //这种方法不会更新页面    //this.persons[index] = newP    //这种方法可以更新页面    this.persons[index].name = newP.age    this.persons.splice(index,1,newp)   }}</code></pre><p><strong>问题4：vue的数据绑定如何实现</strong><br>1.vue会监视data中所有层次的属性<br>2.对象中的属性数据通过添加set方法来实现监视<br>3.数组中的元素也实现了监视data的数据,重写数组一系列更新元素的方法。首先调用原生对应的方法对元素进行处理，再更新界面。</p><p>重写的数组方法:push()、pop()、shift()、unshift()、splice()、sort()、reverse()</p><blockquote><p>在定义数据时，可以考虑根据状态赋值，如数组排序，比如有不排序，升序，降序三种状态，可以考虑用一个数字来表示该状态 0-不排序、1-升序、2-降序</p></blockquote><blockquote><p>如果两个不同的事件回调函数里面操作大部分相同，也可以尝试参数用true/false来表示不同的事件</p></blockquote><p><strong>事件处理</strong></p><p>1.绑定监听</p><p>当函数需要操作事件对象时，可以显示的传<code>$event</code></p><pre><code>&lt;button @click=&quot;test(&#39;x&#39;,$event)&quot;&gt;&lt;/buuton&gt;</code></pre><p>2.事件修饰符</p><p>阻止(prevent)事件的默认行为 / 停止(stop)事件冒泡 / once 只触发一次</p><pre><code>&lt;button @click.prevent=&quot;test(&#39;x&#39;)&quot;&gt;&lt;/buuton&gt;</code></pre><p>3.按键修饰符</p><p>@keyup.enter 表示回车按键起来时执行</p><p>还可以自定义按键修饰符</p><pre><code>Vue.config.keyCodes.f1 = 112//@key.f1=&quot;&quot;使用</code></pre><p><strong>声明周期钩子(回调)函数</strong><br>钩子函数都是自己定义</p><p>beforeCreate()</p><p>在这两个回调之间，vue会实现<strong>数据代理</strong>，后面可以通过vm读取data中的数据。</p><p>created()</p><p>beforeMount() 在显示前执行一次</p><p>这期间，会把之前模块中解析的内容批量替换el里的内容</p><p>mounted() 在第一次显示之后执行1次,同一个组件对象只执行一次。</p><p>这里的更新指的是<strong>页面更新</strong>,通常通过数据改变触发页面更新，也就是一下两个回调<strong>都发生在数据改变后</strong>，只不过一个页面还没有更新，一个页面更新完毕</p><p>beforeUpdate() 读老页面<br>updated()  读新页面</p><p>beforeDestroy() 销毁前执行1次</p><p>常用的声明周期方法<br>created()/mounted() 常用于异步请求,发送ajax请求，启动定时器等异步任务<br>beforeDestory() 做收尾工作，清除定时器等</p><p><strong>过渡和动画</strong></p><p>transition标签，需要有过渡和动画的标签部分需要包裹在transition标签内。</p><p><img src="/img/vue/动画.png"></p><p>在x-enter-active里面写transition/animation样式，定义进入动画的过渡<br>在x-leave-active里面写transition/animation样式，定义离开动画的过渡</p><pre><code>&lt;transition name:&quot;自定义过渡的动画名称如:fade&quot;&gt;...&lt;transition&gt;</code></pre><p><strong>过滤器</strong></p><p>功能:对要显示的数据进行特定格式化后再显示，没有改变原有数据。<br>语法:</p><pre><code>Vue.filter(filterName,function(value被处理的数据,formatStr传过来的值{return 显示的数})</code></pre><p>在html使用</p><pre><code>{{xxx | filterName(formatStr)}}</code></pre><p><strong>常用内置指令</strong><br>指令的作用是操作标签</p><p>v-if:如果为true，当前标签才会输出到页面<br>v-show:通过控制display样式来控制显示/隐藏<br>v-for:遍历数组/对象<br>v-on:绑定事件监听，简写@<br>v-model:双向数据绑定<br>ref:为某个元素/组件注册一个唯一标识，vue对象通过$refs属性访问这个元素/组件对象<br>v-html:更新元素的innerHTML，会解析标签<br>v-text:更新元素的textContent</p><p>自定义标签</p><p>1.注册全局指定</p><pre><code>Vue.directive(&quot;指令名称如:xxx&quot;,function(el,binding){  //el:指令属性所在的标签元素对象  //binding:包含指令相关信息数据的对象，如指令名，指令值等})</code></pre><p>2.定义局部指令<br>指令在vue实例上的局部指令</p><pre><code>new Vue({  directives:{  //&quot;xxx&quot;:function() ES6中省略fuction和冒号  &quot;xxx&quot;(el,binding){}  }})</code></pre><p><strong>插件</strong><br>每个插件对象都必须有一个install方法，该方法通过Vue.use(插件名)调用。<br>所以声明使用Vue插件，Vue.use(插件名)内部调用插件的install方法来安装插件。</p><p><strong>单文件组件</strong></p><p><strong>组件中的data必须用函数返回对象的形式</strong>,因为每个组件标签都会产生一个实例，如果直接会对象形式，每个组件就共享了data中的数据，而使用函数返回对象的形式，每个组件通过调用data函数使用独立的数据。</p><p>保证对一个组件的多个实例对象的data对象不是共有的，而是各自的data对象。</p><p>每个组件只能有一个<strong>根标签</strong>,一个组件对象就是一个小的vm，组件内回调函数的this是指向组件对象，模板中获取数据读取组件对象的对应属性值。</p><p>单文件vue组件，后缀名为vue</p><pre><code>&lt;template&gt;&lt;/template&gt;&lt;script&gt;//1.引入组件 importexport default{  //声明接收属性，该属性在组件标签中传值  //接收的所有标签属性都会成功组件对象的属性  props:[]/{},  data(){    return{    }  },  methods:{},  watch:{},  //2.注册组件  components:{    //组件名  },  filters:{},  directive{},}&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><p>引入组件时的<strong>问题:什么时候加./什么时候不加？</strong></p><p>不加时直接用模块名引入的是第三方库，默认从node_modules里面找，如果是自己定义的组件不是第三方引用的则需要添加</p><p>组件化编码的基本流程<br>1.拆分界面，抽取组件<br>2.编写静态组件<br>3.编写动态组件，初始化数据、动态显示初始化界面、实现与用户交互功能</p><p>设置数据 -&gt; 类型，名称，位置如果是哪些组件用则交给共有的父组件。<br>数据的更新-&gt; data数据定义在哪个组件，更新数据的行为就定义在哪个组件，如果子组件要更新父组件的数据，调用父组件的更新函数来更新父组件的数据。一个组件接收属性数据不是用来直接修改，只是用来读取显示的。</p><p><strong>问题：组件对象和vm之间的关系</strong></p><p>所有组件对象的原型对象都是不同的vm,所有的vm都是Vue的实例、都有一个共同的原型对象。</p><p><a href="https://biubiuins.github.io/2020/08/06/vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/" target="_blank" rel="noopener">组件传值</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;创建vue实例&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;//————html
&amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;
&amp;lt;a href = &amp;quot;msg&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>奇奇怪怪的坑们</title>
    <link href="http://yoursite.com/2020/07/30/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E5%9D%91%E4%BB%AC/"/>
    <id>http://yoursite.com/2020/07/30/奇奇怪怪的坑们/</id>
    <published>2020-07-30T08:56:46.000Z</published>
    <updated>2020-08-01T15:10:49.519Z</updated>
    
    <content type="html"><![CDATA[<h2 id="7-30-hexo拒绝访问"><a href="#7-30-hexo拒绝访问" class="headerlink" title="7.30 hexo拒绝访问"></a>7.30 hexo拒绝访问</h2><p>今天发现博客无法访问，报错是ERR_CONNECTION_REFUSED。开始慢慢寻找原因。</p><p>先重新上传了本地库，发现可以上传成功并且<code>hexo s</code>启动后本地可以访问。<br>然后用手机流量可以访问博客。那么问题就到了PC端。<br>ping了网址发现是127.0.0.1,检查了浏览器没开代理。<br>通过朋友的帮助，在hosts文件中，添加<code>185.199.111.153 biubiuins.github.io</code>，让DNS在解析该域名时解析成前面的ip。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;7-30-hexo拒绝访问&quot;&gt;&lt;a href=&quot;#7-30-hexo拒绝访问&quot; class=&quot;headerlink&quot; title=&quot;7.30 hexo拒绝访问&quot;&gt;&lt;/a&gt;7.30 hexo拒绝访问&lt;/h2&gt;&lt;p&gt;今天发现博客无法访问，报错是ERR_CONNECTI
      
    
    </summary>
    
      <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="http://yoursite.com/2020/07/28/promise/"/>
    <id>http://yoursite.com/2020/07/28/promise/</id>
    <published>2020-07-28T09:36:10.000Z</published>
    <updated>2020-07-28T10:16:15.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><h4 id="1-函数对象与实例对象"><a href="#1-函数对象与实例对象" class="headerlink" title="1.函数对象与实例对象"></a>1.函数对象与实例对象</h4><p>函数对象：将函数作为对象使用<br>实例对象：new函数产生的对象</p><blockquote><p>括号左边是函数，点左边是对象</p></blockquote><pre><code class="bash">function Fn(){ //Fn函数}const fn = new Fn() //这里的Fn是构造函数，fn是实例对象（new返回的，简称对象）Fn.prototype  //Fn本身是个函数，但是使用了XX.XXX(使用了.)，把该函数作为对象来使用，所以这里的Fn是函数对象</code></pre><h4 id="2-两种类型的回调函数"><a href="#2-两种类型的回调函数" class="headerlink" title="2.两种类型的回调函数"></a>2.两种类型的回调函数</h4><pre><code class="bash">/*-----------同步回调函数--------------*/const arr = [1,3,5]arr.forEach(item =&gt;{  //遍历回调，同步回调函数，一上来就执行，不会放入队列 console.log(item)})//forEach是一个函数，回调函数也是一个函数。说明该回调函数是同步回调函数，等完全执行完毕之后才执行最后一个打印语句console.log(&quot;forEach()执行完毕之后&quot;)//输出//1，3，5 forEach()执行完毕之后/*-----------异步回调函数--------------*/setTimeout(()=&gt;{//异步回调函数，会放入队列中将来执行 console.log(&quot;timeout callback()&quot;)},0)console.log(&quot;setTimeout()之后&quot;)//输出//setTimeout()之后 timeout callback()</code></pre><p><strong>同步回调</strong></p><p>理解：立即执行，完全执行完了才结束，不会放入回调队列中<br>例子：数组遍历相关的回调函数 /promise的excutor函数</p><p><strong>异步回调</strong></p><p>理解：不会立即执行，会放入回调队列中来执行<br>例子：定时器回调 /ajax回调 /promise的成功与失败的回调</p><h4 id="3-error处理"><a href="#3-error处理" class="headerlink" title="3.error处理"></a>3.error处理</h4><p><strong>错误类型</strong></p><p>Error:所有错误的父类型<br>子类型(常见的)：<br>ReferenceError: 引入错误，引用的变量不存在<br>TypeError: 数据类型不正确的错误<br>RangeError：数据值不在其所允许的范围内。<br>SyntaxError：语法错误</p><p><strong>错误处理</strong></p><p>若没有捕获error，后续的代码是不会执行的<br>捕获错误:try{}catch(error){}<br>抛出错误:throw new Error(message)</p><pre><code class="bash">//抛出错误，自己定义错误function something(){if(Date.now()%2 ===1){  console.log(&quot;当前时间为奇数,可以执行任务&quot;)}else{//  throw new Error(里面为传出的message) 固定格式  throw new Error(&#39;当前时间为偶数，无法执行任务&#39;)}try{  something()} catch(error){//error下面两个属性message与stackconsole.log(error.message)//错误相关信息console.log(error.stack)//函数调用栈记录信息}}</code></pre><h3 id="Promise的理解和使用"><a href="#Promise的理解和使用" class="headerlink" title="Promise的理解和使用"></a>Promise的理解和使用</h3><p>Promise是JS中进行异步编程的新的解决方案（旧的是纯回调的方式）<br>从语法来说：Promise是一个构造函数<br>从功能上说：Promise对象用来封装一个异步操作并可以获取其结果</p><p><strong>Promise的状态</strong></p><ol><li>pending变为resolved（成功）</li><li>pending变为rejected (失败)</li></ol><p>说明：只有这两种变化，且<strong>一个Promise对象只能改变一次</strong>。无论是成功还是失败，都会有一个结果数据。成功的结果数据一般称为value，失败的结果数据一般称为reason</p><p><img src="/img/js/promise.png"></p><pre><code class="bash">//1.创建一个新的promise对象,里面传一个回调函数const p = new Promise((resolve,reject)=&gt;{ //执行器函数excutor 同步回调//2.执行异步操作,promise常用于封装异步函数。setTimeout(()=&gt;{const time = Date.now() //如果当前时间是偶数代表成功，否则代表失败if(time%2 ==0){//3.1 如果成功了，调用resolve(value)  resolve(&quot;成功的数据,time=&quot;+time)}else{//3.2 如果失败了，调用reject（reason） reject(&quot;成功的数据,time=&quot;+time)}},1000);})p.then( value =&gt;{ //接收得到成功的value数据  onResolved   console.log(&quot;成功的回调&quot;,value) }, reason =&gt; { //接收得到失败的reason数据 onRejected    console.log(&quot;失败的回调&quot;,reason) })//输出 成功的回调 成功的数据,time=XXXX</code></pre><p><strong>优势</strong></p><ol><li><p>指定回调函数的方式更加灵活。旧的，必须在启动异步任务前指定回调函数;promise：启动异步任务 =&gt; 返回peomise对象 =&gt; 给promise对象绑定回调函数(甚至可以在异步执行之后才指定他的回调函数)</p></li><li><p>支持链式调用，可以解决回调地狱问题（回调函数嵌套调用，不便于阅读/不便于异常）。</p></li></ol><p><strong>几个关键问题</strong></p><p>1.如何改变promise的状态？<br>（1）resolve(value):如果当前是pending就会变为resolved<br>（2）reject（reason）：如果当前是pending就会变为rejected<br>（3）抛出异常(throw)：如果当前是pending就会变成rejected <code>throw new Error(&quot;出错了&quot;)</code> reason值是你抛出的东西</p><p>2.一个promise指定多个成功/失败的回调函数，都会调用吗？</p><p>当promise改变为对应状态时<strong>都会</strong>调用</p><p>3.改变promise状态和指定回调函数谁先执行。</p><pre><code class="bash">/*---------先指定回调函数后改状态------------*/new Promise((resolve,reject)=&gt;{ setTimeout(()&gt;{  resolve(1)//后改变的状态，同时指定数据，异步执行回调函数 },1000);}).then(//先指定回调函数，保存当前指定的回调函数value=&gt;{},reason=&gt;{})/*---------先改状态后指定回调函数------------*/new Promise((resolve,reject)=&gt;{ //同步回调  resolve(1)//先改变的状态，同时指定数据);}).then(//异步回调value=&gt;{},reason=&gt;{}//后指定回调函数，异步执行回调函数)</code></pre><p>4.promise.then()返回的新的promise的结果状态由什么决定</p><p>then方法返回的结构也是promise，返回的promise的状态由then执行的回调函数结果决定。</p><p>回调函数中return的值是非promise类型的数据，则返回的promise的状态为成功，value为return值。<br>若return的值是新promise，由返回的promise状态决定。</p><p>5.promise异常传透和中止</p><p>当使用promise的then链式调用时，可以在最后指定失败的回调，因为没有处理异常相当于 <code>reason =&gt; {throw reason}</code>，会一层一层往下寻找异常处理直到找到。</p><p>当使用promise的then链式调用时，若想中断promise链，可以<code>return new Promise(()=&gt;{})</code>返回一个处于pending的promise。</p><blockquote><p>自定义promise链接：<a href="https://github.com/biubiuins/promise-/tree/master" target="_blank" rel="noopener">https://github.com/biubiuins/promise-/tree/master</a></p></blockquote><h3 id="promise方法"><a href="#promise方法" class="headerlink" title="promise方法"></a>promise方法</h3><p><strong>Promise.resolve()/reject()</strong></p><p>Promise.resolve()：该方法返回一个新的成功的promise，值为参数<br>Promise.reject():该方法返回一个新的失败的promise，值为参数。</p><p><strong>Promise.race()</strong></p><p>返回一个新的promise，第一个完成的promise的结果就是最终返回的promise结果。</p><p><strong>Promise.allSettled()</strong></p><p>该方法接收promise数组，返回promise对象，该对象的状态永远为成功，该对象的值为一个数组，数组的元素为参数中每一个promise的当前值与当前状态。</p><p><strong>Promise.all(iterable)</strong></p><p>包含n个promise的数组(可迭代对象)，返回一个新的promise，所有promise都成功返回的新的promise状态才成功。<br>成功则返回一个数组，里面包含参数中promise成功的返回值，顺序与参数顺序一致。<br>失败则返回失败的原因。</p><h2 id="async与await"><a href="#async与await" class="headerlink" title="async与await"></a>async与await</h2><p>本质:Generator语法糖，async取代Generator函数的星号*.await取代的是yield</p><p>ES7的async/await进一步的优化Promise的写法，async函数始终返回一个Promise，await可以实现一个”等待”的功能，async/await被称为异步编程的终极解决方案，即用同步的形式书写异步代码，并且能够更优雅的实现异步代码顺序执行。</p><h3 id="1-async-函数"><a href="#1-async-函数" class="headerlink" title="1.async 函数"></a>1.async 函数</h3><p>async是’异步’的简写，用于申明这个函数是异步的。<br>函数的返回值为<strong>Promise对象</strong>，promise对象的结果由async函数执行的<strong>返回值</strong>决定。</p><h3 id="2-await-表达式"><a href="#2-await-表达式" class="headerlink" title="2.await 表达式"></a>2.await 表达式</h3><p>await相当于then的语法糖。<br>当await后面的表达式为promise，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，得到的结果就是promise成功的value。如果右侧表达不是promise，得到的结果就是它本身。</p><p><strong>注意：</strong><br>1.await必须放在async函数里面<br>2.await只能得到成功的结果，失败的结果需用try-catch<br>3.try catch只能捕获同步代码，不能捕获异步代码，在async函数内，使用await可以捕获异步代码，这里实际上是异步代码变成了同步代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Promise&quot;&gt;&lt;a href=&quot;#Promise&quot; class=&quot;headerlink&quot; title=&quot;Promise&quot;&gt;&lt;/a&gt;Promise&lt;/h2&gt;&lt;h3 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>promise链式调用顺序</title>
    <link href="http://yoursite.com/2020/07/28/promise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/07/28/promise链式调用顺序/</id>
    <published>2020-07-28T07:43:54.000Z</published>
    <updated>2020-07-29T13:16:24.025Z</updated>
    
    <content type="html"><![CDATA[<p><strong>第一题</strong></p><pre><code class="bash">    setTimeout(()=&gt;{        console.log(1);    },0)    Promise.resolve().then(()=&gt;{        console.log(2);    })    Promise.resolve().then(()=&gt;{        console.log(3);    })    console.log(4);    /*    输出：4 2 3 1     */</code></pre><p><strong>第二题</strong></p><pre><code>    setTimeout(() =&gt; {        console.log(1);    }, 0)    //Promise为构造函数    new Promise(resolve =&gt; {        console.log(2); //同步执行        resolve()//成功    }).then(() =&gt; { //成功的回调        console.log(3);    }).then(() =&gt; {//此处的then等上一个执行完之后再放入微队列执行        console.log(4);    })    console.log(5);//同步执行    /*    输出:2 5 3 4 1     */</code></pre><p><strong>注意：链式的then要等前一个then执行完毕才知道状态，才可以进入微队列执行。</strong></p><p><strong>第三题</strong></p><pre><code class="bash">  //定义了一个返回promise的函数     const first = () =&gt; (new Promise((resolve, reject) =&gt; {          console.log(1);  //同步执行1          //返回promise的函数          let p = new Promise((resolve, reject) =&gt; {              console.log(2); //同步执行2              //放入宏队列1              setTimeout(() =&gt; {                  console.log(3);                  resolve(4) //最后执行宏队列时状态已经修改，不再是等待，所以该行代码不执行              }, 0)              resolve(5) //立刻执行，p的状态立刻成功          })          resolve(6) //first的状态变成成功          //成功的回调放入微队列1          p.then((arg) =&gt; {              console.log(arg);          })      }))      //成功的回调放入为微队列2      first().then((arg)=&gt;{          console.log(arg);      })      console.log(7);//同步执行3      /*输出      1 2 7 5 6 3      开始：输出 1 2 7      宏[3]      微[5 6]      输出微队列：5 6      输出宏队列：3       */</code></pre><p><strong>第四题</strong></p><pre><code>    //加入宏队列1    setTimeout(()=&gt;{        console.log(0);    },0)    new Promise((resolve,reject) =&gt;{        console.log(1); //同步执行1        resolve()        //成功的回调加入微队列1    }).then(()=&gt;{        console.log(2);        new Promise((resolve, reject) =&gt; {            console.log(3);            resolve()            //成功的回调加入微队列3        }).then(()=&gt;{            console.log(4);            //成功的回调加入微队列5        }).then(()=&gt;{            console.log(5);        })        //成功的回调加入微队列4    }).then(()=&gt;{        console.log(6);    })    new Promise((resolve, reject) =&gt; {        console.log(7); // 同步执行2        resolve()        //成功的回调加入微队列2    }).then(()=&gt;{        console.log(8);    })    /*    输出：1 7 2 3 8 4 6 5 0    状态1：同步执行输出1 7 宏[0]  微[2 8]    状态2,执行微任务1（整个then）：输出2 3 宏[0]  微[8 4 6]    状态3,执行微任务2：输出 8 宏[0]  微[4 6]    状态4,执行微任务3：输出4 宏[0]  微[6 5]    ....    */</code></pre><p>这道题我错在6和5的顺序上面，不太懂为什么6在5前面。阅读了<a href="https://www.jianshu.com/p/aa3d8b3adde3" target="_blank" rel="noopener">一篇文章</a>之后才明白，下面是对知识点进行摘录+总结。</p><p><strong>知识点1</strong></p><p>当执行 then 方法时，如果前面的 promise 已经是 resolved 状态，则直接将回调放入微队列中。</p><p><strong>then方法是同步执行的，但是then中的回调是异步执行的。</strong></p><p>在同步执行then方法时，会进行判断：</p><ul><li>如果前面的 promise 已经是 resolved 状态，则会立即将回调推入微队列</li><li>如果前面的 promise 是 pending 状态则会将回调存储在 promise 的内部(不会被执行，也不会被放入微队列中)，一直等到 promise 被 resolve 才将回调推入微队列</li></ul><p><strong>知识点2</strong></p><p>resolve的作用除了将当前的 promise 由 pending 变为 resolved，还会遍历之前通过 then 给这个 promise 注册的所有回调，将它们<strong>依次放入微队列中</strong>，很多人以为是由 then 方法来触发它保存回调，而事实上是由 promise 的 resolve 来触发的，then 方法只负责注册回调。</p><p>对于 then 方法返回的 promise 它是没有 resolve 函数的，取而代之只要 then 中回调的代码执行完毕并获得同步返回值，这个 then 返回的 promise 就算被 resolve</p><pre><code> new Promise((resolve,reject) =&gt;{   console.log(1);   resolve()//第一个then }.then(()=&gt;{   ... //第二个then }).then(()=&gt;{ ... })</code></pre><p>首先Promise是实例化，同步执行函数，打印1，执行resolve函数，将 promise 变为 resolved，但由于此时 then 方法还未执行。由知识点2：resolve会触发保存它的回调。then是同步的，所以会依次保存第一个then和第二个then</p><p>[主]外部第一个 then，外部第二个 then [微] 空</p><p>然后执行第一then,由于前面的promise已经被resolve了，所以将第一then的回调放入微队列。</p><p>[主]外部第二个 then  [微]外部第一个 then的回调</p><p>但是这个回调还没有执行，所以第一then返回的promise 仍为 pending 状态，所以同步执行第二个then。由于前面的 promise 是 pending 状态，所以外2then 的回调也不会被推入微任务队列也不会执行</p><p>[主]空  [微]外一 then的回调</p><p>现在主线程空了，执行微任务，也就外一 then的回调，首先打印出2，随后实例化内部promise，打印3，执行resolve函数<br>,遍历then保存。</p><pre><code> new Promise((resolve,reject) =&gt;{ .... //外1  }.then(()=&gt;{   console.log(2);   new Promise((resolve, reject) =&gt;{   console.log(3);    resolve()   }.then(()=&gt;{   //内部第一个then     console.log(4);   }).then(()=&gt;{   //内部第二个then    console.log(5);   })  }  //外2  .then(()=&gt;{  .....  })</code></pre><p>[主]内1 then 内2的then  [微]空</p><p>然后执行内1的then，由于前面的 promise 已被 resolve，所以将回调放入微任务队列中。</p><p>[主]内2的then  [微]内1then的回调</p><p>然后执行内2的then，因为内部第一个then的回调还未执行所以状态为pending，所以内2then 的回调和外2then 的回调一样，不注册不执行。</p><p>[主]空  [微]内1then的回调</p><p><strong>外1的回调全部执行完毕</strong>，这里尤其注意:内2then的回调没执行，但是内2then是执行了的，相当于回调执行完毕。<br>外1then 返回的 promise 的状态由 pending 变为 resolved，同时遍历之前通过 then 给这个 promise 注册的所有回调，将它们的回调放入微任务队列中。</p><p>[主]空  [微]内1then的回调 外2then 的回调</p><p>主线程执行完毕，取出内1then的回调执行</p><p>[主]内1then的回调  [微]外2then 的回调</p><p>打印4，内1then返回的promise状态由 pending 变为 resolved，同时遍历之前通过 then 给这个 promise 注册的所有回调，将它们的回调放入微任务队列中。</p><p>[主] 空 [微]外2then 的回调 内2的回调</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;第一题&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;    setTimeout(()=&amp;gt;{
        console.log(1);
    },0)
    Promise.resolve().then(()=&amp;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>js异步:宏队列与微队列</title>
    <link href="http://yoursite.com/2020/07/28/%E5%AE%8F%E9%98%9F%E5%88%97%E4%B8%8E%E5%BE%AE%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/07/28/宏队列与微队列/</id>
    <published>2020-07-28T05:50:43.000Z</published>
    <updated>2020-07-28T10:48:39.796Z</updated>
    
    <content type="html"><![CDATA[<p>异步执行的函数(回调函数)放入队列中执行。队列分为宏队列与微队列。</p><p>宏队列：用来保存执行的宏任务（回调），比如：dom事件回调，ajax回调，定时器回调<br>微队列：用来保存执行的微任务（回调），比如：promise回调，mutation回调</p><p>1.JS为单线程引擎，必须先执行所有的初始化同步任务代码。<br>2.每次取出第一个宏任务<strong>执行前</strong>，都要将所有的微任务执行完毕。</p><p>注:取到栈里执行，若有嵌套的情况如下列代码，执行第一个setTimeout回调时，把里面的微任务放入微队列，执行第二宏任务前，先将所有的微任务执行完毕。</p><pre><code> setTimeout(()=&gt;{ //会立即放入宏队列        console.log(&quot;timeout callback1()&quot;);        Promise.resolve(3).then(            value =&gt;{ //会立即放入微队列                console.log(&quot;Promise onResolved3()&quot;,value);            }        )    },0)    setTimeout(()=&gt;{ //会立即放入宏队列        console.log(&quot;timeout callback2()&quot;);    },0)    Promise.resolve(1).then(        value =&gt;{ //会立即放入微队列            console.log(&quot;Promise onResolved1()&quot;,value);        }    )    Promise.resolve(2).then(        value =&gt;{ //会立即放入微队列            console.log(&quot;Promise onResolved2()&quot;,value);        }    )    /*    输出:Promise onResplved(),1          Promise onResplved(),2          timeout callback1()          Promise onResolved3()          timeout callback2())     */</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;异步执行的函数(回调函数)放入队列中执行。队列分为宏队列与微队列。&lt;/p&gt;
&lt;p&gt;宏队列：用来保存执行的宏任务（回调），比如：dom事件回调，ajax回调，定时器回调&lt;br&gt;微队列：用来保存执行的微任务（回调），比如：promise回调，mutation回调&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>数组的方法</title>
    <link href="http://yoursite.com/2020/07/27/%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/07/27/数组的方法/</id>
    <published>2020-07-27T13:02:27.000Z</published>
    <updated>2020-08-13T10:37:27.092Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h2><h3 id="slice-与splice"><a href="#slice-与splice" class="headerlink" title="slice()与splice()"></a>slice()与splice()</h3><p>语法:array.slice(start,end)<br>第一个参数截取开始的位置索引，包含<br>第二个参数为结束的位置索引，不包含</p><ul><li>不修改原数组</li><li>返回截取的新数组</li></ul><p>语法:array.splice(start,length,increase1,increase2..)<br>删除数组中的指定元素，并为数组添加新元素<br>第一个参数是开始的索引<br>第二个参数是删除的数量<br>第三个参数及以后是新添加的元素，添加的位置在开始索引之前。</p><ul><li>修改原数组</li><li>返回值为删除的元素，有添加的元素返回值是整个数组</li></ul><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><p>语法:array.concat(array2,array3..)<br>concat()可以连接两个或多个数组</p><ul><li>不修改原数组</li><li>返回值为新数组</li></ul><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p>语法:arrayy.join(连接符)<br>join()将数组转换为一个字符串，默认逗号</p><ul><li>不修改原数组</li><li>返回值为转换的字符串</li></ul><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h3><p>语法:array.reverse()<br>反转数组</p><ul><li>修改元素组</li></ul><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><p>语法:array.sort()<br>对数组中的元素进行排序,默认按照Unicode编码进行排序，默认<strong>升序</strong></p><ul><li>修改原数组</li></ul><p>指定排序的规则,浏览器将会分别使用数组中的元素作为实参去调用回调函数，回调函数需要定义两个形参。<br>浏览器根据回调函数的返回值来决定元素的顺序，<br><strong>返回值大于0</strong>则元素a、b交换位置,其余不变<br>语法:array.sort(function(a,b){<br>    //a一定在b前面,比如升序<br>    return a&gt;b?1: 0<br>    //return a-b 更简单<br>})</p><h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><p><strong>Array.from(v)</strong></p><p>把v的伪数组(字符串也可)转换为真数组<br>类数组(伪数组)最基本的要求就是具有length属性的对象,该类数组对象的属性名必须为数值型或字符串型的数字。</p><pre><code>let arrayLike = {    0: &#39;tom&#39;,    1: &#39;65&#39;,    2: &#39;男&#39;,    3: [&#39;jane&#39;,&#39;john&#39;,&#39;Mary&#39;],    &#39;length&#39;: 4}let arr = Array.from(arrayLike)console.log(arr) // [&#39;tom&#39;,&#39;65&#39;,&#39;男&#39;,[&#39;jane&#39;,&#39;john&#39;,&#39;Mary&#39;]]</code></pre><p>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。如下：</p><pre><code>  let arr = [1,2,2,2,3,4,5]    let set = new Set(arr)    console.log(Array.from(set, item =&gt; item + 1)) // [2,3,4,5,6]</code></pre><p><strong>Array.of(v1,v2,v3)</strong></p><p>将v1，v2..等元素转换成数组</p><p><strong>find()</strong></p><p>找到第一个满足条件返回true的元素</p><pre><code>let arr = [2,4,6]console.log(arr.find((value, index) =&gt; value &gt; 4));//输出6</code></pre><p><strong>findIndex()</strong></p><p>找到第一个满足条件返回true的元素下标</p><pre><code>let arr = [2,4,6]console.log(arr.findIndex((value, index) =&gt; value &gt; 4));//输出2</code></pre><p><strong>Array.prototype.includes(value)</strong></p><p>字符串与数组都有includes方法，判断数组中是否包含指定的value，返回值为布尔值。<br>以前判断用indexOf返回的是数字。</p><p><strong>Array.prototype.indexOf(value)/lastIndexOf(value)</strong></p><p>返回value在数组中出现的第一个下标和最后一下下标，没有出现则返回-1</p><p>应用场景：<br>两个方法结合判断下标是否相等，可以用来判断数组中唯一出现的值</p><p><strong>Array.prototype.flat()/flatMap()</strong></p><p>Array.prototype.flat()将多维数组转化为低维数组,从外层括号开始删，默认一次删一个，比如从三维到一维，需要删2个则flat()传参2</p><pre><code>const arr = [1,2,3,4,[5,6,[7,8]]]console.log(arr.flat())//输出[1,2,3,4,5,6,[7,8]]</code></pre><p>Array.prototype.flatMap()类似map()。先执行map在执行flat，也就是先返回数组再降低维度。</p><h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><h3 id="Array-prototype-forEach"><a href="#Array-prototype-forEach" class="headerlink" title="Array.prototype.forEach()"></a>Array.prototype.forEach()</h3><p>语法: array.forEach(function(currentValue, index, array){})<br>调用数组的每个元素，并将元素传递给回调函数。<br>第一个参数，当前遍历的元素。<br>第二个参数，当前遍历的元素索引<br>第三个元素，当前遍历的数组</p><p><strong>特点</strong></p><ul><li>不返回新数组</li><li>不能中断</li><li>对空数组不执行回调</li></ul><h3 id="for-in-for-of"><a href="#for-in-for-of" class="headerlink" title="for-in/for-of"></a>for-in/for-of</h3><h3 id="Array-prototype-map"><a href="#Array-prototype-map" class="headerlink" title="Array.prototype.map()"></a>Array.prototype.map()</h3><p>语法: array.map(function(currentValue,index,arr), thisValue)</p><p>按照原始数组元素顺序依次处理元素，结果放在一个新数组里返回。</p><pre><code>/*------从接口得到数据------*/const users=res.items.map(item =&gt; ({    url: item.html_url,    img: item.avatar_url,    name: item.login,    }));</code></pre><p><strong>特点</strong></p><ul><li>返回新数组，不改变原始数组。</li></ul><h3 id="for-of-for-in"><a href="#for-of-for-in" class="headerlink" title="for-of / for-in"></a>for-of / for-in</h3><p><code>for-of</code>不仅仅可以遍历数组，<strong>具有iterator接口的，都可以使用<code>for-of</code>进行遍历</strong></p><pre><code>for (var value of arr) {      console.log(value); // 1,2,3}</code></pre><p>与<code>for-in</code>的区别：<br>1.for-in 获取的是<strong>键名</strong>，数组的键名是索引，for-of获取的是<strong>键值</strong><br>2.for-in 会遍历对象的整个原型链,性能非常差不推荐使用。</p><h3 id="Array-prototype-filter"><a href="#Array-prototype-filter" class="headerlink" title="Array.prototype.filter()"></a>Array.prototype.filter()</h3><p>语法：array.filter(function(currentValue,index,arr), thisValue)</p><p>创建一个新的数组，指定数组中符合条件的元素放入新数组。</p><p><strong>返回一个新数组，按照约定条件筛选数组元素时比较常用</strong></p><pre><code>/*-----去重问题----*/var arr = [1, 2, 2, 3, 4, 5, 5, 6, 7, 7,8,8,0,8,6,3,4,56,2];var arr2 = arr.filter((x, index,self)=&gt;self.indexOf(x)===index)console.log(arr2); //[1, 2, 3, 4, 5, 6, 7, 8, 0, 56]</code></pre><h3 id="every-some"><a href="#every-some" class="headerlink" title="every()/some()"></a>every()/some()</h3><p>语法: array.every(function(currentValue,index,arr), thisValue)</p><p>对整个数组进行检查，如有一个元素不满足，整个表达式返回false，且其余元素不检查。否则返回true。</p><p><strong>不会改变原数组</strong></p><p>语法:array.some(function(currentValue,index,arr),thisValue)</p><p>对整个数组进行检查，如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。反之返回false。</p><p><strong>不会改变原数组</strong></p><p>这两个方法在实际开发中，大有可用之处。比如在判定用户是否勾选了不可操作的数据，或者是否勾选了一条可以操作的数据可以使用这两个方法遍历循环数组。</p><h3 id="reduce-reduceRight"><a href="#reduce-reduceRight" class="headerlink" title="reduce()/reduceRight()"></a>reduce()/reduceRight()</h3><p>语法:arr.reduce(callback,[initialValue])</p><p>callback （执行数组中每个值的函数，包含四个参数）</p><ul><li>previousValue 必选。上一次调用回调返回的值，或者是提供的初始值（initialValue）</li><li>currentValue 必选。数组中当前被处理的元素</li><li>index 可选。当前元素在数组中的索引。</li><li>arr    可选。当前元素所属的数组对象。</li></ul><p>initialValue （作为第一次调用 callback 的第一个参数。）</p><p>将数组元素做“叠加”处理，<strong>返回一个值。</strong> reduce方向从左向右，reduceRight方向从右向左</p><pre><code>var arr = [1, 2, 3, 4];var sum = arr.reduce(function(prev, cur, index, arr) {    console.log(prev, cur, index);    return prev + cur;})console.log(arr, sum);/*-----打印结果---*/1 2 13 3 26 4 3[1, 2, 3, 4] 10</code></pre><p>index是从1开始的，第一次的prev的值是数组的第一个值。数组长度是4，<strong>但是reduce函数循环3次。</strong></p><pre><code>var  arr = [1, 2, 3, 4];var sum = arr.reduce(function(prev, cur, index, arr) {    console.log(prev, cur, index);    return prev + cur;}，0) //注意这里设置了初始值console.log(arr, sum);/*----打印结果----*/0 1 01 2 13 3 26 4 3[1, 2, 3, 4] 10</code></pre><p>这个例子index是从0开始的，第一次的prev的值是我们设置的初始值0，数组长度是4，reduce函数循环4次。</p><p><strong>如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始</strong></p><p>对空数组来说，不设置初始值会报错，设置了初始值不会报错，所以一般来说我们提供初始值通常更安全。</p><p>使用场景也很多，具体可以看 <a href="https://www.jianshu.com/p/e375ba1cfc47" target="_blank" rel="noopener">参考文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数组的方法&quot;&gt;&lt;a href=&quot;#数组的方法&quot; class=&quot;headerlink&quot; title=&quot;数组的方法&quot;&gt;&lt;/a&gt;数组的方法&lt;/h2&gt;&lt;h3 id=&quot;slice-与splice&quot;&gt;&lt;a href=&quot;#slice-与splice&quot; class=&quot;header
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>字符串的方法</title>
    <link href="http://yoursite.com/2020/07/27/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/07/27/字符串的方法/</id>
    <published>2020-07-27T12:55:53.000Z</published>
    <updated>2020-07-29T13:52:09.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串的属性"><a href="#字符串的属性" class="headerlink" title="字符串的属性"></a>字符串的属性</h2><p>在底层字符串是以<strong>字符数组</strong>的形式保存的[“h”,”e”]</p><h2 id="charAt"><a href="#charAt" class="headerlink" title="charAt()"></a>charAt()</h2><p>语法：string.charAt()<br>根据索引获取指定的字符，返回值为获取的字符</p><h2 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h2><p>语法:string.concat(str1，str2….)<br>连接一个或多个字符串，返回值为新的字符串</p><h2 id="indexof"><a href="#indexof" class="headerlink" title="indexof()"></a>indexof()</h2><p>语法:string.indexof(“x”,start)<br>在string中寻找x的位置，找到返回索引，没找到返回-1<br>第一个参数为查找的字符<br>第二个参数为开始查找的位置<br>indexof()是从前往后找<br>lastindexof()是从后往前找</p><h2 id="slice-substring"><a href="#slice-substring" class="headerlink" title="slice()/substring()"></a>slice()/substring()</h2><p>语法:string.slice(start,end)<br>第一个参数截取开始的位置索引，包含<br>第二个参数为结束的位置索引，不包含</p><p>如果为-1值的是从后往前的第一个</p><ul><li>不修改原字符串</li><li>返回截取的字符串</li></ul><p>语法:string.substring(start,end)</p><p>与slice类似<br>区别：</p><ul><li>substring不可以传递负值，传了默认为0</li><li>如果第二个参数小于第一个参数，会自动调整参数的位置</li></ul><h2 id="toUpperCase-toLowerCase"><a href="#toUpperCase-toLowerCase" class="headerlink" title="toUpperCase()/toLowerCase()"></a>toUpperCase()/toLowerCase()</h2><p>语法：string.toUpperCase()</p><p>字符串转换成大写</p><ul><li>不修改原字符串</li><li>返回转化的大写字符串</li></ul><h3 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h3><p>语法：string.split(“,”)/string.split(/[0-9]/)<br>join()的功能相反,可以将一个字符串拆分为一个数组<br>参数为拆分规则,如例子的根据字符串里的逗号拆分数组,参数可以是正则表达式</p><p>默认全拆<br>不修改原字符串，返回值为数组</p><pre><code>let str=&quot;1a2b3c4d5e6f&quot;let result = str.split(/[0-9]/)//输出[a,b,c,d,e,f]</code></pre><h3 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h3><p>语法:string.search(搜索的内容)<br>搜索字符串中是否含有指定内容,返回<strong>第一次</strong>(g失效)出现的索引或者-1<br>参数是指定内容可以是正则表达式</p><h3 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h3><p>语法:string.match(条件)<br>根据正则表达式，从一个字符串中将符合条件的内容提取出来,返回值是<strong>数组</strong></p><p>默认返回符合条件的第一个内容<br>要找所有内容，开启全局匹配模式<br>可以为一个正则表达式设置多个匹配模式，顺序无所谓</p><pre><code>let str=&quot;1a2b3c4d5e6f&quot;let result = str.match(/[0-9]/g)//输出[1,2,3,4,5,6]</code></pre><h3 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h3><p>语法:string.search(被替换的内容，新的内容)<br>可以将字符串中指定内容替换为新内容，被替换的内容可以是正则表达式。</p><p>默认只替换第一个<br>不影响原来的字符串，返回新的字符串</p><p><strong>可以使用它去空格</strong></p><pre><code>//会去掉全部的空格str = str.replace(/\s/g,&quot;&quot;)//去掉开头的空格str = str.replace(/^\s*/,&quot;&quot;)//去掉结尾的空格str = str.replace(/\s*$/,&quot;&quot;)//去掉开头和结尾的空格str = str.replace(/^\s*|\s*$/g,&quot;&quot;)</code></pre><p>这里去掉字符串的头尾空格可以使用字符串的<strong>trim()</strong>方法</p><h2 id="字符串的扩展属性"><a href="#字符串的扩展属性" class="headerlink" title="字符串的扩展属性"></a>字符串的扩展属性</h2><p><strong>string.includes(str)</strong></p><p>判断是否包含指定的字符串<br>返回值：包含true,不包含false</p><p><strong>string.startsWith(str)</strong></p><p>判断是否以指定字符串开头<br>返回值：是true,否false</p><p><strong>string.endsWith(str)</strong></p><p>判断是否以指定字符串结尾<br>返回值：是true,否false</p><p><strong>string.repeat(count)</strong></p><p>指定目标字符串重复的次数<br>返回值:重复后的字符串</p><p><strong>string.trim()/string.trimStart()/string.trimEnd()</strong></p><p>trim()清除字符串左侧与右侧的空格<br>trimStart()清除字符串左侧的空格<br>trimEnd()清除字符串右侧的空格</p><p><strong>String.prototype.matchAll() 实用</strong></p><p>常用来获取正则批量匹配的结果，返回可迭代对象，可以用for of进行遍历或者扩展运算符展开。<br><strong>爬虫常用</strong></p><pre><code>let str = `&lt;ul&gt;          &lt;li&gt;            &lt;a&gt;ranan&lt;/a&gt;            &lt;p&gt;喜欢粉色&lt;/p&gt;         &lt;/li&gt;         &lt;li&gt;            &lt;a&gt;linin&lt;/a&gt;            &lt;p&gt;喜欢白色&lt;/p&gt;         &lt;/li&gt;         &lt;/ul&gt;         `const reg = /&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\/a&gt;.*?&lt;p&gt;(.*?)&lt;\/p&gt;/sgconst result = str.matchAll(reg)for (let v of result) {  console.log(v);  }//输出[exec匹配返回的结果1],[exec匹配返回的结果2]</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;字符串的属性&quot;&gt;&lt;a href=&quot;#字符串的属性&quot; class=&quot;headerlink&quot; title=&quot;字符串的属性&quot;&gt;&lt;/a&gt;字符串的属性&lt;/h2&gt;&lt;p&gt;在底层字符串是以&lt;strong&gt;字符数组&lt;/strong&gt;的形式保存的[“h”,”e”]&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>深度克隆</title>
    <link href="http://yoursite.com/2020/07/27/%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2020/07/27/拷贝/</id>
    <published>2020-07-27T11:46:18.000Z</published>
    <updated>2020-07-27T08:36:45.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深拷贝浅拷贝"><a href="#深拷贝浅拷贝" class="headerlink" title="深拷贝浅拷贝"></a>深拷贝浅拷贝</h2><p>深浅拷贝只是针对引用数据类型。</p><p>浅拷贝：修改拷贝以后的数据会影响原数据，拷贝的引用。使得原数据不安全。<br>深拷贝：修改拷贝以后的数据不会影响原数据，拷贝的时候生成新数据。</p><p><strong>js的数据类型</strong></p><p>基本数据类型： Undefined、Null、Boolean、Number、String和Symbol(ES6)<br>引用数据类型： Object(Array, Date, RegExp, Function)</p><h2 id="拷贝数据的方法"><a href="#拷贝数据的方法" class="headerlink" title="拷贝数据的方法"></a>拷贝数据的方法</h2><p>1.引用类型直接赋值是浅拷贝<br>2.Object.assign()</p><pre><code>    let obj = {        a: {            a1: &#39;a1&#39;        },        b: &#39;b&#39;    }    let ass = Object.assign({}, obj);    ass.a.a1 = &#39;aaa&#39;;    ass.b=&quot;c&quot;    console.log(obj);    /*    输出：a:{a1:&quot;aaa&quot;},          b:&quot;b&quot;    */</code></pre><p>说明: Obejct.assign()只能对一层进行深拷贝,如果拷贝的层数超过了一层的话，那么就会进行浅拷贝。</p><p>这种克隆方式，只能克隆原始对象自身的值，不能克隆它的继承值。</p><pre><code>function clone(origin) {  return Object.assign({}, origin);}</code></pre><p>如果要保持继承链。</p><pre><code>function clone(origin) {  //Object.getPrototypeOf方法返回指定对象的原型（内部[[Prototype]]属性的值）  let originProto = Object.getPrototypeOf(origin);  //Object.create方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。  return Object.assign(Object.create(originProto), origin);}</code></pre><p>3.三点运算符<br>对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p><pre><code>let obj = {    a: {        a1: &#39;a1&#39;    },    b: &#39;b&#39;}let ass = {...obj};ass.a.a1 = &#39;aaa&#39;;ass.b = &#39;bbb&#39;console.log(obj); /*    输出：a:{a1:&quot;aaa&quot;},          b:&quot;b&quot;    */</code></pre><p>说明:扩展运算符只能对一层进行深拷贝,如果拷贝的层数超过了一层的话，那么就会进行浅拷贝。</p><p>Object.assign(）和展开原算符对于深浅拷贝的结果是一样。</p><p>4.Array.prototype.concat()</p><p>concat() 方法用于连接两个或多个数组。<br>该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。</p><pre><code>    let arr= [1,3,{name:&#39;ran&#39;}]      let arr2 = arr.concat()   // arr2[1]=55  //输出[1，3，{name:&#39;ran&#39;}]    arr2[3].name = &#39;ke&#39;    console.log(arr);    //输出 [1,3,{name:&#39;ke&#39;}]</code></pre><p>遍历arr数组时得到arr数组的元素，把该元素赋值给arr2对应的位置，当遍历的元素是对象时，因为对象的赋值浅拷贝，所有会改变原来的值。</p><p>5.Array.prototype.slice(startindex,endindex)</p><pre><code>  let arr= [1,3,{name:&#39;ran&#39;}]  let arr2 = arr.slice()  arr2[1]=55  arr2[2].name = &#39;ke&#39;  console.log(arr); // 输出[1,3,{name:&#39;ke&#39;}]</code></pre><p>因此，slice和concat这两个方法，仅适用于对不包含引用对象的一维数组的深拷贝</p><p>6.JSON.parse(JSON.stringify()) <strong>深拷贝</strong></p><p>JSON.stringify()：将JavaScript对象转换为JSON字符串<br>JSON.parse()：可以将JSON字符串转为一个对象。</p><pre><code>let arr= [1,3,{name:&#39;ran&#39;}]  let arr2 = JSON.parse(JSON.stringify(arr))  //在JSON.stringify()完成后，对象就转为了字符串，也就可以说实实在在的复制了一个字符串，字符串是基本数据类型。  arr2[1]=55  arr2[2].name = &#39;ke&#39;  console.log(arr);//输出[1,3,{name:&#39;ran&#39;}]</code></pre><p>缺点：拷贝会忽略undefined,symbol,function、也有可能导致原型链缺失。</p><p><strong>补充1</strong></p><p><strong>判断数组是否包含某对象，或者判断对象是否相等。</strong></p><p>转化成字符串比较。</p><pre><code>//判断数组是否包含某对象let data = [    {name:&#39;echo&#39;},    {name:&#39;听风是风&#39;},    {name:&#39;天子笑&#39;},    ],    val = {name:&#39;天子笑&#39;};JSON.stringify(data).indexOf(JSON.stringify(val)) !== -1;//true//判断两数组/对象是否相等let a = [1,2,3],    b = [1,2,3];JSON.stringify(a) === JSON.stringify(b);//true</code></pre><p><strong>补充2</strong></p><p>localStorage/sessionStorage默认只能存储字符串，而实际开发中，我们往往需要存储的数据多为对象类型，那么这里我们就可以在存储时利用json.stringify()将对象转为字符串，而在取缓存时，只需配合json.parse()转回对象即可</p><p><strong>补充3</strong><br>JSON.stringify()与toString()的区别，这两者虽然都可以将目标值转为字符串，但本质上还是有区别的。</p><pre><code>let arr = [1,2,3];JSON.stringify(arr);//&#39;[1,2,3]&#39;arr.toString();//1,2,3</code></pre><p>JSON.stringify常用于对象，toString()常用于数组</p><p><a href="https://www.cnblogs.com/echolun/p/9631836.html" target="_blank" rel="noopener">参考文章</a></p><h2 id="如何实现深拷贝？"><a href="#如何实现深拷贝？" class="headerlink" title="如何实现深拷贝？"></a>如何实现深拷贝？</h2><p>拷贝的数据里面不能有引用类型。如果有，只要拿到的是基本数据类型，然后再去赋值，就可以实现深拷贝</p><h3 id="如何判断数据类型"><a href="#如何判断数据类型" class="headerlink" title="如何判断数据类型"></a>如何判断数据类型</h3><p><code>typeof</code>返回的数据类型:<strong>String,Number,Boolean,Undefined,Object(Array,null也是),Function</strong>，不能准确的确定数据的类型。</p><p><strong>Object.prototype.toString.call()</strong></p><p><code>Object.prototype.toString.call()</code>可以区分各种类型，但它无法区分自定义对象类型，自定义类型可以采用instanceof区分。</p><pre><code>console.log(Object.prototype.toString.call(&quot;jerry&quot;));//[object String]console.log(Object.prototype.toString.call(12));//[object Number]console.log(Object.prototype.toString.call(true));//[object Boolean]console.log(Object.prototype.toString.call(undefined));//[object Undefined]console.log(Object.prototype.toString.call(null));//[object Null]console.log(Object.prototype.toString.call({name: &quot;jerry&quot;}));//[object Object]console.log(Object.prototype.toString.call(function(){}));//[object Function]console.log(Object.prototype.toString.call([]));//[object Array]console.log(Object.prototype.toString.call(new Date));//[object Date]console.log(Object.prototype.toString.call(/\d/));//[object RegExp]function Person(){};console.log(Object.prototype.toString.call(new Person));//[object Object]</code></pre><p>那么为什么<code>Object.prototype.toString.call()</code>可以区分？</p><p>toString方法返回反映这个对象的字符串（除了null和undefined之外）</p><pre><code>console.log({name:&quot;张三&quot;}.toString());//[object Object]console.log([1,2].toString());//1,2console.log(typeof [1,2].toString())//String</code></pre><p>obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？</p><p>因为toString为Object的原型方法，而Array,function等类型作为Object的实例重写了toString方法，调用toString方法时，优先调用的是重写之后的toString方法，所以要使用Object原型上的toString才可以反映对象的具体类型。</p><p><strong>获取标识类</strong></p><p>Object.prototype.toString.call()返回的是字符串类型的[object xxx],但是我们只需要后面的标识数据类型的xxx，可以使用Array的slice方法。</p><pre><code>let data = [1,3]//slice包含开始的位置，不包含结束的位置，结束位置为-1console.log(Object.prototype.toString.call(data).slice(8,-1));//Array</code></pre><h3 id="最终实现"><a href="#最终实现" class="headerlink" title="最终实现"></a>最终实现</h3><pre><code>//检测数据类型的功能函数function checkedType(target) { return Object.prototype.toString.call(target).slice(8,-1)}//实现深度克隆 数组/对象function  clone(target) {  let result,targetType=checkedType(target)    switch (targetType) {    case &#39;Object&#39;:        result = {};        break;    case &#39;Array&#39;:        result = []        break;    default:        return target}  //遍历，基本数据类型的赋值    for (let i in target){      //获取数据结构的每一项值      let value = target[i]      //判断目标结构里的每一值是否存在对象/数组       if (checkedType(value) === &#39;Object&#39; || checkedType(value) === &#39;Array&#39;){        //继续遍历获取到的value           result[i] = clone(value)       }else { //获取到的value值是基本的数据类型或者函数           result[i] = value       }    }    return result}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;深拷贝浅拷贝&quot;&gt;&lt;a href=&quot;#深拷贝浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;深拷贝浅拷贝&quot;&gt;&lt;/a&gt;深拷贝浅拷贝&lt;/h2&gt;&lt;p&gt;深浅拷贝只是针对引用数据类型。&lt;/p&gt;
&lt;p&gt;浅拷贝：修改拷贝以后的数据会影响原数据，拷贝的引用。使得原数据
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>对象的方法</title>
    <link href="http://yoursite.com/2020/07/27/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/07/27/对象的方法/</id>
    <published>2020-07-27T10:31:03.000Z</published>
    <updated>2020-08-13T09:01:42.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象的扩展属性"><a href="#对象的扩展属性" class="headerlink" title="对象的扩展属性"></a>对象的扩展属性</h2><p><strong>Obejct.setPrototypeOf/getPrototypeOf</strong></p><p>Obejct.setPrototypeOf(对象，对象的原型指向的元素)<br>设置原型<strong>proto</strong></p><p>Object.getPrototypeOf(对象)<br>获取指定对象的<strong>proto</strong>指向的值,没有返回null</p><p> <strong>Object.is(v1,v2)</strong></p><p>判断对象v1与v2是否完全相等。</p><pre><code>console.log(0 === -0)  //trueconsole.log(NaN == NaN)//false NaN与任何数都不相等console.log(Object.is(0,-0)) //falseconsole.log(Object.is(NaN,NaN))//true</code></pre><p>由上面代码可知该方式是以字符串是否相等来判断的</p><p><strong>Object.assign(target,source1,source2..)</strong></p><p>这个Object静态方法允许我们进行多个对象的合并，遍历需要合并给target的对象（仅可枚举属性），用等号进行赋值(这里可能有深浅拷贝的问题)</p><p><strong>注意</strong>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p><pre><code>const target = { a: 1, b: 1 };const source1 = { b: 2, c: 2 };const source2 = { c: 3 };Object.assign(target, source1, source2);target // {a:1, b:2, c:3}</code></pre><p><strong>常见用途</strong></p><p>1.<a href="https://biubiuins.github.io/2020/02/19/%E6%8B%B7%E8%B4%9D/" target="_blank" rel="noopener">关于拷贝的用法</a><br>2.为属性指定默认值</p><pre><code>```const DEFAULTS = {  logLevel: 0,  outputFormat: &#39;html&#39;};//options对象是用户提供的参数。function processContent(options) {  options = Object.assign({}, DEFAULTS, options);  console.log(options);  // ...}```</code></pre><p><strong>Object.keys(obj)</strong><br>获取对象所有的键名，返回数组</p><p><strong>Object.values(obj)</strong><br>获取对象所有的值，返回数组</p><p><strong>Object.entries(obj)</strong><br>返回数组[[键名，键值],[键名，键值]]，此方法可以用于创建Map对象。</p><pre><code>const m = new Map(Object.entries(obj))</code></pre><p><strong>Object.fromEntries()</strong><br>用于创建一个对象，参数为二维数组或者Map</p><pre><code>Object.fromEntries([    [&quot;name&quot;,&quot;ranan&quot;],     [&quot;like&quot;,&quot;pink&quot;,&quot;white&quot;]])//{name:&quot;ranan&quot;,like:&quot;pink,white&quot;}</code></pre><p>Object.entries(obj)/Object.fromEntries(二维数组)互为逆运算。</p><p><strong>Object.create(prototype,[descriptors])</strong></p><p>作用：以指定对象为原型创建新的对象。为新的对象指定新的属性，并对属性进行描述</p><p>第一个参数指定原型，第二个参数为实例添加属性。</p><pre><code>let obj = {name:&quot;ranan&quot;,age:2}//第一个参数指定原型，第二参数为实例添加属性let obj1 = Object.create(obj,{sex:{    value:&quot;女&quot;,//value指定值    //属性的描述    writable:true,//标识当前属性是否可以被删除，默认为false    configurable:true,//表示当前属性是否可以被删除，默认为false    enumerable:true,//标识当前属性是否能用for-in枚举，默认false    }})//obj1的原型__proto__指向obj  console.log(obj1);</code></pre><p>克隆保持原型链</p><pre><code>function clone(origin) {  //Object.getPrototypeOf方法返回指定对象的原型（内部[[Prototype]]属性的值）  let originProto = Object.getPrototypeOf(origin);  //Object.create方法创建一个新对象，originProto为原型创建新对象  return Object.assign(Object.create(originProto, origin));</code></pre><p>getOwnPropertyDescriptor/getOwnPropertyDescriptors就是获取内部属性的描述,可以用于深层次的克隆。</p><pre><code>const obj = Object.create(null,{    //内部属性的描述    name:{        value:&#39;尚硅谷&#39;,        //属性特性        writable:true, //修改        configurable:true //删除        enumerable:true //枚举    }})</code></pre><p>如果不指定configurable, writable, enumerable ，则这些属性默认值为false，如果不指定value, get, set，则这些属性默认值为undefined。</p><p><strong>Object.defineProperties(object,descriptors)</strong></p><p>作用:为指定的object对象扩展多个属性</p><p>一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</p><p>Object的defineProperty/defineProperties主要功能就是用来定义或修改这些内部属性。</p><p>语法: Object.defineProperty(obj, prop, descriptor)</p><p>obj: 需要被操作的目标对象<br>prop: 目标对象需要定义或修改的属性的名称<br>descriptor: 将被定义或修改的属性的描述符</p><pre><code>var obj = new Object();Object.defineProperty(obj, &#39;name&#39;, {    configurable: false,    writable: true,    enumerable: true,    value: &#39;张三&#39;})console.log(obj.name)  //张三</code></pre><p>语法: Object.defineProperties(obj, props)</p><p>obj: 将要被添加属性或修改属性的对象<br>props: 该对象的一个或多个键值对定义了将要为对象添加或修改的属性的具体配置</p><p>方法直接在一个对象上定义一个或多个新的属性或修改现有属性，并返回该对象。</p><pre><code>var obj = new Object();Object.defineProperties(obj, {    name: {        value: &#39;张三&#39;,        configurable: false,        writable: true,        enumerable: true    },    age: {        value: 18,        configurable: true    }})console.log(obj.name, obj.age) // 张三, 18</code></pre><p>该方法的存储器属性(setter,getter)可以实现简单的数据双向绑定</p><pre><code>&lt;body&gt;   &lt;input type=&quot;text&quot; id=&quot;input1&quot;&gt;&lt;div&gt;    上面输入的数据是    &lt;span id=&quot;span&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;    let oInput1 = document.getElementById(&#39;input1&#39;);    let oSpan = document.getElementById(&#39;span&#39;);    let obj = {};    Object.defineProperties(obj, {    //惰性求值，get之后才有值        val1: {            configurable: true,//可修改            get: function() {                oInput1.value = 0;                oSpan.innerHTML = 0;                return 0            },            set: function(newValue) {                oSpan.innerHTML = newValue            }        },    })    //设置默认值为0 调用get方法    oInput1.value = obj.val1;    oInput1.addEventListener(&#39;keyup&#39;, function() {        //调用set方法        obj.val1 = oInput1.value;    }, false)&lt;/script&gt;</code></pre><p><strong>get/set propertyName(){}</strong></p><p>对象本身的两个方法，用法和上面的get/set一样</p><pre><code>let obj = {firstName:&quot;xx&quot;,lastName:&quot;xx&quot;, get fullName(){return this.firstName+ this.lastName}}</code></pre><p><strong>判断对象是否是数组/对象的元素/属性</strong><br>格式： 变量 in 对象/数组<br>当是数组时，变量指的是索引(不常用)<br>当是对象时，变量指的是对象的属性名</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;对象的扩展属性&quot;&gt;&lt;a href=&quot;#对象的扩展属性&quot; class=&quot;headerlink&quot; title=&quot;对象的扩展属性&quot;&gt;&lt;/a&gt;对象的扩展属性&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Obejct.setPrototypeOf/getPrototypeOf&lt;/stro
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>class类</title>
    <link href="http://yoursite.com/2020/07/26/class%E7%B1%BB/"/>
    <id>http://yoursite.com/2020/07/26/class类/</id>
    <published>2020-07-26T07:59:42.000Z</published>
    <updated>2020-07-29T11:14:56.952Z</updated>
    
    <content type="html"><![CDATA[<p>ES6的class可以看作只是一个语法糖，只是<br>让对象原型的写法更加清晰，更像面向对象编程的语言。</p><pre><code>//定义一个人物的类class Person{//类的构造方法,es5写在构造函数上的 constructor(){} //这里不需要逗号 //其余(原型)方法的写法必须使用该语法(静态的可以不用)。方法名(){} //es5写在原型上的 call(){ }}</code></pre><p>构造方法名字不能修改且当new实例对象时，会自动执行。<br><strong>注意</strong> 类里面方法的写法。方法名(){}</p><pre><code>console.log(typeof Person);//functionconsole.log(Person===Person.prototype.constructor);//true</code></pre><p>从上面的代码可以看出类实质上就是一个函数，可以任务ES6的类就是构造函数的另外一种写法。<br>实际上类的所有方法都定义在类的prototype属性上。<br>constructor内的属性可以称为实例属性（和前面说的实例成员一样）,constructor外声明的属性都是定义在原型上的，可以称为原型属性（即定义在class上)</p><p><strong>注意</strong>  <code>class</code>不存在变量提升，所以需要先定义再使用</p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>实例对象和函数对象的属性是独立的，实例对象的属性和该构造函数的原型上的属性是相通的。</p><p>实例对象和函数对象的独立属性称为<strong>静态成员/方法</strong>，只能函数对象使用。在ES6中，在方法/属性前加上<strong>static关键字</strong>，该类属性属于类不属于识类对象。</p><pre><code>class Foo{  static classMethod() {    return &#39;hello&#39;;  }}//Foo.classMethod()使用</code></pre><h3 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h3><p>私有属性前面加<code>#</code>,私有属性类外部直接获取不到结果会报错，只能通过类里面使用。</p><pre><code>class Person{  //公有属性  name;  //私有属性  #age;  constructor(name,age,weight){    this.name = name;    this.#age = age ;    this.#weight = weight;  }}</code></pre><h3 id="extends继承"><a href="#extends继承" class="headerlink" title="extends继承"></a>extends继承</h3><p>ES5的继承</p><pre><code>function Father(name,age){    this.name = name;    this.age = age;}Father.prototype.money= ()=&gt;{    console.log(&#39;父亲要上班&#39;);}function  Son(name,age) {    Father.call(this,name,age)}Son.prototype = new Father();Son.prototype.constructor = Son</code></pre><p>ES6的extends继承</p><pre><code>class Son extends Father{//子类的构造方法constructor(name,age,height){// 调用父类的构造方法，这里也要注意参数//父类的方法也会继承  super(name,age)  //子类自己的方法  this.height = height;}}</code></pre><p>子类继承父类相当于子类的<strong>proto</strong>指向父类Father。</p><h2 id="get和set"><a href="#get和set" class="headerlink" title="get和set"></a>get和set</h2><pre><code>class Phone{    get price(){        console.log(&quot;该属性被读取了&quot;)        return &quot;属性调用的返回值&quot;    }    set price(newVal){         console.log(&quot;该属性被修改了&quot;)    }}let s = new Phone()s.prices.price = &quot;free&quot;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ES6的class可以看作只是一个语法糖，只是&lt;br&gt;让对象原型的写法更加清晰，更像面向对象编程的语言。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//定义一个人物的类
class Person{
//类的构造方法,es5写在构造函数上的
 constructor(){}
 //这里不
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>迭代器</title>
    <link href="http://yoursite.com/2020/07/26/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>http://yoursite.com/2020/07/26/迭代器/</id>
    <published>2020-07-26T02:15:09.000Z</published>
    <updated>2020-07-26T03:23:10.894Z</updated>
    
    <content type="html"><![CDATA[<p>iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署了iterator接口(对象里面的一个属性)，就可以用来完成遍历操作。</p><p>iterator接口是解构赋值，三点运算符，生成器，<code>for-of</code>循环的基础，主要供<code>for-of</code>消费。</p><p>默认具有iterator接口的数据结构有以下几个，注意普通对象默认是没有iterator接口的（可以自己创建iterator接口让普通对象也可以迭代）</p><ul><li>Array</li><li>Map</li><li>Set</li><li>String</li><li>TypedArray（类数组）</li><li>函数的 arguments 对象</li><li>NodeList 对象</li></ul><p>工作原理:<br>1.symbol.iterator对应的函数创建一个指针对象，指向数据结构的起始位置。<br>2.第一次调用next方法，指针自动指向数据结构的第一个成员<br>3.接下来不断调用next方法，直到指向最后一个成员<br>4.每次调用next方法返回的是一个包含value和done的对象</p><p>注意：第一个next方法是symbol.iterator对应函数执行的返回值，每次调用next方法返回的是一个包含value和done的对象{value:当前成员的值，done：布尔值}其中done对用的布尔值表示当前的数据的结构是否遍历结束。当遍历结束的时候返回的value值是undefined，done值为true</p><pre><code>let zimu = [a,b,c,d]//返回一个iterator对象,该对象对象里面有next方法let iterator = zimu[Symbol.iterator](); //调用对象的next方法,返回值{value:a,done:false}console.log(iterator.next()); </code></pre><p>1.可迭代的数据结构会有一个[Symbol.iterator]方法,<br>2.[Symbol.iterator]执行后返回一个iterator对象</p><p>自定义部署iterator接口</p><pre><code>let obj = {    data: [&quot;a&quot;, &quot;b&quot;],    [Symbol.iterator]() {        const self = this //用于返回值对象        let index = 0 //索引变量        return {//遍历器对象，返回iterator对象            next() {                if (index &lt; self.data.length) {                    return {                        value: self.data[index++],                        done: false                    }                } else {                    return {                        value: undefined,                        done: true                    }                }            }        }    }}</code></pre><h3 id="for-of"><a href="#for-of" class="headerlink" title="for..of"></a>for..of</h3><p>以前我们遍历数组中的元素的时，最开始使用的是for</p><pre><code>let arr = [1,2,3]for(let i = 0;i&lt;arr.length;i++){console.log(arr[i])//输出1，2，3}</code></pre><p>自ES5之后，可以使用<code>forEach</code></p><pre><code>arr.forEach(function (value) {    console.log(value);    //输出1，2，3});</code></pre><p>但是<code>foeEach</code>有两个缺点：<br>1.不能使用<code>break</code>语句中断循环<br>2.不能使用<code>return</code>语句返回到外层函数</p><p>ES6增加了<code>for-of</code>循坏，是现在简洁、最直接的<strong>遍历数组</strong>元素的语法。<code>for-of</code>不仅仅可以遍历数组，<strong>具有iterator接口的，都可以使用<code>for-of</code>进行遍历</strong></p><pre><code>for (var value of arr) {      console.log(value); // 1,2,3}</code></pre><p>与<code>for-in</code>的区别：<br>1.for-in 获取的是对象的键名，for-of获取的是键值<br>2.for-in 会遍历对象的<strong>整个原型链</strong>,性能非常差不推荐使用。</p><p><strong>使用场景</strong></p><p>1.对数组和Set结构进行结构赋值时<br>2.扩展运算符<br>3.yieId后面跟的是一个可遍历的结构<br>4.由于数组的遍历会调用遍历器接口，所以任何接收数组作为参数的场合其实都调用了遍历器接口。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署了iterator接口(对象里面的一个属性)，就可以用来完成遍历操作。&lt;/p&gt;
&lt;p&gt;iterator接口是解构赋值，三点运算符，生成器，&lt;code&gt;for-of&lt;/code&gt;循环的
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>箭头函数</title>
    <link href="http://yoursite.com/2020/07/24/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2020/07/24/箭头函数/</id>
    <published>2020-07-24T13:12:22.000Z</published>
    <updated>2020-07-24T13:54:36.844Z</updated>
    
    <content type="html"><![CDATA[<p>用处：常用在回调函数</p><p>let a = ()=&gt;{ … }</p><p>形参</p><ul><li>只有一个形参的时候，()可以省略</li><li>其余时候，()不能省略</li></ul><p>函数体</p><ul><li>函数体内只有一条语句或者表达式，{}可省略，省略后自动return</li><li>其余情况不可以省略，并且需要返回值时，需要加上return</li></ul><p>注意：由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</p><pre><code>//报错let getTempItem = id =&gt; { id, name: &quot;Temp&quot; };// 不报错let getTempItem = id =&gt; ({ id, name: &quot;Temp&quot; });</code></pre><p>特点：<br>1.箭头函数没有arguments，但是如果在箭头函数需要参数时，可以使用rest运算符来取代arguments<br>2.箭头函数没有prototype属性，不能用作构造函数（不能用new关键字调用）<br>3.箭头函数<strong>本身是没有this</strong>，它的this不是调用的时候决定的，而是<strong>声明时所在作用域下的this值</strong>。</p><pre><code>let obj = {   getName(){   btn2.onclick = ()=&gt;{   console.log(this)   }   }   }   obj.getName()   //输出obj    let obj = {    getName:()=&gt;{    btn2.onclick = ()=&gt;{    console.log(this)    }    }    }    obj.getName()   //输出window</code></pre><p>因此，箭头函数替代了以前需要显式的声明一个变量保存this的操作，使得代码更加的简洁。<br>还有一个好处在数组的迭代中使用箭头函数更加简洁，并且省略了return关键字。</p><pre><code>let arr = [1,2,3]arr.filter (item=&gt; item === 2)//[2]arr.map(item =&gt; item*2 ) //[2,4,6]arr.reduce((acc,cur) = acc+cur) //6</code></pre><p><strong>总结</strong></p><p>1.箭头函数适合与this无关的问题，定时器、数组的方法回调<br>2.箭头函数不适合与this有关的回调，事件回调，对象的方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用处：常用在回调函数&lt;/p&gt;
&lt;p&gt;let a = ()=&amp;gt;{ … }&lt;/p&gt;
&lt;p&gt;形参&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只有一个形参的时候，()可以省略&lt;/li&gt;
&lt;li&gt;其余时候，()不能省略&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;函数体&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数体内只有
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>es6(含之后的版本)</title>
    <link href="http://yoursite.com/2020/07/24/es6/"/>
    <id>http://yoursite.com/2020/07/24/es6/</id>
    <published>2020-07-24T04:51:14.000Z</published>
    <updated>2020-07-28T03:26:42.523Z</updated>
    
    <content type="html"><![CDATA[<h2 id="let-const"><a href="#let-const" class="headerlink" title="let/const"></a>let/const</h2><p>特点:</p><ul><li>不能重复定义</li><li>在块级作用域内有效,不影响作用域链</li><li>不存在变量提升</li><li>const不可以被修改，声明时必须赋值</li></ul><p>补充:<br>1.新增块级作用域：if、else\while、for后面的{}或者直接的{}<br>2.数组和对象常量的元素是可以修改的，因为常量地址是没有变化的。</p><p>变量的声明提前:使用var关键字声明的变量。会在所有的代码执行前被声明（但是不会赋值）<br>函数的声明提前：使用function 函数名{}声明的函数会在所有的代码执行前就被创建</p><p>使用let/const定义的变量在没声明前是无法使用的。</p><p>在循环使用中常用。如下述代码，结果会全部输出2，原因是：点击事件是回调函数进入队列，等同步执行的代码执行完毕之后，再执行,i是全局变量，此时的i已经是最后一次循环之后的i了。es6中的let也可以解决这个问题，因为let有自己的块级作用域，使用i值的时候，仅当次循环有用。</p><pre><code>//html  &lt;button&gt;测试1&lt;/button&gt;  &lt;button&gt;测试2&lt;/button&gt;  &lt;button&gt;测试3&lt;/button&gt;//js   let btns = document.getElementsByTagName(&quot;button&quot;);   for (var i = 0;i&lt;btns.length;i++) {   var btn = btns[i];    btn.onclick =function () {      alert(i)        }      }  //执行回调时此时的i已经是最后一次循环之后的i了     //{var i = 0} {var i = 1}   {var i = 2}          </code></pre><p>还有一点是let/const<strong>不属于顶层全局变量</strong>，不用担心污染全局的window对象。</p><pre><code>let a = 0console.log(window.a)//undefinedvar b = 1console.log(window.b)//1</code></pre><h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><p>理解：从对象或数组中提取数据，并赋值给变量(多个)。<br>常用：函数形参对象的解构赋值。</p><p>例：交换对象,解构的目标是数组，所以以数组的形式来接收。</p><pre><code>let a = 1let b = 2[a,b] = [b,a]//a=2 , b =1</code></pre><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>作用：简化字符串的拼接<br>使用：模板字符串必须用<code></code>包含，变化的部分使用${xxx}定义</p><h2 id="对象属性-方法简写"><a href="#对象属性-方法简写" class="headerlink" title="对象属性/方法简写"></a>对象属性/方法简写</h2><p>对象属性简写：当对象的属性和值相同时，省略属性名</p><ul><li>省略的是属性名而不是值</li><li>必须是一个变量</li></ul><p>方法的简写：当对象的属性是一个方法，可以使用简写形式。</p><pre><code>//es5let obj ={ func:function(){} }}//es6let obj2={ func(){}  //不太常用 func:()=&gt;{} //常用箭头函数}</code></pre><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p><a href="https://biubiuins.github.io/2020/07/24/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/" target="_blank" rel="noopener">箭头函数</a></p><h2 id="形参默认值"><a href="#形参默认值" class="headerlink" title="形参默认值"></a>形参默认值</h2><p>在定义函数时可以定义形参的默认值，当不传入参数的时候默认使用形参里的默认值。一般有默认值的形参放在最后。</p><pre><code>//定义形参默认值function add(a=0,b=1) {        return a+b}console.log(add());//输出1</code></pre><h2 id="…"><a href="#…" class="headerlink" title="…"></a>…</h2><p>rest参数<code>...</code> 把<strong>实参</strong>封装成数组，rest参数中的变量代表一个数组。主要用于形参，且rest参数之后不能有其他参数。<br>在ES9中，封装成对象也可以了。</p><p>剩余运算符：用来代替arguments，比arguments灵活。</p><p>补充:arguments.callee()方法的意思是：调用函数本身。</p><pre><code>function foo(...value){ //收集传过来的2，65两个元素console.log(value)//输出[2,65]是一个真数组}function foo(value){console.log(arguments)//2,65是一个伪数组}foo(2,65)</code></pre><p>扩展运算符<code>...</code>将<strong>数组转换为逗号分割的参数序列</strong>，常用于函数调用<br>ES9中也可以将对象转换为逗号分割的参数序列。</p><blockquote><p>扩展运算符可以和数组的解构赋值一起使用，但是必须放在最后一个，因为剩余/扩展运算符的原理其实是利用了数组的迭代器，它会消耗3个点后面的数组的所有迭代器，读取所有迭代器生成对象的value属性，剩余/扩展运算符后不能在有解构赋值，因为剩余/扩展运算符已经消耗了所有迭代器，而数组的解构赋值也是消耗迭代器，但是这个时候已经没有迭代器了，所以会报错</p></blockquote><pre><code>let [first,...arr]=[1,2,3,4,5]//不会报错let[...arr,last] = [1,2,3,4,5] //报错</code></pre><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>Symbol主要用于解决ES5的对象属性名都是字符串，容易造成属性名的冲突问题。是一种类似于字符串的数据类型。</p><p>Symbol是ES6中添加的新的数据类型(原来的有：String，Number,Boolean,Object,Null(空对象指针),Undefined(声明的变量未被初始化时))</p><p>特点:</p><ul><li>Symbol的值是唯一的，解决命名冲突问题。(类似id)</li><li>Symbol值不能与其他数据进行计算，包括同字符串拼接</li><li>Symbol可以转化为布尔值</li><li>Symbol定义的对象属性不能用for/in 循环遍历，可以使用Reflect.ownKeys来获取对象的所有键名。</li></ul><pre><code>//创建Symbol，通过Symbol函数创建 let symbol = Symbol();console.log(symbol) //输出Symbol//Symbol(&#39;对实例的描述&#39;),Symbol是唯一的与如何描述实例无关//对实例进行描述，主要是用于控制台输出时容易区分let s1 = Symbol(&quot;a&quot;)let s2 = Symbol(&quot;a&quot;)console.log(s1===s2) //false//Symbol.for 创建let s3 = Symbol.for(&quot;b&quot;)let s4 = Symbol.for(&quot;b&quot;)console.log(s3===s4) //true</code></pre><p>symbol的作用场景就是给对象添加属性/方法</p><p>1.当symbol作为对象的属性时，用[Symbol]形式，不用XX.Symbol形式。并且在定义的时候也需要加中括号<br>2.除了自己定义使用的Symbol值以外，ES6还提供了11个内置的Symbol方法，比如<code>Symbol.iterator</code>属性</p><p><strong>Symbol.prototype.description</strong></p><p>获取创建symbol实例时对其的描述。</p><h2 id="iterator迭代器"><a href="#iterator迭代器" class="headerlink" title="iterator迭代器"></a>iterator迭代器</h2><p><a href="https://biubiuins.github.io/2020/07/26/%E8%BF%AD%E4%BB%A3%E5%99%A8/" target="_blank" rel="noopener">iterator迭代器</a></p><h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><p>概念：ES6提供的解决异步编程的方案之一。</p><p>特点：<br>1.写法:<code>function函数名*</code><br>2.内部用yield表达式来定义不同的状态<br>3.其返回值是一个Iterator迭代器（指针对象）<br>4.通过调用返回值的next()方法执行函数内部语句</p><p>比如某个事物只有三种状态（状态A，状态B，状态C），而这三种状态的变化是 状态A =&gt; 状态B =&gt; 状态C =&gt; 状态A ，这就是状态机。Generator特别适用于处理这种状态机。</p><pre><code class="bash">// A，B，C三种状态循环function* state(){    while(1){        yield &#39;A&#39;;        yield &#39;B&#39;;        yield &#39;C&#39;;    }}  let status = state();//返回的是指针对象,迭代器对象//碰到yield返回console.log(status.next()); // 先暂停到A，后面的代码不执行，返回{value: &quot;A&quot;, done: false}console.log(status.next()); // 执行下一条指令，暂停到B，返回{value: &quot;B&quot;, done: false}console.log(status.next()); // {value: &quot;C&quot;, done: false}console.log(status.next()); // {value: &quot;A&quot;, done: false}console.log(status.next()); // {value: &quot;B&quot;, done: false}function* state(){        yield &#39;A&#39;;        yield &#39;B&#39;;        yield &#39;C&#39;;} for(let v of gen(){ console.log(v) //输出A,B,C})</code></pre><p>Iterator迭代器遍历结束时，返回的是：{value: undefined, done: true},Generator函数可以使用return来改变最后的返回值</p><p>next传的参数可以作为yield语句(默认返回undefined)的返回值。<br>第一个next表示启动，第二个next对应的才是第一个yieId语句。</p><pre><code>function * state(){    let result = yield &#39;hello&#39;    console.log(result)//输出xxx    }    let iterator = state()    iterator.next(&quot;aaa&quot;)    iterator.next(&quot;xxx&quot;)</code></pre><p><strong>实例</strong>如何实现异步</p><pre><code>//需求:1s 输出111，2s后输出 222，3s输出 333//定时器方法setTimeout(() =&gt; {    console.log(111);    setTimeout(() =&gt; {        console.log(222);        setTimeout(() =&gt; {            console.log(333);        }, 3000)    }, 2000)}, 1000)//使用生成器函数function one(){    setTimeout(()=&gt;{        console.log(111);        iterator.next();    },1000)}function two(){    setTimeout(()=&gt;{        console.log(111);        iterator.next()    },2000)}function three(){    setTimeout(()=&gt;{        console.log(111);        iterator.next()    },3000)}function * gen(){    yield one();    yield two();    yield three();}//调用生成器函数let iterator = gen()</code></pre><h2 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h2><p>Promise是JS中进行异步编程的新的解决方案，之前是纯回调的方法。</p><p>回调函数的一些缺点:<br>1.多重嵌套，导致回调地狱<br>    Promise引入了链式调用的概念，每个then方法同样也是一个promise，所以可以链式调用下去。其次将异步操作以同步的流程表达出来，更方便阅读。<br>2.不清楚回调是否都是异步调用的（可以同步调用ajax，在收到响应前会阻塞整个线程，会陷入假死状态，非常不推荐）<br>3.第三方库可能没有提供错误处理<br>    Promise在异步请求发送错误的时候，即使没有捕获错误，也不会阻塞主线程的代码</p><p>更深入的内容，在之前的博客中<a href="https://biubiuins.github.io/2020/01/08/promise/" target="_blank" rel="noopener">Promise学习笔记</a></p><h2 id="Set-Map容器"><a href="#Set-Map容器" class="headerlink" title="Set/Map容器"></a>Set/Map容器</h2><p>Set容器：无序不可重复的多个value的集合体,<strong>类似数组</strong>但成员唯一，集合实现了iterator接口。</p><ul><li>new Set(array)创建方法</li><li>add(value)添加方法</li><li>delete(value)删除方法</li><li>has(value)判断是否存在方法</li><li>clear()清空方法</li></ul><pre><code>let set = new Set([1,3,2,2])console.log(set);//输出唯一出现的值//add(value)添加方法set.add(7)console.log(set.size,set)//set.size相当于数组的length</code></pre><p><strong>遍历</strong><br>可以使用Set/Map<strong>实例对象</strong>的keys()，values()，entries()方法进行遍历。<br>由于Set的键名和键值是同一个值，它的每一个元素的key和value是相同的，所有keys()和values()的返回值是相同的，entries()返回的元素中的key和value是相同的。</p><pre><code>  let set = new Set([4, 5, &#39;hello&#39;])    for(let item of set.keys()) {        console.log(item) //输出4，5，hello    }    for(let item of set.values()) {        console.log(item) // 输出4，5，hello    }    for(let item of set.entries()) {        console.log(item) //[4,4],[5,5],[&#39;hello&#39;,&#39;hello&#39;]    }</code></pre><p>Map容器:Map是一组键值对(key-value，只取前两个元素。)的结构,key不重复。</p><pre><code>let a = new Map()m.set(&#39;Adam&#39;, 67); //添加新的key-valuem.has(&#39;Adam&#39;);//是否存在key&quot;Adam&quot;  truem.get(&#39;Adam&#39;); //获得key为Adam的value  67m.delete(&#39;Adam&#39;);//删除key&quot;Adam&quot;m.clear() //清空Map容器</code></pre><p>一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉。</p><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p><a href="https://biubiuins.github.io/2020/07/26/class%E7%B1%BB/" target="_blank" rel="noopener">class类</a></p><h2 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h2><p>Number.EPSILON 属性的值表示JavaScript里面的最小值</p><p><strong>进制表示法</strong><br>二进制用0b，八进制用0o</p><pre><code>console.log(0b1010);//输出10</code></pre><p><strong>Number.isFinite(i)</strong></p><p>判断i是否有限大的数<br>返回值：是true,否false</p><pre><code>Number.isFinite(Infinity)//false</code></pre><p><strong>Number.isNaN(i)</strong></p><p>判断i是否NaN<br>返回值：是true,否false</p><p><strong>Number.isInteger(i)</strong></p><p>判断i是否整数<br>返回值：是true,否false</p><pre><code>Number.isInteger(120.0)//true</code></pre><p><strong>Number.parseInt(str)</strong></p><p>将字符串转换为对应的数值<br>返回值：对应的数值</p><p><strong>Math.trunc(i)</strong></p><p>直接i的去除小数部分<br>返回值:整数部分</p><p><strong>Math.sign(i)</strong></p><p>判断i是正数、负数、还是零</p><p><strong>指数运算符(幂)</strong></p><pre><code>  console.log(3 ** 3);  //3的3次方=27</code></pre><p><strong>BigInt</strong></p><p>在普通数据后面加上n，数据类型是大整型。用于很大的数值运算，只能大整型与大整型运算。</p><pre><code>//创建大整型let n = 521n//正数转化成大整型let n = 123console.log(BigInt(n)) //输出123n</code></pre><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>模块功能主要由两个命令构成<br>export 命令用于规定模块的对外接口<br>import 命令用于输入其他模块提供的功能</p><pre><code>//分别暴露export let name = &quot;ranan&quot;export let fun = function(){}//统一暴露export {name,fun}//默认暴露export default {   name : &quot;ranan&quot; ,   fun : function(){}}//通用导入的方式 as 别名 from 地址import * as data from &quot;path&quot; //如果是默认暴露方式，使用时应该是data.default.fun()//解构赋值形式,如果重复了可以使用as别名import {name,fun} from &quot;path&quot;import {name as na,function} from &quot;path&quot;import {default as data} from &quot;path&quot; //默认暴露的写法，必须要写别名//简便形式 针对默认暴露import data from &quot;path&quot;console.log(data) //输出{name : &quot;ranan&quot; ,fun : functio(){}}</code></pre><p><strong>动态import加载</strong></p><p>实现懒加载/按需加载,使用import()函数，返回值是promise对象,pormise返回的成功值就是暴露的对象。</p><pre><code>import(path).then(data =&gt; data.xx)</code></pre><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>Proxy也就是在目标对象之前设置一层拦截，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p><p>Proxy的作用</p><ul><li>拦截和监视外部对对象的访问</li><li>降低函数或类的复杂度</li><li>在复杂操作前对操作进行校验或对所需资源进行管理</li></ul><p>语法：new Proxy(target,handler)</p><ul><li>target就是被设置一层拦截的对象，可以是任何类型的对象(包括原生数组，函数，甚至另一个代理)</li><li>handler是一个对象，用来定制拦截行为</li></ul><p><strong>Proxy一般和Reflect配套使用,前者拦截对象,后者返回拦截的结果,Proxy上有的的拦截方法Reflect都有</strong></p><p><img src="/img/js/Proxy.png" width="50%"></p><p>1.set/get方法</p><p>set方法接收两个常用参数</p><ul><li>target：得到的目标值</li><li>key：目标的key值，相当于对象的属性</li></ul><p>set方法可以接收四个参数</p><ul><li>target:目标值。</li><li>key：目标的Key值。</li><li>value：要改变的值。</li><li>receiver：改变前的原始值。</li></ul><pre><code>    let handler = {        get:function (target,key) {            if (target.hasOwnProperty(key)){                return target[key]//key为属性名，target[key]为属性值            }            else{                console.warn(`对不起，没有这个${key}`)                return            }        },        set:function (target,key,value) {            console.log(&quot;set&quot;,target,key,value);            target[key] =value //设置了p.a才打印1        },        //删除属性        deleteProperty:function (target,key) {            console.log(`删除${key}属性的${target[key]}值`);            delete target[key]        },        // 拦截key in object操作        has(target, key) {            // 自定义限制：只暴露a属性            if (key === &#39;a&#39;) {                return target[key];            } else {                return false;            }        },    }    let p = new Proxy({},handler)    p.a=1 //set {} a 1    p.b=2    console.log(&#39;b&#39; in p); // false,没有暴露    console.log(&#39;a&#39; in p); //true    //console.log(p.a);    //delete p.b //删除了b属性的2值    //console.log(p.b); //undefined</code></pre><p>可以使用Proxy实现表单验证。</p><p>Object.defineProperty也可以实现数据拦截，Proxy有什么优势吗？<br>1.支持数组<br>数组的key是下标，对象的key是属性名</p><pre><code>    let arr = [1,2,3]    let proxy = new Proxy(arr, {        get (target, key, receiver) {            console.log(&#39;get&#39;, key)            return Reflect.get(target, key, receiver)        },        set (target, key, value, receiver) {            console.log(&#39;set&#39;, key, value)            return Reflect.set(target, key, value, receiver)        }    })    proxy.push(4)    // get push     (寻找 proxy.push 方法)    // get length   (获取当前的 length)    // set 3 4      (设置 proxy[3] = 4)    // set length 4 (设置 proxy.length = 4)</code></pre><p>2.Object.defineProperty()的升级版</p><p>外界对某个对象的访问，都必须经过这层拦截。因此它是针对整个对象，而不是对象的某个属性。</p><h2 id="可选链操作符"><a href="#可选链操作符" class="headerlink" title="可选链操作符"></a>可选链操作符</h2><p>可选链操作符<code>?.</code>允许读取一个被连接对象的深层次的属性的值而无需明确校验链条上每一个引用的有效性，类似<code>.</code>运算。<br><code>.</code>:如果对象链.上有数据为null或undefiend，操作符会抛出一个错误<br><code>?.</code>:如果对象链上有数据为null或undefiend，操作符则会按照短路计算的方式进行处理，返回 undefined。</p><p>比如读取一个对象的深层属性</p><pre><code>const obj = {  foo: {    bar: {      baz: 42,      fun: ()=&gt;{}    },  },};// 不使用?.  需要层层判断防止报错let baz = obj &amp;&amp; obj.foo &amp;&amp; obj.foo.bar &amp;&amp; obj.foo.bar.baz;// 使用?.  不需要层层判断let baz = obj?.foo?.bar?.baz; // 结果：42</code></pre><h2 id="绝对全局对象globalThis"><a href="#绝对全局对象globalThis" class="headerlink" title="绝对全局对象globalThis"></a>绝对全局对象globalThis</h2><p>不管是浏览器还是nodejs还是其他环境，<code>globalThis</code>永远表示全局对象，比如浏览器环境表示window，nodejs下表示global</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;let-const&quot;&gt;&lt;a href=&quot;#let-const&quot; class=&quot;headerlink&quot; title=&quot;let/const&quot;&gt;&lt;/a&gt;let/const&lt;/h2&gt;&lt;p&gt;特点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不能重复定义&lt;/li&gt;
&lt;li&gt;在块级作用域内有效
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript高级</title>
    <link href="http://yoursite.com/2020/07/22/JavaScript%E9%AB%98%E7%BA%A7/"/>
    <id>http://yoursite.com/2020/07/22/JavaScript高级/</id>
    <published>2020-07-22T12:36:14.000Z</published>
    <updated>2020-07-24T09:42:32.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>typeof返回数据类型的<strong>字符串</strong>表达,它的返回值都是’数据类型’</p><p>undefined -&gt; ‘undefined’<br>string -&gt; ‘string’<br>boolean -&gt;’boolean’<br>null -&gt; ‘object’  因为该类型只有一个值，所以可以用=== 来判断类型<br>object -&gt;’object’<br>object(function) -&gt; ‘function’<br>object(array) -&gt;’object’</p><p><strong>总结</strong><br>typeof不能明确的区别null和object、object和array</p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>可以使用instanceof对对象进行细分</p><p>A instanceof 构造函数</p><p>通过instanceof可以检查一个对象是否一个构造函数的实例，instanceof原来是寻找实例对象A的原型链</p><p>function -&gt; Function object -&gt; Object array-&gt; Array</p><p><strong>综合例题</strong></p><pre><code>let a = {    age: 12}function fu(obj) {    obj = {        age: 13    }}fu(a)console.log(a.age);//输出12//开始传参可以理解成obj=a，函数执行时obj重新指向另外一个空间//函数执行完毕函数作用域销毁，obj自动释放，obj所指对象的空间在后面的某个时刻由垃圾回收器回收</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p><a href="https://biubiuins.github.io/2020/02/23/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/" target="_blank" rel="noopener">回调函数</a></p><h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><p>防止污染全局命名空间,编写js模块<br>匿名函数自调用;(function(){})()</p><p><strong>分号的问题</strong><br>需要加分号的语句,一般js最终执行时会压缩。<br>1.小括号开头的前一条语句，如匿名函数自调用<br>2.中括号开头的前一条语句</p><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p><a href="https://biubiuins.github.io/2020/07/15/this%E6%8C%87%E9%92%88/" target="_blank" rel="noopener">this指针</a></p><h2 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h2><p><a href="https://biubiuins.github.io/2020/07/15/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/" target="_blank" rel="noopener">原型与原型链</a></p><h2 id="变量提升与函数提升"><a href="#变量提升与函数提升" class="headerlink" title="变量提升与函数提升"></a>变量提升与函数提升</h2><p>通过var声明的变量，会被提升。定义的函数，可以在定义语句前执行，这就是函数提升。</p><pre><code>var a=3function fu(){    console.log(a)    var a = 4     //输出undefined 局部函数定义个变量a会提升到函数的最开始}fn()</code></pre><p>在全局代码执行前，JS引擎会创建一个栈来存储管理所有的执行上下文。在全局执行上下文(window)确定后，将其添加到栈中，在函数执行上下文(调用函数时产生)，将其添加到栈中。在当前函数执行完后，函数执行上下文出栈，最后所有代码执行完后，栈中只剩下window</p><p>作用域是静态的，开始就存在且不会变化。函数上下文是动态的。</p><pre><code>var x = 10;//fn作用域，开始就存在了function fn(){    console.log(x)}//show作用域function show(f){    var x = 20    f() //执行时先在fn的作用域里面找x是不存在的，然后再从全局作用域中找 所以输出10}show(fn) //输出10</code></pre><p><strong>全局执行上下文</strong></p><p>在执行全局代码前，将window确定为全局执行上下文<br>对全局数据进行预处理:<br>var 定义的全局变量 -&gt; undefined 添加为window的属性<br>function 声明的全局函数 -&gt; 赋值，添加为window的方法<br>this -&gt; 赋值(window)<br>开始执行全局代码</p><p><strong>函数执行上下文</strong><br>在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象（虚拟对象，因为函数执行完毕会销毁）<br>对局部数据进行预处理:<br>1.函数的上下文对象 this<br>2.封装<strong>实参</strong>的对象 arguments 是一个类数组对象/有length、可以通过索引操作的对象<br>3.形参变量 -&gt; 赋值 -&gt; 添加为执行上下文的属性<br>其余类似全局执行上下文</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><a href="https://biubiuins.github.io/2020/02/23/%E9%97%AD%E5%8C%85/" target="_blank" rel="noopener">闭包</a></p><h2 id="宏队列与微队列"><a href="#宏队列与微队列" class="headerlink" title="宏队列与微队列"></a>宏队列与微队列</h2><p><a href="https://biubiuins.github.io/2020/02/16/%E5%AE%8F%E9%98%9F%E5%88%97%E4%B8%8E%E5%BE%AE%E9%98%9F%E5%88%97/" target="_blank" rel="noopener">宏队列与微队列</a></p><p><strong>H5 Web Workers(多线程)</strong></p><p>Web Workers 是 HTML5 提供的一个javascript多线程解决方案（常用于计算），但是子线程完全受主线程控制，且不得操作DOM，所以这个新标准并没有改变javascript单线程的本质。</p><p>1.创建一个分线程执行的js文件</p><p><strong>分线程的全局对象不再是window了</strong>，所以分线程不得操作DOM</p><pre><code>var onmessage = function(event){    //不能用函数声明，只能用赋值的形式    var upper = event.data //通过event.data获得主线程发来的数据    postMessage(upper) //将数据发给主线程}</code></pre><p>2.在主线程中的js中发消息并设置回调</p><pre><code>//创建一个Woker对象var worker = new Worker(&quot;分线程执行的js文件地址&quot;)//向分线程发送消息worker.postMessage(&quot;向分线程执行的js发送数据&quot;)//接收worker传过来的数据函数worker.onmessage = function(event){    alert(event.data) //分线程返回的数据在event.data里面}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;判断数据类型&quot;&gt;&lt;a href=&quot;#判断数据类型&quot; class=&quot;headerlink&quot; title=&quot;判断数据类型&quot;&gt;&lt;/a&gt;判断数据类型&lt;/h2&gt;&lt;h3 id=&quot;typeof&quot;&gt;&lt;a href=&quot;#typeof&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>BOM</title>
    <link href="http://yoursite.com/2020/07/21/BOM/"/>
    <id>http://yoursite.com/2020/07/21/BOM/</id>
    <published>2020-07-21T03:30:48.000Z</published>
    <updated>2020-07-22T14:40:27.305Z</updated>
    
    <content type="html"><![CDATA[<p>BOM 浏览器对象模型，可以通过js代码操作浏览器</p><p>BOM对象<br>window代表的是整个浏览器窗口，同时window也是网页中的全局对象<br>navigator代表的当前浏览器的信息，通过该对象识别不同的浏览器<br>location代表当前浏览器的地址栏信息，可以操作页面重定向<br>history代表浏览器的历史记录，可以通过该对象操作浏览器的历史记录，由于隐私获取不到具体的历史记录，只能操作浏览器后退与前进，只在当次访问时有效<br>screen代表用户的屏幕信息</p><p>这些BOM对象在浏览器中作为window对象的属性保存，可以通过window对象来使用，也可以直接使用。</p><h2 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h2><p>由于历史原因，navigator对象中的大部分属性都已经不能帮助我们识别浏览器了。<br>一般只会使用userAgent属性来判断浏览器的信息<br>/chrom/i.test(navigator.userAgent) 测试是否是chrom浏览器,但是最新的IE判断不出来了</p><h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><p>history.length 可以获取当前访问了的页面数<br>history.back() 返回上一个页面，类似浏览器的回退按钮<br>history.forword() 可以跳转到下一个页面，类似浏览器前进<br>history.go(整数) 可以跳转到指定页面 -1回退一个界面，1前进一个页面</p><h2 id="location"><a href="#location" class="headerlink" title="location"></a>location</h2><p>如果直接打印location，则可以获得当前页面的完整路径<br>通过location修改的路径，会有历史记录(可回退)。</p><p>location.assign(path) 用来跳转到其他页面，类似直接修改location路径。<br>location.reload() 刷新页面，默认会情况缓存。<br>location.replace(path) 用新页面代替当前页面，不会生成历史记录。</p><h2 id="window"><a href="#window" class="headerlink" title="window"></a>window</h2><p><strong>定时器</strong></p><p>setInterval(回调函数,时间)<br>回调函数每个一段时间就被调用一次。<br>返回一个Number类型的数据，用于标识定时器，利用返回值可以关闭定时器<br>clearInterval(标识是哪一个定时器)，可以接收任意参数，如果参数不是一个有效的标识，也不会报错只是什么 都不做。</p><p>为了防止开启多个定时器，导致定时器重叠，<strong>在开启定时器之前，需要将上一个定时器关闭。</strong></p><p><strong>延时调用</strong><br>延时调用一个函数不马上执行，而是隔一段时间后在执行，而且只会执行一次<br>setTimeout(回调函数,时间)<br>clearTimeout(标识是哪一个定时器)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;BOM 浏览器对象模型，可以通过js代码操作浏览器&lt;/p&gt;
&lt;p&gt;BOM对象&lt;br&gt;window代表的是整个浏览器窗口，同时window也是网页中的全局对象&lt;br&gt;navigator代表的当前浏览器的信息，通过该对象识别不同的浏览器&lt;br&gt;location代表当前浏览器的地
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>DOM</title>
    <link href="http://yoursite.com/2020/07/18/DOM/"/>
    <id>http://yoursite.com/2020/07/18/DOM/</id>
    <published>2020-07-18T02:30:57.000Z</published>
    <updated>2020-08-06T08:27:13.326Z</updated>
    
    <content type="html"><![CDATA[<p>DOM全程Document Object Model文档对象模型。文档表示的是整个的HTML网页文档;对象表示将网页中的每一个部分都转换成了一个对象;模型来表示对象之间的关系,方便我们获取对象。</p><p>Document对象：实际上是window对象的属性。这个对象的独特之处是唯一一个既属于BOM又属于DOM的对象。在页面中可以直接使用，代表的是整个网页。</p><p><strong>注意点</strong></p><p>1.取消默认行为可以通过在响应函数的最后return false来取消默认行为，或者使用event.preventDefault()<br>2.如果需要读取元素节点属性，直接使用 元素.属性名，但是class属性不能采用这种方式，需要使用className。<br>3.window.onload = function(){<br>//页面加载完之后再执行，确保所有的DOM对象已经加载完毕<br>}</p><h2 id="DOM查询"><a href="#DOM查询" class="headerlink" title="DOM查询"></a>DOM查询</h2><p>innerText 获取到元素内部的文本内容，会自动将html标签去除<br>innerHTML 获取到元素内部的文本内容，会保存html标签</p><p><strong>获取元素节点，通过document对象调用</strong><br>document.getElementById() 通过id获取dom<br>document.getElementsByClassName() 通过类名获取dom<br>document.getElementsByName() 通过name属性获取dom<br>document.getElementsByTagName() 通过标签名获取dom<br>document.querySelector()  该方法总会返回唯一的一个元素document.querySelectorAll() 返回数组。</p><p><strong>获得元素节点的子节点，通过具体的元素节点调用</strong><br>getElementsByTagName() 方法，返回当前节点指定标签名的后代节点<br>childNodes 属性，表示当前节点的所有子节点,会获取包括文本节点在内的所有结点，DOM标签与标签之间的换行也会看成文本结点。<br>children 属性可以获取当前元素的所有子元素<br>firstChild 属性，表示当前节点的第一个子节点，包括空白文本结点<br>firstElementChild 属性获取当前元素的第一个子元素<br>lastChild  属性，表示当前节点的最后一个子节点</p><p><strong>获取父节点和兄弟结点,通过具体的节点调用</strong><br>parentNode 属性，表示当前节点的父节点<br>previousSibling 属性，表示当前节点的前一个兄弟节点，可能会获取到空白文本<br>previousElementSibling 属性，表示当前节点的前一个兄弟元素<br>nextSibling 属性，表示当前节点的后一个兄弟节点</p><p><strong>补充</strong><br>获取body,document中有一个属性body，它保存的就是body的引用<code>document.body</code></p><p>获取html,<code>document.documentElement</code></p><h2 id="DOM-增删改"><a href="#DOM-增删改" class="headerlink" title="DOM 增删改"></a>DOM 增删改</h2><p>document.createElement() 参数为标签名，用于创建一个元素节点对象，并返回创建好的对象<br>document.createTextNode() 参数为文本内容，根据内容创建文本节点，并返回新的节点<br>父节点.appendChild() 向一个父节点中添加新的子节点<br>父节点.insetBefore() 在指定的子节点前插入新的子节点,(新节点,旧节点)<br>父节点.replaceChild() 使用指定的子节点替换已有的子节点，(新节点,旧节点)<br>父节点.removeChild() 删除一个子节点</p><h2 id="DOM操作css"><a href="#DOM操作css" class="headerlink" title="DOM操作css"></a>DOM操作css</h2><p>js通常返回的是<strong>不带单位的数值</strong></p><p><strong>内联样式</strong></p><p>语法:元素.style.样式名 = 样式值</p><p>如果css的样式名中含有-,需要改成驼峰命名法。<br>通过style属性<strong>设置/读取</strong>的样式都是<strong>内联样式</strong>，内联样式有很高的优先级。</p><p>通过style属性来修改元素的样式，每修改一个样式，浏览器需要重新渲染一次页面</p><p>如果要同时修改多个样式，直接通过类名修改<br>对象.className = “”</p><p><strong>当前正在显示的样式</strong><br>语法:元素.currentStyle.样式名</p><p>只有ie浏览器支持,没设置的值获取默认值，其他浏览器可以使用<code>window.getComputedStyle()</code>来获取。</p><p>第一个参数是要获取样式的元素<br>第二个参数可以传递伪元素，一般都传null<br>返回值是当前元素对应的样式的对象,后接样式名获取样式<br>如果该样式没设置获取到的是真实值而不是默认值</p><p><strong>通过以上两种方式获取到的样式都是只读的,如果需要修改只能使用style属性</strong></p><p><strong>处理兼容性问题</strong></p><p>定义一个函数来获取指定元素当前的样式，参数obj要获取样式的元素，style要获取的样式名字符串</p><pre><code>function getStyle(obj,style){if(window.getComputedStyle){//正常浏览器有getComputedStyle方法return getComputedStyle(obj,null)[style]}else{//IE8浏览器没有定义getComputedStylereturn obj.currentStyle[style]}}</code></pre><p><strong>注意</strong>if里面用getComputedStyle不行，要用window.getComputedStyle<br>没使用window时getComputedStyle是一个变量需要去作用域中寻找，没定义就是用会报错，后续代码不会执行<br>使用window之后属于属性，没找到属性返回undefined</p><p><strong>其他样式相关属性</strong></p><p>element.clientWidth/clientHeight<br>这两个属性可以获取元素的<strong>可见(内容和内边距)</strong>宽度和高度,返回的是<strong>数字，不带px</strong>，因为包括的是可见区域所以设置起来无法分配,所以这两个属性都是只读属性。<br>element.offsetWidth/offsetHeight<br>获取元素的整个大小,包括内容、内边距、边框，其他特点与clientWidth/clientHeight属性相似。</p><p>element.offsetParent<br>可以获取当前元素的<strong>定位</strong>父元素,都没有定位返回body<br>element.offsetLeft/offsetTOP<br>当前元素相对于其定位的水平偏移量和垂直偏移量<br>element.scrollHeight/scrollLeft/scrollTop/scrollWidth<br>表示元素整个滚动区域的宽度/高度,可以获取滚动条滚动的距离<br>当满足下面等式的时候，说明滚动条滚动到最底，水平滚动条类似。<br>总长度 - 看不见的长度 = 可见的长度<br>element.scrollHeight - element.scrollTop = clientHeight </p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>当事件的响应函数被触发时，浏览器每次都会将一个<strong>事件对象</strong>(event)作为实参传递给响应函数，封装当前事件相关的一切信息，比如：鼠标坐标，键盘哪个键被按。但是IE8不会传,事件对象作为window对象的属性保存的window.event</p><p>可以使用 event = event || window.event 来解决兼容性问题</p><p><strong>事件对象</strong><br>event.clientX 可以获取鼠标指针的水平坐标，返回数值，不带单位<br>event.clientY 可以获取鼠标指针的垂直坐标，返回数值，不带单位<br>用于获取鼠标在当前的<strong>可见窗口</strong>的坐标<br>event.pageX/event.pageY获取鼠标相对于<strong>当前页面</strong>(document)的坐标,但是IE8不支持，可以通过对top = scrollTop + clientX实现<br>offsetX/offsetY  screenX/screenY<br><img src="/img/js/event.png"></p><p>补充:chrome认为浏览器的滚动条是body的，通过body.scrollTop获取，但是火狐等浏览器认为是html的，通过documentElement.scrollTop获取</p><blockquote><p>现在浏览器的滚动条都是html的了</p></blockquote><p>event.wheelDalta 获得滚轮的方向 正向上滚，负向下滚<br>event.target 触发事件的对象<br>event.keyCode 获取按键的编码 event.altKey/ctrlKey/shiftKey判断alt/ctrl/shift是否被按下</p><p>onscroll 该事件会在元素的滚动条滚动时触发<br>onmousemove 该事件会在鼠标在元素中移动时被触发<br>onmousedown 该事件会在鼠标按下被触发<br>onmouseup 该事件会在鼠标弹上被触发<br>onwheel 该事件会在鼠标滚轮滚动时被触发</p><p>onmouseenter/onmouseleave 与 onmouseover/onmouseout 区别是前面的一组移入子元素是不会触发的</p><p>键盘事件一般绑定给可以获取焦点的对象或者是document<br>onkeydown 键盘按下触发，一直按着不松手会连续触发，<strong>在文本框中输入内容，属于onkeydown的默认行为</strong>根据此性质可以限定文本框内容输入的类型<br>onkeyup  按键被松开，不会连续触发</p><p><strong>事件的冒泡</strong><br>所谓的冒泡指的是事件向上传递，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发。<br>在开发中大部分情况冒泡都是有用的，如果不希望发生事件冒泡可以通过事件对象取消冒泡<br>event.cancelBubble = true</p><p><strong>事件的委派</strong><br>需求场景：给a标签绑点点击事件，后添加的a标签也有该绑定事件。<br>解决:可以尝试把时间绑定到元素共有的祖先元素。<br>事件委派利用了冒泡，从父元素到子元素</p><p><strong>事件的绑定</strong></p><p>对象.事件 = 函数 的形式绑定响应函数，同时只能为一个事件绑定一个响应函数</p><p>addEventListener可以为一个事件同时绑定多个响应函数，后面的不会覆盖前面的<br>对象.addEventListener() 第一个参数事件的字符串，不要on，第二个参数时间触发时的回调函数，第三个参数是否在捕获阶段触发事件，一般都是false</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;DOM全程Document Object Model文档对象模型。文档表示的是整个的HTML网页文档;对象表示将网页中的每一个部分都转换成了一个对象;模型来表示对象之间的关系,方便我们获取对象。&lt;/p&gt;
&lt;p&gt;Document对象：实际上是window对象的属性。这个对象的
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://yoursite.com/2020/07/16/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/07/16/正则表达式/</id>
    <published>2020-07-16T13:56:06.000Z</published>
    <updated>2020-07-27T13:56:30.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>创建正则表达式的对象</p><p>构造函数方式<br>语法:let 变量 = new RegExp(“正则表达式”,”匹配模式”)<br>字面量方式<br>语法:let 变量 = /正则表达式/匹配模式</p><p><a href="https://www.w3school.com.cn/jsref/jsref_obj_regexp.asp" target="_blank" rel="noopener">具体用法</a></p><p><strong>匹配模式</strong><br>i 忽略大小写<br>g 全局匹配模式</p><p><strong>test()</strong><br>检查一个字符串是否符合正则表达式的规则<br>参数为被检查的字符串<br>返回值为布尔值</p><pre><code>//正则表达式规则:字符串是否含有alet reg = new RegExp(&quot;a&quot;)let str = &quot;a&quot;reg.test(str)</code></pre><p><strong>或</strong><br>|表示或 reg=/a|b/ -&gt; a或者b<br>[]里的内容也是或 reg=/a-z/ -&gt; 任意的小写字母<br>[^ ] 查找任何除了[]里的字符 reg=/[^ab]/ -&gt; 除了a或b的字符</p><pre><code>//以a开头c结尾中间是b或d或ereg = /a[bde]c///c是除了ab的字符，所以返回truereg = /[^ab]/reg.test(&#39;abc&#39;)</code></pre><p><strong>量词</strong><br>通过量词可以设置一个内容出现的次数，量词只对它前面的一个内容起作用，如果要对多个加括号。</p><p>a{n} 表示n个连续的a<br>a{1,3} 表示最少一个a最多3个连续a<br>a+ 表示至少一个a,{1,}<br>a* 表示0个或多个,{0,}<br>a? 表示0个会1个,{0,1}<br>^a 表示以a开头<br>a$ 表示以a结尾</p><p>注意: ^a$只表示a</p><p><strong>元字符</strong></p><p>.表示任意字符,如果要检查.需要转义/./,new RegExp(“\.”)<br><strong>使用构造函数时，它的参数是一个字符串，而\是字符串中转义字符，所以使用\需要转义成\使用</strong><br>\w 任意字母、数字、_ 相当于[A-z0-9_]<br>\W 除了字母、数字、_ 相当于[^A-z0-9_]<br>\d 任意的数字<br>\D 除了数字<br>\s 空格 \S除了空格<br>\b 单词边界，\bxxx\b独立的单词 \D 除了单词边界</p><h2 id="字符串和正则相关的方法"><a href="#字符串和正则相关的方法" class="headerlink" title="字符串和正则相关的方法"></a>字符串和正则相关的方法</h2><h3 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h3><p>语法：string.split(“,”)/string.split(/[0-9]/)<br>join()的功能相反,可以将一个字符串拆分为一个数组<br>参数为拆分规则,如例子的根据字符串里的逗号拆分数组,参数可以是正则表达式</p><p>默认全拆<br>不修改原字符串，返回值为数组</p><pre><code>let str=&quot;1a2b3c4d5e6f&quot;let result = str.split(/[0-9]/)//输出[a,b,c,d,e,f]</code></pre><h3 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h3><p>语法:string.search(搜索的内容)<br>搜索字符串中是否含有指定内容,返回<strong>第一次</strong>(g失效)出现的索引或者-1<br>参数是指定内容可以是正则表达式</p><h3 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h3><p>语法:string.match(条件)<br>根据正则表达式，从一个字符串中将符合条件的内容提取出来,返回值是<strong>数组</strong></p><p>默认返回符合条件的第一个内容<br>要找所有内容，开启全局匹配模式<br>可以为一个正则表达式设置多个匹配模式，顺序无所谓</p><pre><code>let str=&quot;1a2b3c4d5e6f&quot;let result = str.match(/[0-9]/g)//输出[1,2,3,4,5,6]</code></pre><h3 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h3><p>语法:string.search(被替换的内容，新的内容)<br>可以将字符串中指定内容替换为新内容，被替换的内容可以是正则表达式。</p><p>默认只替换第一个<br>不影响原来的字符串，返回新的字符串</p><p><strong>可以使用它去空格</strong></p><pre><code>//会去掉全部的空格str = str.replace(/\s/g,&quot;&quot;)//去掉开头的空格str = str.replace(/^\s*/,&quot;&quot;)//去掉结尾的空格str = str.replace(/\s*$/,&quot;&quot;)//去掉开头和结尾的空格str = str.replace(/^\s*|\s*$/g,&quot;&quot;)</code></pre><p>这里去掉字符串的头尾空格可以使用字符串的<strong>trim()</strong>方法</p><h2 id="常用正则"><a href="#常用正则" class="headerlink" title="常用正则"></a>常用正则</h2><p><strong>检查是否合法手机号</strong></p><p>手机号11位,以1开头,第二位3-9，三位以后任意数字9个</p><p>/^1[3-9][0-9]{9}$/</p><p><strong>电子邮件</strong></p><p><a href="mailto:hello.nihao@qbc.com.cn" target="_blank" rel="noopener">hello.nihao@qbc.com.cn</a></p><p>任意字母数字下划线 \w{3,}<br>.任意字母数字下划线 (.\w+)*<br>@<br>任意字母数字 [A-Za-z0-9]+<br>.任意字母(2-5位) .任意字母(2-5位)   (.[A-Za-z]{2,5}){1,2}</p><pre><code>let emailReg=/^\w{3,}(\.\w+)*@[A-Za-z0-9]+/ (\.[A-Za-z]{2,5}){1,2}$/</code></pre><h2 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h2><p>贪婪模式:匹配尽可能多的字符<br>懒惰模式:匹配尽可能少的字符，会不断的回溯</p><p>常用场景<code>.*</code>与<code>.*?</code>，使用?来表示使用懒惰模式匹配</p><h2 id="正则扩展"><a href="#正则扩展" class="headerlink" title="正则扩展"></a>正则扩展</h2><h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><p><strong>捕获()括号包裹的内容</strong></p><p>语法:RegExpObject.exec(string)<br>方法用于检索字符串中的正则表达式的匹配。<br>如果 exec() 找到了匹配的文本，则返回一个结果数组。否则，返回 null。<br>不管是否/g开启全局，<strong>只返回匹配的第一个</strong>。<br>如果要返回匹配的多个可以使用while(reg.exec(str))或者使用String.prototype.matchAll()方法。</p><pre><code>let str = `&lt;ul&gt;          &lt;li&gt;            &lt;a&gt;ranan&lt;/a&gt;            &lt;p&gt;喜欢粉色&lt;/p&gt;         &lt;/li&gt;         &lt;li&gt;            &lt;a&gt;linin&lt;/a&gt;            &lt;p&gt;喜欢白色&lt;/p&gt;         &lt;/li&gt;         &lt;/ul&gt;         `const reg = /&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\/a&gt;.*?&lt;p&gt;(.*?)&lt;\/p&gt;/sconst result = reg.exec(str)console.log(result);//输出一个数组，第一个元素是匹配的文本，第二个值第一个(.*?)返回值，第三个值第二个(.*?)返回值</code></pre><p><strong>命名捕获分组</strong></p><p>通过?&lt;对捕获到的元素进行命名&gt;,返回的数组中有一个groups属性。</p><pre><code>let str = &#39;&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;&#39;const reg = /&lt;a href=&quot;(?&lt;url&gt;.*)&quot;&gt;(?&lt;text&gt;.*)&lt;\/a&gt;/const result = reg.exec(str)console.log(result)//数组前面3个返回值与上述方法相同，[....,goups:{url:http://www.baidu.com},text:&quot;尚硅谷&quot;]//result.groups使用。</code></pre><p><strong>反向断言</strong></p><p>判断匹配结果是否正确</p><p>正向断言,常用表示(?=pattern),从当前匹配位置开始测试后面(<strong>右边</strong>)匹配字符串是否成立。(?!patter)为其否定写法。</p><pre><code>//正向断言let str = &#39;JS51566哈哈哈11嗯嗯&#39;const reg = /\d+(?=嗯)/ const result = reg.exec(str) //输出[11]</code></pre><p>反向断言，常见表达式(?&lt; pattern)或者(?&lt;!pattern),表示当前位置<strong>左边</strong>将出现匹配字符</p><p><strong>dotAll模式</strong></p><p><code>.</code> 代表元字符查找单个字符，除了换行和行结束符。<br>dotAll /正则/s，新增修饰符s使<code>.</code>可以匹配任意字符。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h2&gt;&lt;p&gt;创建正则表达式的对象&lt;/p&gt;
&lt;p&gt;构造函数方式&lt;br&gt;语法:let 变量 = new RegExp(“正则表达式”
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>call-apply-bind</title>
    <link href="http://yoursite.com/2020/07/15/call-apply-bind/"/>
    <id>http://yoursite.com/2020/07/15/call-apply-bind/</id>
    <published>2020-07-15T13:13:53.000Z</published>
    <updated>2020-07-24T14:22:26.198Z</updated>
    
    <content type="html"><![CDATA[<p><strong>函数对象的call方法与apply方法</strong></p><p>函数对象：函数像对象一样去使用,<code>函数.xx</code>。</p><p>共同点：<br>1.这两个方法都是函数对象的方法，需要通过函数对象来调用<br>2.当对函数调用 call()和apply()时，都会执行该函数<br>3.call()和apply()的第一个参数为对象，执行call()与apply的函数对象里的this指向第一个参数</p><p>不同点：<br>call()方法方法可以将实参在第一个参数对象之后依次传递<br>apply()方法需要将实参封装到一个数组中统一传递</p><p><strong>bind()、call()、apple()的区别</strong></p><ul><li>都能指定函数中的this</li><li>Array.prototype.call()/Array.prototype.apply()是立即调用函数，Array.prototype.bind()是将函数返回</li><li>Array.prototype.call(obj)/Array.prototype.bind()从第二个参数开始依次传，Array.prototype.apply(obj)第二个参数是数组，传入的数据放入数组中</li></ul><pre><code>let obj ={name:&quot;ranan&quot;}function f(data,data2) {    console.log(this);    console.log(data + data2);    return data+data2}f.call(obj,33,22) //{name:&quot;ranan&quot;} 55f.apply(obj,[33,22])//{name:&quot;ranan&quot;} 55//所以apply通常用于将数组转化为函数的参数let bar=f.bind(obj) //bind不调用函数bar(33,22)//{name:&quot;ranan&quot;} 55//上面也可以写成f.bind(obj)(33,22)//{name:&quot;ranan&quot;} 55</code></pre><p><strong>Function.prototype.bind(obj)</strong></p><p>作用:将函数内的this绑定为obj，并将函数返回(并不调用)</p><ul><li>返回原函数的拷贝，我们称这个拷贝的函数为绑定函数。</li><li>将函数中的this固定为调用bind方法时的第一个参数，</li><li>绑定this之后，无论有哪个对象调用绑定函数，绑定函数中的this依旧之前绑定的第一个参数</li><li>如果绑定函数作为构造函数，已经捆绑的this会被忽略掉，this依然指向实例对象</li></ul><pre><code>function Person(name){this.name = name;}var bindPerson = Person.bind({name:&quot;绑定函数&quot;}) new bindPerson(&quot;张三&quot;)          // Person {name: &quot;张三&quot;}</code></pre><p><strong>通常用于指定回调函数的this，因为apply与call会立即调用</strong></p><p><strong>使用场景</strong></p><p>保持上下文的方法</p><pre><code>var o={    f: function () {        var self=this;        var fff=function() {            console.log(this.value);             // bind(this) 中 this 指向的是o，这里也可直接写成 bind(o)        }.bind(this);        fff();    },    value: &quot;Hello World!&quot;};o.f(); // Hello World！</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;函数对象的call方法与apply方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数对象：函数像对象一样去使用,&lt;code&gt;函数.xx&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;共同点：&lt;br&gt;1.这两个方法都是函数对象的方法，需要通过函数对象来调用&lt;br&gt;2.当对函数调用 c
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>原型与原型链</title>
    <link href="http://yoursite.com/2020/07/15/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yoursite.com/2020/07/15/原型与原型链/</id>
    <published>2020-07-15T05:55:09.000Z</published>
    <updated>2020-07-24T03:56:02.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型(prototype)"></a>原型(prototype)</h2><p><img src="/img/js/原型.png"><br>此图中的实例对象也称为原型对象</p><p>我们所创建的每一个函数，解析器都会向函数中添加一个属性<code>prototype</code></p><p>函数的<code>prototype</code>属性，这个属性指向着一个对象(原型对象),<strong>原型对象相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，所以我们可以将对象中共有的内容，统一设置到原型对象中。</strong></p><p>如果函数作为普通函数调用<code>prototype</code>没有任何作用。<br>如果函数作为构造函数调用，它所创建的对象中都有一个属性<code>__proto__</code>指向构造函数的原型对象。</p><p><strong>注</strong><br>理解一定要把握对象的<strong>proto</strong>指向的是构造函数的prototype（原型）。</p><p><strong>显式原型与隐式原型</strong></p><p>每个对象都有隐式原型·<strong>proto</strong>·这个属性，而function既有隐式原型（<em>proto</em>）又有显式原型（prototype），因为函数在js里面既是函数也是对象。</p><p>prototype也是一个对象，只要是对象就有<strong>proto</strong>.</p><p><img src="/img/js/原型1.png"><br><img src="/img/js/原型2.png"></p><p><strong>对象的隐式原型的值为其对应构造函数的显式原型的值，<code>prototype</code>与<code>__proto__</code>里面保存一样的地址值。</strong></p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>当访问一个对象的属性时，先在自身属性中查找，找到返回。如果没有，则会去<strong>原型对象</strong>中寻找（根据元素本身的<strong>proto</strong>去找），找到返回，如果最终没有找到，返回undefined,所以Object的原型对象是原型链的尽头，Object的原型对象没有原型。(Object.prototype.<strong>ptoto</strong> === null)</p><p>注意函数的产生：所有函数都是Function的实例包括它本身，所以<strong>Function.<strong>proto</strong> === Function.prototype</strong></p><pre><code>function Foo(){}//实际上var Foo = new Function()//Function是它自身的实例Function = new Function()Function.__proto__ === Function.prototype //true//构造函数objectfuntion Object(){} let Object = new Function()//所以Object的__proto__指向Function.prototype</code></pre><p><strong>原型继承</strong><br>构造函数的实例对象自动拥有构造函数原型对象的属性(方法)，原理是利用原型链</p><h2 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a>补充知识点</h2><h3 id="1-静态成员与实例成员"><a href="#1-静态成员与实例成员" class="headerlink" title="1.静态成员与实例成员"></a>1.静态成员与实例成员</h3><p>实例成员就是构造函数内部通过this添加的成员。实例成员只能通过实例化的对象来访问。（不可以通过构造函数来访问实例成员）<br>静态成员在构造函数本身上添加的成员(<code>Fn.xxx=&quot;xxx&quot;</code>)。静态成员只能通过函数对象访问。（不可以通过实例对象来访问）</p><h3 id="2-构造函数、实例、原型对象三者之间的关系"><a href="#2-构造函数、实例、原型对象三者之间的关系" class="headerlink" title="2.构造函数、实例、原型对象三者之间的关系"></a>2.构造函数、实例、原型对象三者之间的关系</h3><p><code>__proto__</code>和原型对象中(xx.prototype)都有一个属性<code>constructor</code>，它指向函数对象（xx.prototype.constructor===xx）。主要用来记录该对象引用哪个构造函数</p><p><img src="/img/js/三者关系.png"></p><h3 id="3-继承-ES5"><a href="#3-继承-ES5" class="headerlink" title="3.继承(ES5)"></a>3.继承(ES5)</h3><p>补充：call()函数，调用这个函数并改变运行时this的指向，<code>调用函数.call(参数)</code>。</p><p>如：obj1.(method).call(obj2,argument1,argument2)<br>call的作用就是把obj1的方法放到obj2上使用，后面的argument1..这些做为参数传入。</p><p>ES6之前没有提供extends继承。可以通过构造函数+原型对象模拟实现继承，被称为组合继承。<br>核心原理:通过 call()把父类型的this指向子类型的this，这样就可以实现子类型继承父类型的属性，然后通过子类型的原型等于父类型的实例，看见父类型原型上的方法</p><pre><code>//父构造函数 this指向父构造函数的对象实例function Father(name,age){    this.name = name;    this.age = age;}Father.prototype.money= ()=&gt;{    console.log(&#39;父亲要上班&#39;);}//子构造函数 this指向子构造函数的对象实例function  Son(name,age) {  //把指向父构造函数的对象实例的this改变成指向子构造函数的对象实例的this，这样可以继承属性    Father.call(this,name,age)}//让Son的原型对象指向Father的实例对象，那么就可以访问到Father实例对象上的方法//这个new Father()是一个原型对象，相当于{}，这样写会覆盖掉Son的原型对象的constructorSon.prototype = new Father();//所以还需要constructor指回原来的构造函数Son.prototype.constructor = Son</code></pre><p><img src="/img/js/继承.png"></p><h3 id="4-Function和Object的关系"><a href="#4-Function和Object的关系" class="headerlink" title="4.Function和Object的关系"></a>4.Function和Object的关系</h3><p>1.Object, Function, Array等等这些都被称作是构造“函数”，他们都是函数。<br>2.所有的函数都是构造函数Function的实例。</p><p>3.原型链机制的的角度来说，那就是说所有的函数都能通过原型链找到创建他们的Function构造函数的Function.protorype原型对象</p><p>所以</p><pre><code>console.log(Object instanceof Function)//true</code></pre><p>4.Function.prototype是一个对象，所以他的构造函数是Object. 从原型链机制的的角度来说，那就是说所有的函数都能通过原型链找到创建他们的Object构造函数的构造原型Object.prototype对象</p><p>所以</p><pre><code>console.log(Function instanceof Object)//true</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原型-prototype&quot;&gt;&lt;a href=&quot;#原型-prototype&quot; class=&quot;headerlink&quot; title=&quot;原型(prototype)&quot;&gt;&lt;/a&gt;原型(prototype)&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/js/原型.png&quot;&gt;&lt;b
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>this指针</title>
    <link href="http://yoursite.com/2020/07/15/this%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2020/07/15/this指针/</id>
    <published>2020-07-15T04:35:06.000Z</published>
    <updated>2020-07-22T14:59:18.120Z</updated>
    
    <content type="html"><![CDATA[<p>解析器在调用函数时，每次都会向函数内部传递一个隐含的参数this，this指向的是一个对象。<br>根据函数的调用方式不同，this会指向不同的对象。</p><p>任何函数本质上都是通过某个对象来调用的。<br><strong>它的值是调用函数的当前对象，谁调用指向谁</strong>,如果没调用时，没有指明是哪个对象调用的则是window。</p><pre><code>function Person(color) {    console.log(this);    this.color = color;    this.getColor = function () {        console.log(this);        return this.color;    };    this.setColor = function (color) {        console.log(this);        this.color = color;    }}//this是谁Person(&quot;red&quot;); //windowlet p  = new Person(&quot;yello&quot;) //Person的实例，pp.getColor();//Plet obj= {};p.setColor.call(obj,&quot;black&quot;) //objlet test = p.setColor;test()//windowfunction fun1(){    function fun2() {        console.log(this);    }    fun2()}fun1()//window</code></pre><p>补充：</p><p><strong>new在执行时完成的4件事情：</strong><br>1.在内存中创造一个新的空对象,在堆内存中分配空间<br>2.让this指向这个新的对象<br>3.执行构造函数里面的代码，给这个新对象添加属性和方法<br>4.返回这个新对象(所以构造函数里面不需要return)</p><p><strong>最终this指向的是调用它的对象</strong>进行了更准确的描述</p><pre><code>var o = {    a:10,    b:{        a:12,        fn:function(){            console.log(this.a); //12        }    }}o.b.fn();</code></pre><p><strong>知识点1</strong>：这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象</p><pre><code>var o = {    a:10,    b:{        fn:function(){            console.log(this.a); //undefined        }    }}o.b.fn();</code></pre><p>尽管对象b中没有属性a，这个this指向的也是对象b，因为this只会指向它的上一级对象，不管这个对象中有没有this要的东西。</p><p><strong>知识点2</strong>：this永远指向的是最后调用它的对象，也就是看它执行的时候是谁调用的</p><pre><code>var o = {    a:10,    b:{        a:12,        fn:function(){            console.log(this.a); //undefined            console.log(this); //window        }    }}var j = o.b.fn;j();</code></pre><p>除此之外，文章还对this用法进行了补充，当this碰到return的时候</p><p><strong>知识点3</strong>当this遇见return时，如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。</p><pre><code>function fn(){    this.user = &#39;xx&#39;;    return function(){};}var a = new fn; console.log(a.user); //undefinedfunction fn(){    this.user = &#39;xx&#39;;    return 1;}var a = new fn;console.log(a.user); //xxfunction fn(){    this.user = &#39;xx&#39;;    return null;}var a = new fn;console.log(a.user); //xx</code></pre><p>还有一点就是虽然null也是对象，但是在这里this还是指向那个函数的实例，因为null比较特殊。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;解析器在调用函数时，每次都会向函数内部传递一个隐含的参数this，this指向的是一个对象。&lt;br&gt;根据函数的调用方式不同，this会指向不同的对象。&lt;/p&gt;
&lt;p&gt;任何函数本质上都是通过某个对象来调用的。&lt;br&gt;&lt;strong&gt;它的值是调用函数的当前对象，谁调用指向谁&lt;/
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>webpack5</title>
    <link href="http://yoursite.com/2020/07/13/webpack5/"/>
    <id>http://yoursite.com/2020/07/13/webpack5/</id>
    <published>2020-07-13T07:25:30.000Z</published>
    <updated>2020-08-11T15:01:40.367Z</updated>
    
    <content type="html"><![CDATA[<p>下载webpack5</p><p>npm i webpack@next webpack-cli -D</p><p>开发环境</p><pre><code>//---------webpack4写法const {resolve} = require(&quot;path&quot;)module.exports={    entry:&quot;./src/js/index.js&quot;,    output:{        //默认的chunk名称是main        filename:&quot;js/[name].js&quot;,        path:Resolve(__dirname,&quot;build&quot;)    },    mode:&quot;development&quot;,}//--------webpack5写法module.exports={         //其余值为默认值    mode:&quot;development&quot;,}</code></pre><p>生产环境</p><p>1.用了es6模块化<br>2.production模式</p><p>满足以上条件webpack4会自动tree shaking<br>但是在实际中依赖关系复杂时webpack4的tree shaking会失效<br>webpack5对此进行了优化tree shaking会更加强大</p><pre><code>//---------webpack4写法const {resolve} = require(&quot;path&quot;)module.exports={    entry:&quot;./src/js/index.js&quot;,    output:{        //默认的chunk名称是main        filename:&quot;js/[name].js&quot;,        path:Resolve(__dirname,&quot;build&quot;)    },    mode:&quot;production&quot;}//--------webpack5写法module.exports={         mode:&quot;production&quot;,}</code></pre><p>webpack5主要的关注内容：</p><ul><li>通过持久缓存提高构建性能</li><li>使用更好的算法和默认值来改善长期缓存</li><li>通过更好的tree shaking和代码生成来改善捆绑包的大小</li></ul><p><strong>Output</strong></p><p>webpack 4默认只能输出ES5代码<br>webpack 5设置<code>output.ecmaVersion:2015</code>来胜出ES6/ES2015的代码</p><p><strong>SplitChunk</strong></p><pre><code>//webpack4 统一设置minSize:30000//webpack5minSize:{    javascript:30000    style:5000}</code></pre><p><strong>cache</strong></p><p>可以通过配置cache实现长久缓存，让第二次打包性能更加高效</p><p>之前的webpack总是在第一次构建是输出全部文件，但是监视重新构造时只更新修改的文件。<br>webpack5在第一次构建时会找到输出文件看是否有变化，从而决定要不要输出全部文件。</p><p><strong>跨域</strong></p><p>解决开发环境ajax请求跨域问题 –&gt; webpack-devServer里面配置代理proxy</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下载webpack5&lt;/p&gt;
&lt;p&gt;npm i webpack@next webpack-cli -D&lt;/p&gt;
&lt;p&gt;开发环境&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//---------webpack4写法
const {resolve} = require(&amp;quot;path
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="构建工具" scheme="http://yoursite.com/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>webpack详细配置</title>
    <link href="http://yoursite.com/2020/07/12/webpack%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2020/07/12/webpack详细配置/</id>
    <published>2020-07-12T08:05:39.000Z</published>
    <updated>2020-08-04T09:41:16.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><p>entry入口起点，值有三种情况<br>1.string —–&gt;’./src/index.js’<br>打包形成一个chunk，输出一个bundle文件,此时的chunk默认名称是main</p><p>2.array  —–&gt;[‘./src/index.js’,’./src/add.js’]<br>所有入口文件最终只会形成一个chunk，输出一个bundle文件，此时的chunk默认名称是main<br>作用：HMR功能中html热更新生效</p><p>3.object  —–&gt;{index:’./src/index.js’,add:’./src/add.js’}<br>有几个入口文件就形成几个chunk，输出几个bundle，chunk的名称是key</p><p>特殊用法：2.3结合,value值为一个数组</p><pre><code>//----------stringmodule.exports={    entry:&quot;./src/js/index.js&quot;,    output:{        //默认的chunk名称是main        filename:&quot;js/[name].js&quot;,        path:Resolve(__dirname,&quot;build&quot;)    },    plugins:[new HtmlWebpackPlugin()],    mode:&quot;development&quot;,}</code></pre><h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><p>library一般结合DLL使用</p><pre><code>module.exports={    entry:&quot;./src/js/index.js&quot;,    output:{        //文件名称（指定名称+目录）        filename:&quot;js/[name].js&quot;,        //输出文件目录，将来所有资源输出的公共目录        path:Resolve(__dirname,&quot;build&quot;),        //所有资源引入公共路径前缀 --&gt;imgs/a.jpg --&gt; /imgs/a.jpg  默认不加一般用于生产环境         publicPath:&quot;/&quot;,        //非入口chunk的名称  import动态导入 optimization设置        chunkFilename:&quot;js/[name]_chunk.js&quot;,        //整个库向外暴露的变量名        //main.js  (function(modules){...} ---&gt; var main = (function(modules){...}        library:&#39;[name]&#39;        //变量名添加到哪个上，之后如何引入window-browser global-node conmmojs        //var main =... --&gt; window[&quot;main&quot;] = ...        libraryTarget:&#39;window&#39;    },    plugins:[new HtmlWebpackPlugin()],    mode:&quot;development&quot;,}</code></pre><h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><p>Loader让Webpack能够去处理那些非JavaScript文件（Webpack自身只理解JavaScript/json）</p><pre><code>module.exports={    entry:&quot;./src/js/index.js&quot;,    output:{        filename:&quot;js/[name].js&quot;,        path:Resolve(__dirname,&quot;build&quot;)    },    module:{        //loader配置        rules:[            {              test:/\.js$/,              //多个loader用use              use:[,]              //单个loeader用loader              //loader:&quot;&quot;              //排除node_modules下的js文件              exclude:/node_modules/,              //只检查src下的js文件              include:resolve(__dirname,&quot;src&quot;),              //优先执行 pre 延后执行 post 默认无顺序              enforce:&quot;post&quot;,              //配置属性              options:{}            },            {                //以下配置只会执行一个                oneOf:[]            }        ]    }    plugins:[new HtmlWebpackPlugin()],    mode:&quot;development&quot;,}</code></pre><h2 id="resolve-路径别名"><a href="#resolve-路径别名" class="headerlink" title="resolve 路径别名"></a>resolve 路径别名</h2><pre><code>module.exports={    entry:&quot;./src/js/index.js&quot;,    output:{        filename:&quot;js/[name].js&quot;,        path:Resolve(__dirname,&quot;build&quot;)    },    module:{        rules:[]    }    plugins:[new HtmlWebpackPlugin()],    mode:&quot;development&quot;,    //解析模块的规则    resolve:{        //配置解析模块路径别名，vue里面的@，避免使用../../../过多的情况        //优点 简写路径 缺点 路径没有提示        alias:{            @:resolve(__dirname,src/css)        },        //配置省略文件路径的后缀名        extensions:[&#39;.js&#39;,&#39;.json&#39;],        //告诉webpack解析模块是去找哪个目录        //可以直接写出找的路径，也可以仅写文件名一层一层去找        modules:[resolve(__dirname,&quot;../../node_modules&quot;),&#39;node_modules&#39;]    }}</code></pre><h2 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h2><p>dev是develop的简写，用于<strong>开发坏境</strong></p><p>利用devServer快速开启一个服务器。</p><p>只有在通过devServer启动webpack时，配置文件里的devServer才会生效，因为这些参数所对应的功能都是devServer提供的，webpack本事并不认识devServer的配置项。</p><pre><code>module.exports={    entry:&quot;./src/js/index.js&quot;,    output:{        filename:&quot;js/[name].js&quot;,        path:Resolve(__dirname,&quot;build&quot;)    },    module:{        rules:[]    }    plugins:[new HtmlWebpackPlugin()],    mode:&quot;development&quot;,    resolve:{},    devServer:{        //运行代码的目录        contentBase:resolve(__dirname,&#39;build&#39;),        //监视contentBase目录下的所有文件，一旦文件发生变化就会reload        watchContentBase:true,        //监视文件的一些配置        watchOptions:{        //忽略文件        ignored:/node_modules/,        },        //启动gzip的压缩        compress:true,        //端口,域名        port:5000,        host:&#39;localhost&#39;,        //自动打开浏览器        open:true,        //开启HMR功能        hot:true,        //不显示启动服务器日志信息        clientLogLevel:&quot;none&quot;,        //除了一些基本启动信息以外，其他内容都不显示        quiet:true,        //如果出错了，不要全屏提示        overlay:false,        //浏览器和代理服务器没有跨域问题，和服务器有跨域问题，通过代理服务器转发        //服务器代理 --&gt; 解决开放环境跨域问题        proxy:{            //一旦devServer(5000)接收到/api/xxx的请求，就会把请求转发到另外一个服务器(3000)            &#39;/api&#39;:{                target:&#39;http://localhost:3000&#39;,                //发送请求时，请求路径重写：将/api/xxx --&gt; /xxx                pathRewrite:{                    &quot;^/api&quot;:&#39;&#39;                }            }        }    }}</code></pre><h2 id="optimization"><a href="#optimization" class="headerlink" title="optimization"></a>optimization</h2><p>用于<strong>生产环境</strong></p><pre><code>module.exports={    entry:&quot;./src/js/index.js&quot;,    output:{        filename:&quot;js/[name].[contenthash:10].js&quot;,        path:Resolve(__dirname,&quot;build&quot;),        chunkFilename:&#39;js/[name].[contenthash:10]_chunk.js&#39;    },    module:{        rules:[]    }    plugins:[new HtmlWebpackPlugin()],    mode:&quot;production&quot;,    resolve:{ },    optimization:{        splitChunk:&#39;all&#39;,        //以下为默认值        //分割的chunk最小为30kb        minSize:30 * 1024,        maxSize:0, //最大没有限制        minChunks:1, //要提取的chunk最少被引用一次        maxAsyncRequests:5,//按需加载时并行加载的文件的最大数量        maxInitialRequests:3,//入口js文件最大并行请求数量        automaticNameDelimiter:&quot;~&quot;,//名称连接符        name:true, //可以使用命名规则        cacheGroups:{            //分割chunk的组            vendors:{                //node_modules文件会被打包到vendors组的chunk中 --&gt;vendors~xxx.js                //上面的规则对分组里的都生效                test:/[\\/]node_modules[\\/]/,                //优先级                priority:-10            },            default:{                //要提取的chunk最少被引用2次                minChunks:2,                priority:-20,                //如果当前要打包的模块，和之前已经被提取的模块是同一个，直接复用不用重新打包模块                reuseExistingChunk:true            }        },        //将当前模块记录其他模块的hash单独打包为一个文件runtime        //解决缓存失效的问题        runtimeChunk:{            name: entrypoint =&gt; `runtime-${entrypoint.name}`        },        //配置生成环境的压缩方案:js和css        minimizer:[            //需要下载引入        new TerserWebpackPlugin({            //开启缓存            cache:true,            //开启多进程打包            parallel:true,            //启动source-map            sourceMap:true        })        ]    }}</code></pre><p>存在问题使用contenthash，当index.js动态引入a.js打包成两个chunk，输出的main.js中记录了a.js的hash值，所以a变化时重新打包时hash变化，main.js也会变会重新打包。导致缓存失效。</p><p>解决办法：设置runtimeChunk</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;entry&quot;&gt;&lt;a href=&quot;#entry&quot; class=&quot;headerlink&quot; title=&quot;entry&quot;&gt;&lt;/a&gt;entry&lt;/h2&gt;&lt;p&gt;entry入口起点，值有三种情况&lt;br&gt;1.string —–&amp;gt;’./src/index.js’&lt;br&gt;打包形
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="构建工具" scheme="http://yoursite.com/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>webpack优化配置</title>
    <link href="http://yoursite.com/2020/07/10/webpack%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2020/07/10/webpack优化配置/</id>
    <published>2020-07-10T14:47:09.000Z</published>
    <updated>2020-07-13T07:08:04.830Z</updated>
    
    <content type="html"><![CDATA[<p><strong>开发环境性能优化</strong></p><p>优化打包构建速度</p><ul><li>HMR 只重新构建发生变化的模块</li></ul><p>优化代码调试（错误在哪里）</p><ul><li>source-map</li></ul><p><strong>生产环境优化</strong></p><p>优化打包构建速度 </p><ul><li>oneOf 找到一个loader就不会继续遍历了</li><li>babel缓存 第二次构建时，会读取之前的缓存，只重新构建变化的文件</li><li>多进程打包</li><li>externals 让某些库不打包，通过link引入</li><li>dll 让某些库不打包（把库单独先打包好），后面直接用</li></ul><p>代码分为node_modules别人的库，和源代码，源代码可以通过import拆分打包，node_modules可以通过dll拆分打包</p><p>优化代码运行的性能</p><ul><li>缓存（hash-chunkhash-contenthash）</li><li>tree shaking 去掉没有使用的代码</li><li>code split 代码分割</li><li>懒加载/预加载（js代码）</li><li>pwa 离线也可以访问</li></ul><h4 id="开发环境性能优化"><a href="#开发环境性能优化" class="headerlink" title="开发环境性能优化"></a>开发环境性能优化</h4><p>HMR：hot module replacement 热模块替换，作用：一块发生变化，只会重新打包这一个模块（而不是打包所有模块）<br>HTML文件：默认不使用HMR功能，同时会导致问题：html文件不能热更新了。解决办法:修改entry入口，将html文件引入之后html可以热更新了，但是仍然不能使用HMR功能。（html不用做HMR功能）<br>样式文件：可以使用HMR功能是因为style-loader内部实现了，所以在开发环境可以使用style-loader，而在生产环境为了把 css单独提取成一个文件就不使用了。<br>js文件：默认不能使用HMR功能–&gt;需要修改js代码，添加支持HMR功能的代码。（不适用过于麻烦）</p><pre><code>module.exports={   entry:[&quot;./src/js/index.js&quot;,&quot;./src/index.html&quot;]    ....    devServer:{     contentBase:resolve(__dirname,&quot;build&quot;),     compress:true,     port:3000,     open:true,     //开启HMR功能     //当修改webpack配置，新配置想要生效，必须重启服务器。     hot:true    }    }</code></pre><p>source-map：<strong>提供源代码到构建后代码映射的技术</strong>，如果构建后代码出错了，会通过映射追踪到源代码错误。</p><p>[inline-|hidden-|eval-][nosources-][cheap-[module]]source-map<br>source-map：外部，错误代码准确信息和可以追踪源代码的错误位置。<br>inline-source-map:内联，只生成一个内联的source-map，错误代码准确信息，可以追踪源代码的错误位置。<br>hidden-source-map:外部，错误代码错误原因，不能追踪到源代码的错误，只能提示到构建后代码的错误位置。<br>eval-source-map:内联，每一个文件都生成对应的source-map，错误代码准备信息和可以追踪源代码的错误位置。<br>nosources-source-map:外部，错误代码准确信息，但是查看不了源代码。<br>cheap-source-map：外部，错误代码准确信息可以追踪源代码的错误位置，只精确到行，精确不到列。<br>cheap-module-source-map：外部，错误代码准确信息可以追踪源代码的错误位置，module会将loader的source map加入<br>内联和外部的区别：1.外部生成了文件，内联没有（直接在生成的输出js中） 2.内联构建速度快3.内联会让体积变得非常大，所以在生成环境不适用内联。</p><p><strong>推荐</strong><br>开发坏境：速度快，调试更友好。<br>      速度快(eval&gt;inline&gt;cheap&gt;…)eval-cheap-source-map&gt;eval-source-map..<br>      调试友好 source-map cheap-module-source-map<br>      一般使用：eval-source-map</p><p>生成环境：源代码要不要隐藏？调试要不要更友好？<br>      源代码隐L藏：hidden-source-map（只隐藏源代码，会提示构建后代码的错误信息） nosources-source-map（全部隐藏）<br>      一般使用source-map </p><pre><code>module.exports = {.....//devtool:&quot;source-map&quot;devtool:&quot;inline-source-map&quot;}</code></pre><h4 id="生产环境性能优化"><a href="#生产环境性能优化" class="headerlink" title="生产环境性能优化"></a>生产环境性能优化</h4><p>oneOf：oneOf以下的loader只会匹配一个，一旦匹配到，则不会在继续匹配下面的loader了。不能有两个配置处理同一种类型的文件，所以之前的两个js处理loader需要有一个放在外部。</p><pre><code>module.exports = {module:{ rules:[ {eslint...}, {   oneOf:[{...},{另外一个js...}...] } ]}}</code></pre><p>babel缓存：第二次构建时，会读取之前的缓存，只重新构建变化的文件。<br>文件资源缓存：输出的文件(没使用hash)，缓存在浏览器，一定时间内不会重新获取。<br>1.hash:输出文件后面加上hash值（所有文件相同），这样在缓存期如果hash值变化（每次打包都会变化）都会重新获取。存在问题：重新打包就会改变hash，即使没有修改的文件。<br>2.chunkhash：根据chunk生成的hash值，如果打包来源于同一个chunk，那么hash就一样。存在问题css与js的hash值一样，因为css被打包进了js，所以同属于一个chunk。修改项目的文件，只有这个文件和于这个文件相关联的打包文件的hash码变化（css和js还是相同），其他的不变。<br>3.contenthash：根据文件的内容生成hash值，不同文件的hash值不一样。内容变化hash值才改变。</p><pre><code>output:{filename:&quot;js/built.[hash:10].js&quot;//filename:&quot;js/built.[chunkhash:10].js&quot;}//兼容性处理{test:/\.js$/,exclude:/node_modules/,loader: &quot;babel-loader&quot;,options: {presets:[&quot;@babel/preset-env&quot;, {useBuiltIns:&quot;usage&quot;,corejs:{version:3},  targets:{  chrome:&quot;60&quot;,   }   }    ], //开启babel缓存 cacheDirectory:true }},</code></pre><p>tree shaking：去除没有使用的代码，减少代码体积<br>前提：必须使用ES6模块化且开发环境</p><p>在package.json中配置”sideEffects”:false所有代码都可以进行tree shaking，但是有些版本可能会把css文件删掉，所以最好配置”sideEffects”:[“*.css”]</p><h4 id="code-split代码分割"><a href="#code-split代码分割" class="headerlink" title="code split代码分割"></a>code split代码分割</h4><p>拆分文件按需加载</p><pre><code>//第一种多入口页面module.exports={    entry:{        //多入口：有一个入口，输出就有一个bundle        main:&quot;./src/js/index.js&quot;,        test:&quot;./src/js/test.js&quot;    },    output:{        //[name]去入口文件的文件名        filename:&quot;js/[name].[contenthash:10].js&quot;,        path:Resolve(__dirname,&quot;build&quot;)    },    plugins:[...],    mode:&quot;production&quot;,}//第二种配置splitChunksmodule.exports={    entry:&quot;./src/js/index.js&quot;,    output:{...},    plugins:[...],    /*     1.可以将node——mudules中代码单独打包成一个chunk输出    2.会自动分析多入口chunk中，有没有公共的文件，如果有会打包成单独的一个chunk不会重复打包    */    optimization:{        splitChunks:{            chunks:&quot;all&quot;        }    },    mode:&quot;production&quot;,}//第三种通过js代码，让某个文件被单独打包成一个chunk//import动态导入语法能将某个文件单独打包,添加该注释可以设置打包的名字//单页面常用这种方法import(/* webpackChunkName:&quot;test&quot; */ &quot;./test&quot;).then().catch()</code></pre><h4 id="懒加载和预加载"><a href="#懒加载和预加载" class="headerlink" title="懒加载和预加载"></a>懒加载和预加载</h4><p>懒加载当文件需要用时才加载<br>预加载等其他资源加载完毕，浏览器空闲了，在偷偷加载资源，ie会有兼容性问题<br>正常加载可以认为是并行加载，同时加载多个文件</p><pre><code>//懒加载，当文件需要用时才加载//仅在点击按钮之后再加载，第二次加载直接从缓存中读取document.getElementById(&quot;btn&quot;).onclick=function(){import(&quot;./test&quot;).then().catch}//预加载,会提前加载在浏览器document.getElementById(&quot;btn&quot;).onclick=function(){import((/* webpackChunkName:&quot;test&quot;,webpackPrefetch:true */&quot;./test&quot;).then().catch}</code></pre><h4 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h4><p>PWA 逐进式网络开发应用程序，离线课访问<br>    workbox –&gt; workbox-weboack-plugin</p><pre><code>//安装npm i workbox-weboack-plugin//引入清除文件插件const WorkboxWeboackPlugin = require(&#39;workbox-weboack-plugin&#39;);plugins:[    new WorkboxWeboackPlugin.GenerateSW({        /*        1.帮助serviceworker快速启动        2.删除旧的serviceworker        生成一个serviceworker配置文件，        */        clientsClaim:true,        skipWaiting:true    })]//一般在index.js里面注册serviceworker//——————————indexjs//注册serviceworker//处理兼容性问题if(&quot;serviceWorker&quot; in navigator){    window.addEventListener(&quot;load&quot;,()=&gt;{        navigator.serviceWorker.register(&#39;/service-worker.js&#39;)        .then(()=&gt;{})        .catch(()=&gt;{})    })}</code></pre><p>可能出现的问题<br>1.eslit不认识window、navigator全局变量<br>解决：需要修改package.json中eslintConfig配置</p><pre><code>&quot;env&quot;:{    &quot;browser&quot;：true //支持浏览器端全局变量}</code></pre><p>2.sw代码必须运行在服务器上<br>npm i serve -g<br>serve -s build 启动服务器，将build目录下所有资源作为静态资源暴露出去</p><h4 id="externals"><a href="#externals" class="headerlink" title="externals"></a>externals</h4><p>externals拒绝打包某资源，自己手动引入</p><pre><code>module.exports={    entry:&quot;./src/js/index.js&quot;,    output:{...},    plugins:[...],    mode:&quot;production&quot;,    externals:{        //库名 -- npm包名        //想使用link在html中引入，拒绝jQuery被打包进来，拒绝被打包时需要手动引进来        jquery:&#39;jQuery&#39;    }}</code></pre><h4 id="DLL"><a href="#DLL" class="headerlink" title="DLL"></a>DLL</h4><p>使用dll技术，对某些库（第三方）进行单独打包<br>当运行webpack时，默认查找webpack.config.js 配置文件<br>需求：需要运行wbpack.dll.js文件<br>–&gt; webpack –config webpack.dll.js</p><pre><code>//————————webpack.dll.jsconst{ resolve } =require(&quot;path&quot;);const webpack = require(&quot;webpack&quot;);module.exports = {entry:{//最终打包生成的name为属性名，属性值为要打包的库 jquery:[&#39;jquery&#39;]},output:{    filename:&#39;[name].js&#39;,    path:resolve(__dirname),&#39;dll&#39;,    library:&quot;[name]_[hash]&quot;  //打包的库里面向外暴露出去的内容叫什么},//以上内容专门用于打包jqueryplugins:[    //打包生成一个 manifest.json --&gt; 提供和jquery映射 new webpack.DllPlugin(     name:&#39;[name]_[hash]&#39;,//映射库的暴露的内容名称     path:resolve(__dirname,&quot;dll/manifest.json&quot;) //输出文件的路径     })] ，mode:&quot;production&quot;}</code></pre><p>打包之后配置webpack.config.js,这样可以重复打包webpack.config.js时不再打包jquery库了</p><pre><code>//-----webpack.config.jsconst webpack = require(&quot;webpack&quot;);const AddAssetHtmlWebpackPlugin = require(&quot;add-asset-html-webpack-plugin&quot;)....//告诉webpack哪些库不参与打包，同时使用时的名称也要变new webpack.DllReferencePlugin({    manifest:resolve(__dirname,&quot;dll/manifest.json&quot;)}),//将某个文件打包输出去，并在html中自动引入该文件new AddAssetHtmlWebpackPlugin({filepath:resolve(__dirname,&quot;dll/jquery.js&quot;)})</code></pre><h4 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h4><p>clean-webpack-plugin:在打包时，先删除原来的再进行打包新的。</p><pre><code>//安装npm i clean-webpack-plugin -D//引入清除文件插件const CleanWebpackPlugin = require(&#39;clean-webpack-plugin&#39;);//使用plugins:[//匹配删除的文件new CleanWebpackPlugin([  &#39;dist&#39;,         //删除dist文件夹  &#39;build/*.*&#39;,    //删除build文件夹下的所有文件],{  //下面可以省略  root: __dirname,  //根目录  verbose:  true,  //开启在控制台输出信息  dry: false    //启用删除文件}),]</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;开发环境性能优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优化打包构建速度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HMR 只重新构建发生变化的模块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优化代码调试（错误在哪里）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;source-map&lt;/li&gt;
&lt;/ul&gt;
&lt;p
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="构建工具" scheme="http://yoursite.com/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript基础（7.15更新）</title>
    <link href="http://yoursite.com/2020/07/09/JavaScript%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/07/09/JavaScript基础/</id>
    <published>2020-07-09T09:17:03.000Z</published>
    <updated>2020-07-23T12:22:12.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>JavaScript（实现） = ECMAScript（标准） + DOM + BOM</p><p>BOM是浏览器对象模型，用来获取或设置浏览器的属性、行为，例如：新建窗口、获取屏幕分辨率、浏览器版本号等。简单的说：bom是浏览器可视窗口操作<br>DOM是文档对象模型，用来获取或设置文档中标签的属性，例如获取或者设置input表单的value值。 BOM的内容不多，主要还是DOM。 由于DOM的操作对象是文档（Document），所以dom和浏览器没有直接关系。</p><p>Window对象：是整个BOM的核心，所有对象和集合都以某种方式回接到window对象。Window对象表示整个浏览器窗口，但不必表示其中包含的内容。<br>Document对象：实际上是window对象的属性。这个对象的独特之处是唯一一个既属于BOM又属于DOM的对象。</p><p><strong>编写基本要求</strong><br>1.html不区别大小写，而JavaScript严格区别大小写<br>2.如果不写分号，浏览器会自动添加，但是会消耗系统资源，所以开发中必须写分号<br>3.JS中会忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化</p><p><strong>基本语法</strong></p><p>1.字面量与变量<br>字面量：一些不可改变的值，可直接使用，比如：1 2 3 4 5 ，一般不用<br>变量：变量可以保存字面量，且可以任意改变，所以一般用变量</p><p>2.标识符<br>在JS中所有可以由我们自主命名，比如：变量名、函数名、属性名<br>可以是字符、数字（不可开头）、__、$<br>不可以是ES中的关键字或保留字<br>标识符一般采用驼峰命名法</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>基本数据类型： Undefined、Null、Boolean、Number、String和Symbol(ES6)<br>引用数据类型： Object(Array, Date, RegExp, Function)</p><p>基本数据类型栈内存中保存的是值，引用数据类型栈内存中保存的是堆内存的地址。</p><p>字符串中可以使用\进行转义字符</p><p>数字的最大值：Number.MAX_VALUE,最小正值：Number.MIN_VALUE<br>超过最大值返回Infinity表示正无穷。<br>NAN（类型仍然是number）是一个特殊的数字，表示NOT A NUMBER。<br>JS进行浮点运算，可能得到一个不精确的结果（不要用JS进行对精确度比较高的运算）</p><p>注意：<br>Null类型的值只有一个null，null专门用来表示为空的对象，所以使用typeof会返回Object<br>Undefined类型的值只有一个undefined，当声明一个变量，但并不给变量赋值时返回undefined</p><p><strong>强制类型转化</strong><br>主要指其他数据类型转换成String，Number，Boolean</p><p>typeof 就是运算符，获得一个值的类型以字符串返回</p><p>转化成String：<br>1.<code>XXX.toString</code>返回转换结果(null,undefined没有该方法)。<br>2.调用String(需要转化的值)函数，对于Number和Boolean实际上调用的是toString方法，对于null/undefined直接转化为”null/undefined”。<br>3.所以非数字类型的运算都转化成数字类型再运算，但是加法中的字符串除外，所以可以利用字符串拼串<code>x+&quot;&quot;</code>（技巧），</p><p>转化成Number：<br>1.调用Number(需要转化的值)函数，如果有非数字类容/undefined转换NaN，空串/null/false转换成0,true转换成1<br>2.对于字符串，parseInt():把一个字符串转换成整数,第二个参数可以指定数字的进制。parseFloat():把一个字符串转化成浮点数。非字符串将其转化成字符串再操作，返回转化结果。<br>3.由于任何值做减法、乘法、除法运算时都会自动转化为Number，所以可以利用<code>x - 0</code></p><p>转化为布尔值：<br>1.调用Boolean(需要转化的值)函数：0、NaN、空串、null、undefined都是false<br>2.两个取反操作可以转化成布尔值。</p><p>布尔值运算：<br>&amp;&amp; js中的“与运算”属于短路的与，如果第一个值为false，则不会看第二个值。<br>|| js中的“或运算”属于短路的或，如果第一个值为true，则不会检查第二个值。</p><p>对于非布尔值进行与或运算时，会将其转化成布尔值运算后返回原数值，结合短路原则分析返回的数值。</p><p><strong>条件分支</strong></p><p>switch</p><pre><code>switch(值，不会转化){    case 值:  //switch判值,严格判等===        代码块;        break;    default:        代码块; //类似else}switch(true){ //case可以为表达式case score &gt;= 90 &amp;&amp; score &lt;100:    alert(&quot;a&quot;)    break;}</code></pre><p>break只会出现在switch和循环语句中，在switch中代表跳出switch语句，在循环中，会跳出离它最近的那一层循环。</p><p><strong>continue与break</strong></p><p>continue:立刻结束本次循环，执行下次循环<br>break:在循环中，跳出离它最近的<strong>整个循环</strong></p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p><strong>in 运算符</strong><br>“属性名” in 对象<br>通过该运算符可以检查一个对象中是否含有指定的属性<br>如果对象中没有但原型中有，也会返回true</p><p><strong>hasOwnProperty</strong><br>对象的hasOwnProperty来检查对象自身中是否含有该属性</p><p>比较两个引用数据类型时，比较的是<strong>内存地址</strong>。</p><pre><code>let obj = new Object();let obj2 = new Object();obj.name = &quot;ranan&quot;;obj2.name = &quot;ranan&quot;;console.log(obj.name == obj2.name)//输出false</code></pre><p>我们直接在页面中打印一个对象时，实际上是输出<strong>Object原型对象上的toString()</strong>的返回值。</p><p>在JS中拥有自动的垃圾回收机制，我们需要将不用的对象设置为null<br>局部变量:函数执行完自动释放<br>对象：成为垃圾对象，由垃圾回收器回收</p><p><strong>Date对象</strong></p><pre><code>//返回的当前代码执行的时间new Date() //需要在构造函数中传递一个表示时间的字符串作为参数let d = new Date(&quot;12/03/2016 11:10:30&quot;)//获得当前的日期d.getDate()//0表示周日d.getDay()//0表示1月d.getMonth()//获得当前对象的时间戳，从1970.1.1 0 0 0 到当前日期的毫秒数d.getTime()//获得当前的时间戳Date.new()</code></pre><p><strong>Math对象</strong><br>但是它不是构造函数，仅做工具使用</p><pre><code>Math.ceil(1.5) //2 向上取整Math.floor(1.5) //1 向下取整Math.round(1.4) //1 四舍五入//0~1的随机数//生成一个0-y之间的随机数 Math.round(Math.random()*y)//生成一个x-y之间的随机数Math.round(Math.random*(y-x)+x)Math.random() //获取多个数中的最大值Math.max(10,20,52) //返回值为最大值</code></pre><p><strong>包装类</strong><br>JS中提供让那个了三个包装类，通过三个包装类可以将基本数据类型转为对象</p><p>String() 可以将基本数据类型字符串转化成String对象<br>Number() 可以将基本数据类型数字转化成Number对象<br>Boolean() 可以将基本数据类型布尔值转化成Boolean对象</p><p>方法和属性只能添加给对象，不能添加给基本数据类型。<br>包装类的作用：当我们对一些基本数据类型的值去调用属性和方法时，浏览器会<strong>临时</strong>使用包装类将其转换成对象，调用完了在转化回来。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><strong>函数也是一个对象</strong></p><p>使用函数声明来创建一个函数，调用函数时解析器不会检查实参的类型与数量。<br>在调用函数时，浏览器每次都会传递进两个隐含的参数<br>1.函数的上下文对象 this<br>2.封装<strong>实参</strong>的对象 arguments 是一个类数组对象/有length、可以通过索引操作的对象</p><p>补充:arguments.callee()方法的意思是：调用函数本身。</p><pre><code>function fun(){    arguments.callee()//调用fun函数本身    return ;//返回值，执行了后面的代码将不会执行，默认返回undefined}//匿名函数赋值形式，最好叫上分号let fun = function{};//第一个括号是表示这个函数是一个整体 框起来，第二个括号表执行。(function(){})()</code></pre><p>return 可以结束整个函数，后面的代码将不会被执行。</p><p><strong>构造函数</strong></p><p>构造函数习惯首字母大写，构造函数通过new构造。构造函数也被成为类，通过构造函数创建的对象称为实例</p><p><strong>new在执行时完成的4件事情：</strong><br>1.在内存中创造一个新的空对象,在堆内存中分配空间<br>2.让this指向这个新的对象<br>3.执行构造函数里面的代码，给这个新对象添加属性和方法<br>4.返回这个新对象(所以构造函数里面不需要return)</p><p><strong>instanceof</strong><br>对象 instanceof Person<br>通过instanceof可以检查一个对象是否一个类的实例<br>所有的对象都是Object的后代</p><p><strong>构造函数使用的优化</strong><br>构造函数方法存在浪费内存的问题，在构造函数中的复杂数据类型（比如函数），实例化对象的时候，会专门开辟一个空间来存放。那么当实例对象过多的时候，就会开辟更多的空间来存放。<br>解决办法:将共享的方法在<strong>全局作用域</strong>中定义<br>存在的问题：将函数定义在全局作用域，污染了全局作用域的命名空间并且不安全。<br>解决办法:当我们希望所有的对象使用同一个函数时，最好使用<code>prototype</code>，这也是为什么方法一般定义在原型中，属性一般通过构造函数定义在对象本身。<br><a href="https://biubiuins.github.io/2020/02/18/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/" target="_blank" rel="noopener">原型</a></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><strong>数组也是一个对象</strong></p><pre><code>naw Array(10)//创建一个长度为10的数组arr = [[1,2,3],[4,5,6]] //二维数组]//向数组的末尾添加数据，返回值为新数组的长度arr.push(&quot;添加的元素&quot;,&quot;添加的元素2&quot;)//删除数组的最后一个元素，返回值为被删除的元素arr.pop()//向数组的开头添加一个或多个元素，返回值为新数组的长度arr.unshift(&quot;添加的元素&quot;,&quot;添加的元素2&quot;)//删除数组的第一个元素，返回值为被删除的元素arr.shift()</code></pre><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>js中的对象只有JS自己支持,其他的语言都不认识，可以转换成任何语言都认识的字符串。<br>JSON就是一个特殊格式的字符串，并可以转换成任意语言中的对象。<br>JSON分为对象、数组  ‘{“属性名”：”属性值”}’ ‘[“值”]’  对象的属性名一定要加引号<br>JSON允许的值字符串、数值、布尔值、null、普通对象、数组</p><p>JSON.parse(json字符串) JSON字符串转换为JS中的对象返回<br>JSON.stringify(js对象) JS对象转换为JSON字符串</p><p>eval() 这个函数可以用来执行一段字符串形式的JS代码，并将结果值返回，如果执行的字符串中含有{},它会将{}当成代码块，需要给字符串加()。<br>此方法常用于IE7以下JSON失效的情况，此方法不要使用性能比较差并且不安全。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h2&gt;&lt;p&gt;JavaScript（实现） = ECMAScript（标准） + DOM + BOM&lt;/p&gt;
&lt;p&gt;BOM是浏览器对象模型，用来获取或设置
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>webpack基本配置</title>
    <link href="http://yoursite.com/2020/07/09/webpack%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2020/07/09/webpack基本配置/</id>
    <published>2020-07-09T09:11:11.000Z</published>
    <updated>2020-08-04T08:52:50.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>Webpack是一种前端资源构建工具，一个静态模块打包器。将根据模块的依赖关系进行静态分析，打包生成对应的静态资源（bundle）</p><p><strong>Webpack五个核心概念</strong></p><ul><li>Entry:入口指示Webpack以哪个文件为入口起点开始打包，分析构建内部依赖图。</li><li>Output:输出指示Webpack打包后的资源bundles输出到哪里去，以及如何命名。</li><li>Loader:Loader让Webpack能够去处理那些非JavaScript文件（Webpack自身只理解JavaScript/json）</li><li>Plugins:插件可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等。</li><li>Mode:模式指示Webpack使用相应模式的配置<ul><li>development：能让代码本地调式运行的环境</li><li>production：能让代码优化上线运行的环境</li></ul></li></ul><p><strong>生产环境和开发环境</strong><br>使用生产环境:npm run build 实际用的webpack<br>在内存中进行编译打包，生成内存中的打包文件。<br>保存到本地，也就是在本地生成打包文件</p><p>使用开发环境:npm run dev 实际用的webpack-dev-server<br>在内存中进行编译打包，生成内存中的打包文件。<br>启动服务器，运行内存中的打包文件，可以通过浏览器虚拟地址访问</p><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>示例：webpack.config.js</p><p>webpack-dev-server 修改代码自动打包</p><pre><code>/*开发环境配置，能让代码运行起来*//*webpack.config.js webpack的配置文件作用：当运行webpack指令时，会加载里面的配置，打包结果会输出出去所有的构建工具都基于nodejs平台运行的，模块化默认采用commonjs *//*loader：1.下载 2.配置（使用）plugins：1.下载 2.引入  3.使用 *///resolve用来拼接绝对路径的方法const  {resolve} = require(&quot;path&quot;)//引用处理html的插件const HtmlWebpackPlugin =require(&quot;html-webpack-plugin&quot;);module.exports = {    //webpack配置    //入口起点    entry: {        filename:static/js/[name].js,        path:path.resolve(__dirname.&#39;dist&#39;)    },    //输出是对象    output:{        //输出文件名        filename: &quot;js/built.js&quot;,        //输出路径        //__dirname是nodejs的变量，代表当前文件的文件夹绝对路径        path:resolve(__dirname,&quot;build&quot;)    },    //loader配置    module:{        rules:[            //详细loader配置            //不同文件配置不同loader处理            {                //匹配哪些文件,以.css结尾的文件                test:/\.css$/,                //使用哪些loader进行处理                use:[                    //use数组中loader执行顺序：从后往前                    //创建style标签，将js中的样式资源插入进行，添加到head中生效                    &quot;style-loader&quot;,                    //将css文件变成commonjs模块加载js中，里面内容是样式字符串，所以css文件不会单独输出                    &quot;css-loader&quot;                ]            },            {               test:/\.less$/,               use:[&quot;style-loader&quot;,               &quot;css.loader&quot;,                   //将less文件编译成css文件                   //需要下载less-loader和less                   &#39;less-loader&#39;               ]            },            //打包其他资源（除了html/js/css资源以外的资源）            //字体不建议这种写法，因为需要排除的东西过多            {            //排除css、js、html以外的资源             exclude:/\.(css|js|html|less|jpg|png|gif)$/,             loader:&quot;file-loader&quot;            options:{             name:&quot;[hash:10].[ext]&quot;            }            }            //处理图片资源            {                //问题：处理html中的img图片                test:/\.(jpg|png|gif)$/,                //使用一个loader时，可直接用loader引用，不用use,                loader: &quot;url-loader&quot;,                options: {                    //图片大小小于8kb，就会被base64处理                    //优点：减少请求数量（减轻服务器压力）                    //缺点：图片体积会更大（文件请求速度更慢）                    limit:8*1024,                    //问题：因为url-loader默认使用es模块化解析，而html-loader引入图片是commonjs                    //解析时会出现问题：[object Module]                    //解决：关闭url-loader的es模块化，使用commonjs解析                    esModule:false,                    //打包之后文件名的hash值取10位，保持原来的后缀名                    name:&quot;[hash:10].[ext]&quot;,                    //设置图片的输出路径                    outputPath:&quot;imgs&quot;                }            },            { //处理html文件的img图片（负责引入img，从而能被url-loader进行处理）                test:/\.html$/,                loader:&quot;html-loader&quot;            }        ]    },    //plugins的配置    plugins: [        //html-webpack-plugin 处理html资源        //功能：默认会创建一个空的HTML，自动引入打包输出的所有资源（js/css）        //  new HtmlWebpackPlugin()        //需求：需要有结构的HTML文件        new HtmlWebpackPlugin({         //复制&quot;index.html&quot;,并自动引入打包输出的所有资源（js/css）            template:&quot;index.html&quot;            path:&quot;index.html&quot;        })        //详细pulgins的配置    ],    //模式    mode:&#39;development&#39;    // mode:&quot;production&quot;    //启动devServer指令为：npx webpack-dev-server（需要安装对应的包）    //localhost:3000本地服务器查看    devServer:{     //构建后的路径     contentBase:resolve(__dirname,&quot;build&quot;),     //启动gzip压缩，使代码体积更小，运行更快。     compress:true,     //指定开发服务器的端口号     port:3000,     //自动打开默认浏览器     open:true    }}</code></pre><p><strong>总结：</strong></p><ul><li>module-&gt;rules-&gt;use 数组(使用多个loader)是从后往前执行的，使用一个可以直接用loader</li><li>loader：①下载 ②配置（使用），plugins：①下载 ②引入 ③使用。</li><li>url-loader可以用于图片和字体</li><li>webpack需要实时打包，可使用开发服务器devServer实现自动化。</li><li>因为url-loader默认使用es模块化解析，而html-loader解析html中的图片的解析是commonjs。所以需要在url-loader中的选项配置中使用esModule:false关闭默认的es模块解析</li></ul><h3 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h3><p>开发服务器 devServer用来实现自动化，比如自动编译，自动打开浏览器，自动刷新浏览器。只会在内存中编译打包，不会有任何输出文件，比如删除build后，使用devServer不会输出新的build文件。相当于打包后放在本地服务器上运行。</p><h3 id="生产环境"><a href="#生产环境" class="headerlink" title="生产环境"></a>生产环境</h3><h4 id="mini-css-extract-plugin插件"><a href="#mini-css-extract-plugin插件" class="headerlink" title="mini-css-extract-plugin插件"></a>mini-css-extract-plugin插件</h4><p>打包过后的css在js文件里，通过下面的插件可以把css单独抽出来。</p><pre><code>//安装npm i mini-css-extract-plugin -D//引入const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;)//loader配置    module:{        rules:[            {                test:/\.css$/,                use:[                    //创建style标签，将js中的样式资源插入进行，添加到head中生效                    //&quot;style-loader&quot;,                    //作用：提取js中的css成单独文件                    MiniCssExtractPlugin.loader                    &quot;css-loader&quot;                ]            },            ]}plugins:[new MiniCssExtractPlugin({//输出的css文件重新命名  filename:&#39;css/built.css&#39;})]</code></pre><p>以上的写法有一个问题是css如果中有文件，需要在该插件的publicPath中重新配置文件路径。</p><pre><code>{loader:MiniCssExtractPlugin.loader,options:{// 这里可以指定一个 publicPath// 默认使用 webpackOptions.output中的publicPathpublicPath: &#39;../&#39; }</code></pre><h4 id="css兼容与压缩"><a href="#css兼容与压缩" class="headerlink" title="css兼容与压缩"></a>css兼容与压缩</h4><p>css兼容性处理：postcss –&gt; postcss-loader postcss-preset-env（在webpack中使用）</p><pre><code>//安装npm i postcss-loader postcss-preset-env -D//使用    module:{        rules:[            {                test:/\.css$/,                use:[                    MiniCssExtractPlugin.loader                    //使用loader的默认配置的写法                    &quot;css-loader&quot;                    //修改loader的配置写法                    {                    loader:&quot;postcsss-loader&quot;                    options:{                    ident:&quot;postcsss&quot;                    plugins:()=&gt;[                    //返回一个数组 postcss的插件                    //此插件帮助postcss找到package.json中browserslist里面的配置，通过配置加载指定的css兼容性样式，默认找的是browerslist里面的生产环境                    //如果要找开发环境的，就需要在webpack.config.js中设置node.js坏境变量process.env.NODE_ENV=&quot;development&quot;                    require(&quot;postcss-preset-env&quot;)()                    ]                    }                    }                ]            },            ]}//====================package.json&quot;browserslist&quot;:{&quot;development&quot;:[//兼容最近的chrome版本&quot;last 1 chrome version&quot;]&quot;production&quot;:[&quot;&gt;0.2%&quot;,//兼容98%的浏览器&quot;not dead&quot;,//已经死了的浏览器&quot;not op_mini all&quot;]}</code></pre><p>css压缩插件：optimize-css-assets-webpack-plugin</p><pre><code>//安装插件npm i optimize-css-assets-webpack-plugin -D//引用const OptimizeCssAssetsWebpackPlugin = require(&quot;optimize-css-assets-webpack-plugin&quot;)//使用plugins:[{//压缩css，默认配置已经可以解决问题了。new OptimizeCssAssetsWebpackPlugin()}]</code></pre><h4 id="js语法检查与兼容性"><a href="#js语法检查与兼容性" class="headerlink" title="js语法检查与兼容性"></a>js语法检查与兼容性</h4><p>语法检查：eslint-loader eslint<br>注意：只检查自己写的js源代码，第三方的库是不用检查的<br>设置检查规则：在package.json中eslintConfig中设置<br>推荐使用airbnb规则： eslint eslint-plugin-import eslint-config-airbnb-base</p><pre><code>//新版在根目录创建.eslintrc//老版本{test:/\.js$/,loader:&quot;eslint-loader&quot;,//一定要排除exclude:/node_modules/,options:{//自动修复eslint错误fix:true}}//===========package.json&quot;eslintConfig&quot;:{&quot;extends&quot;:&quot;airbnb-base&quot;}</code></pre><p>兼容性处理ES6：babel-loader @babel/preset-env @babel/core<br>基本的js兼容性处理 –&gt; @babel/preset-env 问题：只能转换基本语法，promise不能<br>全部js兼容性处理 –&gt; @babel/polyfill 被弃用，体积还会变大。<br>需要做兼容行处理的就做：按需加载 –&gt;corejs</p><pre><code>{test:/\.js$/,//一定要排除exclude:/node_modules/,loader:&quot;babel-loader&quot;,options:{//预设:指示babel做什么样的兼容性处理 presets:[&quot;@babel/preset-env&quot;]}}//========corejsnpm i core-js -D//配置presets:[[&quot;@babel/preset-env&quot;, //预设包:包含多个常用插件的包{//按需加载 useBuiltIns:&quot;usage&quot;, //指定core-js版本 corejs:{   version:3 }, //指定兼容性做到哪个版本浏览器 targets:{ chrome: &quot;60&quot;, firefox:&quot;60&quot;, ie:&quot;9&quot; }}]]</code></pre><p>js压缩与html压缩</p><pre><code>//生产坏境下自动压缩jsmode:&quot;production&quot;,new HtmlWebpackPlugin({ //复制&quot;./src/index.html&quot;,并自动引入打包输出的所有资源（js/css）template:&quot;./src/index.html&quot;//压缩html代码minify:{  //移除空格  collapseWhitespace:true,  //移除注释  removeComments:true}})</code></pre><h4 id="生产环境的基本配置"><a href="#生产环境的基本配置" class="headerlink" title="生产环境的基本配置"></a>生产环境的基本配置</h4><p>正常来讲，一个文件只能被一个loader处理，当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序:先执行eslint,在执行babel。</p><p>配置vue的相关信息可以在vue官网文档查看，注意vue.esm.js文件的设置</p><pre><code>const {resolve} = require(&quot;path&quot;)//用于将css从js中抽离成单独文件const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;)//css兼容const  OptimizeCssAssetsWebpackPlugin= requir(&quot;optimize-css-assets-webpack-plugin&quot;)const HtmlWebpackPlugin= require(&quot;html-webpack-plugin&quot;)//css兼容const commonCssLoader = [    {        loader:MiniCssExtractPlugin.loader,        options:{            publicPath: &#39;../&#39;        }    },    &quot;css-loader&quot;,    {  //兼容性,还需要在package.json中定义browserslist        loader: &quot;post-loader&quot;,        options: {            ident:&quot;postcss&quot;,            plugins:()=&gt;[                require(&quot;postcss-preset-env&quot;)()            ]        }    }]module.exports={    entry:&quot;./src/js/index.js&quot;,    output: {        filename: &quot;js/built.js&quot;,        path: resolve(__dirname,&quot;build&quot;)    },    module: {        rules: [            {                test:/\.css$/,                use:[...commonCssLoader]            },            {                test:/\.less$/,                use:[...commonCssLoader, &quot;less-loader&quot;]            },            //配置eslint            {                //在package.json中eslintCofig中配置--&gt;airbnb                //npm install -D eslint  eslint --init可以按需配置eslint                test:/\.js$/,                exclude:/node_modules/,                //设置优先执行。                enforce: &quot;pre&quot;,                loader: &quot;eslint-loader&quot;,                options: {                    fix:true                }            },            //兼容性处理            {                test:/\.js$/,                exclude:/node_modules/,                loader: &quot;babel-loader&quot;,                options: {                    presets:[                        &quot;@babel/preset-env&quot;,                        {                            useBuiltIns:&quot;usage&quot;,                            corejs:{version:3},                            targets:{                                chrome:&quot;60&quot;,                            }                        }                    ]                }            },            {                test:/\.(jpg|png|gif)/,                loader: &quot;url-loader&quot;,                options: {                    limit:8*1024,                    name:&quot;[name].[hash:10].[ext]&quot;,                    outputPath:&quot;imgs&quot;,                    esModule:false                }            },            {                test:/\.html$/,                loader: &quot;html-loader&quot;            },            {                exclude:/\.(js|css|less|html|jpg|png|gif)/,                loader: &quot;file-loader&quot;,                options: {                    outputPath:&quot;media&quot;                }            }        ]    },    plugins: [        new MiniCssExtractPlugin({            filename:&quot;css/built.css&quot;        }),        //只需要调用        new OptimizeCssAssetsWebpackPlugin(),        new HtmlWebpackPlugin({            template:&quot;./src/index.html&quot;,            minify:{                collapseWitespace:true,                removeComments:true            }        })    ],    mode: &quot;production&quot;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h2&gt;&lt;p&gt;Webpack是一种前端资源构建工具，一个静态模块打包器。将根据模块的依赖关系进行静态分析，打包生成对应的静态资源（bundle）&lt;/p&gt;

      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="构建工具" scheme="http://yoursite.com/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Less学习笔记</title>
    <link href="http://yoursite.com/2020/07/08/less%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/07/08/less学习笔记/</id>
    <published>2020-07-08T14:50:42.000Z</published>
    <updated>2020-07-08T11:05:18.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="less"><a href="#less" class="headerlink" title="less"></a>less</h1><p> less属于css的一种预处理器<strong>处理在浏览器运行前</strong>, 作为css的扩展、增强版，是一种动态样式语言。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p> //less中的单行注释，不会被编译到css文件中，以/<em> </em>/注释的内容会被编译到css文件</p><h2 id="less嵌套规则"><a href="#less嵌套规则" class="headerlink" title="less嵌套规则"></a>less嵌套规则</h2><p>  和html结构相似，层层嵌套<br><code>&amp;</code> 代表的上一层选择器的名字</p><pre><code>        /* Less */        #header{          &amp;:after{            content:&quot;Less is more!&quot;;          }          .title{            font-weight:bold;          }          &amp;_content{//理解方式：直接把 &amp; 替换成 #header            margin:20px;          }          &gt; .title{            font-weight:bold;          }        }        /* 生成的 CSS */        #header::after{          content:&quot;Less is more!&quot;;        }        #header .title{ //嵌套了          font-weight:bold;        }        #header_content{//没有嵌套！            margin:20px;        }           #header &gt; .title{ //嵌套了          font-weight:bold;        }</code></pre><h2 id="less的继承"><a href="#less的继承" class="headerlink" title="less的继承"></a>less的继承</h2><p>extend 是 Less 的一个伪类。它可继承 所匹配声明中的全部样式。<br>extend（这里放规则）是一个函数</p><pre><code>          /* Less */          //规则的定义，没有参数          .animation{              transition: all .3s ease-out;              .hide{                transform:scale(0);              }          }          #main{              &amp;:extend(.animation);          }          #con{              &amp;:extend(.animation .hide){                color:red;              }          }          /* 生成后的 CSS */          .animation,#main{            transition: all .3s ease-out;          }          .animation .hide , #con{              transform:scale(0);          }          #con{            color:red          }</code></pre><p>更简单的写法</p><pre><code>.p1 {  width:100px}.p2{  //相当于复制p1，性能不太好  p1();}</code></pre><h3 id="all全局搜索替换"><a href="#all全局搜索替换" class="headerlink" title="all全局搜索替换"></a>all全局搜索替换</h3><p>使用选择器匹配到的 全部声明。</p><pre><code>          /* Less */          #main{            width: 200px;          }          #main {            &amp;:after {              content:&quot;Less is good!&quot;;            }          }          #wrap:extend(#main all) {}          /* 生成的 CSS */          #main,#wrap{            width: 200px;          }          #main:after, #wrap:after {              content: &quot;Less is good!&quot;;          }</code></pre><ul><li>从表面 看来，extend 与 方法 最大的差别，就是 extend 是同个选择器共用同一个声明，而 方法 是使用自己的声明。</li><li>~”XXXXX” less之中避免编译，让浏览器编译</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p> 以 <code>@</code> 开头定义变量，使用是直接 @定义的名称</p><p> 变量做类名使用时必须在@后使用大括号包裹</p><p> 声明变量（类比于写好的css引用）类似于混合方法  结构: @name: { 属性: 值 ; }; 使用：@name(); </p><p> 使用@来申明一个变量: @pink:pink //不要添加引号</p><ol><li>作为普通属性值只是来使用：直接使用@pink</li><li>作为选择器和属性名: @{selector的值}的形式（不常用）</li><li>作为URL：@{url} （@images:’../img’ 注意要加引号）</li><li>变量的延迟加载（一个块级域解析完再加载变量）</li></ol><pre><code>       /* Less */       @color: #999;       @bgColor: skyblue;//不要添加引号       @width: 50%;       #wrap {         color: @color;         width: @width;       }       /* 选择器变量 */         @mySelector: #wrap;          @Wrap: wrap;          @{mySelector}{ //变量名 必须使用大括号包裹            color: #999;            width: 50%;            //如果继承width的值可以直接用$width            height: $width;           }          .@{Wrap}{            color:#ccc;          }          #@{Wrap}{            color:#666;          }        /* url 变量*/         @images: &quot;../img&quot;;//需要加引号              body {                background: url(&quot;@{images}/dog.png&quot;);//变量名 必须使用大括号包裹              }       /* 声明变量 */             @background: {background:red;};             #main{                 @background();             }             @Rules:{                 width: 200px;                 height: 200px;                 border: solid 1px red;             };             #con{               @Rules();             }             /* 生成的 CSS */             #main{               background:red;             }             #con{               width: 200px;               height: 200px;               border: solid 1px red;             }</code></pre><h3 id="变量的运算"><a href="#变量的运算" class="headerlink" title="变量的运算"></a>变量的运算</h3><p> 注意点：</p><ol><li>加减法时，以第一个数据的单位为基准</li><li>乘除法时，注意单位一定要统一</li></ol><h2 id="less中的混合"><a href="#less中的混合" class="headerlink" title="less中的混合"></a>less中的混合</h2><p>  混合：将一系列的规则集引入另一个规则集中。</p><p>  类名后面不添加括号，这个样式会在css编译出来并且作用到该类名上。</p><p>  类名后面添加了括号之后就不是一个选择器了，只是创建了一个mixins，专门给别人用的。</p><p>  混合使用 <code>.</code> 或 <code>#</code> 的形式来定义；声明变量使用的是 <code>@</code> 来定义，@变量名（）来使用</p><h3 id="普通混合"><a href="#普通混合" class="headerlink" title="普通混合"></a>普通混合</h3><pre><code>    /* Less */        .card { // 等价于 .card()            background: #f6f6f6;            -webkit-box-shadow: 0 1px 2px rgba(151, 151, 151, .58);            box-shadow: 0 1px 2px rgba(151, 151, 151, .58);        }        #wrap{          .card;//等价于.card();        }        //其中 .card 与 .card() 是等价的。</code></pre><h3 id="带参数的混合"><a href="#带参数的混合" class="headerlink" title="带参数的混合"></a>带参数的混合</h3><p> 注意点：</p><ol><li><p>Less 可以使用默认参数，如果没有传参数，那么将使用默认参数。冒号后面的是默认值</p></li><li><p>@arguments代表全部参数，实参列表</p></li><li><p>传的参数中必须带单位，且按顺序，如果不按顺序，需要在参数中带上参数名类似@width:100px</p></li></ol><pre><code>      /* Less */    .border(@a:10px,@b:50px,@c:30px,@color:#000){     border:solid 1px @color;     box-shadow: @arguments;//指代的是 全部参数      }      #main{       .border(0px,5px,30px,red);//必须带着单位       }      #wrap{               .border(0px);      }           /*  命名参数 */      #wrap{      .border(@color:black);               }      #content{       .border;//等价于 .border()       }           /* 生成的 CSS */    #main{               border:solid 1px red;               box-shadow:0px,5px,30px,red;           }    #wrap{               border:solid 1px #000;               box-shadow: 0px 50px 30px #000;           }    #content{               border:solid 1px #000;               box-shadow: 10px 50px 30px #000;           }</code></pre><h3 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h3><p>注意点：</p><ol><li><p>第一个参数 <code>left</code> 要会找到方法中匹配程度最高的，如果匹配程度相同，将全部选择，并存在着样式覆盖替换。</p></li><li><p>如果匹配的参数 是变量， <code>@_</code> 表示的会被调用任意标志的 。</p></li></ol><pre><code>    /* Less */          .triangle(top,@width:20px,@color:#000){              border-color:transparent  transparent @color transparent ;          }          .triangle(right,@width:20px,@color:#000){              border-color:transparent @color transparent  transparent ;          }          .triangle(bottom,@width:20px,@color:#000){              border-color:@color transparent  transparent  transparent ;          }          .triangle(left,@width:20px,@color:#000){              border-color:transparent  transparent  transparent @color;          }          .triangle(@_,@width:20px,@color:#000){              border-style: solid;              border-width: @width;          }          #main{              .triangle(left, 50px, #999)          }          /* 生成的 CSS */          #main{            border-color:transparent  transparent  transparent #999;            border-style: solid;            border-width: 50px;          }</code></pre><h2 id="方法的命名规范"><a href="#方法的命名规范" class="headerlink" title="方法的命名规范"></a>方法的命名规范</h2><p>注意点：</p><ul><li>在 CSS 中 <code>&gt;</code> 选择器，选择的是 儿子元素，就是 必须与父元素 有直接血源的元素。</li><li>在引入命令空间时，如使用 <code>&gt;</code> 选择器，父元素不能加 括号。</li><li>不得单独使用命名空间的方法 必须先引入命名空间，才能使用 其中方法。</li><li>子方法 可以使用上一层传进来的方法</li></ul><pre><code>           /* Less */           #card(){               background: #723232;               .d(@w:300px){                   width: @w;                   #a(@h:300px){                       height: @h;//可以使用上一层传进来的方法                       width: @w;                   }               }           }           #wrap{               #card &gt; .d &gt; #a(100px); // 父元素不能加 括号           }           #main{               #card .d();           }           #con{               //不得单独使用命名空间的方法               //.d() 如果前面没有引入命名空间 #card ，将会报错               #card; // 等价于 #card();               .d(20px); //必须先引入 #card           }           /* 生成的 CSS */           #wrap{             height:100px;             width:300px;           }           #main{             width:300px;           }           #con{             width:20px;           }//通过import引入其他的less文件@import &quot;&quot;;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;less&quot;&gt;&lt;a href=&quot;#less&quot; class=&quot;headerlink&quot; title=&quot;less&quot;&gt;&lt;/a&gt;less&lt;/h1&gt;&lt;p&gt; less属于css的一种预处理器&lt;strong&gt;处理在浏览器运行前&lt;/strong&gt;, 作为css的扩展、增强版，是一种动
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/CSS/"/>
    
    
      <category term="Less" scheme="http://yoursite.com/tags/Less/"/>
    
  </entry>
  
  <entry>
    <title>meta标签</title>
    <link href="http://yoursite.com/2020/07/08/meta%E6%A0%87%E7%AD%BE/"/>
    <id>http://yoursite.com/2020/07/08/meta标签/</id>
    <published>2020-07-08T11:03:45.000Z</published>
    <updated>2020-07-08T11:27:41.572Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>仅仅记录我已经使用过的，如果后续有使用过新的，会补充在文章中</p></blockquote><p>meta标签主要用于设置网页中的一些元数据，元数据不是给用户看的。</p><ul><li>charset 指定网页的字符集</li><li>name 指定数据的名称</li><li>content 指定的数据的内容</li><li>http-quiv 向浏览器传信息</li></ul><mata name="keywords" content="blog,HTML,购物网址"><p>keywords表示网站的关键字，搜索时用于识别。</p><mata name="description" content="这是一个非常不错的网站"><p>description用于指定网站的描述，网站的描述会显示在搜索引擎的搜索结果中</p><p>补充：title标签的内容会作为搜索结果的超链接的文字显示</p> <meta http-equiv="refresh" content="3;url=https://www.baidu.com"><p> 网页重定向，3秒后跳转到百度</p> <meta name="viewport" content="width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no"><p> viewport是HTML5新增的，常用于移动端。</p><p> width:可视区域的宽度，值可为数字或关键词device-width<br> intial-scale:页面首次被显示是可视区域的缩放级别，取值1.0则页面按实际尺寸显示，无任何缩放<br> maximum-scale=1.0, minimum-scale=1.0;可视区域的缩放级别，<br>user-scalable:是否可对页面进行缩放，no 禁止缩放</p></mata></mata>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;仅仅记录我已经使用过的，如果后续有使用过新的，会补充在文章中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;meta标签主要用于设置网页中的一些元数据，元数据不是给用户看的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;charset 指定网页的字符集&lt;/li&gt;
&lt;li
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="HTML" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/HTML/"/>
    
    
      <category term="HTML" scheme="http://yoursite.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>《在线》阅读笔记</title>
    <link href="http://yoursite.com/2020/06/23/%E3%80%8A%E5%9C%A8%E7%BA%BF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/06/23/《在线》阅读笔记/</id>
    <published>2020-06-23T08:10:29.000Z</published>
    <updated>2020-08-13T09:41:53.103Z</updated>
    
    <content type="html"><![CDATA[<p>互联网的离线到在线，计算机到云计算，信息到数据是贯穿这本书的3个核心概念。王坚博士把<strong>在线</strong>定义为今天我们这个时代的关键词，读到后面的”互联网的渗透，让我们的生活在线了”让我对他的话有了一点理解和感悟。互联网的渗透，让我们的生活中的行为在互联网中进行实时反馈成数据，对数据进行分析与模拟，真正地利用数据做到更多的事情。<br><strong>互联网成为基础设施，数据成为生产资料，计算成为公共服务。</strong><br>互联网把万物、机器与人连接在一起，每一分钟每一秒都在产生新的资源，即数据。数据经由互联网的计算产生智能，进而推动科技，社会与生活的发展。数据其实不是一个新概念，新的是如何处理数据与利用数据。<br>读这本书的时间太晚了，同时也被王坚博士对互联网科技未来发展的理解感到震惊。他的理解我现在读到的都可以说是正确，很难想象在以前是怎样的眼界能看到现在。希望这本书在之后能给我带来更多的惊喜，<br>回忆以前，最开始好像频繁使用的是座机，拥有一个移动的手机好像也是一件很了不起的事情。再到零几年，手机开始慢慢流行，但手机的常用的功能只是止步与通信或者是离线的小说阅读，像电脑对于我来说好像是从来没有听过的事情。在后面，互联网突然超速前进，智能手机与网上冲浪的盛行开始让人们沉迷于在网络中接触到的新东西，那时候对于普通人来说最流行的还是社交与游戏。现在，互联网开始慢慢成为生活中必不可少的东西，各种传统行业的在线化，生活慢慢开始在线，离开网络似乎变成了一件很难实现的事情。<br>我在不断的经历着在线带来的变化，也能很清晰的感受到网络时代的到来以及未来的发展一定离不开互联网。可是现在的经历很难让我在其中充当推动者的角色，哪怕是小小的一个推动者。经常会思考为什么会生活会这样变化?别人是怎么从中抓住机遇？以后到底会怎么样？我想不出结果，似乎也想不出自己的未来计划。是想要去接触更多的东西扩大眼界去做一个真正的对社会有用的人。如果仅仅有想法而不去做是很难把想法实际化的。我更像一个把自己圈在自己想法世界的人，有很多不足，也开始慢慢跨出那一步去改变自己这种状态。我希望渴望变得更好的愿望能促使我坚持下去。<br>谷歌曾把惊人的计算能力成为‘云’，云计算的核心思想基础就是把计算成为一种公共服务。我理解的云计算像是电网一样的一个集中式计算的平台，可以随处接入随时使用与无限扩展。云计算并不是真正的把计算传回本地，而是把你的请求传回到云（数据中心），处理之后再把结果传回给你，计算是在云上的计算设备完成的。<br>让大数据通过云计算产生价值。<br>城市大脑计划真的是一个很酷的决定，更加直白的让数据开始为社会产生价值。利用科技完成人们很难完成的事情，中国的未来真的很令人憧憬。读完了这本书有很多感想，但很难用我贫瘠的语言能力表述出来。似乎通过这本书，看见了未来。</p><p>本书最喜欢的两句话<br><strong>坚持相信的，相信坚持的。</strong><br><strong>梦想永在凌云意意气风发，代码成就万事基积沙镇海。</strong></p><p>现在还年轻，虽然无法拥有经历和学识带来的眼界，但热气腾腾的野心和时间似乎可以带我赶上技术创新的时代。未知总是能给人带来希望，希望勤奋、自律会一直贯穿我的研究生生涯甚至我的整个人生，衷心的祝愿自己。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;互联网的离线到在线，计算机到云计算，信息到数据是贯穿这本书的3个核心概念。王坚博士把&lt;strong&gt;在线&lt;/strong&gt;定义为今天我们这个时代的关键词，读到后面的”互联网的渗透，让我们的生活在线了”让我对他的话有了一点理解和感悟。互联网的渗透，让我们的生活中的行为在互联网
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>CSS学习笔记</title>
    <link href="http://yoursite.com/2020/06/20/CSS/"/>
    <id>http://yoursite.com/2020/06/20/CSS/</id>
    <published>2020-06-20T14:50:42.000Z</published>
    <updated>2020-07-20T08:19:47.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li>伪类选择器</li><li>单位<ul><li>移动端适配</li><li>媒体查询</li><li>省略</li><li>雪碧图</li></ul></li><li>CSS盒模型<ul><li>过渡约束</li><li>外边距折叠</li><li>轮廓和圆角</li></ul></li><li>浮动<ul><li>高度塌陷</li><li>BFC</li><li>清除浮动</li><li>外边距折叠的解决</li><li>clearfix</li></ul></li><li>定位<ul><li>层级</li></ul></li><li>居中<ul><li>垂直居中</li><li>水平居中</li></ul></li><li>动画<ul><li>过渡</li></ul></li><li>弹性盒子</li><li>其他<ul><li>三角形</li></ul></li></ul><h1 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h1><p>伪类带一个冒号，伪元素带两个冒号。</p><p><strong>常见伪类</strong></p><p>li:first-child<br>li:last-child<br>li:nth-child(n)  //n从1开始，2n/even选中偶数位，2n+1/odd奇数位</p><p>这三个 排序是根据所有的子元素进行的，并不是li中的第几个。</p><pre><code>li:first-child{    color: orange;}//第一个li元素并不会变色，因为在子元素中第一个元素是span&lt;span&gt;abc&lt;/span&gt;&lt;li&gt;ff&lt;/li&gt;&lt;li&gt;zz&lt;/li&gt;</code></pre><p>:first-of-type<br>:last-of-type<br>:nth-of-type()</p><p>这几个伪类与上述相似，不过是在同类型元素中选择排序。</p><p>:not()否定伪类</p><pre><code>ul&gt;li:not(li:nth-of-type(3))//当前后相同时，也可以写成ul&gt;li:not(:nth-of-type(3))</code></pre><p><strong>超链接的伪类</strong></p><p>:link 用来表示没访问过的链接（正常的链接）<br>:visited 用来表示访问过的链接，由于隐私的原因，该伪类只能改变颜色（所以不常用）<br>上述两个伪类只用于a标签<br>:hover 用来表示鼠标移入的状态<br>:active 用来鼠标点击</p><p>顺序:lvha</p><p><strong>伪元素</strong></p><p>伪元素表示页面中一些特殊的并不真实存在的元素</p><p>p::first- letter 表示标签p里的第一个字母<br>::first-line 表示第一行<br>::selection 表示选中的内容<br>div::before 表示div标签内的开始位置<br>div::after 表示div标签内的最后一个位置</p><p>before,after添加的文字不可以被选中</p><h1 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h1><p>在前端像素分为两种：css像素和物理像素。编写网页时，所用的像素是CSS像素。浏览器在加载网页时，会将CSS像素转化成物理像素。默认情况在pc端1个css像素=1个物理像素</p><p>视口(viewport)就是屏幕中用来网页显示的区域，可以通过html查看。物理像素是设备的宽度。</p><p>编写移动端的页面时，通过调整视口大小来调整像素比，meta标签设置，<code>content=&quot;width=device-width&quot;</code>可以将像素比设置为最佳像素比的视口大小。</p><p>em是相对于自身元素的字体大小来计算的，1 em = 1 font-size<br>rem是相对于根元素（html）的字体大小来计算的。<br>行高（line-height）指的是文字占有的实际高度，行高如果是整数，则是该元素字体大小的倍数</p><p>移动端不适用px来布局，常常使用vw来布局。<br>vw表示视口的宽度 100vw=1个视口的宽度</p><p>常用的vw适配方案</p><p>比如当前最佳视口大小375px,设计图宽度750px,100vw = 750px(<strong>这个750指的是设计图中的宽度</strong>),<br>那么设计图中的 1px = 0.1333 vw。</p><p>给font-size设置0.133vw对应的是设计图中的1px，所以设计图中的10px可以写成10rem。</p><p>但是一般浏览器对字体的大小有限制，所以会对font-size进行放大比如放大了40倍，那么使用的时候需要缩小40倍。</p><pre><code>html{    //100vw/750 = 0.1333vw    font-size:100vw/750 * 40}.box{    width:设计图中该元素的宽度/40 rem}</code></pre><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><pre><code>@media(min-width:xxx/max-width:xxx){}@media not (){}//除了@media(),(){} //两个条件满足一个就可以了@media()and(){} //两个条件全部满足</code></pre><p>样式切换的分界点称为断点，常用断点：</p><p>小于768 超小屏幕 max-width=768px<br>大于768 小屏幕 min-width=768ox<br>大于992 中型屏幕 min-width=992px<br>大于1200 大屏幕 min-width=1200px</p><p><strong>响应式设计的网站:移动端优先</strong></p><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>字体框就是字体存在的格子，设置font-size实际上就是在设置字体框的高度。<br>行高会在字体框的上下平均分配。<br>font属性：字体大小/行高 字体族，</p><pre><code>//可以将服务器中的字体直接提供给用户去使用//问题：1.加载速度 2.版权@font-face {//xx为你给该字体起的名font-family:&quot;xx&quot;;//服务器中字体的路径src:url();}</code></pre><p>图标字体<br>在使用图标时，可以将图标直接设置为字体，通过font-face的形式来字体进行引用。</p><pre><code>//使用iconfont的方式,本地引用icconfont.css//伪元素引用p::before{content:&quot;\xxxx&quot;; //字体图标的编码font-family:&quot;iconfont&quot;;font-size:xxx;}//类名引用&lt;i class=&quot;iconfont icon-qitalaji&quot;&gt;&lt;/i&gt;</code></pre><p>text-align文本的水平对齐<br>vertical-align 设置元素垂直对齐</p><p>图片默认的基线对齐，但是基线可能和外边框之间有缝隙，所以图片常常设置<code>vertical-align</code>的值来改变对齐方式。</p><p><strong>省略</strong></p><pre><code>width:xx;white-space:nowrap;  //white-space 设置网页如何处理空白 normal 正常 nowrap 不换行 pre 保留原格式overflow:hidden;text-overflow:ellipsis;</code></pre><p><strong>背景</strong></p><p>background-clip 背景范围<br>background-origin 背景图片的偏移量计算的源点，默认在内边距开始<br>可选值 border-box 默认值 padding-box，content-box</p><p>background-size  背景图片的大小 cover 图片比例不变，将元素铺满高度100% contain 图片比例不变，将图片在元素中完整显示，宽度100%<br>background-attachment 背景图片是否跟随元素移动 scroll默认移动，fixed背景会固定在页面中<br>background-image还可以设置渐变的背景色</p><p>解决图片闪烁问题（CSS-Sprite）：可以将多个小图片统一保存在一个大图片（雪碧图），通过图片背景定位来解决问题。</p><p><strong>隐藏文字</strong></p><p>常常使用<code>text-indext:-9999px</code>来隐藏文字,需配合overflow使用。</p><h1 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h1><p><strong>CSS将页面中的所有元素都设置为一个矩形的盒子，</strong>对页面的布局就变成了将不同的盒子摆放到不同的位置。</p><p>盒子 = 内容content + 内边距padding + 边框border + 外边距margin（看不见，其余为可见框）</p><p>由width和height决定的是content的大小。</p><h2 id="块级元素盒模型"><a href="#块级元素盒模型" class="headerlink" title="块级元素盒模型"></a>块级元素盒模型</h2><p>控制布局的时候最好对块级元素进行布局，块级元素占一行。</p><h3 id="过渡约束"><a href="#过渡约束" class="headerlink" title="过渡约束"></a>过渡约束</h3><p><strong>水平布局</strong></p><p>一个块级元素在其父元素中，水平布局必须满足<strong>margin-left + border-left + padding-left + width +  padding-right + border-right + margin-right =  其父元素内容的宽度，如果相加结果不相等，则称为过渡约束。</strong><br>这七个值中可以设置为auto：width，margin。<br>如果发生过渡约束，等式会自动调整，宽度优先，左右平分：<br>1.如果7个值无auto的情况，则浏览器会自动调整margin-right<br>2.如果某个值为auto，则会自动调整auto的值是等式成立。<br>3.如果一个宽度和一个外边距设置为auto，则优先把宽度调整到最大。<br>4.如果两个外边距设置为auto，宽度固定，则会将外边距设置为相同的值。<strong>利用这个特点实现一个元素在其父元素水平居中。</strong>  (width:xx;margin:xx auto）</p><p><strong>垂直布局</strong></p><p>若父元素没设置高度，则默认父元素的高度被内容撑开。<br>使用overflow属性来设置父元素如何处理溢出的子元素，设置在子元素。</p><pre><code>overflow:visible //默认值，子元素会从父元素中溢出overflow:hidden //溢出内同被裁剪不会显示overflow:scroll //生成双向滚动条overflow:auto //根据需要生成滚动条overflow-x/overflow-y</code></pre><h3 id="外边距的折叠"><a href="#外边距的折叠" class="headerlink" title="外边距的折叠"></a>外边距的折叠</h3><p>相邻的垂直方向外边距会发生重叠方向。<br>兄弟元素间的相邻垂直外边距会取两者之间的绝对值较大值，若一正一负取和。兄弟元素之间的外边距重叠对开发有利，不需要处理。</p><p>父子元素的相邻外边距，子元素会传递给父元素(上边距)。</p><h2 id="行内元素盒模型"><a href="#行内元素盒模型" class="headerlink" title="行内元素盒模型"></a>行内元素盒模型</h2><p>行内元素不支持设置宽度和高度，行内元素可以设置padding/border/margin，但是垂直方向padding/border/margin不会影响页面的布局。<br>垂直方向取最大，水平方向取和。</p><p>使用display来设置元素的类型，与display:none相似的还有visibility：hidden。区别是前者隐藏后不占据位置，后者仍然占据位置只是不可见。</p><pre><code>visibility：hidden  //元素隐藏不显示，但是仍然占据位置visibility：visible //元素可见display:inlinedisplay:block //块元素占一行display:inline-block //行内块元素，宽高生效但不占一行，尽量不用换行符会解析display:none //元素不显示display:table //将元素设置为一个表格</code></pre><h2 id="CSS3的盒模型"><a href="#CSS3的盒模型" class="headerlink" title="CSS3的盒模型"></a>CSS3的盒模型</h2><p>CSS3新增<code>box-sizing</code>属性，该属性设置width与height的作用范围。</p><pre><code>box-sizing: border-box //使用ie盒模型box-sizing: content-box //使用标准盒模型，默认box-sizing:padding-box  //width/height设置的是左右padding+content</code></pre><p>标准盒子模型的width/height设置的是content的高度与宽度。<br>IE盒子模型的width/height设置的是content+左右padding+左右border之和。</p><p><strong>可以记忆成属性值为什么从哪个地方开始到对应的地方结束</strong></p><h2 id="轮廓和圆角"><a href="#轮廓和圆角" class="headerlink" title="轮廓和圆角"></a>轮廓和圆角</h2><p><strong>outline</strong><br>轮廓<code>outline</code>与<code>border</code>用法相同，轮廓<code>outline</code>不会影响布局，不会撑大盒子。</p><p><strong>box-shadow</strong><br><code>box-shadow</code>用来设置元素的阴影，前两个值为左侧下侧偏移量，第三个值为模糊程度，第四个值为颜色，不会影响布局。</p><p><strong>border-radius</strong><br><code>border-radius</code>用来设置圆角，指定画圆的半径，值为50%则是一个圆。第一个值是x方向半径，第二个值是y方向半径。</p><h1 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h1><p>通过浮动<code>float</code>可以使一个元素相对于<strong>父元素</strong>进行向左向右浮动，默认不会从<strong>父元素</strong>中移动。<br>元素设置浮动以后，水平布局的等式<strong>margin-left + border-left + padding-left + width +  padding-right + border-right + margin-right =  其父元素内容的宽度</strong>失效并且<strong>脱离文档流</strong>不占用文档流的位置。<br>如果浮动元素上面是在文档流中的，则浮动元素从该位置后面进行排序，而不是上移。<br>浮动元素不会超过它<strong>上一个浮动的兄弟元素高度</strong>，最多就是一样高。<br><strong>浮动元素不会盖住文字</strong>，文字会自动环绕在图片的周围。<br>元素从文档流中脱离，会具有<strong>行内块元素</strong>的特性。</p><h2 id="高度塌陷"><a href="#高度塌陷" class="headerlink" title="高度塌陷"></a>高度塌陷</h2><p>一般父元素的高度不会写死，高度根据子元素高度决定。当子元素浮动后，完全脱离文档流，子元素将无法撑起父元素的高度，导致父元素的高度丢失。</p><pre><code>//style.box1{ border:10px red solid;}.box2{width:100px;height:100px;background-color:green;float:left}//html&lt;div class=&quot;box1&quot;&gt;   &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p><img src="/img/css/高度塌陷.png"></p><p>解决办法：BFC<br>Block Formatting Context 块级格式化环境，是CSS中的一个隐含的属性，可以为一个元素开启BFC，开启BFC该元素会变成一个独立的布局区域。</p><p><strong>元素开启BFC后的特点</strong><br>1.开启BFC的元素不会被浮动元素所覆盖。<br>2.开启BFC的元素子元素和父元素外边距不会重叠。（不会发生子元素设置外边距，父元素跟着动的情况）<br>3.开启BFC的元素可以包含浮动的子元素，使其不会发生高度塌陷。</p><p>启动特殊方式开启元素的BFC<br>方法一：设置元素的浮动（不推荐）<br>副作用：会从文档中脱离。<br>方法二：变成行内块元素（不推荐）<br><strong>方法三</strong>：将元素的<code>overflow</code>设置为一个非visible的值，一般用<code>hidden</code>（常用方式）</p><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>给<strong>受影响</strong>的盒子添加<code>clear</code>属性，<code>clear</code>元素的原理是设置清除浮动以后，浏览器会自动为元素添加上外边距，所以添加了clear的属性<strong>不可以手动添加margin-top</strong>。</p><pre><code>clear:left //清除左侧浮动元素对当前元素的影响clear:right //清除右侧浮动元素对当前元素的影响clear:both //清除两侧中最大影响的那侧</code></pre><p><strong>高度塌陷的最终解决方案：使用after伪类</strong></p><p>在父元素的后面添加一个空标签(行内元素)，清除浮动对其的影响并使其为块元素，浏览器自动改变margin-top使其可以撑开父元素。</p><p>因为行内元素【如span】的padding-top,padding-bottom,margin-top,margin-bottom（垂直方向）属性设置无效。</p><pre><code>//表示box1(父元素)盒子里面内容的最后.box1::after{content:&quot;&quot;;display:block;clear:both}</code></pre><p>使用这种思想同时可以解决外边距重叠的问题。</p><pre><code>&lt;style&gt;  .box1{      width: 200px;      height: 200px;      background: green;  }    .box2{        width: 100px;        height: 100px;        background: orange;        margin-top: 100px;    }&lt;/style&gt;&lt;body&gt;&lt;div class=&quot;box1&quot;&gt;    &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><p><img src="/img/css/外边距折叠.png"></p><p>解决办法：让其外边距不相邻</p><pre><code>//box1盒子内容的最前面.box1::before{content:&quot;&quot;;display:table;}</code></pre><p><strong>clearfix</strong>解决外边距重叠与高度塌陷的问题，谁塌陷这个类名加在谁的身上。</p><pre><code>.clearfix::before,.clearfix::aftee{content:&quot;&quot;;display:table;clear:both;}</code></pre><h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><p>可以通过定位将元素摆到页面的任意位置（一般使用在微小的地方，大布局使用浮动），当元素开启了定位以后，可以通过偏移量(top bottom left right 仅对开启定位的元素有用)来设置元素的位置。</p><p><code>positon</code>属性的值:</p><ul><li>static 默认值，元素是静止的没有开启定位</li><li>relative 相对定位 sticky 粘滞定位</li><li>absolute 绝对定位 fixed 固定定位</li></ul><p><strong>relative相对定位</strong></p><p>开启绝对定位后，如果不设置偏移量元素不会发生变化<br>relative是参照于开启相对定位的元素在文档流中的位置（<strong>元素本身</strong>）进行定位的。<br>相对定位会提升元素的层次<br><strong>相对定位不会让元素脱离文档流</strong>并且不会改变元素的性质。脱离文档流后，元素会变成行内块元素（不会独占一行，宽高属性生效）</p><p><strong>absolute绝对定位</strong></p><p>开启绝对定位后，如果不设置偏移量元素的位置不会发生变化。<strong>元素会从文档流中脱离</strong>，绝对定位的元素会提升层级。<br>absolute定位元素是相对与其包含块（块级元素）进行定位<br>正常情况下，包含块就是离当前元素最近的祖先块元素。<br>绝对定位的包含块就是离它最近的<strong>开启了定位</strong>的祖先元素。</p><p>注意：平时使用的width:100%是指的是相对于包含块的长度</p><p>absolute定位的特点是<strong>父相子绝</strong>，使用绝对定位的元素会向上寻找第一个使用相对定位的父元素。</p><p>水平布局等式<strong>margin-left + border-left + padding-left + width +  padding-right + border-right + margin-right =  其父元素内容的宽度</strong></p><p>当开启了绝对定位之后的水平布局等式变成了<strong>left + margin-left + border-left + padding-left + width +  padding-right + border-right + margin-right + right = 包含块的宽度</strong><br>这9个值中可以设置为auto：width，margin，left，right。<br>如果发生过渡约束，等式会自动调整，宽度优先，right/left其次，左右平分：<br>1.如果9个值无auto的情况，则浏览器会自动调整right<br>2.如果某个值为auto，则会自动调整auto的值是等式成立。<br>3.如果一个宽度和一个外边距设置为auto，则优先把宽度调整到最大。<br>4.如果两个外边距设置为auto，宽度固定，则会将外边距设置为相同的值。<strong>利用这个特点实现一个元素在其父元素水平居中。</strong>  (width:xx;margin:xx auto）</p><p><strong>注意</strong>left和right的默认值是auto，所以如果不知道left和right，则等式不满足会自动调整这两个值。所以以上4点要在left/right设置的情况下进行。</p><p>当我们开启绝对定位后，垂直方向也需要满足垂直方向的等式也需要满足（正常的不会）,其规则类似水平布局。</p><p>所以可以利用其特点，进行元素的垂直居中</p><pre><code>//垂直居中的元素width:xxx;height:xxx;position:absolute; //父相子绝,在谁中间就给谁相对定位margin:autoleft:0;right:0;top:0;bottom:0;</code></pre><p><strong>fixed固定定位</strong></p><p>固定定位也是绝对定位的一种，所以固定定位的大部分特点都和绝对定位一样。<br>不同点是固定定位永远参照与<strong>浏览器的视口（可视区域，固定不动）</strong>进行定位</p><p><strong>sticky粘滞定位</strong></p><p>粘滞定位和相对定位的特点基本一致，不同的是粘滞定位当元素到达一定高度的时候固定住，常常和<code>top</code>结合。<br>sticky定位的元素元素仅在其父元素内生效且父元素的高度不能低于sticky定位 元素的高度，所以如果滚动到父元素的高度低于sticky定位元素的高度，该定位失效。</p><h2 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h2><p>定位的层级大于浮动的层级</p><p><code>z-index</code>属性可以来指定元素的层级，数越大层级越高。</p><p><strong>如果优先级一样，优先显示结构上靠下的元素</strong></p><p>祖先元素的层级再高也不会盖住后代元素。</p><h1 id="居中"><a href="#居中" class="headerlink" title="居中"></a>居中</h1><h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><p>1.文字的垂直居中</p><p>要让文字在父元素中垂直居中，只需将父元素的<code>line-height</code>设置为和父元素的高度一样。</p><p>2.利用定位</p><pre><code>//垂直居中的元素width:xxx;height:xxx;position:absolute; //父相子绝,在谁中间就给谁相对定位，也可以实现垂直水平居中，原理是利用布局等式margin:autotop:0;bottom:0;</code></pre><p>3.利用tabel的性质（很少使用）</p><pre><code>//将元素设置为单元格tddisplay:table-cell;//元素类的子元素垂直居中vertical-align:middle;</code></pre><p>4.利用transform</p><p>当元素的大小并不明确的时候，以水平为例子，垂直类似。</p><pre><code>.box{position:absolute;left:50%;//相对与包含块的50%transform:translateX(-50%)//相对于元素自身的50%}</code></pre><h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><p>一个元素在父元素中水平居中,该代码写在<strong>该元素</strong>的样式中，该代码仅对块级元素有效。</p><pre><code>width:xx;margin:xx auto</code></pre><p>这种办法的原理是利用水平布局的<strong>margin-left + border-left + padding-left + width +  padding-right + border-right + margin-right =  其父元素内容的宽度</strong>等式。</p><p>所有元素也可以通过对<strong>父元素</strong>设置 text-align：center；的方式来实现居中。<br>而对于块元素来说，对要<strong>居中的元素自身</strong>进行设置text-align:center也能实现居中，而无需对其父元素进行设置。</p><h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><h2 id="过渡transition"><a href="#过渡transition" class="headerlink" title="过渡transition"></a>过渡transition</h2><p>过渡三要素:起始位置 过渡时间 终止位置</p><p>transition-property        表示执行过渡的属性<br>transition-duration        指定用于过渡的持续时间<br>transition-timing-function 指定过渡的时序函数<br>transition-delay           指定过渡效果的延迟</p><p>在简写中，如果有2个时间，则第一个为持续时间，第二个为延迟时间。</p><h2 id="动画animation"><a href="#动画animation" class="headerlink" title="动画animation"></a>动画animation</h2><p>动画可以自动触发动态效果。设置动画效果，必须先设置一个关键帧，关键帧设置了动画执行每一个步骤。</p><pre><code>//定义关键帧@keyframes name{//第一种from{}to{}//第二种0%{}5%{}}//使用动画animation-name...  //其余属性同transitionanimation-iteration-count //迭代次数animation-direction //动画方向animation-play-state //设置动画的执行状态 执行或者暂停animation-fill-mode //动画开始/停止的位置，默认动画执行完毕回到原来的位置</code></pre><p>使用图片实现动画的一些小技巧</p><pre><code>.box{background-image:url(&quot;&quot;); //开启平铺animation:name 1s steps(几个图片就几次) infinite;}@keyframes name{from{background-position:0 0;}to{background-position:-图片的长度 0;}}</code></pre><h2 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h2><p>变形不会影响页面的布局，只会改变元素的形状或位置。</p><p><strong>平移</strong></p><p>可以与定位结合实现居中的效果。</p><pre><code>//百分比是相对于自身计算的，并不是根据包含块transform:translateX()/translateY()/translateZ()</code></pre><p>Z轴平移，正常情况就是调整人和元素之间的距离，距离越大，元素离人越近。如果想要看见效果必须要设置网页的视距。一般设置在html，<code>perspective:1000px</code> 表示人眼距离网页的距离</p><p><strong>旋转与缩放</strong></p><p>通过旋转可以使元素<strong>沿轴旋转</strong>指定的角度<br>沿X轴转的时候，设置视距可以看见近大远小的效果。<br>转了轴也会跟着转。</p><pre><code>transform:rotateZ（45deg）/rotateZ(.5turn)//旋转的背面是否可以看见backface-visibility:hidden;transform:scaleX() //缩放的是轴</code></pre><p>即使设置了视距可以看见近大远小的效果，但是仍然仅仅是2D的效果，如果想看见3D的效果还需要设置<code>transform-style:preserve-3d</code></p><h1 id="弹性盒子"><a href="#弹性盒子" class="headerlink" title="弹性盒子"></a>弹性盒子</h1><p>flex是CSS3中新增的布局手段，它主要用来代替浮动来完成页面的布局。</p><p>弹性容器：要使用弹性盒，必须先将一个容器设置为弹性容器,display:flex设置为块级弹性容器，display:inline-flex设置为行内的弹性容器。<br>    主轴：弹性元素的排列方式为主轴<br>    侧轴：与主轴垂直方向为侧轴</p><pre><code>弹性容器的样式flex-direction 指定容器中弹性元素的排列方式flex-wrap 指定弹性元素是否在容器中按侧轴换行flex-flow是上述两个属性的简写属性justify-content 如果分配主轴的空白空间align-items 元素在侧轴如何对齐,控制元素间的对齐align-content 侧轴空白空间的分配</code></pre><p>弹性元素：弹性容器的子元素<br>    弹性元素的样式<br>    flex-grow 指定弹性元素的伸展的系数，当父元素有多余空间时，子元素如何分配。<br>    flex-shrink 指定弹性元素的收缩性，当父元素的空间无法容纳所有的子元素时，如何对子元素进行收缩。<br>    align-self 用来覆盖当前弹性元素上的align-items<br>    flex-basis 指定元素在主轴上的基础长度，如果主轴是横向的，那么指定的就是元素的宽度<br>    flex 是上述的三个属性的简写，顺序也是上述的顺序<br>    order决定弹性盒子的排列顺序</p><p>一个元素可以同时是弹性盒子和弹性元素。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h2><p><code>border</code>四个方向的边框实际是一个<strong>梯形</strong>并不是矩形。当内容区域的高度宽度为0时，边框就会变成小三角形。</p><pre><code> .box1{    width: 0;    height: 0;    border: 20px red solid;    border-color:  border-color: red orange greenyellow yellow;}//常常用伪类添加三角效果//把不需要的方向颜色换成transparent就可以了。或者为了防止占位，可以添加 border-top:none 等来设计。.xxx::before{width: 0;height: 0;content:&quot;&quot;;display:block;border:10px solid transparent;border-top:none;border-bottom-color:white//如果开始不显示设置为display:none}//那么hover的时候可以用下面的写法使其显示//xxxhover的时候他的伪元素怎么样.xxx:hover::after{display:block}</code></pre><p><img src="/img/css/三角形.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;伪类选择器&lt;/li&gt;
&lt;li&gt;单位&lt;ul&gt;
&lt;li&gt;移动端适配&lt;/li&gt;
&lt;li&gt;媒体查询&lt;/li&gt;
&lt;li&gt;省略&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>《图解HTTP》阅读笔记</title>
    <link href="http://yoursite.com/2020/06/18/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/06/18/《图解HTTP》阅读笔记/</id>
    <published>2020-06-18T14:32:44.000Z</published>
    <updated>2020-06-22T09:20:26.181Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>给自己定了100天阅读计划，希望每天都可以坚持，让日子过得更有趣一点。</p></blockquote><p>6.18-6.22</p><p>HTTP是无状态协议，目的是让服务器更快处理大量事务，确保协议的可伸缩性。</p><p><strong>问题1：浏览器输入URL发生了什么</strong></p><p>1.浏览器分析目标的URL，向DNS请求解析该URL的IP地址。因为TCP是通过IP地址连接的。<br>2.通过IP地址与该服务器建立TCP连接。<br>3.浏览器发出HTTP请求。<br>4.服务器响应后TCP连接释放。</p><p>在请求方法中，这里仅记录平时看见过。  但不太熟悉的方法。<br>HEAD方法同DET方法一样，只是仅仅返回报文首部，用于确定URI的有效性及资源更新的日期时间等。<br>OPTIONS方法用来查询该URL支持的方法</p><p><strong>常见的状态码</strong></p><p>1xx：接收的请求正在处理，信息性状态码<br>2xx：请求正常处理完毕，成功状态码<br>3xx：需要进行附加操作以完成请求，重定向状态码<br>4xx：服务器无法处理请求，客户端错误状态码<br>5xx：服务器处理请求错误，服务器错误状态码</p><p>注意：状态码和状态的情况不一致，不少返回的状态码响应都是错误的，但是用户可能察觉不到这点。比如Web应用程序内部发生错误，状态码依旧返回200 OK。</p><p>HTTP1.1中，所有的连接默认都是持久连接。只要任意一端没有明确提出断开连接，则保持连接状态。持久连接的好处是减少了TCP连接重复建立和断开造成的额外开销。<br>持久连接使请求可以管线化，不用等待响应可直接发送下一个请求。（HTTP1.1并没有实现）</p><p><strong>问题2：HTTP1.1与1.0的区别在哪里？</strong><br>1.HTTP1.1默认的是持久连接，只要任意一端没有明确提出断开连接，则保持连接状态。而HTTP1.0默认是非持久连接。<br>2.HOST首部字段。在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中必须有HOST首部字段，如果没有Host头域会报告400 Bad Request的错误。<br>3.HTTP1.1增加了更多的状态响应码。<br>4.HTTP1.0中，存在一些浪费的现象，例如：客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1可以分块请求数据以及断点续传。</p><p><strong>问题3：HTTP2.0带来的改进是？</strong><br>1.二进制分帧，在应用层和传输中之前增加了一个二进制分成帧层，在此层中HTTP2会将所有传输的信息分割为更小的消息和帧，并采用二进制格式的编码。<br>2.复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，实现了管线化。<br>3.HTTP1.1中服务器不能主动的push，HTTP2.0允许服务器未经请求，主动向客户端发送资源，即服务器推送（server push）。<br>4.HTTP1.1中头部数据太长，HTTP2.0引入头部压缩机制，头信息使用gzip或compress压缩后再发送；客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，不发送同样字段，只发送索引号，提高速度</p><p>HTTP不管哪个版本都存在安全性问题：</p><ul><li>通信使用明文（未加密的报文），内容可能会被窃听。</li><li>不验证通信方的身份，因此有可能遭遇伪装，并且无意义的请求也会接收，无法阻止海量请求下的DoS攻击。</li><li>无法证明报文的完整性，所以可能报文被篡改，容易导致中间人攻击。</li></ul><p>而SSL（secure socket layer安全套接层）可以将整个通信线路加密处理，还使用证书来确定通信方以及对报文的完整性保护，因此SSL+HTTP协议的结合产生了HTTPS，提高了通信的安全性。</p><p><strong>问题5：HTTP与HTTPS的区别是什么？</strong></p><p>HTTP + 加密 + 认证 + 完整性保护 = HTTPS</p><p>1.http明文传输，HTTPS加密传输更加安全。<br>2.使用的端口不同，一般http协议的端口为80，https的端口为443</p><p><strong>问题6：SPDY的优点是什么？</strong><br>SPDY可以说是综合HTTPS与HTTP的传输协议。<br>1.多路复用，在一个连接里可以无限处理多个HTTP请求，降低延迟。<br>2.请求优先级，可以给请求分配优先级顺序。<br>3.压缩HTTP首部。<br>4.SPDY规定通信中使用SSL，提高数据传输的可靠性。<br>5.服务器推送，服务器可以主动向客户端推送数据，例如有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到</p><p><strong>问题7：SPDY与HTTP2.0的区别是什么？</strong><br>HTTP2.0可以说是SPDY的升级版（基于SPDY设计的）<br>1.HTTP2.0支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS<br>2.HTTP2.0消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE</p><p><strong>WebSockt</strong></p><p>WebSocket是由HTML5开始提供的Web浏览器与Web服务器之间全双工通信的协议，由于建立在HTTP基础上的协议，因此需要进行一次由客户端发起的HTTP连接，一旦确立WebSocket通信连接，即是全双工通信。</p><p>WebSocket优点：<br>1.支持由服务器向客户端推送数据。（HTTP/2 只能推送静态资源,无法推送指定的信息）<br>2.WebSocket是持久连接，较少每次连接时的总开销。<br>3.WebSocket的首部信息很小，较少通信量。</p><p><img src="/img/学习笔记/WebSocket.jpg"></p><p><strong>总结</strong></p><p>SPDY不是可以替代HTTP的协议，而是对HTTP协议的增强，SPDY强制使用HTTPS。HTTP2以SPDY2为基础进行改进，支持HTTP传输。HTTPS是身披SSL外壳的HTTP。</p><p><strong>不管所用网络协议是什么版本，什么样的网络协议，最终的目标都应该是消除或减少不必要的网络延迟，将需要传输的数据压缩至最少。</strong></p><p><strong>评价</strong></p><p>此书的有些语句过于拗口且也歧义，理解真正的意思有困难。其次前6章对于HTTP报文的介绍只是简单的把每个部分的语法代表什么意思说了出来，缺乏整体性的认识，过于枯燥。阅读性不高。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;给自己定了100天阅读计划，希望每天都可以坚持，让日子过得更有趣一点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;6.18-6.22&lt;/p&gt;
&lt;p&gt;HTTP是无状态协议，目的是让服务器更快处理大量事务，确保协议的可伸缩性。&lt;/p&gt;
&lt;p&gt;&lt;stro
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>exports与module.exports的区别</title>
    <link href="http://yoursite.com/2020/05/26/exports/"/>
    <id>http://yoursite.com/2020/05/26/exports/</id>
    <published>2020-05-26T02:20:58.000Z</published>
    <updated>2020-07-06T08:04:33.927Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h2><p>CommonJS加载模块是<strong>同步</strong></p><p><strong>知识点1</strong> Node中，一个js文件就是一个模块</p><p>引入：require(路径)，<strong>使用相对路径，必须以<code>.</code>或<code>..</code>开头</strong><br>引入模块以后，该函数会<strong>返回一个对象</strong>，这个对象代表的是引入的模块。</p><p>模块分成两大类：<br>核心模块：由node引擎提供的模块，核心模块的标识就是模块的名字<br>文件模块：由用户自己创建的模块，文件模块的标识为路径</p><p><strong>知识点2</strong>在Node中，<strong>每一个js文件中的js代码都是独立运行在一个函数体中</strong>。所以如果想要其他文件访问，必须要将数据暴露出来<br>暴露：exports.x = “xxxx”</p><pre><code>//当node在执行模块中的代码时，它首先在代码的最顶部，添加如下代码function(exports,require,module,__filename,__dirname){//里面才是自己写的name=XX}</code></pre><p>形参中</p><ul><li>exports：将变量或函数暴露到外部</li><li>require：用来引入外部的模块</li><li>module：代表当前模块本身</li><li>__filename：当前模块的完整路径</li><li>__dirname：当前模块所在文件夹的完整路径</li></ul><h3 id="exports与module-exports的区别"><a href="#exports与module-exports的区别" class="headerlink" title="exports与module.exports的区别"></a>exports与module.exports的区别</h3><p>本质上exports就是module的属性，module.exports===exports</p><ul><li>exports只能用.的方式来向外暴露内部变量，比如：exports.name = XXX</li><li>module.exports即可以通过.，也可以直接赋值暴露</li></ul><pre><code>//可以这样写module.exports = {}//错误写法exports = {}</code></pre><p>首先无论用<code>module.exports</code>还是<code>exports</code>都是改变的module的exports属性。</p><p>本质是exports与module.exports指向的是同一个对象。</p><pre><code>//module指向a空间let module = {};//在a空间中分配一块空间b给exportsmodule.exports =  {};//引用类型赋值，exports变量指向空间blet exports = module.exports//使用.赋值是ok的，相当于修改b空间里给name分配的c空间exports.name = &quot;xxx&quot;//使用直接赋值是不行的，因为引用类型在内存中存放的是指向数据的地址指针//直接赋值相当于修改的指针使其不在指向b，让指针指向别处。exports = {}</code></pre><p><img src="/img/node/export.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CommonJS规范&quot;&gt;&lt;a href=&quot;#CommonJS规范&quot; class=&quot;headerlink&quot; title=&quot;CommonJS规范&quot;&gt;&lt;/a&gt;CommonJS规范&lt;/h2&gt;&lt;p&gt;CommonJS加载模块是&lt;strong&gt;同步&lt;/strong&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Node" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/Node/"/>
    
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>npm包管理</title>
    <link href="http://yoursite.com/2020/05/25/npm%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2020/05/25/npm包管理/</id>
    <published>2020-05-25T14:40:46.000Z</published>
    <updated>2020-08-04T07:38:15.233Z</updated>
    
    <content type="html"><![CDATA[<p>NPM（Node Package Manager）<br>CommonJS包规范是理论（CommonJS的包规范 = 包结构+包描述文件），NPM是其中一种实践。<br>npm是Node.js的软件包管理，对于Node而言，NPM帮助其完成了第三方模板的发布、安装、依赖等。借助NPM，Node与第三方模块之间形成了很好的一个生态系统。</p><p>基本的操作：<br>查看版本：npm -v<br>搜索模块包：npm search 包名<br>安装包：npm install 包名 安装包并添加到依赖  （最好在要安装包的位置创建package.json文件）<br>        npm install 包名 -g 全局安装</p><p>初始化package.json:npm init (名字不用大写)<br>删除包：npm remove 包名</p><p>通过npm下载的包都在node_mudules文件夹中，直接通过包名即可引用。<br>node在使用模块名字来引入模块时，它会首先在当前目录的node_modules中寻找是否含有该模块，如果没有去上一级目录的node_modules中寻找，直到找到磁盘的根目录。</p><h3 id="问题1：全局安装与本地安装"><a href="#问题1：全局安装与本地安装" class="headerlink" title="问题1：全局安装与本地安装"></a>问题1：全局安装与本地安装</h3><p>npm install xxx # 本地安装<br>npm install xxx -g # 全局安装</p><p>本地安装</p><ol><li>将安装包放在 ./node_modules 下（运行npm时所在的目录）</li><li>可以通过 require() 来引入本地安装的包</li></ol><p>全局安装</p><ol><li>将安装包放在 /usr/local 下</li><li>可以直接在命令行里使用</li></ol><h3 id="问题2：-d与-s的区别"><a href="#问题2：-d与-s的区别" class="headerlink" title="问题2：-d与-s的区别"></a>问题2：-d与-s的区别</h3><p>npm install -d 就是npm install –save-dev<br>npm insatll -s 就是npm install –save</p><p>我们在使用npm install 安装模块或插件的时候，上述两种命令都可以把他们写入到 package.json 文件里面去。<br>首先dev是develop的简写，-save-dev安装的插件，被写入到 devDependencies 域里面去，<br>而使用 –save 或者默认没写 安装的插件，则是被写入到 dependencies区块里面去。devDependencies 里面的插件只用于开发环境，不用于生产环境，而dependencies是生产环境也就是项目运行在服务器需要的插件。</p><p>例子：比如我们写一个项目要依赖于jQuery，没有这个包的依赖运行就会报错，这时候就把这个依赖写入dependencies ；而我们使用的一些<strong>构建工具比如glup、webpack这些只是在开发中使用的包</strong>，上线以后就和他们没关系了，所以将它写入devDependencies。</p><h3 id="问题3：什么是npx"><a href="#问题3：什么是npx" class="headerlink" title="问题3：什么是npx"></a>问题3：什么是npx</h3><p>npm从5.2版本，增加了npx命令。npx主要作用是调用项目内部安装的模块和方法。<br>现在的工具包一般都安装在局部，而不是全局。</p><pre><code>//安装在开发环境的webpack-dev-servernpm install webpack-dev-server -D//命令行中启动webpack-dev-servernpx webpack-dev-server</code></pre><p>npx的原理是运行的时候会到<strong>node_modules/.bin路径和path里面，查看命令是否存在</strong>。</p><p>注意：Bash内置的命令不在Path中，所以类似cd的Bash命令不可以使用npx。</p><p>npx还可以运行一些需要全局安装的依赖（但不安装该依赖），npx将会把该依赖下载到一个临时目录，使用以后再删除，<strong>所以可以避免全局安装模块。</strong></p><p>可以在package.json中scripts属性中配置命令如”build”:webpack ,npm run build 实现npx同样的效果。</p><p>–no-install与–ignore-existing参数</p><p>–no-install:可以时npx强制使用本地模块，不下载远程模块，所以如果本地不存在该模块，就会报错。<br>–ignore-existing:可以使npx强制安装使用远程模块，忽略本地的同名模块。</p><p>-p参数用于指定npx所要安装的模块。</p><pre><code>//-p也可以省略npx -p node@0.12.8</code></pre><p><strong>总结</strong></p><ul><li>利用npx可以下载模块使用过后再删除的特点，可以在某些场景切换版本。</li><li>使用npx可以不需要全局安装依赖，较少使用本机的存储空间。</li><li>使用本地已安装的可执行工具，而不需要配置scripts。</li><li>可以执行依赖包中的命令，安装完成自动运行。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;NPM（Node Package Manager）&lt;br&gt;CommonJS包规范是理论（CommonJS的包规范 = 包结构+包描述文件），NPM是其中一种实践。&lt;br&gt;npm是Node.js的软件包管理，对于Node而言，NPM帮助其完成了第三方模板的发布、安装、依赖等。
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Node" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/Node/"/>
    
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>unexpected-token&lt; 报错</title>
    <link href="http://yoursite.com/2020/03/22/unexpected-token/"/>
    <id>http://yoursite.com/2020/03/22/unexpected-token/</id>
    <published>2020-03-22T06:13:48.000Z</published>
    <updated>2020-07-13T08:17:11.945Z</updated>
    
    <content type="html"><![CDATA[<p>因为团队信息的后台返回数据格式发生了变化，前端字段应该做相应变化。<br>改完之后，本地是没有问题的，打包上线到服务器之后发现了报错了<code>Uncaught SyntaxError: Unexpected token &lt;</code></p><p><img src="\img\软件超市\报错图.png" alt="报错图"></p><p>所以原因要么在服务器，要么就是打包的问题。</p><p>首先进行排查的是文档类型，因为报错的三行都是与js相关。<br>点击控制台错误的代码提示，查看<code>network</code>对应的文件加载状态,发现返回的不是<code>js</code>形式。而是<code>doctype html</code>,那么很大概率是服务器把<code>js</code>文件当作<code>html</code>响应，导致解析错误。正常情况返回<code>content-type:applocation/javascript</code>，而现在的错误情况<code>js</code>文档的响应信息，变成了<code>text/html</code></p><p><img src="\img\软件超市\文档类型错误.png" alt="文档类型错误"><br><img src="\img\软件超市\文档类型错误1.png" alt="文档类型错误1"></p><p>把上一个版本部署上去，发现没问题。那么排除了服务器的问题，应该是打包的问题。</p><p>确定是打包的问题之后查看<code>config/index.js</code>,找到了原因。</p><p><img src="\img\软件超市\打包路径.png" alt="打包路径"></p><p>默认的是在路径前面添加/,但是此项目的路由设置了所有路径都会跳转到/manage/xx,所以需要在修改assetPublicPath属性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为团队信息的后台返回数据格式发生了变化，前端字段应该做相应变化。&lt;br&gt;改完之后，本地是没有问题的，打包上线到服务器之后发现了报错了&lt;code&gt;Uncaught SyntaxError: Unexpected token &amp;lt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img s
      
    
    </summary>
    
      <category term="project" scheme="http://yoursite.com/categories/project/"/>
    
    
      <category term="软件超市" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82/"/>
    
  </entry>
  
  <entry>
    <title>XHR的ajax封装(简单版本)</title>
    <link href="http://yoursite.com/2020/03/01/XHR%E7%9A%84ajax%E5%B0%81%E8%A3%85/"/>
    <id>http://yoursite.com/2020/03/01/XHR的ajax封装/</id>
    <published>2020-03-01T07:23:33.000Z</published>
    <updated>2020-07-09T08:16:05.302Z</updated>
    
    <content type="html"><![CDATA[<p>目的:熟练XHR的基本使用</p><p><strong>特点</strong><br>1.函数的返回值为promise，成功的结果为response，失败的结果为error<br>2.能处理多种类型的请求：GET/POST/PUT/DELETE<br>3.函数的参数为一个配置对象</p><pre><code>    {    url:&quot;&quot;,//请求地址    method:&quot;&quot;,//请求方式    params:{},//GRT/DELETE请求的query参数    data:{},//POST或DELETE请求的请求体参数    }</code></pre><p>4.响应json数据自动解析为js<br>5.response只实现了data，status，statusText<br>6.put请求提交的是请求体参数，delete提交query参数</p><p><strong>补充</strong><br>1.query，params，body<br>    req.params,req.query是用在get请求当中<br>    query参数<br>    返回值：对数据过滤产生一个新数组<br>    param参数:常用于REST API风格</p><pre><code>localhost:3000/posts?id=1</code></pre><p>  返回值：定位到对应的对象<br>  返回值：定位到对应的对象</p><pre><code>localhost:3000/posts/1</code></pre><p>  req.body是用在post请求中的，body 不是 nodejs 默认提供的，你需要载入 body-parser 中间件才可以使用，req.body此方法通常用来解析 POST 请求中的数据。</p><p>2.OPTIONS请求，预检查（get不需要）是否跨域等，没有响应体。</p><p><strong>注意</strong>:<br>1.axios的params是指定get或者delete请求的query参数（拼接在url后面）<br>2.发送json格式请求体参数，需要设置请求头</p><pre><code>function axios({    url,    method=&quot;GET&quot;, //设置默认值    parmas={},//默认空对象    data={}//设置默认值  }) {    //返回一个Promise对象    return new Promise((resolve, reject) =&gt; {        //处理query参数，拼接到url        let queryString=&#39;&#39;        for (key in params){            queryString+=`${key}=${parmas[key]}&amp;`        }        if (queryString){            //去掉最后的&amp;           queryString = queryString.substring(0,queryString.length-1)           //拼接           url += &quot;?&quot;+queryString        }        //处理method为大写        method = method.toUpperCase()    //1.执行异步ajax请求        //创建xhr对象        const request = new XMLHttpRequest();        //初始化请求(异步)        request.open(method,url,true)        //绑定状态改变的监听,send是异步的，所以绑定监听写在send后面也可以        request.onreadystatechange = function () {            //如果请求没有完成，直接结束            if (request.readyState!==4){                return            }        }        switch (method){            case &quot;GET&quot;||&quot;DELETE&quot; :                //get的参数通过url传                request.send();                break;            case &quot;POST&quot;||&quot;PUT&quot;:                //发送请求                // post请求的data不能是对象需要是字符串                //发送JSON格式，需要加请求头                request.setRequestHeader(&quot;Content-Type&quot;,&quot;application/json;charset=utf&quot;)//告诉服务器请求体的格式是json                request.send(JSON.stringify(data))                break;        }        //如果响应状态码在【200，300)之间代表成功，否则失败     const {status,statusText} = request     if (status&gt;=200&amp;&amp;status&lt;=299){         //2.1如果请求成功了，调用resolve()         //准备结果response对象         const response = {             //服务器返回的是JSON数据需要转换成对象             //响应json数据自动解析为js的对象/数组             data:JSON.parse(request.response),             status,             statusText,         }            resolve(response)     }else {         //2.2如果请求失败,调用reject()         reject(new Error(`request error status is ${status}`))     }    })}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目的:熟练XHR的基本使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;br&gt;1.函数的返回值为promise，成功的结果为response，失败的结果为error&lt;br&gt;2.能处理多种类型的请求：GET/POST/PUT/DELETE&lt;br&gt;3.函数的参数为一个
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="库" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E5%BA%93/"/>
    
    
      <category term="ajax" scheme="http://yoursite.com/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>axios</title>
    <link href="http://yoursite.com/2020/02/27/axios/"/>
    <id>http://yoursite.com/2020/02/27/axios/</id>
    <published>2020-02-27T13:34:38.000Z</published>
    <updated>2020-07-06T07:59:18.626Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP相关"><a href="#HTTP相关" class="headerlink" title="HTTP相关"></a>HTTP相关</h2><p>交互的基本过程</p><p>客户端 ===》（请求行，请求头，请求体）服务器<br>服务器 ===》（状态行，响应头，响应体）客户端</p><p><strong>请求报文</strong><br>请求行：method url<br>多个请求头：host主机，cookie，Content-Type(请求体的内容类型)application/json 或者 application/x-<a href="http://www.form.urlencoded" target="_blank" rel="noopener">www.form.urlencoded</a><br>请求体（get请求没有）：{“username”:”tom”,”pwd”:123} 或者 username=tom&amp;pwd=123</p><p><strong>响应报文</strong><br>状态行：status statusText<br>多个响应头：Content-Type(响应体的内容类型):text/html;charset=uft-8   Set-Cookie:BD_CK_SAM=1;path=/<br>响应体：html 文本/json 文本/js/css/图片…</p><p><strong>post请求体参数格式</strong><br>Content-Type:application/x-<a href="http://www.form.urlencoded" target="_blank" rel="noopener">www.form.urlencoded</a><br>例如：username=tom&amp;pwd=123</p><p>Content-Type:application/json<br>例如：{“username”:”tom”,”pwd”:123}</p><p>Content-Type:multipart/form-data<br>用于文件上传请求</p><p><strong>常见的响应状态码</strong><br>200 ok  请求成功，一般用于GET与POST请求<br>201 created 已创建。成功请求并创建了新的资源<br>401 Unauthorized 未到授权/请求要求用户的身份认证<br>404 Not Found 服务器无法根据客户端的请求找资源<br>500 Internal Serve Error 服务器内部错误，无法完成请求</p><p><strong>常用请求类型</strong></p><p>GET:从服务器端读取数据<br>POST:向服务器端添加新数据<br>PUT:更新服务器端已有数据<br>DELETE:删除服务器端数据</p><p><strong>API的分类</strong><br>1.REST API: restful</p><ul><li>发送请求进行操作由请求方式决定</li><li>同一个请求路径可以进行多个操作（如同一个路径的get、delete）</li><li>请求方式会用到GET/POST/PUT/DELETE<br>2.非REST API restless</li><li>请求方式不决定请求的操作</li><li>一个请求路径只能对用一个操作</li><li>一般只有GET/POST</li></ul><p>json-server工具包可快速搭建REST API</p><h2 id="XHR的理解和使用"><a href="#XHR的理解和使用" class="headerlink" title="XHR的理解和使用"></a>XHR的理解和使用</h2><p>XHR对象可以从URL获取数据，而<strong>无需让整个页面刷新</strong></p><p>一般的http请求与ajax请求<br>1.ajax请求是一种特别的http请求<br>2.对服务端来说，没有任何区别，区别在浏览器端<br>3.浏览器端发请求：只有XHR或fetch发出的才是ajax请求<br>4.浏览器端接收响应：<br>    一般请求：浏览器一般会直接显示响应体数据，也就是我们常说的刷新/跳转页面<br>    ajax请求：浏览器不会对界面进行任何更新操作，只是调用监视的回调函数并传入响应相关数据。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>XHR对象的属性：<br>XMLHttpRequest():创建XHR对象的构造函数<br>readyState（请求的状态）：<br>    0：初始<br>    1：open()之后<br>    2：send()之后<br>    3：请求中<br>    4：请求完成<br>onreadystatechange：绑定readyState改变的监听<br>responseType:指定响应数据类型，如果是’json’,得到响应后自动解析响应体数据<br>response：响应体数据，类型取决于responseType<br>open(method，url[,async]):初始化一个请求,默认async：true<br>send(data)：发送请求<br>abort()：中断请求<br>getResponseHeader(name)：获取指定名称的响应头值<br>getAllResponseHeaders():获取所有响应头组成的字符串<br>setResponseHeaders(name,value):设置请求头<br>status：由服务器返回的HTTP状态代码<br>statusText：由服务器返回的HTTP状态文本</p><h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><p>ajax技术的核心是XMLHttpRequest对象(简称XHR)，</p><blockquote><p><a href="https://biubiuins.github.io/2020/03/01/XHR%E7%9A%84ajax%E5%B0%81%E8%A3%85/" target="_blank" rel="noopener">XHR的ajax简单封装</a></p></blockquote><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p>axios的post请求头默认是<code>application/x-www-form-urlencoded</code>,如果data是对象,默认Json。<br>axios请求的方式可以通过函数axios(config)使用，也可以通过对象axios.get()使用</p><p><strong>特点</strong><br>1.基于promise的异步ajax请求库（基于promise的 HTTP 库）<br>2.浏览器端/node端都可以使用<br>3.支持请求/响应拦截器<br>4.支持请求取消<br>5.请求/响应数据转换<br>6.批量发送多个请求</p><h3 id="axios-create-config"><a href="#axios-create-config" class="headerlink" title="axios.create(config)"></a>axios.create(config)</h3><p>自定义配置新建一个新的axios实例，新axios只是没有取消请求和批量发请求的方法，其他所有语法都是一致的。</p><pre><code> const instance = axios.create({        baseURL:&quot;http://localhost:3000&quot;    })    //使用instance发请求    instance({        url:&quot;/posts&quot; //请求端口3000    })</code></pre><p>这个语法的用处：<br>    需求：项目中有部分接口需要的配置与另一部分接口需要的配置不太一样<br>    解决：创建2个新的axios，每个都有自己特有的配置，分别应用到不同要求的接口请求中</p><pre><code>   axios.default.baseURL = &quot;http://localhost:4000&quot;    axios({        url:&quot;/posts&quot; //请求的端口4000    })    const instance = axios.create({        baseURL:&quot;http://localhost:3000&quot;    })    //使用instance发请求    instance({        url:&quot;/posts&quot; //请求端口3000    })</code></pre><h3 id="axios的处理链流程"><a href="#axios的处理链流程" class="headerlink" title="axios的处理链流程"></a>axios的处理链流程</h3><p><strong>axios拦截器</strong></p><p>请求拦截器<br>axios.interceptor.request.use(callback)<br>响应拦截器<br>axios.interceptor.response.use(callback)</p><pre><code>   axios.interceptors.request.use(config=&gt;{        console.log(&quot;request interceptor1 &quot;);        //拦截请求，处理请求之后，必须要返回该配置，若不返回相当于axios请求没有添加配置        return config    },error=&gt;{        console.log(&quot;request interceptor1 err&quot;);        return Promise.reject(error)    })    axios.interceptors.request.use(config=&gt;{        console.log(&quot;request interceptor2 &quot;);        return config    },error=&gt;{        console.log(&quot;request interceptor2 err&quot;);        return Promise.reject(error)    })    axios.interceptors.response.use(response=&gt;{        console.log(&quot;response interceptor1 &quot;);        return response    },error=&gt;{        console.log(&quot;response interceptor1 err&quot;);        return Promise.reject(error)    })    axios.interceptors.response.use(response=&gt;{        console.log(&quot;response interceptor2 &quot;);        //拦截response结果处理之后，要返回结果        return response    },error=&gt;{        console.log(&quot;response interceptor2 err&quot;);        return Promise.reject(error)    }) axios.get(&quot;http://localhost:/posts&quot;).then(response =&gt;{     console.log(&quot;response data&quot;); }).catch(error=&gt;{     console.log(&quot;response error&quot;); }) /* 输出request interceptor2request interceptor1response interceptor1 errresponse interceptor2 errresponse error */</code></pre><p>注意点：<br>1.请求拦截器后添加先执行。<br>2.拦截请求，处理请求之后，必须要返回该配置，若不返回相当于axios请求没有添加配置<br>3.拦截response结果处理之后，要返回结果。</p><h3 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h3><p>应用场景:如果发送请求2的时候，发现请求1还没有完成则取消请求1</p><pre><code>let cancel //保存用于取消请求的函数function getProducts1(){    if (typeof cancel === &quot;function&quot;){        //需要使用取消请求时调用        //如果请求取消了，则该请求进入请求失败的流程，请求失败的error是Cancel对象类型，Cancel里面有message属性        cancel(&quot;这里可以传消息提示&quot;)    }    axios.get(&quot;/user&quot;,{        cancelToken:new axios.CancelToken(            //执行器回调，同步进行            c =&gt; {//c是用于取消当前请求的函数                cancel = c            }        )    }).then(response =&gt;{        cancel = null //如果请求完成就不要取消请求了    },error =&gt;{        if (axios.isCancel(error)){            // 取消请求            console.log(&quot;请求取消了&quot;,error.message);        }        else{            //请求本身出错            cancel = null            console.log(error);        }    })}function getProducts2(){    if (typeof cancel === &quot;function&quot;){  cancel(&quot;这里可以传消息提示&quot;)    }    axios.get(&quot;/user/1&quot;,{        cancelToken:new axios.CancelToken(            c =&gt; {cancel = c}        )    }).then(response =&gt;{        cancel = null    },error =&gt;{        if (axios.isCancel(error)){            console.log(&quot;请求取消了&quot;,error.message);        }        else{            cancel = null            console.log(error);        }    })}</code></pre><p>改进版本</p><pre><code> //添加请求拦截器 axios.interceptors.request.use(config=&gt;{     if (typeof cancel === &quot;function&quot;){         cancel(&quot;这里可以传消息提示&quot;)     }     config.cancelToken =new axios.CancelToken(         c =&gt; {             cancel = c         }     )     return config }) //添加响应拦截器axios.interceptors.response.use(    respose=&gt;{        cancel = null        return respose    },    error =&gt;{            if (axios.isCancel(error)){                console.log(&quot;请求取消了&quot;,error.message);                //中断promise链接                return new Promise(()=&gt;{})            }            else{                cancel = null                //将错误继续向下传递               // throw error                return Promise.reject(error)            }})let cancelfunction getProducts1(){    axios.get(&quot;/user&quot;).then(response =&gt;{         //其他数据响应    },error =&gt;{       //只需要处理请求失败    })}function getProducts2(){    axios.get(&quot;/user/1&quot;).then(response =&gt;{        //其他数据响应    },error =&gt;{        //只需要处理请求失败    })}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HTTP相关&quot;&gt;&lt;a href=&quot;#HTTP相关&quot; class=&quot;headerlink&quot; title=&quot;HTTP相关&quot;&gt;&lt;/a&gt;HTTP相关&lt;/h2&gt;&lt;p&gt;交互的基本过程&lt;/p&gt;
&lt;p&gt;客户端 ===》（请求行，请求头，请求体）服务器&lt;br&gt;服务器 ===》（状态
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="库" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E5%BA%93/"/>
    
    
      <category term="ajax" scheme="http://yoursite.com/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>Node.js（3.28更新）</title>
    <link href="http://yoursite.com/2020/02/25/node-js/"/>
    <id>http://yoursite.com/2020/02/25/node-js/</id>
    <published>2020-02-25T06:49:46.000Z</published>
    <updated>2020-07-09T08:13:55.752Z</updated>
    
    <content type="html"><![CDATA[<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>Node.js是能够在<strong>服务器端</strong>运行JavaScript的开放源代码、跨平台JavaScript<strong>运行环境</strong></p><ul><li>Node是对ES标准一个实现，Node也是一个JS引擎</li><li>通过Node可以使js代码在服务器端执行</li><li>Node仅仅对ES标准进行了实现，所以在Node中不包含DOM和BOM</li><li>Node中可以使用所有的内建对象（String Number Boolean Math Date RegExp Function Object Array）而BOM（操作浏览器）和DOM（文档对象模型）都不能使用，但是可以用console也可以用定时器</li><li>Node可以在后台来编写服务器，Node服务器都是单线程的服务器。</li></ul><p>补充：<br>1.node中有一个全局对象global，它的作用和网页中window类似，在全局创建的变量/方法都会作为global的属性/方法保存<br>2.代码风格：建议无论有分号代码或者无分号代码，都建议如果一<code>（</code>、<code>[</code>、<code>\`</code>开头，最好都在前面补上一个分号。</p><h2 id="Buffer（缓存区）"><a href="#Buffer（缓存区）" class="headerlink" title="Buffer（缓存区）"></a>Buffer（缓存区）</h2><p>Buffer的结构和数组很像，操作的方法也和数组类似。数组中不能存储二进制的文件，而Buffer专门用来存储二进制数据(图片/mp3/视频 二进制文件)</p><p>使用：buffer不需要引入模块，直接使用即可</p><p><strong>常用操作</strong><br>Buffer.from(str[,encoding])</p><ul><li>str 需要编码的字符串</li><li>encoding 默认’utf8’<br>把字符串转换成二进制,buffer中每个元素的范围从00-ff（8bit）,如果要转换成字符串用<code>toString()</code></li></ul><p>Buffer.length<br>Buffer占用的内存大小</p><p>Buffer.alloc(size[, fill[, encoding]])</p><ul><li>size，分配的内存长度</li><li>fill，用于预填充新Buffer的值，默认值：0</li><li>encoding，如果fill是一个字符串，则这是它的字符编码，默认’utf8’</li></ul><pre><code>//创建一个10个字节的bufferlet buf = Buffer.alloc(10)//通过索引，来操作buf中的元素buf[0] = 88</code></pre><p>注意：Buffer的大小一旦确定，则不能在修改，因为Buffer是对内存的直接操作<br>      只要数字在控制台或页面中输出一定是10进制<br>      如果要16进制输出，number的toString(进制)里面可以传参。</p><pre><code>  ```   let buf = Buffer.alloc(10)   buf[1]=0xaa;   console.log(buf[1].toString(16));   //输出aa  ```</code></pre><p> Buffer.allocUnsafe(size)<br> 创建一个指定大小的buffer，但是buffer中可能含有敏感数据（分配空间并没有预设默认值0）</p><h2 id="fs（文件系统）"><a href="#fs（文件系统）" class="headerlink" title="fs（文件系统）"></a>fs（文件系统）</h2><p>文件系统简单来说就是通过Node来操作系统的文件。服务器的本质就是将本地的文件发送给远程的客户端。<br>fs模块中所有的操作都有同步和异步两种形式选择，同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码，异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回。</p><p>使用：使用文件系统，需要先引入fs模块，fs是核心模块，直接用名字引入不需要下载。</p><h3 id="同步-异步文件写入"><a href="#同步-异步文件写入" class="headerlink" title="同步/异步文件写入"></a>同步/异步文件写入</h3><p>同步的文件的写入：<br>1.打开文件  fs.openSync(path[, flags, mode])</p><pre><code>- path 打开文件的路径- flags 打开文件要做的操作的类型 默认&#39;r&#39;- mode 设置文件的操作权限，一般不传返回值：该方法会返回一个文件的描述符作为结果，我们可以通过该描述符对文件进行各种操作</code></pre><p>2.向文件中写入内容 fs.writeSync(fd, buffer[, offset[, length[, position]]])</p><pre><code>- fd 文件的描述符，需要传递要写入的文件的描述符- buffer 要写入的内容- offset 写入的位置</code></pre><p>3.保存并关闭文件 fs.closeSync(fd)</p><pre><code>let fs = require(&quot;fs&quot;)//打开文件let fd = fs.openSync(&quot;hello.txt&quot;,&quot;w&quot;)//向文件中写入内容console.log(fd);fs.writeSync(fd,&quot;hello&quot;)//保存并关闭文件fs.closeSync(fd)</code></pre><p>异步方法(不可能有返回值):<br>1.打开文件  fs.open(path[, flags[, mode]], callback)</p><p>，结果是通过回调函数返回的,回调函数路两个参数。</p><pre><code>- err 错误对象，如果没有错误则为null（js的设计思想，错误优先）- fd 文件描述符</code></pre><p>2.向文件中写入内容 fs.write(fd, buffer[, offset[, length[, position]]], callback）<br>3.关闭文件 fs.close(fd, callback)</p><pre><code>let fs = require(&quot;fs&quot;)//打开文件fs.open(&quot;hello.txt&quot;,&quot;w&quot;,function (err,fd) {   if (!err) {       console.log(&quot;打开成功&quot;);        //向文件中写入内容        fs.write(fd,&quot;这是异步写入的内容&quot;,function (err) {        if (!err){           console.log(&quot;写入成功&quot;);       }       //关闭文件            fs.close(fd, function (err) {                console.log(&quot;文件关闭&quot;);            })   })   }    else console.log(err);})</code></pre><h3 id="常用-简单的文件写入"><a href="#常用-简单的文件写入" class="headerlink" title="(常用)简单的文件写入"></a>(常用)简单的文件写入</h3><p>fs.writeFile(file, data[, options], callback)</p><ul><li>file 要操作的文件的路径</li><li>data 要写入的数据</li><li>options 选项，可以对写入进行一些设置</li><li>callback 当写入完成以后执行的函数</li></ul><pre><code>const fs = require(&quot;fs&quot;)fs.writeFile(&quot;hello.text&quot;,&quot;这是通过writeFile写入的内容&quot;,function (err) {    if (!err){        console.log(&quot;写入成功&quot;);    }})</code></pre><p><strong>文件打开常用模式：</strong><br>w：写入文件，如果不存在则创建，文件写入默认从头开始写会覆盖文件。<br>r+:读写文件，写操作时会覆盖，文件不存在则出现异常。<br>w+:读写文件，文件不存在先创建，会覆盖。<br>a: 写入文件，打开文件用于追加，如果不存在则新建。<br>a+：读写文件，文件不存在先建立，追加<br>r：读取文件，文件不存在则出现异常<br>rb/wb：分别与r/w相似，但是用于读写二进制文件</p><h3 id="流式文件写入"><a href="#流式文件写入" class="headerlink" title="流式文件写入"></a>流式文件写入</h3><p>同步、异步、简单文件的写入都不适合大文件的写入（只要写一次），性能较差，容易导致内存溢出。<br>只要流存在，可以分多次写入。</p><p>创建一个可写流：fs.createWriteStream(path,[,options])</p><pre><code>  - path：文件路径  - options 配置的参数  - 有返回值，该方法会返回一个文件的描述符作为结果，我们可以通过该描述符对文件进行各种操作</code></pre><pre><code>const fs = require(&quot;fs&quot;)//流失文件写入//创建一个可写流let ws = fs.createWriteStream(&quot;hello.txt&quot;)//可以通过监听流的open和close事件来监听流的打开和关闭ws.once(&quot;open&quot;,function () {    //open只会触发一次，on绑定了事件会一直存在，所以用once绑定一次性事件。    console.log(&quot;已经打开流&quot;);})ws.once(&quot;close&quot;,function () {    console.log(&quot;流关闭&quot;);})ws.write(&quot;写入成功&quot;)ws.write(&quot;哈哈哈哈&quot;)ws.write(&quot;写入成功&quot;)ws.write(&quot;哈哈哈哈&quot;)//关闭流，关闭的接收方，ws.close()</code></pre><h3 id="文件的读取"><a href="#文件的读取" class="headerlink" title="文件的读取"></a>文件的读取</h3><p>操作基本上和文件的写入差不多，具体看API。<br>注意：<br>1.读取到的数据会返回一个Buffer<br>2.如果要读取一个可读流中的数据，必须要为可读流绑定一个data事件，data事件绑定完毕，它会自动开始读取数据，读取完毕后可读流自动关闭</p><pre><code>const fs = require(&quot;fs&quot;)//流失文件读取，可以分多次将文件读取到内存中//创建一个可读流let rs = fs.createReadStream(&quot;消息提醒.png&quot;)//创建一个可写流let ws = fs.createWriteStream(&quot;xxx.png&quot;)//可以通过监听流的open和close事件来监听流的打开和关闭rs.once(&quot;open&quot;,function () {    console.log(&quot;已经打开流&quot;);})rs.once(&quot;close&quot;,function () {    console.log(&quot;流关闭&quot;);    //读取完毕后可读流自动关闭，所以在这个时候关闭可写流    ws.close()})//如果要读取一个可读流中的数据，必须要为可读流绑定一个data事件，data事件绑定完毕，它会自动开始读取数据，读取完毕后自动关闭rs.on(&quot;data&quot;,function (data) {    console.log(data);    ws.write(data);    //ws.close()，可能导致只读了一条数据就关闭})</code></pre><p><strong>pipe()</strong><br>更简单的写法pipe(),<code>rs.pipe(ws)</code>在可读流rs与可写流ws之间架起一个管道，自动将可读流中的内容，直接输出可写流。</p><h3 id="fs其他常用方法"><a href="#fs其他常用方法" class="headerlink" title="fs其他常用方法"></a>fs其他常用方法</h3><p>验证路径是否存在  fs.existsSync(path)   返回值：存在true，不存在false<br>获取文件状态  fs.stat(path,callback)/fs.statSync(path) 返回对象：文件的状态<br>删除文件  fs.unlink(path,callback)/fs.unlinkSync(path)<br>读取一个目录的目录结构 fs.readdir(path[,options],callback)/fs.readdirSync(path[,options]) 返回一个字符串数组，每一个元素就是一个文件夹或文件的名字<br>截断文件  fs.truncate(path,len,callback)/fs.truncateSync(path,len)   将文件修改成指定的len大小（一个汉字3个字节）<br>创建文件夹  fs.mkdir(path[,mode],callbcak)/fs.mkdirSync(path[,mode])<br>删除文件夹  fs.rmdir(path,callbcak)/fs.rmdirSync(path)<br>重命名文件/剪贴文件 fs.rename(oldPath(oldName),newPath,callback)/fs.renameSync(oldPath,newPath)<br>监视文件的修改 fs.watchFile(filename[,options],listener)  listener回调函数，当文件发生变化时，回调函数会执行。</p><h2 id="ip地址和端口号"><a href="#ip地址和端口号" class="headerlink" title="ip地址和端口号"></a>ip地址和端口号</h2><ul><li>ip地址用来定位计算机</li><li>端口号用来定位具体的应用程序</li><li>一切需要联网通信的软件都会占用一个端口号</li><li>端口号的范围从0-65536</li><li>在计算中有写一些默认端口号，最好不要去使用。如：http服务的80</li></ul><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>request 请求事件处理函数，需要接收两个参数：request，response。</p><pre><code>const http = require(&quot;http&quot;)const server = http.createServer()server.on(&quot;request&quot;,function (request,response) {    console.log(&quot;请求路径是&quot; + request.url);    //在服务端默认发送的数据，其实是utf8编码的内容    //但是浏览器不知道是utf8的内容，在不知道服务器响应内容的编码的情况下会按照当前操作系统默认编码解析   //text/plain;普通文本    //response对象有一个方法：write可以用来给客服端发送响应数据；    //write可以使用多次，但最后一定要使用end来结束响应，否则客服端会一致等待    //响应的数据只能是二进制(默认)或字符串    fs.readFile(xxx,function(err,data){    response.setHeader(&#39;Content-type&#39;,&quot;text/html;charset=utf-8&quot;)    response.end(data)    })    }})server.listen(3000,function () {    console.log(&quot;服务器启动成功&quot;);})</code></pre><h2 id="url"><a href="#url" class="headerlink" title="url"></a>url</h2><p>url：统一资源定位符，url核心模块在为我们解析url地址时提供了非常方便的API<br>url.parse()方法可以解析一个url地址，通过传第二个参数(true)把包含有查询字符串的query转化成对象</p><pre><code>const url = require(&quot;url&quot;)let httpUrl = &quot;https://sale.vmall.com/hwmate.html#abc?cid=10602&quot;let urlObj = url.parse(httpUrl)console.log(urlObj);//Url {//   protocol: &#39;https:&#39;, 协议//   slashes: true,//   auth: null,//   host: &#39;sale.vmall.com&#39;,  主机//   port: null, 端口号//   hostname: &#39;sale.vmall.com&#39;,//   hash: &#39;#abc?cid=10602&#39;,//   search: &#39;?cid=10602&#39;, 查找的内容//   query: &#39;cid=10602&#39;,  query问号后面的内容//   pathname: &#39;/hwmate.html&#39;, 路径的名称//   path: &#39;/hwmate.html?cid=10602&#39;,//   href: &#39;https://sale.vmall.com/hwmate.html?cid=10602&#39; }</code></pre><p>url.resolve()方法合成url，第一个参数基url，第二个参数目标url</p><pre><code>const url = require(&quot;url&quot;)let targetUrl=&quot;http://www.taobao.com/&quot;let httpUrl = &quot;./xxx.html&quot;console.log(url.resolve(targetUrl, httpUrl));//自动去掉.///http://www.taobao.com/xxx.html</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h2&gt;&lt;p&gt;Node.js是能够在&lt;strong&gt;服务器端&lt;/strong&gt;运行JavaScript的开放源代码、跨平台JavaScript&lt;stron
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Node" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/Node/"/>
    
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>闭包</title>
    <link href="http://yoursite.com/2020/02/23/%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2020/02/23/闭包/</id>
    <published>2020-02-23T08:48:04.000Z</published>
    <updated>2020-07-30T10:43:48.167Z</updated>
    
    <content type="html"><![CDATA[<p>ES5时，有个经典的需求：点击某个按钮，提示”点击的是第n个按钮”</p><pre><code>//html&lt;button&gt;测试1&lt;/button&gt;&lt;button&gt;测试2&lt;/button&gt;&lt;button&gt;测试3&lt;/button&gt;//js  var btns = document.getElementsByTagName(&quot;button&quot;);   //遍历加监听   for (var i = 0;i&lt;btns.length;i++) {   var btn = btns[i];    btn.onclick =function () {      alert(i)        }</code></pre><p>这里有个关于效率的问题,btns是伪数组，for循环中btns.length每次都要计算一遍才能得到结果，这里循环就会计算多次。改进之后的代码:</p><pre><code>  var btns = document.getElementsByTagName(&quot;button&quot;);   //遍历加监听   for (var i = 0,length=btns.length;i&lt;length;i++) {   var btn = btns[i];    btn.onclick =function () {      alert(i)        }    }</code></pre><p>但是点击按钮之后发现每个按钮都打印的3。<strong>因为点击之后的函数是回调函数，需要放在宏队列中执行</strong>，而for循环已经执行结束(i已经等于3了)</p><p>ES6之前的解决办法：<br>解决办法1：将btn所对应的下标保存在btn上</p><pre><code> var btns = document.getElementsByTagName(&quot;button&quot;);   //遍历加监听   for (var i = 0,length=btns.length;i&lt;length;i++) {   var btn = btns[i];   btn.index = i    btn.onclick =function () {      alert(this.index)        }    }</code></pre><p>解决办法2:闭包 </p><pre><code>    var btns = document.getElementsByTagName(&quot;button&quot;);     for (var i = 0;i&lt;btns.length;i++) {         var btn = btns[i];         (function (i) {//这i是局部的             btn.onclick = function () {                 alert(i)             }         })(i)//这个i是全局i     }</code></pre><p>问题1:如何产生闭包？<br>当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时，就产生了闭包。</p><p>问题2：闭包到底是什么?<br>(用chrome调试查看)<br>闭包是嵌套的内部函数<br>注意:闭包存在于嵌套函数的内部函数中</p><p>问题3：产生闭包的条件<br>1.函数嵌套<br>2.内部函数引用了外部函数的数据</p><p>函数定义时就会产生闭包，调用一次外部函数产生一个新的闭包。做闭包的题的时候仔细分析哪个变量导致闭包且是否有新的闭包产生。</p><h2 id="常见的闭包"><a href="#常见的闭包" class="headerlink" title="常见的闭包"></a>常见的闭包</h2><p>1.将函数作为另一个函数的返回值</p><pre><code>function fn1() {    var a = 2  function fn2() {    a++;    console.log(a);  }//仅一个闭包  return fn2}//f指向了fn2的函数对象(局部变量fn2已经不在了，因为fn2不在闭包里面)，这也是闭包一直存在的原因var f = fn1()//已经产生了闭包，执行完后，a还在f()//3f()//4</code></pre><p>局部函数调用时存在，调用结束消失。<br>外部函数执行几次，就产生几个闭包。所以此例子只产生了一个闭包。</p><p>2.将函数作为实参传递给另一个函数调用</p><pre><code>function showDelay(msg,time) {    //setTimeout()是在执行这个函数    setTimeout(function () {//闭包是在定义内部函数时生成的        alert(msg)//回调函数是内部函数，且用了外部函数的msg值    },time)}showDelay(&quot;xxx&quot;,2000) //产生了闭包</code></pre><h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><p>(又想隐藏，又想使用)</p><ul><li>使用函数内部的变量在函数执行完后，仍然存活在内存中(延长了局部变量的生命周期)</li><li>让函数外部可以操作(读写)到函数内部的数据</li></ul><h2 id="闭包的生命周期"><a href="#闭包的生命周期" class="headerlink" title="闭包的生命周期"></a>闭包的生命周期</h2><p>产生：在嵌套内部函数定义执行完成时就产生了(不是在调用)<br>死亡：在嵌套的内部函数成为垃圾对象时</p><pre><code>function fn1() {    var a = 2//此时闭包就已经产生了(函数提升，内部函数对象已经创建了)  function fn2() {    a++;    console.log(a);  }  return fn2}var f = fn1()f = null //闭包死亡(包含闭包的函数对象成为垃圾对象)</code></pre><h2 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h2><p>1.定义JS模块</p><ul><li>具有特定功能的JS文件</li><li>将所有的数据和功能都封装在函数内部（私有的）//对象的属性外部直接可以见，所以封装在对象里不算私有</li><li>只向外暴露一个包含n个方法的对象或函数</li></ul><pre><code>//module.jsfunction myModule(){//私有数据var msg = &quot;xxx&quot;function doSomething(){ console.log(&quot;doSomething&quot;+msg.toUpperCase())}function doOtherthing(){ console.log(&quot;doOtherthing&quot;+msg.toLowerCase())}//向外暴露对象return{doSomething,doOtherthing}}}//其他界面调用时，需要一个函数来接收</code></pre><p>匿名函数自调用</p><pre><code>//module2.js(function myModule(window){//私有数据var msg = &quot;xxx&quot;function doSomething(){ console.log(&quot;doSomething&quot;+msg.toUpperCase())}function doOtherthing(){ console.log(&quot;doOtherthing&quot;+msg.toLowerCase())}//向外暴露对象window.module2 = {doSomething,doOtherthing}})(window)//其他界面调用时，直接module2.doSomethig</code></pre><h2 id="闭包的缺点及解决"><a href="#闭包的缺点及解决" class="headerlink" title="闭包的缺点及解决"></a>闭包的缺点及解决</h2><p>缺点：<br>函数执行完后，函数内的局部变量没有释放，占用内存时间会变长。(容易造成内存泄漏)<br>解决：<br>能不用闭包就不用，及时释放（让内部函数称为垃圾对象–&gt;回收闭包）</p><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p>一种程序运行出现的错误。<br>当程序运行需要的内存超过了剩余的内存时，就会抛出溢出的错误。</p><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>占用的内存没有及时释放就是内存泄露，内存泄漏积累多了就容易导致内存溢出。<br>常见的内存泄漏：意外的全局变量，没有及时清理的计时器（如启动循环定时器后不清理）或回调函数，闭包。</p><pre><code>let intervalId = setInterval(function(){//启动循环定时器后不清理 console.log(&quot;---&quot;)},1000)//清除定时器clearInterval(intervalId)</code></pre><p><strong>面试题</strong></p><pre><code>var name = &quot;The Window&quot;;var object = {    name:&quot;My object&quot;,    getNameFunc : function () {        return function () {            return this.name;        }    }}console.log(object.getNameFunc()());//The Window var name = &quot;The Window&quot;;var object = {    name:&quot;My object&quot;,    getNameFunc : function () {        var that = this        return function () {            return that.name; //that等于的this是 调用了getNameFunc的对象        }    }}console.log(object.getNameFunc()());//My object</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ES5时，有个经典的需求：点击某个按钮，提示”点击的是第n个按钮”&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//html
&amp;lt;button&amp;gt;测试1&amp;lt;/button&amp;gt;
&amp;lt;button&amp;gt;测试2&amp;lt;/button&amp;gt;
&amp;lt;button&amp;gt;测
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>回调函数</title>
    <link href="http://yoursite.com/2020/02/23/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2020/02/23/回调函数/</id>
    <published>2020-02-23T04:46:00.000Z</published>
    <updated>2020-07-22T14:42:57.115Z</updated>
    
    <content type="html"><![CDATA[<p>一直都知道回调函数这种说法，但是并不能很准确的回答什么是回调函数？</p><p>这个是知乎<a href="https://www.zhihu.com/question/19801131/answer/13005983" target="_blank" rel="noopener">常溪玲</a>的答案，非常的通俗易懂</p><blockquote><p>你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。</p></blockquote><p>或者说回调函数的特征:你定义的，你没有调，但它最终执行了。</p><p>常见回调函数</p><ul><li>dom事件回调函数</li><li>定时器回调函数</li><li>ajax请求回调函数</li><li>生命周期回调函数</li></ul><pre><code>document.getElementById(&quot;btn&quot;).onclick=function () {//dome事件回调函数    alert(this.innerHTML)}    //定时器    setTimeout(function () {  //定时器回调函数        alert(&quot;到点了&quot;)    },2000)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直都知道回调函数这种说法，但是并不能很准确的回答什么是回调函数？&lt;/p&gt;
&lt;p&gt;这个是知乎&lt;a href=&quot;https://www.zhihu.com/question/19801131/answer/13005983&quot; target=&quot;_blank&quot; rel=&quot;noop
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>git&amp;GitHub</title>
    <link href="http://yoursite.com/2020/02/14/git-1/"/>
    <id>http://yoursite.com/2020/02/14/git-1/</id>
    <published>2020-02-14T07:26:23.000Z</published>
    <updated>2020-07-28T07:37:32.628Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/git/Git&GitHub.bmp"></p><h2 id="git介绍"><a href="#git介绍" class="headerlink" title="git介绍"></a>git介绍</h2><p><strong>结构</strong></p><p>工作区（本身文件）：写代码   = git add =&gt;  暂存区：临时存储   = git commit =&gt;  本地库（.git）：存储历史版本</p><p><strong>Git和代码托管中心</strong></p><p>代码托管中心(如GitHub):帮忙维护远程库</p><p><strong>本地库和远程库</strong></p><p><strong>团队内部协作</strong></p><p><img src="/img/git/团队内协作.png"></p><p><strong>跨团队协作</strong></p><p>外团队人员<code>fork</code>该团队远程库A（复制新的远程库B），<code>clone</code>到本地修改后<code>push</code>到B，之后外团队人员<code>pull request</code> =&gt;  该团队人 审核 =&gt; <code>merge</code> 远程库A的内容更新成远程库B的内容。</p><h2 id="git命令行操作"><a href="#git命令行操作" class="headerlink" title="git命令行操作"></a>git命令行操作</h2><h3 id="本地库初始化"><a href="#本地库初始化" class="headerlink" title="本地库初始化"></a>本地库初始化</h3><p>命令：git init<br>效果：出现隐藏文件.git<br>注意：.git目录中存放的是本地库相关的子目录和文件，不要删除，也不要乱修改</p><h3 id="设置签名"><a href="#设置签名" class="headerlink" title="设置签名"></a>设置签名</h3><p>形式:<br>    用户名：XXX<br>    Email地址：XXXXX</p><p>作用：区分不同开发人员的身份<br>辨析：这里设置的签名和代码托管中心的账号、密码没有任何关系<br>命令:<br>    项目级别/仓库级别：仅在当前本地库起作用<br>        <code>git config user.name XX</code><br>        <code>git config user.email XX</code><br>    系统用户级别：登陆当前操作系统的用户范围， <code>git config --global</code><br>        <code>git config --global user.name XX</code><br>        <code>git config --global user.email XX</code><br>    级别优先级：项目级别优于系统用户级别</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="状态检查"><a href="#状态检查" class="headerlink" title="状态检查"></a>状态检查</h4><p>命令: git status<br>作用：查看工作区、暂存区状态</p><h4 id="移除暂存区"><a href="#移除暂存区" class="headerlink" title="移除暂存区"></a>移除暂存区</h4><p>命令: git rm –cached [filename]</p><h4 id="添加到暂存器"><a href="#添加到暂存器" class="headerlink" title="添加到暂存器"></a>添加到暂存器</h4><p>命令：git add[filename]   添加所有git add .   添加所有修改的git add -A</p><h4 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h4><p>命令：git commit -m”commit message”[filename]     提交所有git commit -m”版本留言描述”<br>作用：将暂存区的内容提交到本地库</p><h4 id="查看历史任务"><a href="#查看历史任务" class="headerlink" title="查看历史任务"></a>查看历史任务</h4><p>命令：<br>    完整形式 git log<br>        若多屏显示控制方式：空格向下翻页 b向上翻页 q退出<br>    以一个漂亮的格式显示 git log –pretty=oneline/git log–oneline(后面的更简洁)<br>    git reflog :索引值更简洁，其中HEAD@{移动到当前版本需要多少步}</p><pre><code>&lt;img src=&quot;/img/git/历史任务.png&quot; /&gt;</code></pre><h4 id="前进后退"><a href="#前进后退" class="headerlink" title="前进后退"></a>前进后退</h4><p>可以配合git reflog使用<br>本质:操作HEAD的指针，默认是指向最近的版本。<br>基于索引值操作（推荐）:<br>     git reset –hard [局部索引值]  例（上图）：git reset–hard a6ace91<br>使用^(异或)符号（只能后退）：<br>     git reset –hard HEAD^  注:一个^表示后退一步，n 个表示后退 n 步<br>使用~符号（只能后退）:<br>     git reset –hard HEAD~n  注:表示后退 n 步</p><h5 id="reset-命令的三个参数对比"><a href="#reset-命令的三个参数对比" class="headerlink" title="reset 命令的三个参数对比"></a>reset 命令的三个参数对比</h5><p>–soft参数：</p><ul><li>仅仅在本地库移动 HEAD 指针</li><li>只回退了commit的信息，如果还要提交，直接commit</li></ul><p>–mixed参数：① 在本地库移动 HEAD 指针 ② 重置暂存区</p><ul><li>默认方式</li><li>git reset –mixed <commit> + git add . = git reset –soft <commit></commit></commit></li></ul><p>–hard参数：①在本地库移动 HEAD 指针 ② 重置暂存区 ③ 重置工作区</p><ul><li>彻底回退到某个版本，本地的源码也会变成上一个版本的内容</li></ul><h5 id="删除文件与恢复"><a href="#删除文件与恢复" class="headerlink" title="删除文件与恢复"></a>删除文件与恢复</h5><p>前提：删除前，文件存在时的状态提交到了本地库。<br>操作：rm [filename]<br>注：rm之后通过 git add [filename] 可把文件再次添加到缓存区<br>    可利用 git reset –hard[指针位置] 回退到之前版本找回文件。</p><p>前提：删除的文件在暂存区，但还没有提交到本地库<br>命令: git reset –hard HEAD（刚刚创建时）</p><h5 id="比较文件差别"><a href="#比较文件差别" class="headerlink" title="比较文件差别"></a>比较文件差别</h5><p>命令：git diff[文件名]<br>作用：将工作区中的文件和暂存区进行比较</p><p>命令：git diff[本地库中历史版本][文件名]<br>作用：将工作区中的文件和本地库历史记录比较</p><p>注意:不带文件名比较多个文件</p><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>优势：</p><ul><li>同时并行推进多个功能开发，提高开发效率</li><li>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可</li></ul><h4 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h4><h5 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h5><p>命令：git branch[分支名]</p><h5 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h5><p>命令：git branch -v</p><h5 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h5><p>命令：git checkout[分支名]</p><h5 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h5><p>如把hot_fix上的修改合并到master上</p><p>第一步：切换到合并的分支上 git checkout[master]<br>第二步：执行 merge 命令 git merge[hot_fix]</p><p><strong>解决冲突</strong><br>合并时同时修改同一个文件的同一个地方</p><p><img src="/img/git/冲突.png"></p><p>第一步:自行修改冲突文件<br>第二步:git add[文件名]<br>第三步:git commit-m”日志信息”     注意：此时 commit 一定不能带具体文件名</p><h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><h4 id="连接远程库"><a href="#连接远程库" class="headerlink" title="连接远程库"></a>连接远程库</h4><p>命令：<br>    git remote-v 查看当前所有远程地址别名<br>    git remote add [别名] [远程地址]   (常用别名：origin)<br>作用：下次上传可以直接用别名上传</p><h4 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h4><p>命令：git push [别名][分支名]</p><h4 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h4><p>命令：git clone 仓库地址<br>作用；完整的把远程库下载到本地；创建origin远程地址别名；初始化本地库。</p><h4 id="团队成员邀请"><a href="#团队成员邀请" class="headerlink" title="团队成员邀请"></a>团队成员邀请</h4><p><img src="/img/git/邀请加入团队.png"></p><p>变成团队成员就可以把自己的修改推送进入远程仓库了。</p><h4 id="拉取pull"><a href="#拉取pull" class="headerlink" title="拉取pull"></a>拉取pull</h4><p>命令: git fetch[远程库地址别名][远程分支名]<br>      git merge[远程库地址别名/远程分支名]<br>      git pull[远程库地址别名][远程分支名]<br>作用: pull=fetch+merge。<br>      fetch 把远程库抓取下来，并没有修改本地文件。<br>      merge 把远程的master合并到本地的master，本地文件修改。</p><p><strong>解决冲突</strong><br>要点：<table><tr><td bgcolor="pink">如果不是基于GitHub远程库的最新版本所作的修改，不能推送，必须先拉取下来</td></tr></table>如<br>若pull下来之后进入冲突状态，其余同分支冲突处理办法一样。</p><h4 id="跨团队操作"><a href="#跨团队操作" class="headerlink" title="跨团队操作"></a>跨团队操作</h4><p>外团队人员<code>fork</code>该团队远程库A（复制新的远程库B、外团队人员的仓库），<code>clone</code>到本地修改后<code>push</code>到B，之后外团队人员<code>pull request</code> （GitHub远程库B操作）=&gt;  该团队人（GitHub远程库A） 审核 =&gt; <code>merge</code> 远程库A的内容更新成远程库B的内容。</p><h4 id="SSH登陆"><a href="#SSH登陆" class="headerlink" title="SSH登陆"></a>SSH登陆</h4><p>第一步：生成ssh（在家目录）<br>ssh-keygen ct rsa -C 邮箱账号         //注意C大写<br>注：在主目录下生成的密钥在 /c/Users/用户名/.ssh/id_rsa 里<br>第二步：查看并复制ssh（需在.ssh目录下执行 cd .ssh进入）<br>cat id_rsa.pub<br>第三步：复制密钥内容添加到 github 上</p><p>使用ssh协议上传文件到仓库</p><p>git init<br>git add .<br>git commit -m “ “<br>git remote add 别名 <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:…<br>git push -u 别名 master</p><h3 id="Git工作流"><a href="#Git工作流" class="headerlink" title="Git工作流"></a>Git工作流</h3><p>在项目开发过程中使用的Git的方式</p><h4 id="GitFlow工作流-常用"><a href="#GitFlow工作流-常用" class="headerlink" title="GitFlow工作流(常用)"></a>GitFlow工作流(常用)</h4><p>Gitflow 工作流通过为功能开发、发布准备和维护设立了独立的分支，让发布 迭代过程更流畅。严格的分支模型也为大型项目提供了一些非常必要的结构。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/img/git/Git&amp;GitHub.bmp&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;git介绍&quot;&gt;&lt;a href=&quot;#git介绍&quot; class=&quot;headerlink&quot; title=&quot;git介绍&quot;&gt;&lt;/a&gt;git介绍&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;结构&lt;/str
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>富文本tinymce</title>
    <link href="http://yoursite.com/2020/02/09/%E5%AF%8C%E6%96%87%E6%9C%ACtinymce/"/>
    <id>http://yoursite.com/2020/02/09/富文本tinymce/</id>
    <published>2020-02-09T03:58:33.000Z</published>
    <updated>2020-07-09T08:07:23.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>//安装tinymce-vuenpm install @tinymce/tinymce-vue -S//安装tinymce,版本为5.Xnpm install tinymce -S//引入中文语言包</code></pre><p><a href="https://www.tiny.cloud/get-tiny/language-packages/" target="_blank" rel="noopener">中文下载包</a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在 node_modules中找到 tinymce/skins目录，然后将skins目录拷贝到static目录下的tinymce</p><p> <img src="/img/富文本/富文本1.png" width="30%"></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>引入基本文件</p><pre><code>  //初始化tinymce  import tinymce from &#39;tinymce/tinymce&#39;  import Editor from &#39;@tinymce/tinymce-vue&#39;  import &#39;tinymce/themes/silver&#39;</code></pre><p>注册组件</p><pre><code class="bash">&lt;Editor&gt;&lt;/Editor&gt;//jscomponents: {Editor}</code></pre><p>初始化配置</p><pre><code class="bash">&lt;Editor :init=&quot;init&quot;&gt;&lt;/Editor&gt; data() { return {  init:{//语言language_url: &#39;/static/tinymce/zh_CN.js&#39;,language: &#39;zh_CN&#39;, //skin路径skin_url: &#39;/static/tinymce/skins/ui/oxide&#39;,}}}, mounted () { tinymce.init({}) },</code></pre><p>初始化配置之后最基本的符文就有了，接下来丰富它的功能</p><p><img src="/img/富文本/富文本2.png"></p><p>数据同步</p><pre><code class="bash">//子组件  &lt;Editor  v-model=&quot;myValue&quot;&gt;&lt;/Editor&gt;   data() {              return {                myValue: this.value                }   },     props: {      value: {               default: &#39;&#39;,               type: String             },     }      watch: {           value(newValue) {             this.myValue = newValue           },           myValue(newValue) {             this.$emit(&#39;input&#39;, newValue)           }         },//父组件  onEditorUploadSuccess为图片上传成功的回调    &lt;editor v-model=&quot;value&quot; @on-upload-success=&quot;onEditorUploadSuccess&quot;        &gt;&lt;/editor&gt;</code></pre><p>完整代码</p><pre><code class="bash">&lt;template&gt;  &lt;div&gt;      &lt;Editor :init=&quot;init&quot; v-model=&quot;myValue&quot;&gt;&lt;/Editor&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  //这个是接口文件  import {ImgUpload} from &#39;@/api/notice&#39;  //初始化tinymce  import tinymce from &#39;tinymce/tinymce&#39;  import Editor from &#39;@tinymce/tinymce-vue&#39;  //引入主题  import &#39;tinymce/themes/silver&#39;  /*  引入插件   */  import &#39;tinymce/plugins/image&#39;  import &#39;tinymce/plugins/table&#39;  import &#39;tinymce/plugins/preview&#39;  import &#39;tinymce/plugins/fullscreen&#39;  import &#39;tinymce/plugins/link&#39;  import &#39;tinymce/plugins/code&#39;  import &#39;tinymce/plugins/lists&#39;  import &#39;tinymce/plugins/hr&#39;  import &#39;tinymce/plugins/advlist&#39;  import &#39;tinymce/plugins/paste&#39;  import &#39;tinymce/plugins/importcss&#39;  import &#39;tinymce/plugins/media&#39;  export default {        data() {            return {              myValue: this.value,              init:{                //语言                language_url: &#39;/static/tinymce/zh_CN.js&#39;,                language: &#39;zh_CN&#39;,                //设置皮肤                skin_url: &#39;/static/tinymce/skins/ui/oxide&#39;,                //高度                height: 400,                //菜单栏                menubar: false,                //隐藏商标                // branding: false,                //工具栏|分类 配置插件                toolbar: `styleselect | fontselect | formatselect | fontsizeselect | forecolor backcolor | bold italic underline strikethrough | image   | table | alignleft aligncenter alignright alignjustify | outdent indent | numlist bullist | preview removeformat  hr |  code  link | undo redo | fullscreen `,                //自动聚焦                auto_focus: true,                //引入插件                plugins: ` paste importcss image code table advlist fullscreen link media lists   hr preview`,                //图片标题                image_caption: true,                //上传本地图片                image_uploadtab:true,                // Image                imagetools_toolbar: &#39;rotateleft rotateright | flipv fliph | editimage imageoptions&#39;,              // 设置Tab             // tabfocus_elements: &#39;:prev,:next&#39;,             //  object_resizing: true,             //设置可选段落样式             style_formats: [                  {                    title: &#39;首行缩进&#39;,                    block: &#39;p&#39;,                    styles: { &#39;text-indent&#39;: &#39;2em&#39; }                  },                  {                    title: &#39;行高&#39;,                    items: [                      { title: &#39;1&#39;, styles: { &#39;line-height&#39;: &#39;1&#39; }, inline: &#39;span&#39; },                      { title: &#39;1.5&#39;, styles: { &#39;line-height&#39;: &#39;1.5&#39; }, inline: &#39;span&#39; },                      { title: &#39;2&#39;, styles: { &#39;line-height&#39;: &#39;2&#39; }, inline: &#39;span&#39; },                      { title: &#39;2.5&#39;, styles: { &#39;line-height&#39;: &#39;2.5&#39; }, inline: &#39;span&#39; },                      { title: &#39;3&#39;, styles: { &#39;line-height&#39;: &#39;3&#39; }, inline: &#39;span&#39; }                    ]                  }                ],             //字体列表              font_formats: `            微软雅黑=微软雅黑;            宋体=宋体;            黑体=黑体;            仿宋=仿宋;            楷体=楷体;            隶书=隶书;            幼圆=幼圆;            Andale Mono=andale mono,times;            Arial=arial, helvetica,            sans-serif;            Arial Black=arial black, avant garde;            Book Antiqua=book antiqua,palatino;            Comic Sans MS=comic sans ms,sans-serif;            Courier New=courier new,courier;            Georgia=georgia,palatino;            Helvetica=helvetica;            Impact=impact,chicago;            Symbol=symbol;            Tahoma=tahoma,arial,helvetica,sans-serif;            Terminal=terminal,monaco;            Times New Roman=times new roman,times;            Trebuchet MS=trebuchet ms,geneva;            Verdana=verdana,geneva;            Webdings=webdings;            Wingdings=wingdings,zapf dingbats`,              //内容样式, 在最后呈现的页面也要写入这个基本样式保证前后一致                content_style: `            *                         { padding:0; margin:0; }            html, body                { height:100%; }            img                       { max-width:100%; display:block;height:auto; }            a                         { text-decoration: none; }            iframe                    { width: 100%; }            p                         { line-height:1.6; margin: 0px; font-family:&quot;宋体&quot;; }            table                     { word-wrap:break-word; word-break:break-all; max-width:100%; border:none; border-color:#999; }            .mce-object-iframe        { width:100%; box-sizing:border-box; margin:0; padding:0; }            ul,ol                     { list-style-position:inside; }          `,                insert_button_items: &#39;image link | inserttable&#39;,                //回车添加的标签                forced_root_block:&quot;p&quot;,                //强制每行添加&lt;p&gt;标签                force_p_newlines: true,                importcss_append: true,                //字体大小栏选项                fontsize_formats: &#39;10px 11px 12px 14px 16px 18px 20px 24px&#39;,                // paste设置                paste_data_images: true,//可以粘贴图片                paste_word_valid_elements: &#39;*[*]&#39;,//word过滤                paste_retain_style_properties:&#39;all&#39;, //允许保留word粘贴过来的格式                paste_convert_word_fake_lists: false,//禁止word的列表内容转换html的ul和ol格式                paste_merge_formats: true,//合并相似格式                nonbreaking_force_tab: false,                paste_auto_cleanup_on_paste: false,                statusbar: false, // 隐藏编辑器底部的状态栏                images_upload_handler: this.uploadImg//图片上传              },            }        },      props: {          //图片最大大小        maxSize: {          default: 2097152,          type: Number        },        //图片可接收类型        accept: {          default: &#39;image/jpeg, image/png, image/jpg, image/svg, image/gif&#39;,          type: String        },        //上传地址        url: {          default: &#39;&#39;,          type: String        },        //数据        value: {          default: &#39;&#39;,          type: String        },      },        methods: {        //上传图片          uploadImg(blobInfo, success, failure)  {            const that = this            //符合大小            if (blobInfo.blob().size &gt; this.maxSize) {      failure(&#39;文件体积过大&#39;);    }            //符合类型            if (this.accept.indexOf(blobInfo.blob().type) &gt; -1) {              let form = new FormData();    form.append(&#39;file&#39;, blobInfo.blob(), blobInfo.filename());              ImgUpload(form).then(res=&gt;{                //给父组件传值                that.$emit(&#39;on-upload-success&#39;, {                  res, success, failure                })              }).catch(err =&gt; {                failure(&#39;上传失败: &#39; + err);              })            }            else failure(&#39;图片格式错误&#39;);  },        },     watch: {      value(newValue) {        this.myValue = newValue      },      myValue(newValue) {        this.$emit(&#39;input&#39;, newValue)      }    },        components: {Editor},      mounted () {        tinymce.init({})      },    }&lt;/script&gt;&lt;!--scoped 样式仅仅在当前组件使用--&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;//安装tinymce-vue
npm install @tinymce/tinymce-vue -S
//安装tinymc
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="库" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E5%BA%93/"/>
    
    
      <category term="富文本" scheme="http://yoursite.com/tags/%E5%AF%8C%E6%96%87%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>软件超市项目后台管理界面开发流程3</title>
    <link href="http://yoursite.com/2020/02/06/%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82%E9%A1%B9%E7%9B%AE%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B3/"/>
    <id>http://yoursite.com/2020/02/06/软件超市项目后台管理界面开发流程3/</id>
    <published>2020-02-06T06:42:08.000Z</published>
    <updated>2020-07-09T08:08:33.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue全局配置"><a href="#vue全局配置" class="headerlink" title="vue全局配置"></a>vue全局配置</h2><p>项目有很多重复用到的变量和方法，新建一个global/index.js来存放。具体的实现是通过在Vue的原型上添加方法和属性，也就是使用<code>Vue.prototype</code>，最后要在main.js引入文件`import “./global”;</p><h2 id="Messsage-vue"><a href="#Messsage-vue" class="headerlink" title="Messsage.vue"></a>Messsage.vue</h2><p>一级导航用于显示消息通知,里面包含了两个组件，一个用于分页的ProjectPagination，一个是用于消息提醒的MessageRemind。<br>这里实现了流程1提到的:如果有未读消息，进入管理页面后直接显示消息通知，如果没有未读消息，则显示第一个路由。</p><pre><code class="bash">    //登陆之后是先跳转到message，此时的pageEnterStatetrue=true。    if (this.pageEnterState) {      //如果没有消息就跳到第一个路由      if (this.msgLen === 0) {        const route = this.$store.getters.addRouter;        this.$router.push(route[0].path);      } else {        //如果有消息就显示，tableData就是登陆时传给state的消息        this.data = this.tableData;        this.isLoading = false;      }      this.$store.commit(&quot;SET_PAGE_ENTER_STATE&quot;, false);    } else {      this.loadData();    }  }</code></pre><h3 id="分页ProjectPagination"><a href="#分页ProjectPagination" class="headerlink" title="分页ProjectPagination"></a>分页ProjectPagination</h3><p>结合element-ui的pagination加上一些修改。前一篇博客中提到了父组件向子组件传值的方法，这里同时也用到了子组件向父组件传值的方法</p><pre><code>&lt;!-- 分页器 --&gt;&lt;template&gt;  &lt;el-pagination class=&quot;x-page&quot; layout=&quot;total,sizes, prev, pager, next, jumper&quot; @current-change=&quot;handleCurrentChange&quot; @size-change=&quot;handleSizeChange&quot; :current-page.sync=&quot;currentPage&quot; :page-sizes=&quot;pageSizes&quot; :page-size=&quot;pageSize&quot; :total=&quot;total&quot;&gt;&lt;/el-pagination&gt;&lt;/template&gt;&lt;script&gt;export default {  name: &quot;ProjectPagination&quot;,  //接收父组件传来的值  props: {    //data为所有数据    data: Array,    //filterData做为一个筛选容器    filterData: Array  },  data() {    return {      //当前页数      currentPage: 1,      //默认的一页显示条数      pageBase: 10    };  },  computed: {    // 数据总数目    total() {      return this.data.length;    },    // 一页有多少条数据    pageSize() {      //如果基础数据大于总数，则显示总数      let size = this.total &gt;= this.pageBase ? this.pageBase : this.total;      return size;    },    // 提供每页条数的选择，返回值为一个数组    pageSizes() {      let count = Math.ceil(this.total / this.pageSize);      let sizes = [];      for (let i = 1; i &lt;= count; i++) {        sizes.push(this.pageSize * i);      }      return sizes;    }  },  methods: {  //pageSize改变执行，回调参数:每页条数    handleSizeChange(val) {      // 获取项目条数      //子组件像父组件传值，更新filterData。      this.$emit(&quot;update:filterData&quot;, this.data.slice(0, val));    },    // 页面页数改变    handleCurrentChange(val) {      // 获取下一页数据      this.$emit(        &quot;update:filterData&quot;,        this.data.slice((val - 1) * this.pageSize, val * this.pageSize)      );    }  },  created() {    //发送一个update:filterData，显示pageSize个数据    this.$emit(&quot;update:filterData&quot;, this.data.slice(0, this.pageSize));  },  watch: {    // 监控数据变化时获取数据    data() {      this.$emit(&quot;update:filterData&quot;, this.data.slice(0, this.pageSize));    }  },  //路由要求刷新  activated() {    if (this.$route.meta.isRefresh) {      this.currentPage = 1;    }  }};&lt;/script&gt;&lt;style scoped&gt;.x-page {  margin-top: 10px;  float: right;}&lt;/style&gt;</code></pre><h4 id="emit-update-prop-“newPropVulue”"><a href="#emit-update-prop-“newPropVulue”" class="headerlink" title="$emit(update: prop, “newPropVulue”)"></a>$emit(update: prop, “newPropVulue”)</h4><p>$emit(update: prop, “newPropVulue”)  这个模式，使子组件向父组件传达：更新属性，并抛出新的属性值。</p><p>从上述代码中可以看出首先更新的值要是从父组件中接收的，也就是props里面的值。其次父组件该值需要写成</p><pre><code>  &lt;ProjectPagination :data=&quot;data&quot; :filter-data=&quot;filterData&quot; @update:filter-data=&quot;filterData=$event&quot;&gt;&lt;/ProjectPagination&gt;</code></pre><p>更简单的写法是<code>.sync</code>修饰符</p><pre><code> &lt;ProjectPagination  :filter-data=&quot;filterData&quot; :filter-data.sync=&quot;filterData&quot;&gt;&lt;/ProjectPagination&gt;</code></pre><p><strong>注意:</strong>这里有一个Vue.sync修饰符与$emit(update:xxx)写法的坑<br>使用.sync修饰符</p><pre><code>//有效this.$emit(&quot;update:filterData&quot;, this.data.slice(0, val));//无效this.$emit(&quot;update:filter-Data&quot;, this.data.slice(0, val));</code></pre><p>不使用.sync修饰符</p><pre><code>//无效this.$emit(&quot;update:filterData&quot;, this.data.slice(0, val));//有效this.$emit(&quot;update:filter-Data&quot;, this.data.slice(0, val));</code></pre><h3 id="MessageRemind"><a href="#MessageRemind" class="headerlink" title="MessageRemind"></a>MessageRemind</h3><p>消息提醒的MessageRemind使用了element-ui的消息提醒，这里最后的实现比较容易，但是在实现的过程中遇到了一个关于路由监控的坑。</p><p>路由监听失效：需要在父路由的组件内才可以监听到子路由的信息。</p><h2 id="Notice-vue"><a href="#Notice-vue" class="headerlink" title="Notice.vue"></a>Notice.vue</h2><p>仅管理员拥有的组件。主要有左边的导航和中间显示部分组成。显示公告列表，增删改查等实现比较容易就没有记录下来。</p><p>这里记录一个文章显示的css，超出部分滚动，但不显示滚轮</p><pre><code class="bash">  .article{    height: 100%;    overflow-x:hidden;    overflow-y: scroll;  }  //  -webkit-scrollbar css3新特性  .article::-webkit-scrollbar {    display: none;  }</code></pre><p><strong>框架</strong></p><pre><code class="bash"> &lt;template&gt;     &lt;div  class=&quot;notice&quot;&gt;       &lt;div class=&quot;nav&quot;&gt;       &lt;el-menu         default-active=&quot;publish&quot;         class=&quot;el-menu-vertical-demo&quot;         @select=&quot;handleSelect&quot;       &gt;         &lt;el-menu-item index=&quot;publish&quot; &gt;           &lt;i class=&quot;el-icon-edit-outline&quot;&gt;&lt;/i&gt;           &lt;span slot=&quot;title&quot;&gt;发布公告&lt;/span&gt;         &lt;/el-menu-item&gt;         &lt;el-menu-item index=&quot;allNotice&quot;&gt;           &lt;i class=&quot;el-icon-document&quot;&gt;&lt;/i&gt;           &lt;span slot=&quot;title&quot;&gt;所有公告&lt;/span&gt;         &lt;/el-menu-item&gt;         &lt;el-menu-item index=&quot;dustbin&quot;&gt;           &lt;i class=&quot;el-icon-delete&quot;&gt;&lt;/i&gt;           &lt;span slot=&quot;title&quot;&gt;回收站&lt;/span&gt;         &lt;/el-menu-item&gt;       &lt;/el-menu&gt;     &lt;/div&gt;       &lt;router-view class=&quot;view&quot;&gt;&lt;/router-view&gt;     &lt;/div&gt; &lt;/template&gt;handleSelect(key) {let path=&#39;/notice/&#39;+key;this.$router.push({path:path})}</code></pre><h3 id="富文本tinymce"><a href="#富文本tinymce" class="headerlink" title="富文本tinymce"></a>富文本tinymce</h3><p>默认显示的是发布公告,选用的是tinymce这款富文本。</p><blockquote><p><a href="https://biubiuins.github.io/2020/02/09/%E5%AF%8C%E6%96%87%E6%9C%ACtinymce/" target="_blank" rel="noopener">学习笔记</a></p></blockquote><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p><strong>问题1</strong>表单规则验证</p><pre><code class="bash"> &lt;el-form-item label=&quot;学/工号&quot; prop=&quot;captainInformation.studentId&quot; &gt;    &lt;el-input v-model.number=&quot;form.captainInformation.studentId&quot; &gt;&lt;/el-input&gt;  &lt;/el-form-item&gt;   data() {        return {    form:{          teamName:&quot;&quot;,          captainInformation:{            name:&quot;&quot;,            studentId:&quot;&quot;,          },        },        rules: {          teamName: [            { required: true, message: &#39;请输入团队名称&#39;, trigger: &#39;blur&#39; },            { min: 3, max: 10, message: &#39;长度在 3 到 10 个字符&#39;, trigger: &#39;blur&#39; }          ],          //这个位置注意一定要加引号           &quot;captainInformation.studentId&quot;: [                      { required: true, message: &#39;请输入学号&#39;, trigger: &#39;blur&#39; },                       {type: &#39;integer&#39;, message: &#39;格式错误&#39;, trigger: &#39;blur&#39;}                    ],  }</code></pre><p><strong>问题二</strong>过滤器</p><p>后台传来的数据只有分数，未评分的分数为-1，这里需要将其显示成状态已完成或未评分，并且可以根据状态筛选数据。</p><pre><code class="bash"> &lt;el-table-column prop=&quot;score&quot; sortable label=&quot;状态&quot; :filters=&quot;tags&quot; :filter-method=&quot;filterTag&quot;&gt;          &lt;template slot-scope=&quot;scope&quot;&gt;            &lt;el-tag disable-transitions style=&quot;font-size:12px&quot; :type=&quot;stateColor(scope.row.score)&quot;&gt;{{scope.row.score| filterState}}&lt;/el-tag&gt;          &lt;/template&gt;        &lt;/el-table-column&gt;//js //筛选标签          filterTag(value, row) {            if (value === -1) {              return row.score === -1;            } else {              return row.score &gt;= value;            }        },   //过滤器      filters: {        filterState(val) {          return val === -1 ? &quot;未评分&quot; : &quot;已完成&quot;;        }      },</code></pre><p><strong>问题三</strong>返回刷新问题<br>从详情返回列表，列表不需要刷新，而从其他页面进入列表，列表需要刷新。<br>首先需要了解两个生命周期：<br><img src="/img/软件超市/created与activated.png"></p><pre><code>      // 数据缓存      beforeRouteEnter(to, from, next) {        //如果不是从teamDetail来的界面需要刷新        if (![&quot;teamDetail&quot;].includes(from.name)) {          to.meta.isRefresh = true;        }        next()      },      activated() {          //需要刷新的界面        if (this.$route.meta.isRefresh) {          // 先重置          this.$route.meta.isRefresh = false;          //重新获取数据          this.isLoading = true;          this.getLoadData();        }      },</code></pre><blockquote><p>后面重复的操作比较多，多为增删查改，重复的东西将不在记录了。有关于vue我不熟悉的知识点，会重新学习了解之后更新博客。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;vue全局配置&quot;&gt;&lt;a href=&quot;#vue全局配置&quot; class=&quot;headerlink&quot; title=&quot;vue全局配置&quot;&gt;&lt;/a&gt;vue全局配置&lt;/h2&gt;&lt;p&gt;项目有很多重复用到的变量和方法，新建一个global/index.js来存放。具体的实现是通过在Vu
      
    
    </summary>
    
      <category term="project" scheme="http://yoursite.com/categories/project/"/>
    
    
      <category term="软件超市" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82/"/>
    
  </entry>
  
  <entry>
    <title>软件超市项目后台管理界面开发流程2</title>
    <link href="http://yoursite.com/2020/01/31/%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82%E9%A1%B9%E7%9B%AE%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B2/"/>
    <id>http://yoursite.com/2020/01/31/软件超市项目后台管理界面开发流程2/</id>
    <published>2020-01-31T13:53:41.000Z</published>
    <updated>2020-03-02T09:33:54.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设置权限时动态加载路由"><a href="#设置权限时动态加载路由" class="headerlink" title="设置权限时动态加载路由"></a>设置权限时动态加载路由</h2><ol><li>路由分为两类，一类是静态路由（不需要登陆验证），一类是动态路由（需要登陆验证）</li><li>当用户登陆后，获取用role（权限），将role和路由表每个页面的需要的权限作比较，生成用户可访问的路由表</li><li>调用router.addRoutes(store.getters.addRouters)添加用户可访问的路由。</li><li>使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。</li></ol><h3 id="permission-js"><a href="#permission-js" class="headerlink" title="permission.js"></a>permission.js</h3><p>首先新建store/permission.js，用来控制生成的路由表。</p><pre><code>//是否有权限访问，role为当前权限function hasPermission(role, route) {  if (route.meta &amp;&amp; route.meta.roles) {    //如果该路由的meta存在，并且有要求权限    const roles = route.meta.roles;    //如果路由要求的权限有当前权限，返回成功    return roles.includes(role);  } else {    //如果不存在说明不需要权限    return true;  }}const permission ={  state: {    //默认路由    routers: constantRouterMap,    //添加的路由    addRouters: []  },  mutations: {    SET_ROUTERS: (state, routers) =&gt; {      //往数组中添加符合条件的路由      state.addRouters = routers;      //符合权限的路由变成默认路由可访问。      state.routers = constantRouterMap.concat(routers);    }  },  actions: {    //定义产生路由的方法    async GenerateRoutes({ commit }, { role }) {      //返回符合权限的异步路由      const accessedRouters = await asyncRouterMap.filter(route =&gt;        hasPermission(role, route)      );      commit(&quot;SET_ROUTERS&quot;, accessedRouters);      return accessedRouters;    }  }}export default permission;</code></pre><p>这里可以把permission.js看成一个模块，因为它拥有自己的state,mutation,action。所以还需要把permission挂载在vuex里。</p><pre><code>export default new Vuex.Store({  modules:{    permission  },  state,  actions,  mutations,  getters});</code></pre><p><strong>问题一</strong>addRoutes在哪里调用<br>登录后，获取用户的权限信息，然后筛选有权限访问的路由，再调用addRoutes添加路由。这个方法是可行的。但是不可能每次进入应用都需要登录，用户刷新浏览器又要登陆一次。所以addRoutes还是要在全局路由守卫里进行调用。</p><pre><code class="bash">if(token){//已经登陆了if (to.path ===&quot;/login&quot;) next({path:&quot;/&quot;})//else{if (!store.getters.role){ //如果没有当前权限信息,role仅getUserInfor后可以获得//用户登陆之后，根据缓存获取登陆信息  store.dispatch(&quot;getUserInfor&quot;).then(role=&gt;{ //产生符合权限路由的方法   store.dispatch(&quot;GenerateRoutes&quot;, { role })     .then(                   data =&gt; {                     // 生成可访问的路由表                     router.addRoutes(data);                    next({ ...to, replace: true });  }).....}}}</code></pre><p><strong>问题一</strong> next()的使用</p><ol><li><p>首先调用next()时会直接进入to路由，不会再调用beforeEach(),所以刷新页面可能会进入无限循环，调用next(‘xxx’)后会拦截路由使得路由重定向xxx，并再次调用beforeEach()。</p></li><li><p>如果把replace设置为true，那么导航不会留下history记录，点击浏览器回退按钮不会再回到这个路由。router.addRoutes之后的next()可能会失效，因为可能next()的时候路由并没有完全add完成，next({…to}) 的时候重新指定以下刷新前的路径。</p></li></ol><p><strong>问题二</strong> 404页面<br>404路由写在动态路由中，否则可能会有闪屏和路由为空时加载的404页面。<br>原因是：当页面刷新，会导致vue重新实例化，路由也恢复了初始路,addRoutes 还没有添加上路由就开始跳转， 所以找不到路由就跳转到404页面了。</p><h2 id="Layout页面"><a href="#Layout页面" class="headerlink" title="Layout页面"></a>Layout页面</h2><p>Layout作为整个后台管理页面的框架，主要有Header、根据权限生成的Sidebar和中间的显示界面组成。</p><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><pre><code class="bash">//Layout组件   &lt;div id=&quot;manage&quot;&gt;      &lt;Header&gt;&lt;/Header&gt;      &lt;div class=&quot;container&quot;&gt;      &lt;Sidebar&gt;&lt;/Sidebar&gt;        &lt;router-view class=&quot;content&quot; &gt;&lt;/router-view&gt;      &lt;/div&gt;    &lt;/div&gt;</code></pre><p>通过把一级路由与二级路由的path设置成同一个，来同时加载Header组件、Sidebar组件和中间对应的显示界面</p><pre><code class="bash">//仅用其中一个举列子const project ={  path: {    path: &quot;/projectManage&quot;,    name: &quot;projectManage&quot;,    component: Layout  },  check: [    {      path: &quot;check&quot;,      name: &quot;projectCheck&quot;,      component: () =&gt;        import(          /* webpackChunkName: &quot;ProjectCheck&quot; */ &quot;../views/projectManage/components/ProjectCheck&quot;          )    },  ],  }export const asyncRouterMap = [{    ...project.path,  children: [      {        path: project.path.path,        redirect: &quot;/projectManage/check&quot;,        component: () =&gt; import(/* webpackChunkName: &quot;ProjectDeveloper&quot; */ &quot;../views/projectManage/ProjectDeveloper&quot;),        children: [...project.check]      },]}]</code></pre><p><strong>注意:</strong>这里有个简单的重定向问题我晕了好久QAQ</p><p>首先是path加/和不加/有什么区别。/xx就是根路径。下面代码去到children是/#/child而不是/#/fa/child。而不以斜杠开头的，都会被当成普通的字符串拼到当前路径的后面。</p><pre><code class="bash">path: /fachildren: {    path: /child}</code></pre><p>然后这里重新定向之后<code>projectManage/check</code>路由到底算几级路由？通过把redirect注释之后终于弄懂了。这里是因为<strong>children控制的是第几个router-view</strong>,第一个children控制的是第二个router-view，即使它重定向<code>/projectManage/check</code>,第二个router-view显示的还是ProjectDeveloper组件。</p><h3 id="Siderbar"><a href="#Siderbar" class="headerlink" title="Siderbar"></a>Siderbar</h3><h4 id="导航图标上显示未读消息数量"><a href="#导航图标上显示未读消息数量" class="headerlink" title="导航图标上显示未读消息数量"></a>导航图标上显示未读消息数量</h4><p>   <img src="/img/软件超市/消息提醒.png" width="30%"></p><p>主要实现是使用element-ui里面的badge组件+父子间传值实现的。这里以导航图标上显示未读消息数量为例子，后续类似操作将不做记录。</p><p>新建一个MessageNue.vue记录未处理的消息数量，作为子组件，接收父组件传来的值。这里接收两个值：customClass样式，因为这个组件会重复使用，并且不同消息显示的位置可能不同，所以关于定位的信息要单独接收。menu接收的是显示的哪一个消息。</p><pre><code class="bash">&lt;template&gt;  &lt;span class=&quot;badgebox&quot;&gt;    &lt;slot&gt;&lt;/slot&gt;    &lt;el-badge :value=&quot;getMsgN(menu)&quot; :style=&quot;customClass&quot; class=&quot;item&quot; :max=&quot;99&quot; :hidden=&quot;!getMsgN(menu)&quot;&gt;&lt;/el-badge&gt;  &lt;/span&gt;&lt;/template&gt;&lt;script&gt;export default {  name: &quot;MessageNum&quot;,  props: {    menu: Object,    customClass: String  },  methods: {    getMsgN(menu) {      return this.count[menu.path];    }  },  computed: {    count() {      return this.$store.state.msgNum;    }  }};&lt;/script&gt;//state.js  //需要显示的消息数量  msgNum: {    publishExamine: 0,    delayExamine: 0,    alterExamine: 0,    undertakeExamine: 0,    projectExamine: 0,    porjectRun: 0,    projectCheck: 0,    projectFinish: 0,    projectManage: 0  },</code></pre><p>Sidebar.vue 作为父组件，把组件挂载好之后。menu值是传的动态值所以用<code>v-bind:</code>绑定，而customClass是一个静态值所以直接传值就行。</p><p><strong>这里有一个命名的坑:</strong><br>props属性支持驼峰命名,不支持连接线命名。HTML特性是不区分大小写的，所以在HTML之中的驼峰写法要变成连接线写法。</p><pre><code>      &lt;message-num :menu=&quot;{path:router.name}&quot; custom-class=&quot;top:-12px;right:-12px&quot;&gt;        &lt;i class=&quot;iconfont&quot; :class=&quot;&#39;icon-&#39;+router.meta.icon&quot;&gt;&lt;/i&gt;      &lt;/message-num&gt;</code></pre><h4 id="Header-vue"><a href="#Header-vue" class="headerlink" title="Header.vue"></a>Header.vue</h4><p>主要功能有：</p><p>1.显示用户名，可退出<br>2.如果身份是开发团队的队长，且同时有几个团队，显示当前团队，并可切换其他团队。<br>3.点击logo的时候，可以操作侧边栏展开</p><p>①下拉框用的是Element-ui的el-dropdown组件,下拉的时候出现退出键。</p><pre><code class="bash">// @command=&quot;handleCommand&quot;为绑定下拉框点击事件，command为值    &lt;el-dropdown class=&quot;exit&quot;  @command=&quot;handleCommand&quot;  trigger=&quot;click&quot;&gt;      &lt;span class=&quot;el-dropdown-link&quot;&gt;        {{ username }}        &lt;i class=&quot;el-icon-arrow-down el-icon--right&quot;&gt;&lt;/i&gt;      &lt;/span&gt;      &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt;        &lt;el-dropdown-item command=&quot;exit&quot;&gt;退出&lt;/el-dropdown-item&gt;      &lt;/el-dropdown-menu&gt;    &lt;/el-dropdown&gt;   // 退出登录或者切换用户管理界面      handleCommand(command) {        console.log(command);        if (command === &quot;exit&quot;) {        //退出之后清除          this.exit();        }，      exit() {      // 退出清除缓存和登录      //登录成功之后重定向到登录页      this.$store.dispatch(&quot;Logout&quot;);      }</code></pre><p>②做第二个功能的时候，首先团队名称是通过axios获取的，并且刷新的时候还要在。所以应该把数据存在session中，同时要解决数据渲染的问题,采用了在state里面设置get和set的方法。</p><pre><code class="bash">//state.js  get teams() {    let vlaue = sessionStorage.getItem(&quot;teams&quot;);    return typeof vlaue === &quot;string&quot; ? JSON.parse(vlaue) : [];  },  set teams(vlaue) {    sessionStorage.setItem(&quot;teams&quot;, JSON.stringify(vlaue));  },  get teamId() {    return sessionStorage.getItem(&quot;teamId&quot;);  },  set teamId(vlaue) {    sessionStorage.setItem(&quot;teamId&quot;, vlaue);  },</code></pre><p>这里切换团队之后页面刷新用了上一篇博客提到的provide/inject组合刷新的办法。</p><p>③第三个功能是兄弟Header和Sidebar组件的通讯，因为做这个项目主要是学习为主，所以选择了借助中央事件总线：在外部新建一个utils/eventBus.js文件。</p><pre><code class="bash">//eventBus.jsimport Vue from &#39;vue&#39;export default new Vue();//Header.vueimport eventBus from &quot;../../utils/eventBus.js&quot;;extendNav() {//通过eventBus中央事件总线用$emit发送一个showNav事件eventBus.$emit(&quot;showNav&quot;); } //Sidebar.vuemounted() {//通过eventBus中央事件总线用$on监听组件1中发送的showNav事件，第二个参数为回调函数。 eventBus.$on(&quot;showNav&quot;, this.change);},</code></pre><p>上述是最开始的做法，后面发现更简便的方法。<br>主要是省略了外部的js文件，把总线放在main.js里的vue实例中</p><pre><code>new Vue({data:{eventBus:new Vue()}})</code></pre><p>兄弟组件调用的时候,用<code>this.$root.eventBus.$on</code>代替<code>eventBus.$on</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;设置权限时动态加载路由&quot;&gt;&lt;a href=&quot;#设置权限时动态加载路由&quot; class=&quot;headerlink&quot; title=&quot;设置权限时动态加载路由&quot;&gt;&lt;/a&gt;设置权限时动态加载路由&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;路由分为两类，一类是静态路由（不需要登陆验证），一类是动
      
    
    </summary>
    
      <category term="project" scheme="http://yoursite.com/categories/project/"/>
    
    
      <category term="软件超市" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82/"/>
    
  </entry>
  
  <entry>
    <title>软件超市项目后台管理界面开发流程1</title>
    <link href="http://yoursite.com/2020/01/29/%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82%E9%A1%B9%E7%9B%AE%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/01/29/软件超市项目后台管理界面开发流程/</id>
    <published>2020-01-29T13:53:41.000Z</published>
    <updated>2020-03-02T09:33:54.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-3-组件编写"><a href="#3-3-组件编写" class="headerlink" title="3.3 组件编写"></a>3.3 组件编写</h1><h2 id="3-3-1-Manage-vue"><a href="#3-3-1-Manage-vue" class="headerlink" title="3.3.1 Manage.vue"></a>3.3.1 Manage.vue</h2><ul><li>存放目录：src/views/Manage.vue</li><li>作用：作为Layout容器</li><li>详情：包含了Header组件与Sidebar组件</li></ul><h2 id="3-3-2-Login-vue"><a href="#3-3-2-Login-vue" class="headerlink" title="3.3.2 Login.vue"></a>3.3.2 Login.vue</h2><ul><li>存放目录：src/views/login/Login</li><li>作用：登陆界面</li><li>详情：通过前台展示界面进入，进入时选择身份，ID的不同身份权限不一样。</li></ul><p><img src="\img\软件超市\后台管理界面login.png" alt="后台管理界面"></p><p><strong>具体实现</strong></p><p>需要根据前台显示的页面获取信息：</p><ol><li>getStudentIdByRequest get请求获取登陆的学号ID</li><li>getUserId?studentId= 通过登陆的studentId获取userId</li><li>getRole?userId= 通过userId获取角色权限，通过不用的权限生成不同的导航栏。</li><li><p>getMessageByUserGet?userGet=userId 通过userId获取消息，如果有未读消息，进入管理页面后直接显示消息通知，如果没有未读消息，则显示第一个路由。<br><img src="/img/软件超市/软件超市项目后台管理界面开发流程2.png" width="50%"></p></li><li><p>权限、登陆时效等相关（重要）</p></li></ol><h3 id="问题一：跨域问题"><a href="#问题一：跨域问题" class="headerlink" title="问题一：跨域问题"></a>问题一：跨域问题</h3><p>由于vue-cli脚手架工具开发时，由于项目本身启动本地服务是需要占用一个端口的，所以必然会有跨域问题。<br>解决办法：config/index（webpack构建下），更改开发环境下(在dev里配置)的proxyTable。将请求代理到目标域名</p><pre><code>proxyTable: {  &quot;/v1&quot;:{    target:&quot;http://software.sicau.edu.cn:8080&quot;,    changeOrigin: true//是否开启代理  }},</code></pre><h3 id="问题二：axios的cookie问题"><a href="#问题二：axios的cookie问题" class="headerlink" title="问题二：axios的cookie问题"></a>问题二：axios的cookie问题</h3><p>由于用的是学校的统一认证平台，采用的是cookie，在使用axios的时候，发现http响应头中少了Set-Cookie属性（axios隐藏了这部分）。<br>解决办法：axios.defaults.withCredentials = true。withCredentials属性主要功能是指定跨域的请求是否应该使用证书（如cookie或授权头header）</p><h3 id="问题三：vue组件刷新问题。（这个方法在添加删除之中比较好用，最后虽然没有采用但还是把记录下来）"><a href="#问题三：vue组件刷新问题。（这个方法在添加删除之中比较好用，最后虽然没有采用但还是把记录下来）" class="headerlink" title="问题三：vue组件刷新问题。（这个方法在添加删除之中比较好用，最后虽然没有采用但还是把记录下来）"></a>问题三：vue组件刷新问题。（这个方法在添加删除之中比较好用，最后虽然没有采用但还是把记录下来）</h3><p>用vue-router重新路由到当前页面，页面是不进行刷新的。采用window.reload,或者router.go(0)刷新时，整个浏览器进行了重新加载，闪烁，体验感不好。<br>解决办法：provide/inject组合<br>provide：选项应该是一个对象或返回一个对象的函数。该对象包含可传递其子孙的属性。<br>inject：一个字符串数组，或一个对象，对象的 key 是本地的绑定名</p><ol><li><p>app.vue 中通过provide将父组件中的数据传给子组件</p><pre><code class="bash"> &lt;router-view v-if=&quot;isRouterAlive&quot;&gt;&lt;/router-view&gt; &lt;script&gt; export default {   name: &quot;App&quot;,   provide() {     return {       reload: this.reload     }   },   data() {     return {       isRouterAlive: true     }   },   methods: {     reload() {       this.isRouterAlive = false       this.$nextTick( ()=&gt;         this.isRouterAlive = true       )     }   } }; &lt;/script&gt;</code></pre></li><li>在要使用的组件中inject:[‘reload’],调用this.reload()既可实现刷新。</li></ol><h3 id="问题4：错误捕获问题"><a href="#问题4：错误捕获问题" class="headerlink" title="问题4：错误捕获问题"></a>问题4：错误捕获问题</h3><p>由于前端要根据返回的不同错误类型，进行不同的处理，在抛出问题时，不知道用async/await的错误如何捕获。<br>解决办法：try catch只能捕获同步代码，不能捕获异步代码，在async函数内，使用await可以捕获异步代码，这里实际上是异步代码变成了同步代码。</p><ul><li>在 async 函数内部使用 try catch 捕获异步错误</li><li>promise 内部使用 .catch 方法来捕获 promise 内部代码错误</li></ul><pre><code>async getRequest({commit,dispatch}){  try{    let  resGetStudentIdByRequest = await getStudentIdByRequest();    if (resGetStudentIdByRequest.status==0){     ...    }    else throw resGetStudentIdByRequest.msg;  }catch(err){    throw {err, msg: &quot;无效登录&quot;, code: 1 }  }},</code></pre><h3 id="问题5：token验证-——————————————————待补充"><a href="#问题5：token验证-——————————————————待补充" class="headerlink" title="问题5：token验证 ——————————————————待补充"></a>问题5：token验证 ——————————————————待补充</h3><blockquote><p>之前的项目用的是session，偶然见看见一篇关于token的文章。<a href="https://blog.csdn.net/mydistance/article/details/84545768" target="_blank" rel="noopener">https://blog.csdn.net/mydistance/article/details/84545768</a></p></blockquote><p>点击进入管理界面时，先根据选择的不同身份，设置不同的不同的角色信息，在进加密。</p><p>进行路由拦截</p><pre><code class="bash">//main.jsrouter.beforeEach((to, from, next) =&gt; {let token = sessionStorage.getItem(&quot;token&quot;);if(token){...}else{  //如果没有token ,如果to.path在白名单中,则免登陆。如果不在白名单中，定向去登陆页面    (whiteList.includes(to.path)) == true ? next(): next(&quot;/login&quot;)}}</code></pre><p>登陆时设置token</p><pre><code class="bash">//action.js//设置角色async setRole({commit,dispatch},roleId){  //给身份加密  setRole(roleId);  //设置token  setToken();},//auth.jsconst verify = 45416289438485;//给角色权限加密export const setRole = roleId =&gt; {  let token = verify * roleId;  sessionStorage.setItem(&quot;xxx&quot;, token);};//设置登陆tokenexport const setToken = () =&gt; {  let token = randomString(32);  sessionStorage.setItem(&quot;token&quot;, token);};//产生随机数function randomString(len) {  len = len || 32;  /****默认去掉了容易混淆的字符oOLl,9gq,Vv,Uu,I1****/  const $chars =    &quot;ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678&quot;;  const maxPos= $chars.length;  let pwd = &quot;&quot;;  for (let i = 0; i &lt; len; i++) {    pwd += $chars.charAt(Math.floor(Math.random() * maxPos));  }  return pwd;}</code></pre><p>然后为了防止用户直接手动按f5刷新页面，这个时候会重新构建vue实例，而又没有重新登录，所以vuex里面的东西会清空，所以将登录后的数据存放在sessionStroage中，在刷新页面，重新构建vue实例的时候，会有判断。</p><h3 id="问题6：button按钮添加回车事件"><a href="#问题6：button按钮添加回车事件" class="headerlink" title="问题6：button按钮添加回车事件"></a>问题6：button按钮添加回车事件</h3><p>最开始的写法，发现login方法根本没有执行，开始以为是@keyup.enter.native的问题，但是写在封装好的组件中的时候加.native才能监听原生的事件。后面发现是输入框事件，在button上面不起效果。</p><pre><code class="bash">&lt;el-button @click=&quot;login&quot;  @keyup.enter.native=&quot;login&quot; class=&quot;btn&quot; :loading=&quot;btnLoading&quot;&gt;进入管理页面&lt;/el-button&gt;</code></pre><p>修改后，用了自定义指令的办法。</p><pre><code> &lt;el-button @click=&quot;login&quot;   v-enter=&quot;this&quot; class=&quot;btn&quot; :loading=&quot;btnLoading&quot;&gt;进入管理页面&lt;/el-button&gt;  directives: {    // 按enter键登录    enter(el, { value }) {      document.onkeydown = e =&gt; {        e = e || window.event;        if (e.keyCode === 13) {          value.login();        }      };    }  },</code></pre><h3 id="问题7：封装好外部链接"><a href="#问题7：封装好外部链接" class="headerlink" title="问题7：封装好外部链接"></a>问题7：封装好外部链接</h3><p>通过新建一个元素a，调用函数时点击a来实现外部跳转</p><pre><code class="bash">const HOME_URL = &quot;主页&quot;;const LOGIN_URL = &quot;统一认证界面&quot;;//新建aexport const goto = url =&gt; {  const link = document.createElement(&quot;a&quot;);  link.href = url;  link.click();};goto.home = () =&gt; goto(HOME_URL);goto.login = () =&gt; goto(LOGIN_URL);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;3-3-组件编写&quot;&gt;&lt;a href=&quot;#3-3-组件编写&quot; class=&quot;headerlink&quot; title=&quot;3.3 组件编写&quot;&gt;&lt;/a&gt;3.3 组件编写&lt;/h1&gt;&lt;h2 id=&quot;3-3-1-Manage-vue&quot;&gt;&lt;a href=&quot;#3-3-1-Manage-
      
    
    </summary>
    
      <category term="project" scheme="http://yoursite.com/categories/project/"/>
    
    
      <category term="软件超市" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82/"/>
    
  </entry>
  
  <entry>
    <title>Cookie、LocalStorage、sessionStorage的区别</title>
    <link href="http://yoursite.com/2020/01/29/Cookie%E3%80%81LocalStorage%E3%80%81sessionStorage/"/>
    <id>http://yoursite.com/2020/01/29/Cookie、LocalStorage、sessionStorage/</id>
    <published>2020-01-29T08:36:10.000Z</published>
    <updated>2020-08-08T02:37:59.767Z</updated>
    
    <content type="html"><![CDATA[<p>注意数组和对象要转化成JSON格式</p><p><strong>主要区别</strong></p><p><img src="/img/js/Cookie.png" width="70%"></p><p><strong>方法</strong></p><p>localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等</p><p>setItem存储value</p><pre><code class="bash">sessionStorage.setItem(&quot;key&quot;, &quot;value&quot;);localStorage.setItem(&quot;key&quot;, &quot;value&quot;);</code></pre><p>getItem获取value</p><pre><code class="bash">let value = sessionStorage.getItem(&quot;key&quot;);let key = localStorage.getItem(&quot;key&quot;);</code></pre><p>removeItem删除key</p><pre><code class="bash">sessionStorage.removeItem(&quot;key&quot;);localStorage.removeItem(&quot;key&quot;);</code></pre><p>clear清除所有的key/value</p><pre><code class="bash">sessionStorage.clear();localStorage.clear();</code></pre><p>localStorage和sessionStorage的key和length属性实现遍历</p><pre><code class="bash">let storage = window.localStorage;for(var i=0, len=storage.length; i&lt;len;i++){    var key = storage.key(i);    var value = storage.getItem(key);    console.log(key + &quot;=&quot; + value);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;注意数组和对象要转化成JSON格式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/js/Cookie.png&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;localS
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB学习笔记</title>
    <link href="http://yoursite.com/2019/08/01/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/08/01/MongoDB学习笔记/</id>
    <published>2019-08-01T14:15:07.000Z</published>
    <updated>2020-07-09T08:13:14.038Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB是非关系型数据库文档数据库，存的<strong>类似JSON</strong>的结构。</p><p>启动服务器，db存放数据库，我创建在D盘的。</p><pre><code>mongod --dbpath D:\mongoDB\data\db/*-----默认端口号27017-----*/mongod --dbpath D:\mongoDB\data\db --port XXX</code></pre><p>注意两个概念：</p><ol><li>数据库的服务器。服务器用来保存数据，mongod启动服务器</li><li>数据库的客户端。客户端用来操作服务器，对数据惊醒增删改查的操作，mongo启动</li></ol><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>数据库：存放集合。<br>集合：类似数组，在集合中存放文档。<br>文档：文档是数据库中的最小单位，存储和操作内容都是文档。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>use 数据库名 //进入数据库</p><h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><p>插入一个放对象db.<collection>.insert({数据})//db.<collection>.insertOne()<br>插入多个放数组db.<collection>.insert([{},{}]) //db .<collection>.insertMang()</collection></collection></collection></collection></p><p>//插入多条可以配合使用for循环</p><pre><code>var arr =[];for (var i=1;i&lt;=20000;i++){arr.push({num:i});}db.numbers.insert(arr)</code></pre><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>db.<collection>.find({条件})，为空查询所有。</collection></p><pre><code>/*----名字为张三并且年龄为28的文档,返回的是一个数组--*/db.stus.find({name:&quot;张三&quot;,age:28})/*----查询符合条件的第一个集合，返回的是一个对象--*/db.stus.findOne({age:28})/*-----返回符合条件的文档数量----*/db.&lt;collection&gt;.find().count()</code></pre><p>MongoDB支持通过内嵌文档的属性进行查询，通过点（.）连接。但是此属性名必须是用引号。</p><pre><code>hobby:{movies:[111,222],XXX}//查找的是hobby里面的moovies里面的值有111db.users.find(‘hobby.movies’:&#39;111&#39;)</code></pre><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>db.<collection>.update(查询条件，新对象,{修改的配置选项，可选})。update默认会使用新对象来替换旧对象。所以不常用。<strong>默认情况下只会修改一个</strong> ，实际上既可修改单个，也可修改多个。<br>db.<collection>.updateMany()。 修改多条<br>db.<collection>.updateOne()。 修改单条<br>db.collection.replaceOne()。替换单条</collection></collection></collection></p><p>常与<code>$set</code>结合使用来修改文档中的指定属性，没有的属性名会自动创建。<code>unset</code>可以删除响应属性。</p><pre><code>db.stus.update({name:&quot;李四&quot;},{$set:{gender:&quot;女&quot;}，{add:&quot;哈哈哈&quot;}})//若值为一个数组,$push往数组中添加。不考虑是否重复//$addToSet 向数组中添加一个新元素。 重复的就不会添加。db.stus.update({name:&quot;李四&quot;},{$push:{hobby.movies’:&#39;333&#39;}})</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>db.collection.remove()  删除符合条件的所有文档，第二个参数可选：删除配置（比如只删除一个）。<strong>必须传参，但如果传递空对象，则所有文档都删除（清空集合，性能太差）</strong><br>db.collection.deleteMany()<br>db.collection.deleteOne()<br>db.collection.drop() 删除集合<br>db.dropDatabase()删除数据库</p><p><strong>一般数据是不会删除的，而是在数据中添加一个字段，表示是否删除</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MongoDB是非关系型数据库文档数据库，存的&lt;strong&gt;类似JSON&lt;/strong&gt;的结构。&lt;/p&gt;
&lt;p&gt;启动服务器，db存放数据库，我创建在D盘的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mongod --dbpath D:\mongoDB\data\db
/*----
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MongoDB" scheme="http://yoursite.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>软件超市-返回刷新问题</title>
    <link href="http://yoursite.com/2019/06/28/%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82-%E8%BF%94%E5%9B%9E/"/>
    <id>http://yoursite.com/2019/06/28/软件超市-返回/</id>
    <published>2019-06-28T13:59:03.000Z</published>
    <updated>2020-03-02T09:35:51.459Z</updated>
    
    <content type="html"><![CDATA[<p>在对项目进行优化的时候，发现返回上一页的函数很多组件都会使用，于是打算把这个函数抽离出来。</p><p>在此之前需要先解决<strong>首页进入列表页面刷新，而详情页返回列表页面不刷新的问题</strong>的问题</p><h3 id="方法一：keep-alive与vue-router配合使用"><a href="#方法一：keep-alive与vue-router配合使用" class="headerlink" title="方法一：keep-alive与vue-router配合使用"></a>方法一：keep-alive与vue-router配合使用</h3><p>实现在定义了两个字段 <code>keepAlive:true</code> 标识是否使用keep-alive组件字段,<code>ifDoFresh:false</code>标识是否刷新数据字符</p><pre><code class="bash">/*------router/index-----*/    {      path: &#39;/project&#39;,      name:&#39;项目列表&#39;      component:resolve =&gt; require([&quot;@/pages/Project/Project&quot;],resolve),      meta: {        keepAlive:true,        ifDoFresh:false,        showNav: true      }    },</code></pre><p>在根组件中根据<code>keepAlive</code> 字符判断是否使用keep-alive组件</p><pre><code class="bash">/*------app.vue----*/&lt;div class=&quot;main&quot;&gt;    &lt;keep-alive&gt;       &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;/&gt;    &lt;/keep-alive&gt;    &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;/&gt;&lt;/div&gt;</code></pre><p>在目标列表页的beforeRouteEnter判断从哪个页面进入的，根据需求更改<code>ifDoFresh</code>变量。这里与<code>activated</code>联合用。</p><pre><code class="bash">beforeRouteEnter(to,from,next){        //需要刷新的页面        if (from.name!=&quot;团队详情&quot;) {          to.meta.ifDoFresh = true;        }        next()      },activated(){       if (this.$route.meta.ifDoFresh){          // 先重置          this.selected=0        this.$route.meta.ifDoFresh=false         this.$store.dispatch(&#39;getTeam&#39;,{teamId:0})        }      }</code></pre><p>按逻辑来说这样就可以了，但是有个的问题出现了！！！！</p><p><img src="\img\软件超市\图3.png" alt="视图3"><br><img src="\img\软件超市\图4.png" alt="视图4"></p><p>返回只显示一个团队了！！好气啊，不断调试中发现我团队详情的团队信息居然和我列表的团队信息存储在同一个变量里！！！！所以点进详情页后，改变了team，而keep-alive缓存的是team里的数据。我是白痴吗？？？？</p><p>还有一个问题就是从列表到首页，在从首页到列表页，分页的缓存仍然存在。</p><p>解决办法：在分页器组件内提前判断（因为使用分页器组件时并没有传当前页码）</p><pre><code class="bash">  activated(){    if (this.$route.meta.ifDoFresh) {      this.currentPage = 1    }  },</code></pre><h3 id="方法二：keep-alive标签内部添加"><a href="#方法二：keep-alive标签内部添加" class="headerlink" title="方法二：keep-alive标签内部添加"></a>方法二：keep-alive标签内部添加</h3><blockquote><p><a href="/2019/06/29/keep-alive">keep-alive的总结</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在对项目进行优化的时候，发现返回上一页的函数很多组件都会使用，于是打算把这个函数抽离出来。&lt;/p&gt;
&lt;p&gt;在此之前需要先解决&lt;strong&gt;首页进入列表页面刷新，而详情页返回列表页面不刷新的问题&lt;/strong&gt;的问题&lt;/p&gt;
&lt;h3 id=&quot;方法一：keep-alive与
      
    
    </summary>
    
      <category term="project" scheme="http://yoursite.com/categories/project/"/>
    
    
      <category term="软件超市" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82/"/>
    
  </entry>
  
  <entry>
    <title>软件超市-改变v-html内容的图片样式</title>
    <link href="http://yoursite.com/2019/06/26/%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82-%E9%97%AE%E9%A2%98v-if%E6%A0%B7%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/06/26/软件超市-问题v-if样式/</id>
    <published>2019-06-26T11:13:48.000Z</published>
    <updated>2020-03-02T09:35:51.382Z</updated>
    
    <content type="html"><![CDATA[<p>在通过v-html把后台传过来的内容渲染到页面之后，发现后台传来的图片是限制了宽和高的。</p><p><img src="\img\软件超市\图1.png" alt="视图1"></p><p>通过查资料发现，这里解析是把v-html传来的数据作为了一个新的组件，所以在scoped下的style里面设置样式不起作用。那么根据原理，或许可以把scoped直接去掉，但是为了防止组件之间的样式污染，使用了其他办法。</p><p><strong>方法一</strong></p><p> <code>&gt;&gt;&gt;</code>(深度作用选择器) 或者 有些sass类的预处理器无法正确解析可以使用 /deep/</p><pre><code class="bash">/*----html----*/&lt;div class=&quot;announcement_img&quot; v-html=&quot;announcement.content&quot;&gt;&lt;/div&gt;/*----style----*/.announcement_img&gt;&gt;&gt;img{width: 100%;display: block;height: auto;}</code></pre><p><strong>方法二</strong></p><p>updated周期函数中，js动态配置样式。</p><p>首先需要清楚updated周期函数在什么时候起作用，①data里面需要有该数据变量如arr ②在页面重新渲染arr完成后才进入updated。更深入的会在以后学习。</p><pre><code>updated:function(){console.log(&quot;1==我会先执行&quot;);this.$nextTick(function(){//在下次 DOM 更新循环结束之后执行这个回调。在修改数据之后立即使用这个方法，获取更新后的DOM.console.log(&quot;3==我只能等页面渲染完了才会立即执行&quot;);})console.log(&quot;2==我虽然在最后但会比$nextTick先执行&quot;)}</code></pre><p><img src="\img\软件超市\图2.png" alt="视图2"></p><p>如果后期发现更好的或者更多的办法会重新更新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在通过v-html把后台传过来的内容渲染到页面之后，发现后台传来的图片是限制了宽和高的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;\img\软件超市\图1.png&quot; alt=&quot;视图1&quot;&gt;&lt;/p&gt;
&lt;p&gt;通过查资料发现，这里解析是把v-html传来的数据作为了一个新的组件，所以在s
      
    
    </summary>
    
      <category term="project" scheme="http://yoursite.com/categories/project/"/>
    
    
      <category term="软件超市" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82/"/>
    
  </entry>
  
  <entry>
    <title>markdown</title>
    <link href="http://yoursite.com/2019/05/15/markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/05/15/markdown学习笔记/</id>
    <published>2019-05-15T14:19:13.000Z</published>
    <updated>2020-07-09T08:12:45.540Z</updated>
    
    <content type="html"><![CDATA[<p>写博客的时候有些不常用的语法会有遗漏，今天重新学习markdown常用语法并把记录下来。</p><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>   兼容HTML。不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。<br>   <span id="jump">用于瞄点测试</span></p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>方法一：</p><pre><code>```# 第一级标题 `&lt;h1&gt;`## 第二级标题 `&lt;h2&gt;`### 第三级标题 `&lt;h3&gt;`#### 第二四级标题 `&lt;h4&gt;`##### 第五级标题 `&lt;h5&gt;`###### 第六级标题 `&lt;h6&gt;````</code></pre><p>方法二：</p><p>任何数量的 = 和 - 都可以有效果。</p><pre><code>```一级标题=二级标题-```</code></pre><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p><strong>如果* 和 _ 两边都有空白的话，它们就只会被当成普通的符号</strong><br>如果要在文字前后直接插入普通的星号或底线，可以用反斜线。</p><p>斜体 <code>*内容*</code>或者<code>_内容_</code>   （em）<br>加粗 <code>**内容**</code>或者<code>__内容__</code>   （strong）<br>倾斜加粗 <code>***内容***</code><br>删除线 <code>~~内容~~</code></p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>行内式</p><pre><code>```[我的博客](https://biubiuins.github.io/)自动生成连接  &lt;https://biubiuins.github.io/&gt;```</code></pre><p>效果：<br><a href="https://biubiuins.github.io/" target="_blank" rel="noopener">我的博客</a><br>自动生成连接  <a href="https://biubiuins.github.io/" target="_blank" rel="noopener">https://biubiuins.github.io/</a></p><p>添加图片形式和链接类似。</p><pre><code>```格式：![图片描述](url)![GitHub set up](http://zh.mweb.im/asset/img/set-up-git.gif)```</code></pre><p>效果：</p><p><img src="http://zh.mweb.im/asset/img/set-up-git.gif" alt="GitHub set up"></p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。</p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><ol><li>只要简单地缩进 4 个空格或是 1 个制表符就可以。 <strong>需要和普通段落之间存在空行！</strong></li><li>`内容`</li><li>多行代码块与语法高亮：在需要高亮的代码块的前一行及后一行使用三个单反引号`包裹，就可以了。</li><li>代码块中包含html代码。在代码区块里面， &amp; 、&lt; 和 > 会自动转成 HTML 实体</li></ol><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ol><li>在被引用的文本前加上&gt;符号，以及一个空格就可以了，如果只输入了一个&gt;符号会产生一个空白的引用。</li><li>引用可以嵌套</li><li>引用的区块内也可以使用其他的Markdown 语法</li></ol><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p><strong>符号后面一定要有一个空格，起到缩进的作用。</strong><br>还需要注意的是在使用列表时，只要是数字后面加上英文的点，就会无意间产生列表，比如2017.12.30 这时候想表达的是日期，有些软件把它被误认为是列表。解决方式：在每个点前面加上\就可以了。</p><ol><li>无序列表<br>使用 *，+，- 表示无序列表。</li><li>有序列表<br>使用数字和一个英文句点表示有序列表。</li></ol><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><pre><code class="html">姓名|分数-|-张三|50李四|80</code></pre><p>效果：</p><table><thead><tr><th>姓名</th><th>分数</th></tr></thead><tbody><tr><td>张三</td><td>50</td></tr><tr><td>李四</td><td>80</td></tr></tbody></table><p>表格对齐方式：我们可以指定表格单元格的对齐方式，冒号在左边表示左对齐，右边表示有对齐，两边都有表示居中。</p><pre><code class="html">姓名|分数:-|-:张三|50李四|80</code></pre><p>效果：</p><table><thead><tr><th style="text-align:left">姓名</th><th style="text-align:right">分数</th></tr></thead><tbody><tr><td style="text-align:left">张三</td><td style="text-align:right">50</td></tr><tr><td style="text-align:left">李四</td><td style="text-align:right">80</td></tr></tbody></table><h3 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h3><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><pre><code>\   反斜线`   反引号*   星号_   底线{}  花括号[]  方括号()  括弧#   井字号+   加号-   减号.   英文句点!   惊叹号</code></pre><h2 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h2><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>方法1: 连续两个以上空格+回车<br>方法2：使用html语言换行标签</p><h3 id="其他特殊字符"><a href="#其他特殊字符" class="headerlink" title="其他特殊字符"></a>其他特殊字符</h3><p><a href="https://unicode-table.com/cn/" target="_blank" rel="noopener">unicode字符编码</a></p><h3 id="内容目录"><a href="#内容目录" class="headerlink" title="内容目录"></a>内容目录</h3><p>在段落中填写 <code>[TOC]</code> 以显示全文内容的目录结构，需要独占一行才能生效。</p><h3 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h3><p>Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3。</p><pre><code class="html">&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;&lt;font color=gray size=5&gt;color=gray&lt;/font&gt;&lt;font color=#0099ff size=5 face=&quot;黑体&quot;&gt;color=#0099ff size=5 face=&quot;黑体&quot;&lt;/font&gt;</code></pre><p>背景色需要借助 table, tr, td 等表格标签的 bgcolor 属性来实现背景色的功能。</p><pre><code class="html">&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=pink&gt;背景色是：pink&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</code></pre><p>效果：</p><table><tr><td bgcolor="pink">背景色是：pink</td></tr></table><h3 id="瞄点"><a href="#瞄点" class="headerlink" title="瞄点"></a>瞄点</h3><p>自定义瞄点</p><p>标签形式的锚点目标的id特性值中是不能含有中文字符；</p><pre><code>//建立一个跳转链接[说明文字](#jump)//需要跳转到的位置&lt;span id = &quot;jump&quot;&gt;跳转到的位置&lt;/span&gt;</code></pre><p>效果：<a href="#jump">瞄点</a></p><p>Markdown会自动给每一个h1~h6标题生成一个锚，其id就是标题内容。如<a href="#表格">表格</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写博客的时候有些不常用的语法会有遗漏，今天重新学习markdown常用语法并把记录下来。&lt;/p&gt;
&lt;h2 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h2&gt;&lt;p&gt;   兼容HTML。不在 Markd
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>element-ui总结</title>
    <link href="http://yoursite.com/2019/04/19/element-ui%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/04/19/element-ui总结/</id>
    <published>2019-04-19T07:37:38.000Z</published>
    <updated>2020-07-06T07:59:18.584Z</updated>
    
    <content type="html"><![CDATA[<p>在一次项目中用到了element-ui框架，对在使用过程中遇见的问题进行总结（持续更新）。</p><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><h3 id="1-数据为二级对象时"><a href="#1-数据为二级对象时" class="headerlink" title="1.数据为二级对象时"></a>1.数据为二级对象时</h3><p>数据为二级对象时，验证的数据要用字符串形式。</p><pre><code class="js">rules:{   &quot;captainInformation.name&quot;: [     { required: true, message: &#39;请输入姓名&#39;, trigger: &#39;blur&#39; },     ],    }</code></pre><h3 id="2-动态添加的数据"><a href="#2-动态添加的数据" class="headerlink" title="2.动态添加的数据"></a>2.动态添加的数据</h3><p>动态添加的输入框或表单绑定数据时注意 <code>:prop=&quot;&#39;v-for绑定的数组.&#39; + index + &#39;.v-model绑定的变量&#39;&quot;</code><br>   我是直接把验证写在标签里面的</p><pre><code>    &lt;el-form-item label=&quot;姓名&quot; :prop=&quot;&#39;memberInformation.&#39;+index+&#39;.name&#39;&quot; :rules=&quot;[ { required: true, message: &#39;请输入姓名&#39;, trigger: &#39;blur&#39; }]&quot;&gt;</code></pre><p>   增加与减少成员</p><pre><code>   //增加成员    addmember() {      let newmember = {            name: &quot;&quot;,            studentId: &quot;&quot;,           }           this.form.memberInformation.push(newmember)         },         //减少成员         reducemember(index) {           this.form.memberInformation.splice(index, 1)         },</code></pre><blockquote><p>这个是我在项目中用到的办法，在阅读时发现了另一种情况的解决办法：<a href="https://blog.csdn.net/weixin_41041379/article/details/81908788" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41041379/article/details/81908788</a></p></blockquote><h3 id="3-普通输入验证"><a href="#3-普通输入验证" class="headerlink" title="3.普通输入验证"></a>3.普通输入验证</h3><pre><code>```jsrules:{data1:[//必填，trigger是触发类型{ required: true, message: &#39;请输入学号&#39;, trigger: &#39;blur&#39; },//数字类型 &#39;number&#39;, 整数: &#39;integer&#39;, 浮点数: &#39;float&#39;//使用整数的时候，首先要保证数据类型为数字，可以v-model.number绑定数据{type: &#39;integer&#39;, message: &#39;格式错误&#39;, trigger: &#39;blur&#39;},//长度限制{ min: 2, max: 4, message: &#39;长度在 2 到 4 个字符&#39;, trigger: &#39;blur&#39; }]}```</code></pre><h3 id="4-手动验证"><a href="#4-手动验证" class="headerlink" title="4.手动验证"></a>4.手动验证</h3><p>   第一种是直接写在rules的里面</p><pre><code>    rules:{    data1:[         { validator:(rule,value,callback)=&gt;{                    if(/^\d+$/.test(value) == false){                      callback(new Error(&quot;只能输入数字&quot;));                    }else{                      callback();                    }                  }, trigger: &#39;blur&#39; }    }    ]</code></pre><p>   第二种写法是抽离出来</p><pre><code>   //注意书写位置    data(){     let checkAge = (rule, value, callback) =&gt; {        if (!value) {          return callback(new Error(&#39;年龄不能为空&#39;));        }         if (!Number.isInteger(value)) {            callback(new Error(&#39;请输入数字值&#39;));          } else {            if (value &lt; 18) {              callback(new Error(&#39;必须年满18岁&#39;));            } else {              callback();            }          }      }    return {    rules:{        age: [       { trigger: &#39;blur&#39;, validator: checkAge }              ]        }    }</code></pre><h3 id="5-手动上传文件"><a href="#5-手动上传文件" class="headerlink" title="5.手动上传文件"></a>5.手动上传文件</h3><pre><code>```html//html     &lt;el-upload          action          ref=&quot;upload&quot;          //覆盖默认的上传行为，自定义上传的实现          :http-request=&quot;finish&quot;          //取消自动上传          :auto-upload=&quot;false&quot;        &gt;          &lt;el-button slot=&quot;trigger&quot; size=&quot;small&quot; type=&quot;primary&quot;&gt;选取文件&lt;/el-button&gt;          &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;请上传您的项目功能清单&lt;/div&gt;        &lt;/el-upload&gt;//js finish() {  this.$refs.form.validate(valid =&gt; {         // 验证成功         if (valid) {         //这里的需求是必须上传文件           const file = this.$refs.upload.uploadFiles[0];           if (!file) {                     this.$message({                       type: &quot;warning&quot;,                       message: &quot;请选择文件&quot;                     });                     return;                   }           //数据处理           let formData = new FormData();           formData.append(&quot;projectId&quot;, this.runId);           formData.append(&quot;timeNode&quot;,JSON.stringify(this.form.timeNode));           formData.append(&quot;teamId&quot;, 1);           formData.append(&quot;functionFile&quot;,file.raw );           //....中间的弹框确定等省略           submitApply(formData)         } } }```</code></pre><h3 id="6-动态获取选项-模糊查询"><a href="#6-动态获取选项-模糊查询" class="headerlink" title="6.动态获取选项+模糊查询"></a>6.动态获取选项+模糊查询</h3><p><img src="/img/element-ui/element-ui.png" alt="演示图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在一次项目中用到了element-ui框架，对在使用过程中遇见的问题进行总结（持续更新）。&lt;/p&gt;
&lt;h2 id=&quot;表单&quot;&gt;&lt;a href=&quot;#表单&quot; class=&quot;headerlink&quot; title=&quot;表单&quot;&gt;&lt;/a&gt;表单&lt;/h2&gt;&lt;h3 id=&quot;1-数据为二级对象时&quot;&gt;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="库" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E5%BA%93/"/>
    
    
      <category term="UI" scheme="http://yoursite.com/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>vuex流程总结</title>
    <link href="http://yoursite.com/2018/12/09/vuex%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/12/09/vuex流程总结/</id>
    <published>2018-12-09T14:04:49.000Z</published>
    <updated>2020-07-09T08:15:21.840Z</updated>
    
    <content type="html"><![CDATA[<p>对如何异步显示数据效果的编码流程进行了总结</p><ol><li><p>ajax<br>ajax请求函数，抛出接口</p></li><li><p>vuex</p><ul><li><p>store里面新建index完成基本配置</p><pre><code>/*vuex最核心的管理对象store组装模块并导出 store 的地方*/// 首先引入Vue及Vueximport Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;// 引入四个基本模块import state from &#39;./state&#39;import mutations from &#39;./mutations&#39;import actions from &#39;./actions&#39;import getters from &#39;./getters&#39;// 一定要声明使用插件Vue.use(Vuex)// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件export default new Vuex.Store({state,mutations,actions,getters})</code></pre></li></ul></li></ol><pre><code>- 现在Vue对象里面挂载store```import store from &#39;./store&#39;new Vue({    el: &#39;#app&#39;,    components: { App },    template: &#39;&lt;App/&gt;&#39;,    store //所有的组件都多了一个$store})```- 在store下新建state.js    state：用于存储状态对象    ```    export default {    user:{}    }    ```- 在store下新建mutation-types.js    mutation是操作state状态的，mutation-types是存放操作state的方法名    ```    export const RECEIVE_USER_INFO = &#39;receive_user_info&#39; // 接收用户信息    ```- 在store下新建actions.js    action是通过操作mutation间接更新state的多个方法的对象    起连接作用。    异步获取数据。(注意需要引入api接口函数)把数据传给mutation。(因为mutation的方法名是放在mutation-types里面，所以注意要引入mutation-types里面对应的方法名)    ```    import {    reqUserInfo,    } from &#39;../api&#39;    import {      RECEIVE_USER_INFO,    } from &#39;./mutation-types&#39;     // 异步获取用户信息     async getUserInfo ({commit}) {      const result = await reqUserInfo()      //如果请求成功，返回code=0      if (result.code === 0) {       const userInfo = result.data       //提交mutation       //把结果{userInfo}提交给RECEIVE_USER_INFO方法       commit(RECEIVE_USER_INFO, {userInfo})        }      },    ```    参数除了commit以外，还可以有state`{commit,state}`- 在store里面新建mutations.js    mutations直接对state进行操作，`[方法名](state,{param}){}` 默认第一个参数state，所以需要引入vue与方法名    ```    import Vue from &#39;vue&#39;    import {      RECEIVE_USER_INFO,      } from &#39;./mutation-types&#39;    export default {      [RECEIVE_USER_INFO] (state, {userInfo}) {        state.userInfo = userInfo      }      }    ```</code></pre><ol start="3"><li>使用数据</li></ol><p>一般放在<code>computed</code>中进行接收，有利于state的值发生改变的时候及时响应给子组件。</p><ul><li>mapState辅助函数<pre><code> mapState返回的是一个对象 其实就是返回值:{return this.$store.XXXX}</code></pre></li></ul><pre><code>   当一个组件需要获取多个状态时候，用mapState辅助函数更为方便   ```   import { mapState } from &#39;vuex&#39;   export default {   computed:mapState({   //方法一：箭头函数   count: state =&gt; state.count;   //方法二：传字符串参数&#39;count&#39;等同于‘state=&gt;state.count’   count:&#39;count&#39;;   //方法三，使用this获取局部状态，必须使用常规函数   count(state){    return this.count   }   })   }   ```当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。    ```    computed:mapState([ &quot;count&quot;])    ```</code></pre><ul><li><p>…mapState()</p><pre><code>  ...mapState是state的语法糖，使用时需要从vuex中引入  ```  computed:{  ...mapState({})  }  ```</code></pre></li><li><p>mapGetters 辅助函数</p><p>  mapGetters辅助函数仅仅是将store中的getter映射到局部属性</p><pre><code>  import { mapGetters } from &#39;vuex&#39;  export default {    // ...    computed: {    // 使用对象展开运算符将 getter 混入 computed 对象中      ...mapGetters([        &#39;doneTodosCount&#39;,        &#39;anotherGetter&#39;,        // ...      ])    }  }</code></pre></li></ul><ul><li>mapActions<br>  类似mapState</li></ul><ul><li><p>getter计算属性</p><pre><code>```computed: { doneTodosCount () {   return this.$store.state.todos.filter(todo =&gt; todo.done).length   } } ```</code></pre><p> 如果有多个组件需要用到这个属性，可以在store里面定义‘getter’，可以说是store的计算属性，像计算属性一样，getter的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算</p><pre><code>  const store = new Vuex.Store({    state: {      todos: [        { id: 1, text: &#39;...&#39;, done: true },        { id: 2, text: &#39;...&#39;, done: false }      ]    },    getters: {    //state作为第一个参数      doneTodos: state =&gt; {        return state.todos.filter(todo =&gt; todo.done)      }      //可以接收其他getter作为第二个参数        doneTodosCount: (state, getters) =&gt; {          return getters.doneTodos.length        }        //可以通过让getter返回一个函数，来实现给getter传参,对store里的数组进行查询时非常有作用         getTodoById: (state) =&gt; (id) =&gt; {            return state.todos.find(todo =&gt; todo.id === id)          }          //store.getters.getTodoById(2) // -&gt; { id: 2, text: &#39;...&#39;, done: false }    }  })  //在组件中使用，同计算属性的调用，不用加括号  this.$store.getters.doneTodosCount</code></pre></li></ul><ul><li><p>dispatch方法</p><p> dispatch(actionName,data)分发调用action，第一个参数是方法名，第二个是数据<br> 触发store里面的action对应方法名的函数</p><pre><code> this.$store.dispatch(&quot;&quot;)</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对如何异步显示数据效果的编码流程进行了总结&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;ajax&lt;br&gt;ajax请求函数，抛出接口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;vuex&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;store里面新建index完成基本配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*

      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
</feed>
