<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[letcode记录]]></title>
    <url>%2F2020%2F03%2F10%2Fletcode%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[第一题：买卖股票的最佳时机时间：2020-03-10题目：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。分析：最终需要比较的量是最大利润，比较的条件是先买入再卖出。如果出现元素比基数还小，那么该元素后面比它大的元素与该元素的差一定大于与基础的差。思路：设置当前基数为prices[0],循环数组当数组元素大于基数时，比较当前利润与之前的利润，大者保存；当元素小于基数时，小的元素作为新的基数。代码： var maxProfit = function(prices) { let price = prices[0],profit=0; for(let i=1;i&lt;prices.length;i++){ if(price&lt;prices[i]){ //当后面的大于前面时计算利润 profit = (prices[i]-price&gt;profit)?(prices[i]-price):profit; }else{ //当后面的价格比当前的价格小时，改变price price = prices[i]; } } return profit; }; 性能分析：执行用时68ms，内存消耗35.8MB 总结改进1：比较大小时了用Math.max，写法更简单。 学习1：看了其他人的解题思路，学习到了dp算法解题结论:由牛顿莱布尼兹的思想可以得出，区间和可以转换成求差问题，求差问题，也可以转换成区间和的问题。最大连续子数组和可以使用动态规划求解，dp[i]表示以i为结尾的最大连续子数组和，递推公式为dp[i]=max(0,dp[i-1]) //dp粗糙版本 var maxProfit = function(prices) { if(prices.length&lt;=1) return 0 let diff = [] //记录数组相邻两元素差值 for (let i = 0; i &lt; prices.length-1; i++) { diff[i] = prices[i+1] -prices[i] } let dp = new Array(prices.length).fill(0) dp[0] = Math.max(0,diff[0]) let max = dp[0] for (let i = 1; i &lt; diff.length; i++) { //转换成区间求和问题 //差值累加，累加的最大值就是两个元素差的最大值 dp[i] = Math.max(0, dp[i-1]+diff[i]) max = Math.max(max,dp[i]) } return max } 解题的思路其实与我想的差不多，就是实现上面把求差问题，转换成了求和问题。 // 方法三：dp优化版 var maxProfit = function(prices) { let last = 0 let max = 0 for (let i = 0; i &lt; prices.length-1; i++) { //累加值为正，说明该元素之前有比他小的 //累加值为负，说明该元素前面暂时没有比他小的 //累加值就是元素之间的差值，累计值最大的就是最大利润。 last = Math.max(0, last + prices[i+1]-prices[i]) max = Math.max(max,last) } return max } 阅读笔记《一个方法解决6道股票题》日期：2020-03-11]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC、MVP、MVVM]]></title>
    <url>%2F2020%2F03%2F04%2FMVC%E3%80%81MVP%E3%80%81MVVM%2F</url>
    <content type="text"><![CDATA[综述MVC后端MVCWeb1.0时代并没有前端概念，开发一个web应用多数采用ASP.NET/Java/PHP编写，项目通常由多个aspx/jsp/php文件构成，每个文件中同时包含了HTML、CSS、JavaScript、C#/Java/PHP代码。也就是前后端混合。 架构的好处：简单快捷架构的去点：JSP代码难以维护 为了让开发更加便捷，代码更容易维护，前后端职责更清晰。便衍生出MVC开发模式和框架，前端展示以模板的形式出现。典型的框架就是Spring、Structs、Hibernata，整体框架如图所示 但这里的MVC仅限于后端，前后端形成了一定的分离，前端只完成了后端开发中的view层（简单的静态页面）。 这种模式存在问题：1.前端页面开发效率不高2.前后端职责不清 Web2.0时代随着Ajax技术的流行，前后端的职责就更加清晰。前端可以通过Ajax与后端进行数据交互。因此，整体的架构图也发成了变化： 架构的好处：减少了服务端负载和流量消耗，用户体验也更好了架构的缺点：缺乏可行的开发模式承载更复杂的业务需求，页面内容都杂糅在一起，一旦应用规模增大，就会导致难以维护。因此，前端的MVC随之而来。 前端MVC前端的MVC与后端类似，具备View、Controller和Model Model：负责保存应用数据，与后端数据进行同步 Controller：负责业务逻辑，根据用户行为对Model数据进行修改 View：负责视图展示，将model中的数据可视化出来 View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，用户得到反馈 由于单向流通，开发过程并不灵活。由于很多开发者都会在View中写一些逻辑代码，逐渐的就导致view中的内容越来越庞大，而controller变得越来越单薄。 MVP在前端的变化中，MVP模式在前端开发中并不常见，因为Angular早早地将MVVM框架模式带入了前端。虽然MVP模式在前端开发并不常见，但是在安卓等原生开发中会考虑。 MVP与MVC很接近，P指的是presenter（中间件），负责和Model/view进行双向交互。虽然分离了view和model，但容易导致presenter的体积增大，难以维护。Model=》presenter=》viewModel《=presenter《=view MVVMMVVM（Model-View-ViewModel） ViewModel通过实现一套数据响应式机制自动响应Model中数据变化；同时ViewModel会实现一套更新策略自动将数据变化转化为视图更新；通过事件监听响应view中用户交互修改Model中数据。这样ViewModel中就减少了大量DOM操作代码。MVVM在保持View和Model松耦合的同时，还减少了维护它们关系的代码，使用户专注于业务逻辑，兼顾开发效率和可维护性。在 MVVM 中，UI 是通过数据驱动的，数据一旦改变就会相应的刷新对应的 UI，UI 如果改变，也会改变对应的数据。这种方式就可以在业务处理中只关心数据的流转，而无需直接和页面打交道。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。 总结 这三者都是框架模式，它们设计的目标都是为了解决Model和View的耦合问题 MVC模式出现在较早主要应用与后端，如Spring MVC等，优点是分成清晰，缺点是数据流混乱，灵活性带来的维护性问题。 MVP模式是MVC的进化形态，Presenter作为中间层负责MV通信，解决了两者耦合问题，但P层过于臃肿会导致维护问题。 MVVM模式在前端领域有广泛应用，它不仅解决MV耦合问题，还同时解决了维护两者映射关系的大量繁杂代码和DOM操作代码，在提高开发效率、可读性同时还保持了优越的性能表现 MVC分为三个部分 View（视图）：用户界面 Controller（控制器）：业务逻辑 Model（模型）：数据保存 通信方式：View ==传指令到==》 Controller ==完成业务逻辑后，要求Model改变状态==》 Model ==将新的数据发送到View==》view 特点：1.单向通信，开发过程并不灵活。2.控制器的代码却是越写越多。3.由于写的代码较多,故不好进行性能测试。 MVP 通讯方式：View =》 Presenter =》 ModelView 《= Presenter 《= Model 特点：1.双向通信2.View与Model不发生联系，通过Presenter传递3.View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。 MVVM MVVM基本与MVP一样，唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。 特点：1.低耦合：分离视图（View）和模型（Model），降低代码耦合，提高视图或者逻辑的重用性2.可复用：你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 View 重用这段视图逻辑。3.独立开发：开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。4.可测试：界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。5.双向绑定使得异常情况很难被调试。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript（更新中）]]></title>
    <url>%2F2020%2F03%2F03%2FJavaScript%2F</url>
    <content type="text"><![CDATA[学习整理的demo库 综述JavaScript（实现） = ECMAScript（标准） + DOM + BOM BOM是浏览器对象模型，用来获取或设置浏览器的属性、行为，例如：新建窗口、获取屏幕分辨率、浏览器版本号等。简单的说：bom是浏览器可视窗口操作DOM是文档对象模型，用来获取或设置文档中标签的属性，例如获取或者设置input表单的value值。 BOM的内容不多，主要还是DOM。 由于DOM的操作对象是文档（Document），所以dom和浏览器没有直接关系。Window对象：是整个BOM的核心，所有对象和集合都以某种方式回接到window对象。Window对象表示整个浏览器窗口，但不必表示其中包含的内容。Document对象：实际上是window对象的属性。这个对象的独特之处是唯一一个既属于BOM又属于DOM的对象。 编写基本要求1.html不区别大小写，而JavaScript严格区别大小写2.如果不写分号，浏览器会自动添加，但是会消耗系统资源，所以开发中必须写分号3.JS中会忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化 基本语法 1.字面量与变量字面量：一些不可改变的值，可直接使用，比如：1 2 3 4 5 ，一般不用变量：变量可以保存字面量，且可以任意改变，所以一般用变量 2.标识符在JS中所有可以由我们自主命名，比如：变量名、函数名、属性名可以是字符、数字（不可开头）、__、$不可以是ES中的关键字或保留字标识符一般采用驼峰命名法 3.数据类型基本数据类型： Undefined、Null、Boolean、Number、String和Symbol(ES6)引用数据类型： Object(Array, Date, RegExp, Function) 字符串中可以使用\进行转义字符 数字的最大值：Number.MAX_VALUE,最小正值：Number.MIN_VALUE超过最大值返回Infinity表示正无穷。NAN（类型仍然是number）是一个特殊的数字，表示NOT A NUMBER。JS进行浮点运算，可能得到一个不精确的结果（不要用JS进行对精确度比较高的运算） Null类型的值只有一个null，null专门用来表示为空的对象，所以使用typeof会返回ObjectUndefined类型的值只有一个undefined，当声明一个变量，但并不给变量赋值时返回undefined 强制类型转化主要指其他数据类型转换成String，Number，Boolean转化成String：1.XXX.toString返回转换结果(null,undefined没有该方法)。2.调用String(需要转化的值)函数，对于Number和Boolean实际上调用的是toString方法，对于null/undefined直接转化为”null/undefined”。转化成Number：1.调用Number(需要转化的值)函数，如果有非数字类容/undefined转换NaN，空串/null/false转换成0,true转换成12.对于字符串，parseInt():把一个字符串转换成整数。parseFloat():把一个字符串转化成浮点数。非字符串将其转化成字符串再操作，返回转化结果。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XHR的ajax封装(简单版本)]]></title>
    <url>%2F2020%2F03%2F01%2FXHR%E7%9A%84ajax%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[目的:熟练XHR的基本使用 特点1.函数的返回值为promise，成功的结果为response，失败的结果为error2.能处理多种类型的请求：GET/POST/PUT/DELETE3.函数的参数为一个配置对象 { url:&quot;&quot;,//请求地址 method:&quot;&quot;,//请求方式 params:{},//GRT/DELETE请求的query参数 data:{},//POST或DELETE请求的请求体参数 } 4.响应json数据自动解析为js5.response只实现了data，status，statusText6.put请求提交的是请求体参数，delete提交query参数 补充1.query，params，body req.params,req.query是用在get请求当中 query参数 返回值：对数据过滤产生一个新数组 param参数:常用于REST API风格 localhost:3000/posts?id=1 返回值：定位到对应的对象 返回值：定位到对应的对象 localhost:3000/posts/1 req.body是用在post请求中的，body 不是 nodejs 默认提供的，你需要载入 body-parser 中间件才可以使用，req.body此方法通常用来解析 POST 请求中的数据。 2.OPTIONS请求，预检查（get不需要）是否跨域等，没有响应体。 注意:1.axios的params是指定get或者delete请求的query参数（拼接在url后面）2.发送json格式请求体参数，需要设置请求头 function axios({ url, method=&quot;GET&quot;, //设置默认值 parmas={},//默认空对象 data={}//设置默认值 }) { //返回一个Promise对象 return new Promise((resolve, reject) =&gt; { //处理query参数，拼接到url let queryString=&#39;&#39; for (key in params){ queryString+=`${key}=${parmas[key]}&amp;` } if (queryString){ //去掉最后的&amp; queryString = queryString.substring(0,queryString.length-1) //拼接 url += &quot;?&quot;+queryString } //处理method为大写 method = method.toUpperCase() //1.执行异步ajax请求 //创建xhr对象 const request = new XMLHttpRequest(); //初始化请求(异步) request.open(method,url,true) //绑定状态改变的监听,send是异步的，所以绑定监听写在send后面也可以 request.onreadystatechange = function () { //如果请求没有完成，直接结束 if (request.readyState!==4){ return } } switch (method){ case &quot;GET&quot;||&quot;DELETE&quot; : //get的参数通过url传 request.send(); break; case &quot;POST&quot;||&quot;PUT&quot;: //发送请求 // post请求的data不能是对象需要是字符串 //发送JSON格式，需要加请求头 request.setRequestHeader(&quot;Content-Type&quot;,&quot;application/json;charset=utf&quot;)//告诉服务器请求体的格式是json request.send(JSON.stringify(data)) break; } //如果响应状态码在【200，300)之间代表成功，否则失败 const {status,statusText} = request if (status&gt;=200&amp;&amp;status&lt;=299){ //2.1如果请求成功了，调用resolve() //准备结果response对象 const response = { //服务器返回的是JSON数据需要转换成对象 //响应json数据自动解析为js的对象/数组 data:JSON.parse(request.response), status, statusText, } resolve(response) }else { //2.2如果请求失败,调用reject() reject(new Error(`request error status is ${status}`)) } }) }]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios]]></title>
    <url>%2F2020%2F02%2F27%2Faxios%2F</url>
    <content type="text"><![CDATA[HTTP相关交互的基本过程 客户端 ===》（请求行，请求头，请求体）服务器服务器 ===》（状态行，响应头，响应体）客户端 请求报文请求行：method url多个请求头：host主机，cookie，Content-Type(请求体的内容类型)application/json 或者 application/x-www.form.urlencoded请求体（get请求没有）：{“username”:”tom”,”pwd”:123} 或者 username=tom&amp;pwd=123 响应报文状态行：status statusText多个响应头：Content-Type(响应体的内容类型):text/html;charset=uft-8 Set-Cookie:BD_CK_SAM=1;path=/响应体：html 文本/json 文本/js/css/图片… post请求体参数格式Content-Type:application/x-www.form.urlencoded例如：username=tom&amp;pwd=123 Content-Type:application/json例如：{“username”:”tom”,”pwd”:123} Content-Type:multipart/form-data用于文件上传请求 常见的响应状态码200 ok 请求成功，一般用于GET与POST请求201 created 已创建。成功请求并创建了新的资源401 Unauthorized 未到授权/请求要求用户的身份认证404 Not Found 服务器无法根据客户端的请求找资源500 Internal Serve Error 服务器内部错误，无法完成请求 常用请求类型 GET:从服务器端读取数据POST:向服务器端添加新数据PUT:更新服务器端已有数据DELETE:删除服务器端数据 API的分类1.REST API: restful 发送请求进行操作由请求方式决定 同一个请求路径可以进行多个操作（如同一个路径的get、delete） 请求方式会用到GET/POST/PUT/DELETE2.非REST API restless 请求方式不决定请求的操作 一个请求路径只能对用一个操作 一般只有GET/POST json-server工具包可快速搭建REST API XHR的理解和使用XHR对象可以从URL获取数据，而无需让整个页面刷新 一般的http请求与ajax请求1.ajax请求是一种特别的http请求2.对服务端来说，没有任何区别，区别在浏览器端3.浏览器端发请求：只有XHR或fetch发出的才是ajax请求4.浏览器端接收响应： 一般请求：浏览器一般会直接显示响应体数据，也就是我们常说的刷新/跳转页面 ajax请求：浏览器不会对界面进行任何更新操作，只是调用监视的回调函数并传入响应相关数据。 APIXHR对象的属性：XMLHttpRequest():创建XHR对象的构造函数readyState（请求的状态）： 0：初始 1：open()之后 2：send()之后 3：请求中 4：请求完成onreadystatechange：绑定readyState改变的监听responseType:指定响应数据类型，如果是’json’,得到响应后自动解析响应体数据response：响应体数据，类型取决于responseTypeopen(method，url[,async]):初始化一个请求,默认async：truesend(data)：发送请求abort()：中断请求getResponseHeader(name)：获取指定名称的响应头值getAllResponseHeaders():获取所有响应头组成的字符串setResponseHeaders(name,value):设置请求头status：由服务器返回的HTTP状态代码statusText：由服务器返回的HTTP状态文本 ajaxajax技术的核心是XMLHttpRequest对象(简称XHR)， XHR的ajax简单封装 axiosaxios的post请求头默认是application/x-www-form-urlencoded,如果data是对象,默认Json。axios请求的方式可以通过函数axios(config)使用，也可以通过对象axios.get()使用 特点1.基于promise的异步ajax请求库（基于promise的 HTTP 库）2.浏览器端/node端都可以使用3.支持请求/响应拦截器4.支持请求取消5.请求/响应数据转换6.批量发送多个请求 axios.create(config)自定义配置新建一个新的axios实例，新axios只是没有取消请求和批量发请求的方法，其他所有语法都是一致的。 const instance = axios.create({ baseURL:&quot;http://localhost:3000&quot; }) //使用instance发请求 instance({ url:&quot;/posts&quot; //请求端口3000 }) 这个语法的用处： 需求：项目中有部分接口需要的配置与另一部分接口需要的配置不太一样 解决：创建2个新的axios，每个都有自己特有的配置，分别应用到不同要求的接口请求中 axios.default.baseURL = &quot;http://localhost:4000&quot; axios({ url:&quot;/posts&quot; //请求的端口4000 }) const instance = axios.create({ baseURL:&quot;http://localhost:3000&quot; }) //使用instance发请求 instance({ url:&quot;/posts&quot; //请求端口3000 }) axios的处理链流程axios拦截器 请求拦截器axios.interceptor.request.use(callback)响应拦截器axios.interceptor.response.use(callback) axios.interceptors.request.use(config=&gt;{ console.log(&quot;request interceptor1 &quot;); //拦截请求，处理请求之后，必须要返回该配置，若不返回相当于axios请求没有添加配置 return config },error=&gt;{ console.log(&quot;request interceptor1 err&quot;); return Promise.reject(error) }) axios.interceptors.request.use(config=&gt;{ console.log(&quot;request interceptor2 &quot;); return config },error=&gt;{ console.log(&quot;request interceptor2 err&quot;); return Promise.reject(error) }) axios.interceptors.response.use(response=&gt;{ console.log(&quot;response interceptor1 &quot;); return response },error=&gt;{ console.log(&quot;response interceptor1 err&quot;); return Promise.reject(error) }) axios.interceptors.response.use(response=&gt;{ console.log(&quot;response interceptor2 &quot;); //拦截response结果处理之后，要返回结果 return response },error=&gt;{ console.log(&quot;response interceptor2 err&quot;); return Promise.reject(error) }) axios.get(&quot;http://localhost:/posts&quot;).then(response =&gt;{ console.log(&quot;response data&quot;); }).catch(error=&gt;{ console.log(&quot;response error&quot;); }) /* 输出 request interceptor2 request interceptor1 response interceptor1 err response interceptor2 err response error */ 注意点：1.请求拦截器后添加先执行。2.拦截请求，处理请求之后，必须要返回该配置，若不返回相当于axios请求没有添加配置3.拦截response结果处理之后，要返回结果。 取消请求应用场景:如果发送请求2的时候，发现请求1还没有完成则取消请求1 let cancel //保存用于取消请求的函数 function getProducts1(){ if (typeof cancel === &quot;function&quot;){ //需要使用取消请求时调用 //如果请求取消了，则该请求进入请求失败的流程，请求失败的error是Cancel对象类型，Cancel里面有message属性 cancel(&quot;这里可以传消息提示&quot;) } axios.get(&quot;/user&quot;,{ cancelToken:new axios.CancelToken( //执行器回调，同步进行 c =&gt; {//c是用于取消当前请求的函数 cancel = c } ) }).then(response =&gt;{ cancel = null //如果请求完成就不要取消请求了 },error =&gt;{ if (axios.isCancel(error)){ // 取消请求 console.log(&quot;请求取消了&quot;,error.message); } else{ //请求本身出错 cancel = null console.log(error); } }) } function getProducts2(){ if (typeof cancel === &quot;function&quot;){ cancel(&quot;这里可以传消息提示&quot;) } axios.get(&quot;/user/1&quot;,{ cancelToken:new axios.CancelToken( c =&gt; {cancel = c} ) }).then(response =&gt;{ cancel = null },error =&gt;{ if (axios.isCancel(error)){ console.log(&quot;请求取消了&quot;,error.message); } else{ cancel = null console.log(error); } }) } 改进版本 //添加请求拦截器 axios.interceptors.request.use(config=&gt;{ if (typeof cancel === &quot;function&quot;){ cancel(&quot;这里可以传消息提示&quot;) } config.cancelToken =new axios.CancelToken( c =&gt; { cancel = c } ) return config }) //添加响应拦截器 axios.interceptors.response.use( respose=&gt;{ cancel = null return respose }, error =&gt;{ if (axios.isCancel(error)){ console.log(&quot;请求取消了&quot;,error.message); //中断promise链接 return new Promise(()=&gt;{}) } else{ cancel = null //将错误继续向下传递 // throw error return Promise.reject(error) } }) let cancel function getProducts1(){ axios.get(&quot;/user&quot;).then(response =&gt;{ //其他数据响应 },error =&gt;{ //只需要处理请求失败 }) } function getProducts2(){ axios.get(&quot;/user/1&quot;).then(response =&gt;{ //其他数据响应 },error =&gt;{ //只需要处理请求失败 }) }]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js（更新中）]]></title>
    <url>%2F2020%2F02%2F25%2Fnode-js%2F</url>
    <content type="text"><![CDATA[综述Node.js是能够在服务器端运行JavaScript的开放源代码、跨平台JavaScript运行环境 Node是对ES标准一个实现，Node也是一个JS引擎 通过Node可以使js代码在服务器端执行 Node仅仅对ES标准进行了实现，所以在Node中不包含DOM和BOM Node中可以使用所有的内建对象（String Number Boolean Math Date RegExp Function Object Array）而BOM（操作浏览器）和DOM（文档对象模型）都不能使用，但是可以用console也可以用定时器 Node可以在后台来编写服务器，Node服务器都是单线程的服务器。 补充：1.node中有一个全局对象global，它的作用和网页中window类似，在全局创建的变量/方法都会作为global的属性/方法保存2.代码风格：建议无论有分号代码或者无分号代码，都建议如果一（、[、\`开头，最好都在前面补上一个分号。 CommonJS规范CommonJS加载模块是同步 知识点1 Node中，一个js文件就是一个模块 引入：require(路径)，使用相对路径，必须以.或..开头引入模块以后，该函数会返回一个对象，这个对象代表的是引入的模块。 模块分成两大类：核心模块：由node引擎提供的模块，核心模块的标识就是模块的名字文件模块：由用户自己创建的模块，文件模块的标识为路径 知识点2在Node中，每一个js文件中的js代码都是独立运行在一个函数体中。所以如果想要其他文件访问，必须要将数据暴露出来暴露：exports.x = “xxxx” //当node在执行模块中的代码时，它首先在代码的最顶部，添加如下代码 function(exports,require,module.__filename,__dirname){ //里面才是自己写的 } 形参中 exports：将变量或函数暴露到外部 require：用来引入外部的模块 module：代表当前模块本身 __filename：当前模块的完整路径 __dirname：当前模块所在文件夹的完整路径 exports与module.exports的区别本质上exports就是module的属性，module.exports===exports exports只能用.的方式来向外暴露内部变量 module.exports即可以通过.，也可以直接赋值原因是module.exports修改的是module对象，而exports`修改的是变量（会改变指针的指向，本来两个是指向一个堆空间） package包是一个包装过规范的模块CommonJS的包规范允许我们将一组相关的模块组合到一起，形成一组完整的工具。CommonJS的包规范 = 包结构+包描述文件包结构：用于组织包中的各种文件 package.json 描述文件（必须） bin 可执行二进制文件 lib js代码 doc 文档 test单元测试包描述文件：描述包的相关的信息，以供外部读取分析 NPM（Node Package Manager）CommonJS包规范是理论，NPM是其中一种实践。对于Node而言，NPM帮助其完成了第三方模板的发布、安装、依赖等。借助NPM，Node与第三方模块之间形成了很好的一个生态系统。 基本的操作：查看版本：npm -v搜索模块包：npm search 包名安装包：npm install 包名 安装包并添加到依赖 （最好在要安装包的位置创建package.json文件） npm install 包名 -g 全局安装 初始化package.json:npm init (名字不用大写)删除包：npm remove 包名 通过npm下载的包都在node_mudules文件夹中，直接通过包名即可引用。node在使用模块名字来引入模块时，它会首先在当前目录的node_modules中寻找是否含有该模块，如果没有去上一级目录的node_modules中寻找，直到找到磁盘的根目录。 Buffer（缓存区）Buffer的结构和数组很像，操作的方法也和数组类似。数组中不能存储二进制的文件，而Buffer专门用来存储二进制数据(图片/mp3/视频 二进制文件) 使用：buffer不需要引入模块，直接使用即可 常用操作Buffer.from(str[,encoding]) str 需要编码的字符串 encoding 默认’utf8’把字符串转换成二进制,buffer中每个元素的范围从00-ff（8bit）,如果要转换成字符串用toString() Buffer.lengthBuffer占用的内存大小 Buffer.alloc(size[, fill[, encoding]]) size，分配的内存长度 fill，用于预填充新Buffer的值，默认值：0 encoding，如果fill是一个字符串，则这是它的字符编码，默认’utf8’ //创建一个10个字节的buffer let buf = Buffer.alloc(10) //通过索引，来操作buf中的元素 buf[0] = 88 注意：Buffer的大小一旦确定，则不能在修改，因为Buffer是对内存的直接操作 只要数字在控制台或页面中输出一定是10进制 如果要16进制输出，number的toString(进制)里面可以传参。 ``` let buf = Buffer.alloc(10) buf[1]=0xaa; console.log(buf[1].toString(16)); //输出aa ``` Buffer.allocUnsafe(size) 创建一个指定大小的buffer，但是buffer中可能含有敏感数据（分配空间并没有预设默认值0） fs（文件系统）文件系统简单来说就是通过Node来操作系统的文件。服务器的本质就是将本地的文件发送给远程的客户端。fs模块中所有的操作都有同步和异步两种形式选择，同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码，异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回。 使用：使用文件系统，需要先引入fs模块，fs是核心模块，直接用名字引入不需要下载。 同步/异步文件写入同步的文件的写入：1.打开文件 fs.openSync(path[, flags, mode]) - path 打开文件的路径 - flags 打开文件要做的操作的类型 默认&#39;r&#39; - mode 设置文件的操作权限，一般不传 返回值：该方法会返回一个文件的描述符作为结果，我们可以通过该描述符对文件进行各种操作 2.向文件中写入内容 fs.writeSync(fd, buffer[, offset[, length[, position]]]) - fd 文件的描述符，需要传递要写入的文件的描述符 - buffer 要写入的内容 - offset 写入的位置 3.保存并关闭文件 fs.closeSync(fd) let fs = require(&quot;fs&quot;) //打开文件 let fd = fs.openSync(&quot;hello.txt&quot;,&quot;w&quot;) //向文件中写入内容 console.log(fd); fs.writeSync(fd,&quot;hello&quot;) //保存并关闭文件 fs.closeSync(fd) 异步方法(不可能有返回值):1.打开文件 fs.open(path[, flags[, mode]], callback) ，结果是通过回调函数返回的,回调函数路两个参数。 - err 错误对象，如果没有错误则为null（js的设计思想，错误优先） - fd 文件描述符 2.向文件中写入内容 fs.write(fd, buffer[, offset[, length[, position]]], callback）3.关闭文件 fs.close(fd, callback) let fs = require(&quot;fs&quot;) //打开文件 fs.open(&quot;hello.txt&quot;,&quot;w&quot;,function (err,fd) { if (!err) { console.log(&quot;打开成功&quot;); //向文件中写入内容 fs.write(fd,&quot;这是异步写入的内容&quot;,function (err) { if (!err){ console.log(&quot;写入成功&quot;); } //关闭文件 fs.close(fd, function (err) { console.log(&quot;文件关闭&quot;); }) }) } else console.log(err); }) (常用)简单的文件写入fs.writeFile(file, data[, options], callback) file 要操作的文件的路径 data 要写入的数据 options 选项，可以对写入进行一些设置 callback 当写入完成以后执行的函数 const fs = require(&quot;fs&quot;) fs.writeFile(&quot;hello.text&quot;,&quot;这是通过writeFile写入的内容&quot;,function (err) { if (!err){ console.log(&quot;写入成功&quot;); } }) 文件打开常用模式：w：写入文件，如果不存在则创建，文件写入默认从头开始写会覆盖文件。r+:读写文件，写操作时会覆盖，文件不存在则出现异常。w+:读写文件，文件不存在先创建，会覆盖。a: 写入文件，打开文件用于追加，如果不存在则新建。a+：读写文件，文件不存在先建立，追加r：读取文件，文件不存在则出现异常rb/wb：分别与r/w相似，但是用于读写二进制文件 流式文件写入同步、异步、简单文件的写入都不适合大文件的写入（只要写一次），性能较差，容易导致内存溢出。只要流存在，可以分多次写入。 创建一个可写流：fs.createWriteStream(path,[,options]) - path：文件路径 - options 配置的参数 - 有返回值，该方法会返回一个文件的描述符作为结果，我们可以通过该描述符对文件进行各种操作 const fs = require(&quot;fs&quot;) //流失文件写入 //创建一个可写流 let ws = fs.createWriteStream(&quot;hello.txt&quot;) //可以通过监听流的open和close事件来监听流的打开和关闭 ws.once(&quot;open&quot;,function () { //open只会触发一次，on绑定了事件会一直存在，所以用once绑定一次性事件。 console.log(&quot;已经打开流&quot;); }) ws.once(&quot;close&quot;,function () { console.log(&quot;流关闭&quot;); }) ws.write(&quot;写入成功&quot;) ws.write(&quot;哈哈哈哈&quot;) ws.write(&quot;写入成功&quot;) ws.write(&quot;哈哈哈哈&quot;) //关闭流，关闭的接收方， ws.close() 文件的读取操作基本上和文件的写入差不多，具体看API。注意：1.读取到的数据会返回一个Buffer2.如果要读取一个可读流中的数据，必须要为可读流绑定一个data事件，data事件绑定完毕，它会自动开始读取数据，读取完毕后可读流自动关闭 const fs = require(&quot;fs&quot;) //流失文件读取，可以分多次将文件读取到内存中 //创建一个可读流 let rs = fs.createReadStream(&quot;消息提醒.png&quot;) //创建一个可写流 let ws = fs.createWriteStream(&quot;xxx.png&quot;) //可以通过监听流的open和close事件来监听流的打开和关闭 rs.once(&quot;open&quot;,function () { console.log(&quot;已经打开流&quot;); }) rs.once(&quot;close&quot;,function () { console.log(&quot;流关闭&quot;); //读取完毕后可读流自动关闭，所以在这个时候关闭可写流 ws.close() }) //如果要读取一个可读流中的数据，必须要为可读流绑定一个data事件，data事件绑定完毕，它会自动开始读取数据，读取完毕后自动关闭 rs.on(&quot;data&quot;,function (data) { console.log(data); ws.write(data); //ws.close()，可能导致只读了一条数据就关闭 }) pipe()更简单的写法pipe(),rs.pipe(ws)在可读流rs与可写流ws之间架起一个管道，自动将可读流中的内容，直接输出可写流。 fs其他常用方法验证路径是否存在 fs.existsSync(path) 返回值：存在true，不存在false获取文件状态 fs.stat(path,callback)/fs.statSync(path) 返回对象：文件的状态删除文件 fs.unlink(path,callback)/fs.unlinkSync(path)读取一个目录的目录结构 fs.readdir(path[,options],callback)/fs.readdirSync(path[,options]) 返回一个字符串数组，每一个元素就是一个文件夹或文件的名字截断文件 fs.truncate(path,len,callback)/fs.truncateSync(path,len) 将文件修改成指定的len大小（一个汉字3个字节）创建文件夹 fs.mkdir(path[,mode],callbcak)/fs.mkdirSync(path[,mode])删除文件夹 fs.rmdir(path,callbcak)/fs.rmdirSync(path)重命名文件/剪贴文件 fs.rename(oldPath(oldName),newPath,callback)/fs.renameSync(oldPath,newPath)监视文件的修改 fs.watchFile(filename[,options],listener) listener回调函数，当文件发生变化时，回调函数会执行。 ip地址和端口号 ip地址用来定位计算机 端口号用来定位具体的应用程序 一切需要联网通信的软件都会占用一个端口号 端口号的范围从0-65536 在计算中有写一些默认端口号，最好不要去使用。如：http服务的80 httprequest 请求事件处理函数，需要接收两个参数：request，response。 const http = require(&quot;http&quot;) const server = http.createServer() server.on(&quot;request&quot;,function (request,response) { console.log(&quot;请求路径是&quot; + request.url); //在服务端默认发送的数据，其实是utf8编码的内容 //但是浏览器不知道是utf8的内容，在不知道服务器响应内容的编码的情况下会按照当前操作系统默认编码解析 //text/plain;普通文本 //response对象有一个方法：write可以用来给客服端发送响应数据； //write可以使用多次，但最后一定要使用end来结束响应，否则客服端会一致等待 //响应的数据只能是二进制(默认)或字符串 fs.readFile(xxx,function(err,data){ response.setHeader(&#39;Content-type&#39;,&quot;text/html;charset=utf-8&quot;) response.end(data) }) } }) server.listen(3000,function () { console.log(&quot;服务器启动成功&quot;); }) urlurl：统一资源定位符，url核心模块在为我们解析url地址时提供了非常方便的APIurl.parse()方法可以解析一个url地址，通过传第二个参数(true)把包含有查询字符串的query转化成对象 const url = require(&quot;url&quot;) let httpUrl = &quot;https://sale.vmall.com/hwmate.html#abc?cid=10602&quot; let urlObj = url.parse(httpUrl) console.log(urlObj); //Url { // protocol: &#39;https:&#39;, 协议 // slashes: true, // auth: null, // host: &#39;sale.vmall.com&#39;, 主机 // port: null, 端口号 // hostname: &#39;sale.vmall.com&#39;, // hash: &#39;#abc?cid=10602&#39;, // search: &#39;?cid=10602&#39;, 查找的内容 // query: &#39;cid=10602&#39;, query问号后面的内容 // pathname: &#39;/hwmate.html&#39;, 路径的名称 // path: &#39;/hwmate.html?cid=10602&#39;, // href: &#39;https://sale.vmall.com/hwmate.html?cid=10602&#39; } url.resolve()方法合成url，第一个参数基url，第二个参数目标url const url = require(&quot;url&quot;) let targetUrl=&quot;http://www.taobao.com/&quot; let httpUrl = &quot;./xxx.html&quot; console.log(url.resolve(targetUrl, httpUrl)); //自动去掉./ //http://www.taobao.com/xxx.html]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F2020%2F02%2F23%2F%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[ES5时，有个经典的需求：点击某个按钮，提示”点击的是第n个按钮” //html &lt;button&gt;测试1&lt;/button&gt; &lt;button&gt;测试2&lt;/button&gt; &lt;button&gt;测试3&lt;/button&gt; //js var btns = document.getElementsByTagName(&quot;button&quot;); //遍历加监听 for (var i = 0;i&lt;btns.length;i++) { var btn = btns[i]; btn.onclick =function () { alert(i) } 这里有个关于效率的问题,btns是伪数组，for循环中btns.length每次都要计算一遍才能得到结果，这里循环就会计算多次。改进之后的代码: var btns = document.getElementsByTagName(&quot;button&quot;); //遍历加监听 for (var i = 0,length=btns.length;i&lt;length;i++) { var btn = btns[i]; btn.onclick =function () { alert(i) } } 但是点击按钮之后发现每个按钮都打印的3。因为点击之后的函数是回调函数，需要放在宏队列中执行，而for循环已经执行结束(i已经等于3了)ES6之前的解决办法：解决办法1：将btn所对应的下标保存在btn上 var btns = document.getElementsByTagName(&quot;button&quot;); //遍历加监听 for (var i = 0,length=btns.length;i&lt;length;i++) { var btn = btns[i]; btn.index = i btn.onclick =function () { alert(this.index) } } 解决办法2:闭包 var btns = document.getElementsByTagName(&quot;button&quot;); for (var i = 0;i&lt;btns.length;i++) { var btn = btns[i]; (function (i) {//这i是局部的 btn.onclick = function () { alert(i) } })(i)//这个i是全局i } 问题1:如何产生闭包？当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时，就产生了闭包。 问题2：闭包到底是什么?(用chrome调试查看)理解1：闭包是嵌套的内部函数理解2：包含被引用变量(函数)的对象注意:闭包存在于嵌套函数的内部函数中 问题3：产生闭包的条件1.函数嵌套2.内部函数引用了外部函数的数据3.执行外部函数 常见的闭包1.将函数作为另一个函数的返回值 function fn1() { var a = 2 function fn2() { a++; console.log(a); }//仅一个闭包 return fn2 } //f指向了fn2的函数对象(局部变量fn2已经不在了，因为fn2不在闭包里面)，这也是闭包一直存在的原因 var f = fn1()//已经产生了闭包，执行完后，a还在 f()//3 f()//4 局部函数调用时存在，调用结束消失。外部函数执行几次，就产生几个闭包。所以此例子只产生了一个闭包。 2.将函数作为实参传递给另一个函数调用 function showDelay(msg,time) { //setTimeout()是在执行这个函数 setTimeout(function () {//闭包是在定义内部函数时生成的 alert(msg)//回调函数是内部函数，且用了外部函数的msg值 },time) } showDelay(&quot;xxx&quot;,2000) //产生了闭包 闭包的作用(又想隐藏，又想使用) 使用函数内部的变量在函数执行完后，仍然存活在内存中(延长了局部变量的生命周期) 让函数外部可以操作(读写)到函数内部的数据 问题1：函数执行完毕后，函数内部声明的局部变量是否还存在？一般是不存在，存在于闭包中的变量才可能存在问题2：在函数外部能直接访问函数内部的局部变量吗？不能，但我们可以通过闭包让外部操作它 闭包的声明周期产生：在嵌套内部函数定义执行完成时就产生了(不是在调用)死亡：在嵌套的内部函数成为垃圾对象时 function fn1() { var a = 2//此时闭包就已经产生了(函数提升，内部函数对象已经创建了) function fn2() { a++; console.log(a); } return fn2 } var f = fn1() f = null //闭包死亡(包含闭包的函数对象成为垃圾对象) 闭包的应用1.定义JS模块 具有特定功能的JS文件 将所有的数据和功能都封装在函数内部（私有的）//对象的属性外部直接可以见，所以封装在对象里不算私有 只向外暴露一个包含n个方法的对象或函数 //module.js function myModule(){ //私有数据 var msg = &quot;xxx&quot; function doSomething(){ console.log(&quot;doSomething&quot;+msg.toUpperCase()) } function doOtherthing(){ console.log(&quot;doOtherthing&quot;+msg.toLowerCase()) } //向外暴露对象 return{doSomething,doOtherthing} } } //其他界面调用时，需要一个函数来接收 匿名函数自调用 //module2.js (function myModule(window){ //私有数据 var msg = &quot;xxx&quot; function doSomething(){ console.log(&quot;doSomething&quot;+msg.toUpperCase()) } function doOtherthing(){ console.log(&quot;doOtherthing&quot;+msg.toLowerCase()) } //向外暴露对象 window.module2 = {doSomething,doOtherthing} })(window) //其他界面调用时，直接module2.doSomethig 闭包的缺点及解决缺点：函数执行完后，函数内的局部变量没有释放，占用内存时间会变长。(容易造成内存泄漏)解决：能不用闭包就不用，及时释放（让内部函数称为垃圾对象–&gt;回收闭包） 内存溢出一种程序运行出现的错误。当程序运行需要的内存超过了剩余的内存时，就会抛出溢出的错误。 内存泄漏占用的内存没有及时释放，内存泄漏积累对了就容易导致内存溢出。常见的内存泄漏：意外的全局变量，没有及时清理的计时器（如启动循环定时器后不清理）或回调函数，闭包。 let intervalId = setInterval(function(){//启动循环定时器后不清理 console.log(&quot;---&quot;) },1000) //清除定时器 clearInterval(intervalId) 面试题 var name = &quot;The Window&quot;; var object = { name:&quot;My object&quot;, getNameFunc : function () { return function () { return this.name; } } } console.log(object.getNameFunc()());//The Window var name = &quot;The Window&quot;; var object = { name:&quot;My object&quot;, getNameFunc : function () { var that = this return function () { return that.name; //that等于的this是 调用了getNameFunc的对象 } } } console.log(object.getNameFunc()());//My object]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回调函数]]></title>
    <url>%2F2020%2F02%2F23%2F%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一直都知道回调函数这种说法，但是并不能很准确的回答什么是回调函数？ 这个是知乎常溪玲的答案，非常的通俗易懂 你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。 或者说回调函数的特征:你定义的，你没有调，但它最终执行了。 常见回调函数 document.getElementById(&quot;btn&quot;).onclick=function () {//dome事件回调函数 alert(this.innerHTML) } //定时器 setTimeout(function () { //定时器回调函数 alert(&quot;到点了&quot;) },2000) dom事件回调函数 定时器回调函数 ajax请求回调函数 生命周期回调函数]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this指针]]></title>
    <url>%2F2020%2F02%2F23%2Fthis%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[this是什么？ 任何函数本质上都是通过某个对象来调用的，如果没有直接指定就是window 所有函数内部都有一个this 它的值是调用函数的当前对象 function Person(color) { console.log(this); this.color = color; this.getColor = function () { console.log(this); return this.color; }; this.setColor = function (color) { console.log(this); this.color = color; } } //this是谁 Person(&quot;red&quot;); //window let p = new Person(&quot;yello&quot;) //Person的实例，p p.getColor();//P let obj= {}; p.setColor.call(obj,&quot;black&quot;) //obj let test = p.setColor; test()//window function fun1(){ function fun2() { console.log(this); } fun2() } fun1()//window new在执行时完成的4件事情：1.在内存中创造一个新的空对象2.让this指向这个新的对象3.执行构造函数里面的代码，给这个新对象添加属性和方法4.返回这个新对象(所以构造函数里面不需要return) 这篇文章对this的理解更为深刻，很有学习意义。 window是js中的全局对象，我们创建的变量实际上是给window添加属性，所以这里可以用window点o对象。 上面的那篇文章对最终this指向的是调用它的对象进行了更准确的描述 var o = { a:10, b:{ a:12, fn:function(){ console.log(this.a); //12 } }}o.b.fn(); **知识点1**：这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象 var o = { a:10, b:{ fn:function(){ console.log(this.a); //undefined } }}o.b.fn(); 尽管对象b中没有属性a，这个this指向的也是对象b，因为this只会指向它的上一级对象，不管这个对象中有没有this要的东西。 **知识点2**：this永远指向的是最后调用它的对象，也就是看它执行的时候是谁调用的 var o = { a:10, b:{ a:12, fn:function(){ console.log(this.a); //undefined console.log(this); //window } }}var j = o.b.fn;j(); 除此之外，文章还对this用法进行了补充，当this碰到return的时候 **知识点3**当this遇见return时，如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。 function fn(){ this.user = ‘追梦子’; return function(){};}var a = new fn;console.log(a.user); //undefined function fn(){ this.user = ‘追梦子’; return 1;}var a = new fn;console.log(a.user); //追梦子 function fn(){ this.user = ‘追梦子’; return null;}var a = new fn;console.log(a.user); //追梦子` 还有一点就是虽然null也是对象，但是在这里this还是指向那个函数的实例，因为null比较特殊。 注:因为平时严格模式用的比较少，所以等之后用到严格模式再进行补充]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拷贝]]></title>
    <url>%2F2020%2F02%2F19%2F%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[深拷贝浅拷贝深浅拷贝只是针对引用数据类型。 js的数据类型 基本数据类型： Undefined、Null、Boolean、Number、String和Symbol(ES6)引用数据类型： Object(Array, Date, RegExp, Function) 基本类型在栈里存放的值是真实的值，而引类型在栈里存放的值是一个地址，该地址为引用类型的数据内容在堆内存中的地址。所以要注意是在改变量的值，还是在改变量内容的值。 浅拷贝：修改拷贝以后的数据会影响原数据，拷贝的引用。使得原数据不安全。深拷贝：修改拷贝以后的数据不会影响原数据，拷贝的时候生成新数据。 拷贝数据的方法1.引用类型直接赋值是浅拷贝2.Object.assign() let obj = { a: { a1: &#39;a1&#39; }, b: &#39;b&#39; } let ass = Object.assign({}, obj); ass.a.a1 = &#39;aaa&#39;; ass.b=&quot;c&quot; console.log(obj); /* 输出：a:{a1:&quot;aaa&quot;}, b:&quot;b&quot; */ 说明: Obejct.assign()只能对一层进行深拷贝,如果拷贝的层数超过了一层的话，那么就会进行浅拷贝。 这种克隆方式，只能克隆原始对象自身的值，不能克隆它的继承值。 function clone(origin) { return Object.assign({}, origin); } 如果要保持继承链。 function clone(origin) { //Object.getPrototypeOf方法返回指定对象的原型（内部[[Prototype]]属性的值） let originProto = Object.getPrototypeOf(origin); //Object.create方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。 return Object.assign(Object.create(originProto), origin); } 3.三点运算符对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。 let obj = { a: { a1: &#39;a1&#39; }, b: &#39;b&#39; } let ass = {...obj}; ass.a.a1 = &#39;aaa&#39;; ass.b = &#39;bbb&#39; console.log(obj); /* 输出：a:{a1:&quot;aaa&quot;}, b:&quot;b&quot; */ 说明:扩展运算符只能对一层进行深拷贝,如果拷贝的层数超过了一层的话，那么就会进行浅拷贝。 Object.assign(）和展开原算符对于深浅拷贝的结果是一样。 4.Array.prototype.concat() concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。 let arr= [1,3,{name:&#39;ran&#39;}] let arr2 = arr.concat() // arr2[1]=55 //输出[1，3，{name:&#39;ran&#39;}] arr2[3].name = &#39;ke&#39; console.log(arr); //输出 [1,3,{name:&#39;ke&#39;}] 遍历arr数组时得到arr数组的元素，把该元素赋值给arr2对应的位置，当遍历的元素是对象时，因为对象的赋值浅拷贝，所有会改变原来的值。 5.Array.prototype.slice(startindex,endindex) let arr= [1,3,{name:&#39;ran&#39;}] let arr2 = arr.slice() arr2[1]=55 arr2[2].name = &#39;ke&#39; console.log(arr); // 输出[1,3,{name:&#39;ke&#39;}] 因此，slice和concat这两个方法，仅适用于对不包含引用对象的一维数组的深拷贝 6.JSON.parse(JSON.stringify()) 深拷贝 JSON.stringify()：将JavaScript对象转换为JSON字符串JSON.parse()：可以将JSON字符串转为一个对象。 let arr= [1,3,{name:&#39;ran&#39;}] let arr2 = JSON.parse(JSON.stringify(arr))//在JSON.stringify()完成后，对象就转为了字符串，也就可以说实实在在的复制了一个值，不存在引用之说 arr2[1]=55 arr2[2].name = &#39;ke&#39; console.log(arr);//输出[1,3,{name:&#39;ran&#39;}] 缺点：拷贝有些对象会被忽略(undefined,symbol,function)也有可能导致原型链缺失。 补充1 判断数组是否包含某对象，或者判断对象是否相等。(这个特别有用) //判断数组是否包含某对象 let data = [ {name:&#39;echo&#39;}, {name:&#39;听风是风&#39;}, {name:&#39;天子笑&#39;}, ], val = {name:&#39;天子笑&#39;}; JSON.stringify(data).indexOf(JSON.stringify(val)) !== -1;//true //判断两数组/对象是否相等 let a = [1,2,3], b = [1,2,3]; JSON.stringify(a) === JSON.stringify(b);//true 补充2 localStorage/sessionStorage默认只能存储字符串，而实际开发中，我们往往需要存储的数据多为对象类型，那么这里我们就可以在存储时利用json.stringify()将对象转为字符串，而在取缓存时，只需配合json.parse()转回对象即可 补充3JSON.stringify()与toString()的区别，这两者虽然都可以将目标值转为字符串，但本质上还是有区别的。 let arr = [1,2,3]; JSON.stringify(arr);//&#39;[1,2,3]&#39; arr.toString();//1,2,3 JSON.stringify更对用于对象，toString()更对用于数组 参考文章 如何实现深拷贝？拷贝的数据里面不能有引用类型。如果有，只要拿到的是基本数据类型，然后再去赋值，就可以实现深拷贝 如何判断数据类型typeof返回的数据类型:String,Number,Boolean,Undefined,Object(Array,null也是),Function，不能准确的确定数据的类型。 1 Object.prototype.toString.call() Object.prototype.toString.call()可以区分各种类型，但它无法区分自定义对象类型，自定义类型可以采用instanceof区分。 console.log(Object.prototype.toString.call(&quot;jerry&quot;));//[object String] console.log(Object.prototype.toString.call(12));//[object Number] console.log(Object.prototype.toString.call(true));//[object Boolean] console.log(Object.prototype.toString.call(undefined));//[object Undefined] console.log(Object.prototype.toString.call(null));//[object Null] console.log(Object.prototype.toString.call({name: &quot;jerry&quot;}));//[object Object] console.log(Object.prototype.toString.call(function(){}));//[object Function] console.log(Object.prototype.toString.call([]));//[object Array] console.log(Object.prototype.toString.call(new Date));//[object Date] console.log(Object.prototype.toString.call(/\d/));//[object RegExp] function Person(){}; console.log(Object.prototype.toString.call(new Person));//[object Object] 那么为什么Object.prototype.toString.call()可以区分？ toString方法返回反映这个对象的字符串（除了null和undefined之外） console.log({name:&quot;张三&quot;}.toString());//[object Object] console.log([1,2].toString());//1,2 console.log(typeof [1,2].toString())//String obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？ 因为toString为Object的原型方法，而Array ，function等类型作为Object的实例重写了toString方法，调用toString方法时，优先调用的是重写之后的toString方法，所以要使用Object原型上的toString才可以反映对象的具体类型。 参考文章 2 获取标识类 Object.prototype.toString.call()返回的是字符串类型的[object xxx],但是我们只需要后面的标识数据类型的xxx，可以使用Array的slice方法。 let data = [1,3] //slice包含开始的位置，不包含结束的位置，结束位置为-1 console.log(Object.prototype.toString.call(data).slice(8,-1));//Array 最终实现//检测数据类型的功能函数 function checkedType(target) { return Object.prototype.toString.call(target).slice(8,-1) } //实现深度克隆 数组/对象 function clone(target) { let result,targetType=checkedType(target) switch (targetType) { case &#39;Object&#39;: result = {}; break; case &#39;Array&#39;: result = [] break; default: return target } //遍历，基本数据类型的赋值 for (let i in target){ //获取数据结构的每一项值 let value = target[i] //判断目标结构里的每一值是否存在对象/数组 if (checkedType(value) === &#39;Object&#39; || checkedType(value) === &#39;Array&#39;){ //继续遍历获取到的value result[i] = clone(value) }else { //获取到的value值是基本的数据类型或者函数 result[i] = value } } return result }]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型与原型链面试题]]></title>
    <url>%2F2020%2F02%2F18%2F%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[第一题 let A = function () { } A.prototype.n = 1 let b =new A() console.log(b); A.prototype = { n:2, m:3 } let c = new A() console.log(b.n, b.m, c.n, c.m); //输出1，undefined,2,3 实例化对象b之后，b的__proto__指向A.prototype指向的空间，而这里的{ n:2,m:3 } 是重新开辟了一个空间，而 A.prototype被赋值的时候，指针改变指向重新开辟的空间。 第二题 let F = function () { } Object.prototype.a = function () { console.log(&#39;a()&#39;); } Function.prototype.b = function () { console.log(&#39;b()&#39;); } let f = new F() f.a() //输出a() f.b() //报错 f是一个实例化对象，对象的__proto__指向function的原型（默认是一个Object实例化对象） F.a() //输出a() F.b() //输出b() function声明的变量(F)的proto指向Function的prototype，其它对象的proto指向Object的prototype]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型与原型链]]></title>
    <url>%2F2020%2F02%2F18%2F%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[原型(prototype) 注理解一定要把握对象的proto指向的是构造函数的prototype（原型）。 显式原型与隐式原型每个对象都有隐式原型proto这个属性，而function既有隐式原型（proto）又有显式原型（prototype），因为函数在js里面既是函数也是对象 函数的prototype属性，默认指向Object实例对象(称为:原型对象)，原型上的方法是给实例对象用的。 prototype也是一个原型对象，只要是对象就有proto. function Fn() { } console.log(Fn.prototype); //输出{constructor：...,__proto__} //所以Fn.prototype也是一个实例对象，是Object的 对象的隐式原型的值为其对应构造函数的显式原型的值，prototype与__proto__里面保存一样的地址值。 function Fn(){} let fn = new Fn() //左边显式原型,右边为隐式原型 Fn.prototype === fn.__proto__ 总结 函数的prototype属性在定义函数时自动添加，默认值是一个空Object实例对象。（Object.prototype不满足。） 实例对象上的proto在创建实例对象时自动添加，默认值为构造函数的prototype属性 程序员能直接操作显式原型，但不能直接操作隐式原型(ES6之前) 原型对象通常用来对原来的内置对象进行扩展自定义方法。比如给数组增加自定义求偶数和的功能 原型链 当访问一个对象的属性时，先在自身属性中查找，找到返回。如果没有，在沿proto这条链往上找，找到返回，如果最终没有找到，返回undefined,所以Object的原型对象是原型链的尽头。 Object的proto指向Function的prototype,而Object的prototype没有proto，这就是真正的原型。 function声明的变量、Function和Object都有prototype， 有prototype的东西可以产生实例（即可以作为new 后边的值）。 别名：隐式原型链，一直沿隐式原型找。作用：查找对象的属性（方法） function Foo(){} //也可以写成 let Foo = new Function() Function = new Function() //所以Function也是Function的实例对象 由上面的代码可以知道，所有函数的ptoto都是一样的，所有的函数都是Function的实例对象。 所有对象都有proto属性，是用来通过proto找到它的原型即prototype，function声明的变量的proto指向Function的prototype，其它对象的proto指向Object的prototype 原型继承构造函数的实例对象自动拥有构造函数原型对象的属性(方法)，原理是利用原型链 原型链的属性问题function Fn() {} Fn.prototype.a=&quot;xx&quot; let fn1=new Fn() let fn2=new Fn() fn2.a=&quot;yy&quot; console.log(fn1.a, fn2.a); //输出xx,输出yy 打印fn1与fn2的结果 说明读取对象的属性值时：会自动到原型链中查找。设置对象的属性值时：不会查找原型链，如果当前对象中没有此属性，直接添加此属性并设置其值。所以方法一般定义在原型中，属性一般通过构造函数定义在对象本身。 补充知识点1.构造函数构造函数是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与new一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。 new在执行时完成的4件事情：1.在内存中创造一个新的空对象2.让this指向这个新的对象3.执行构造函数里面的代码，给这个新对象添加属性和方法4.返回这个新对象(所以构造函数里面不需要return) 构造函数方法存在浪费内存的问题，在构造函数中的复杂数据类型（比如函数），实例化对象的时候，会专门开辟一个空间来存放。那么当实例对象过多的时候，就会开辟更多的空间来存放。当我们希望所有的对象使用同一个函数时，最好使用prototype，这也是为什么方法一般定义在原型中，属性一般通过构造函数定义在对象本身。 2.静态成员与实例成员实例成员就是构造函数内部通过this添加的成员。实例成员只能通过实例化的对象来访问。（不可以通过构造函数来访问实例成员）静态成员在构造函数本身上添加的成员(Fn.xxx=&quot;xxx&quot;)。静态成员只能通过函数对象访问。（不可以通过实例对象来访问） 3.构造函数、实例、原型对象三者之间的关系__proto__和原型对象中(xx.prototype)都有一个属性constructor，它指向函数对象（xx.prototype.constructor===xx）。主要用来记录该对象引用哪个构造函数 4.原型对象this指向1.在构造函数中，里面this指向的是对象实例2.原型对象的this也是指向对象实例 5.继承(ES5)补充：call()函数，调用这个函数并改变运行时this的指向，调用函数.call(参数)，第一个参数：当前调用函数this的指向对象。后面的参数为传递给调用函数的参数。 如：obj1.(method).call(obj2,argument1,argument2)call的作用就是把obj1的方法放到obj2上使用，后面的argument1..这些做为参数传入。 ES6之前没有提供extends继承。可以通过构造函数+原型对象模拟实现继承，被称为组合继承。核心原理:通过 call()把父类型的this指向子类型的this，这样就可以实现子类型继承父类型的属性 //父构造函数 this指向父构造函数的对象实例 function Father(name,age){ this.name = name; this.age = age; } Father.prototype.money= ()=&gt;{ console.log(&#39;父亲要上班&#39;); } //子构造函数 this指向子构造函数的对象实例 function Son(name,age) { //把指向父构造函数的对象实例的this改变成指向子构造函数的对象实例的this Father.call(this,name,age) } //让Son的原型对象指向Father的实例对象，那么就可以访问到Father实例对象上的方法 //这个new Father()是一个原型对象，相当于{}，这样写会覆盖掉Son的原型对象的constructor Son.prototype = new Father(); //所以还需要constructor指回原来的构造函数 Son.prototype.constructor = Son 6.instanceof函数表达式: A instanceof B(A为实例对象，B为构造函数)原理:如果B的显式原型对象在A对象的原型链上，返回true，否则返回false function Fn(){} let f1 = new Foo() console.log(f1 instanceof Foo) //true console.log(f1 instanceof Object)//true console.log(Object instanceof Function)//true console.log(Object instanceof Object)//true console.log(Function instanceof Function)//true console.log(Function instanceof Object)//true 7.Function和Object的关系1.Object, Function, Array等等这些都被称作是构造“函数”，他们都是函数。2.所有的函数都是构造函数Function的实例。3.原型链机制的的角度来说，那就是说所有的函数都能通过原型链找到创建他们的Function构造函数的构造原型Function.protorype对象 所以 console.log(Object instanceof Function)//true 4.Function.prototype是一个对象，所以他的构造函数是Object. 从原型链机制的的角度来说，那就是说所有的函数都能通过原型链找到创建他们的Object构造函数的构造原型Object.prototype对象 所以 console.log(Function instanceof Object)//true]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es5/es6/es7]]></title>
    <url>%2F2020%2F02%2F17%2Fes6%2F</url>
    <content type="text"><![CDATA[let/const特点: 不能重复定义 在块级作用域内有效 不会预处理，不存在变量提升 const不可以被修改，声明时必须赋值 预处理：声明var后的变量但并不赋值(undefined)，声明function。因此使用let/const定义的变量在没声明前是无法使用的。 在循环使用中常用。如下述代码，结果会全部输出2，原因是：点击事件是回调函数进入队列，等同步执行的代码执行完毕之后，再执行。以前常用的解决办法是使用闭包。es6中的let也可以解决这个问题，因为let有自己的块级作用域，使用i值的时候，仅当次循环有用。 //html &lt;button&gt;测试1&lt;/button&gt; &lt;button&gt;测试2&lt;/button&gt; &lt;button&gt;测试3&lt;/button&gt; //js let btns = document.getElementsByTagName(&quot;button&quot;); for (var i = 0;i&lt;btns.length;i++) { var btn = btns[i]; btn.onclick =function () { alert(i) } } //js 闭包解决办法 let btns = document.getElementsByTagName(&quot;button&quot;); for (var i = 0;i&lt;btns.length;i++) { var btn = btns[i]; (function (i) { btn.onclick =function () { alert(i) } })(i) } 还有一点是let/const不属于顶层全局变量，不用担心污染全局的window对象。 let a = 0 console.log(window.a)//undefined var b = 1 console.log(window.b)//1 变量的解构赋值理解：从对象或数组中提取数据，并赋值给变量(多个)。常用：对象的解构赋值。(后台返回的数据进行利用) 例：交换对象,解构的目标是数组，所以以数组的形式来接收。 let a = 1 let b = 2 [a,b] = [b,a] //a=2 , b =1 模板字符串作用：简化字符串的拼接使用：模板字符串必须用包含，变化的部分使用${xxx}定义 对象属性/方法简写对象属性简写：当对象的属性和值相同时，省略属性名 注意点： 省略的是属性名而不是值 必须是一个变量 方法的简写：当对象的属性值是一个函数(即是一个方法)，可以使用简写形式。 //es5 let obj ={ func:function(){} } } //es6 let obj2={ func(){} //不太常用 func:()=&gt;{} //常用箭头函数 } 箭头函数用处：常用在回调函数 let a = ()=&gt;{ ... } 形参 只有一个形参的时候，()可以省略 其余时候，()不能省略 函数体 函数体内只有一条语句或者表达式，{}可省略，省略后自动return 其余情况不可以省略，并且需要返回值时，需要加上return 注意：由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 //报错 let getTempItem = id =&gt; { id, name: &quot;Temp&quot; }; // 不报错 let getTempItem = id =&gt; ({ id, name: &quot;Temp&quot; }); 特点： 箭头函数没有arguments，但是如果在箭头函数需要参数时，可以使用rest运算符来取代arguments 箭头函数没有prototype属性，不能用作构造函数（不能用new关键字调用） 箭头函数没有自己的this，箭头函数的this，不是调用的时候决定的(一般函数是由调用时决定)，而是在定义的时候所处在的对象就是他的this let obj = { name:箭头函数 getName(){ btn2.onclick = ()=&gt;{ console.log(this) } } } obj.getName() //输出obj let obj = { name:箭头函数 getName:()=&gt;{ btn2.onclick = ()=&gt;{ console.log(this) } } } obj.getName() //输出window 理解 如果箭头函数外面有函数，则箭头函数的this同外层函数的this一样。 若外层没有函数，指向window。 因此，箭头函数替代了以前需要显式的声明一个变量保存this的操作，使得代码更加的简洁。还有一个好处在数组的迭代中使用箭头函数更加简洁，并且省略了return关键字。 let arr = [1,2,3] arr.filter (item=&gt; item === 2)//[2] arr.map(item =&gt; item*2 ) //[2,4,6] arr.reduce((acc,cur) = acc+cur) //6 注意:不要在可能改变this指向的函数中使用箭头函数，类似Vue中的methods,computed中的方法,生命周期函数，Vue将这些函数的this绑定了当前组件的vm实例，如果使用箭头函数会强行改变this，因为箭头函数优先级最高（无法再使用call,apply,bind改变指向） 三点运算符... 剩余运算符：用来代替arguments，但比arguments灵活。 补充:arguments.callee()方法的意思是：调用函数本身。 function foo(...value){ //收集传过来的2，65两个元素 console.log(value)//输出[2,65]是一个真数组 } function foo(value){ console.log(arguments)//2,65是一个伪数组 } foo(2,65) 扩展运算符：只要含有iterator接口的数据结构都可以使用扩展运算符 扩展运算符可以和数组的解构赋值一起使用，但是必须放在最后一个，因为剩余/扩展运算符的原理其实是利用了数组的迭代器，它会消耗3个点后面的数组的所有迭代器，读取所有迭代器生成对象的value属性，剩余/扩展运算符后不能在有解构赋值，因为剩余/扩展运算符已经消耗了所有迭代器，而数组的解构赋值也是消耗迭代器，但是这个时候已经没有迭代器了，所以会报错 let [first,...arr]=[1,2,3,4,5]//不会报错 let[...arr,last] = [1,2,3,4,5] //报错 剩余运算符和扩展运算符的区别就是，剩余运算符会收集这些集合，放到右边的数组中，扩展运算符是将右边的数组拆分成元素的集合，它们是相反的 形参默认值在定义函数时可以定义形参的默认值，当不传入参数的时候默认使用形参里的默认值 //定义形参默认值 function add(a=0,b=1) { return a+b } console.log(add()); //输出1 Promise对象Promise是JS中进行异步编程的新的解决方案，之前是纯回调的方法。 回调函数的一些缺点:1.多重嵌套，导致回调地狱 Promise引入了链式调用的概念，每个then方法同样也是一个promise，所以可以链式调用下去。其次将异步操作以同步的流程表达出来，更方便阅读。2.不清楚回调是否都是异步调用的（可以同步调用ajax，在收到响应前会阻塞整个线程，会陷入假死状态，非常不推荐）3.第三方库可能没有提供错误处理 Promise在异步请求发送错误的时候，即使没有捕获错误，也不会阻塞主线程的代码 更深入的内容，在之前的博客中Promise学习笔记 SymbolSymbol是ES6中添加的新的数据类型(原来的有：String，Number,Boolean,Object,Null(空对象指针),Undefined(声明的变量未被初始化时)) 特点: Symbol属性对应的值是唯一的，解决命名冲突问题。(类似id) Symbol值不能与其他数据进行计算，包括同字符串拼接 for in/for of遍历时不会遍历symbol属性 //创建Symbol属性值 let symbol = Symbol(); //let symbol = Symbol(&#39;传一个标识&#39;); console.log(symbol) //输出Symbol //Symbol(&#39;传一个标识&#39;) let obj ={ name:&quot;ko&quot;,age:48 } obj[symbol]=&quot;男&quot; 1.当symbol作为对象的属性时，用XX[Symbol]形式，不用XX.Symbol形式。2.可以定义常量3.除了自己定义使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部的使用方法。比如Symbol.iterator属性 iterator迭代器概念:iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制。iterator接口是解构赋值，三点运算符，生成器，for-of循环的基础，主要供for-of消费。 工作原理:1.创建一个指针对象(遍历器对、iterator迭代器)，指向数据结构的起始位置。2.第一次调用next方法，指针自动指向数据结构的第一个成员3.接下来不断调用next方法，直到指向最后一个成员 注意：每次调用next方法返回的是一个包含value和done的对象{value:当前成员的值，done：布尔值}其中done对用的布尔值表示当前的数据的结构是否遍历结束。当遍历结束的时候返回的value值是undefined，done值为true 可迭代的数据结构会有一个[Symbol.iterator]方法, [Symbol.iterator]执行后返回一个iterator对象 默认具有iterator接口的数据结构有以下几个，注意普通对象默认是没有iterator接口的（可以自己创建iterator接口让普通对象也可以迭代） Array Map Set String TypedArray（类数组） 函数的 arguments 对象 NodeList 对象 自定义部署iterator接口 let targetData = { [Symbol.iterator]:function(){ let nextIndex = 0 //记录指针的位置 return{//遍历器对象 next:function(){ return nextIndex &lt; this.length?{value:this[nextIndex++],done:false}:{value:undefined,done:true}} } } } } for..of以前我们遍历数组中的元素的时，最开始使用的是for let arr = [1,2,3] for(let i = 0;i&lt;arr.length;i++){ console.log(arr[i]) //输出1，2，3 } 自ES5之后，可以使用forEach arr.forEach(function (value) { console.log(value); //输出1，2，3 }); 但是foeEach有两个缺点：1.不能使用break语句中断循环2.不能使用return语句返回到外层函数 ES6增加了for-of循坏，是现在简洁、最直接的遍历数组元素的语法。for-in不仅仅可以遍历数组，具有iterator接口的，都可以使用for-of进行遍历 for (var value of arr) { console.log(value); // 1,2,3 } 与for-in的区别：1.for-in 获取的是对象的键名2.for-in会遍历对象的整个原型链,性能非常差不推荐使用, Generator函数概念：ES6提供的解决异步编程的方案之一。 特点：1.function函数名*2.内部用yield表达式来定义不同的状态3.其返回值是一个Iterator迭代器（指针对象） 比如某个事物只有三种状态（状态A，状态B，状态C），而这三种状态的变化是 状态A =&gt; 状态B =&gt; 状态C =&gt; 状态A ，这就是状态机。Generator特别适用于处理这种状态机。 // A，B，C三种状态循环 function* state(){ while(1){ yield &#39;A&#39;; yield &#39;B&#39;; yield &#39;C&#39;; } } let status = state();//返回的是指针对象 //碰到yield返回 console.log(status.next()); // 先暂停到A，后面的代码不执行，返回{value: &quot;A&quot;, done: false} console.log(status.next()); // 执行下一条指令，暂停到B，返回{value: &quot;B&quot;, done: false} console.log(status.next()); // {value: &quot;C&quot;, done: false} console.log(status.next()); // {value: &quot;A&quot;, done: false} console.log(status.next()); // {value: &quot;B&quot;, done: false} Iterator迭代器遍历结束时，返回的是：{value: undefined, done: true},Generator函数可以使用return来改变最后的返回值 next传的参数可以作为启动yield(默认返回undefined)的返回值 function* state{ let result = yield &#39;hello&#39; console.log(result)//输出aaa } state.next(&quot;aaa&quot;) async函数本质:Generator语法糖，async取代Generator函数的星号*.await取代的是yield ES7的async/await进一步的优化Promise的写法，async函数始终返回一个Promise，await可以实现一个”等待”的功能，async/await被称为异步编程的终极解决方案，即用同步的形式书写异步代码，并且能够更优雅的实现异步代码顺序执行。 补充一种更高级的写法。 new Promise(resolve=&gt;{ setTimeout(()=&gt;{ resolve() //第一个参数为函数，目的在与执行resolve },2000) //更高级的写法 setTimeout(resolve,2000) }) 更深入的内容，在之前的博客中Promise学习笔记 class//定义一个人物的类 class Person{ //类的构造方法 constructor(){} } 注意类里面的方法，用es6简写形式不加function console.log(typeof Person);//function console.log(Person===Person.prototype.constructor);//true 从上面的代码可以看出类实质上就是一个函数，可以任务ES6的类就是构造函数的另外一种写法。实际上类的所有方法都定义在类的prototype属性上。constructor内的属性可以称为实例属性（和前面说的实例成员一样）,constructor外声明的属性都是定义在原型上的，可以称为原型属性（即定义在class上) 注意 class不存在变量提升，所以需要先定义再使用 extends继承ES5的继承 //父构造函数 this指向父构造函数的对象实例 function Father(name,age){ this.name = name; this.age = age; } Father.prototype.money= ()=&gt;{ console.log(&#39;父亲要上班&#39;); } //子构造函数 this指向子构造函数的对象实例 function Son(name,age) { //把指向父构造函数的对象实例的this改变成指向子构造函数的对象实例的this Father.call(this,name,age) } //让Son的原型对象指向Father的实例对象，那么就可以访问到Father实例对象上的方法 //这个new Father()是一个原型对象，相当于{}，这样写会覆盖掉Son的原型对象的constructor Son.prototype = new Father(); //所以还需要constructor指回原来的构造函数 Son.prototype.constructor = Son ES6的extends继承 class Son extends Father{ constructor(name,age){//继承时注意写参数 super(name,age)// 调用父类的构造方法，这里也要注意参数 } } static不同于普通在类中定义的会被实例继承的方法。在方法前加上static关键字。就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。（静态属性差不多的意思） class { static classMethod() { return &#39;hello&#39;; } } //Foo.classMethod()使用 扩展方法字符串扩展String.includes(str)判断是否包含指定的字符串返回值：包含true,不包含false String.startsWith(str)判断是否以指定字符串开头返回值：是true,否false String.endsWith(str)判断是否以指定字符串结尾返回值：是true,否false String.repeat(count)指定目标字符串重复的次数返回值:重复后的字符串 数值扩展进制表示法二进制用0b，八进制用0o console.log(0b1010);//输出10 Number.isFinite(i)判断i是否有限大的数返回值：是true,否false Number.isFinite(Infinity)//false Number.isNaN(i)判断i是否NaN返回值：是true,否false Number.isInteger(i)判断i是否整数返回值：是true,否false Number.isInteger(120.0)//true Number.parseInt(str)将字符串转换为对应的数值返回值：对应的数值 Math.trunc(i)直接i的去除小数部分返回值:整数部分 数组扩展Array.from(v)把v的伪数组(字符串也可)转换为真数组类数组(伪数组)最基本的要求就是具有length属性的对象,该类数组对象的属性名必须为数值型或字符串型的数字。 let arrayLike = { 0: &#39;tom&#39;, 1: &#39;65&#39;, 2: &#39;男&#39;, 3: [&#39;jane&#39;,&#39;john&#39;,&#39;Mary&#39;], &#39;length&#39;: 4 } let arr = Array.from(arrayLike) console.log(arr) // [&#39;tom&#39;,&#39;65&#39;,&#39;男&#39;,[&#39;jane&#39;,&#39;john&#39;,&#39;Mary&#39;]] Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。如下： let arr = [1,2,2,2,3,4,5] let set = new Set(arr) console.log(Array.from(set, item =&gt; item + 1)) // [2,3,4,5,6] Array.of(v1,v2,v3)将v1，v2..等元素转换成数组 find()找到第一个满足条件返回true的元素 let arr = [2,4,6] console.log(arr.find((value, index) =&gt; value &gt; 4)); //输出6 findIndex()找到第一个满足条件返回true的元素下标 let arr = [2,4,6] console.log(arr.findIndex((value, index) =&gt; value &gt; 4)); //输出2 拷贝笔记 对象扩展proto隐式原型可直接操作 let obj3={ } let obj4 = {name:&quot;xx&quot;} obj3.__proto__ = obj4 Object.is(v1,v2)判断对象v1与v2是否完全相等。 console.log(0 === -0) //true console.log(NaN == NaN)//false NaN与任何数都不相等 console.log(Object.is(0,-0)) //false console.log(Object.is(NaN,NaN))//true 由上面代码可知该方式是以字符串是否相等来判断的 Object.assign(target,source1,source2..)这个Object静态方法允许我们进行多个对象的合并，遍历需要合并给target的对象（仅可枚举属性），用等号进行赋值(这里可能有深浅拷贝的问题) 注意如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 const target = { a: 1, b: 1 }; const source1 = { b: 2, c: 2 }; const source2 = { c: 3 }; Object.assign(target, source1, source2); target // {a:1, b:2, c:3} 常见用途 1.关于拷贝的用法2.为属性指定默认值 ``` const DEFAULTS = { logLevel: 0, outputFormat: &#39;html&#39; }; //options对象是用户提供的参数。 function processContent(options) { options = Object.assign({}, DEFAULTS, options); console.log(options); // ... } ``` Set/Map容器Set容器：无序不可重复的多个value的集合体 new Set(array)创建方法 add(value)添加方法 delete(value)删除方法 has(value)判断是否存在方法 clear()清空方法 let set = new Set([1,3,2,2]) console.log(set);//输出唯一出现的值 //add(value)添加方法 set.add(7) console.log(set.size,set)//set.size相当于数组的length。 遍历：可以使用Set实例对象的keys()，values()，entries()方法进行遍历。由于Set的键名和键值是同一个值，它的每一个元素的key和value是相同的，所有keys()和values()的返回值是相同的，entries()返回的元素中的key和value是相同的。 let set = new Set([4, 5, &#39;hello&#39;]) for(let item of set.keys()) { console.log(item) //输出4，5，hello } for(let item of set.values()) { console.log(item) // 输出4，5，hello } for(let item of set.entries()) { console.log(item) //[4,4],[5,5],[&#39;hello&#39;,&#39;hello&#39;] } 数组去重(常用) let array = [0,1,1,2,2,5,5,66,99,65,65]; console.log(Array.from(new Set(array))); //Array(7) [0, 1, 2, 5, 66, 99, 65] console.log([...new Set(array)]); //Array(7) [0, 1, 2, 5, 66, 99, 65] Map容器:Map是一组键值对(key-value，只取前两个元素。)的结构,key不重复 let a = new Map([[&#39;Michael&#39;, 95],[&quot;Bot&quot;,99]] m.set(&#39;Adam&#39;, 67); //添加新的key-value m.has(&#39;Adam&#39;);//是否存在key&quot;Adam&quot; true m.get(&#39;Adam&#39;); //获得key为Adam的value 67 m.delete(&#39;Adam&#39;);//删除key&quot;Adam&quot; m.clear() //清空Map容器 一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉。 ES7(16年发布)指数运算符(幂)** console.log(3 ** 3); //3的3次方=27 Array.prototype.includes(value)字符串与数组都有includes方法，判断数组中是否包含指定的value ProxyProxy也就是在目标对象之前设置一层拦截，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。 Proxy的作用 拦截和监视外部对对象的访问 降低函数或类的复杂度 在复杂操作前对操作进行校验或对所需资源进行管理 语法：new Proxy(target,handler) target就是被设置一层拦截的对象，可以是任何类型的对象(包括原生数组，函数，甚至另一个代理) handler是一个对象，用来定制拦截行为 Proxy一般和Reflect配套使用,前者拦截对象,后者返回拦截的结果,Proxy上有的的拦截方法Reflect都有 1.set/get方法 set方法接收两个常用参数 target：得到的目标值 key：目标的key值，相当于对象的属性 set方法可以接收四个参数 target:目标值。 key：目标的Key值。 value：要改变的值。 receiver：改变前的原始值。 let handler = { get:function (target,key) { if (target.hasOwnProperty(key)){ return target[key]//key为属性名，target[key]为属性值 } else{ console.warn(`对不起，没有这个${key}`) return } }, set:function (target,key,value) { console.log(&quot;set&quot;,target,key,value); target[key] =value //设置了p.a才打印1 }, //删除属性 deleteProperty:function (target,key) { console.log(`删除${key}属性的${target[key]}值`); delete target[key] }, // 拦截key in object操作 has(target, key) { // 自定义限制：只暴露a属性 if (key === &#39;a&#39;) { return target[key]; } else { return false; } }, } let p = new Proxy({},handler) p.a=1 //set {} a 1 p.b=2 console.log(&#39;b&#39; in p); // false,没有暴露 console.log(&#39;a&#39; in p); //true //console.log(p.a); //delete p.b //删除了b属性的2值 //console.log(p.b); //undefined 可以使用Proxy实现表单验证。 Object.defineProperty也可以实现数据拦截，Proxy有什么优势吗？1.支持数组数组的key是下标，对象的key是属性名 let arr = [1,2,3] let proxy = new Proxy(arr, { get (target, key, receiver) { console.log(&#39;get&#39;, key) return Reflect.get(target, key, receiver) }, set (target, key, value, receiver) { console.log(&#39;set&#39;, key, value) return Reflect.set(target, key, value, receiver) } }) proxy.push(4) // get push (寻找 proxy.push 方法) // get length (获取当前的 length) // set 3 4 (设置 proxy[3] = 4) // set length 4 (设置 proxy.length = 4) 2.Object.defineProperty()的升级版 外界对某个对象的访问，都必须经过这层拦截。因此它是针对整个对象，而不是对象的某个属性。 ES5JSON对象 JSON.stringify(obj/arr):js对象(数组)转换为json对象 JSON.parse(json):json对象(数组)转换为js对象(数组) Object扩展Object.create(prototype,[descriptors])作用：以指定对象为原型创建新的对象。为新的对象指定新的属性，并对属性进行描述 let obj = {name:&quot;ranan&quot;,age:2} //第一个参数指定原型，第二参数为实列添加属性 let obj1 = Object.create(obj,{sex:{ value:&quot;女&quot;,//value指定值 writable:true,//标识当前属性是否可以被删除，默认为false configurable:true,//表示当前属性是否可以被删除，默认为false enumerable:true,//标识当前属性是否能用for-in枚举，默认false }}) console.log(obj1); 克隆保持原型链 function clone(origin) { //Object.getPrototypeOf方法返回指定对象的原型（内部[[Prototype]]属性的值） let originProto = Object.getPrototypeOf(origin); //Object.create方法创建一个新对象，originProto为原型创建新对象 return Object.assign(Object.create(originProto), origin); Object.defineProperties(object,descriptors)作用:为指定的object对象扩展多个属性一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。如果不指定configurable, writable, enumerable ，则这些属性默认值为false，如果不指定value, get, set，则这些属性默认值为undefined。 Object的defineProperty/defineProperties主要功能就是用来定义或修改这些内部属性,getOwnPropertyDescriptor/getOwnPropertyDescriptors就是获取这行内部属性的描述。 语法: Object.defineProperty(obj, prop, descriptor) obj: 需要被操作的目标对象prop: 目标对象需要定义或修改的属性的名称descriptor: 将被定义或修改的属性的描述符 var obj = new Object(); Object.defineProperty(obj, &#39;name&#39;, { configurable: false, writable: true, enumerable: true, value: &#39;张三&#39; }) console.log(obj.name) //张三 语法: Object.defineProperties(obj, props) obj: 将要被添加属性或修改属性的对象props: 该对象的一个或多个键值对定义了将要为对象添加或修改的属性的具体配置 方法直接在一个对象上定义一个或多个新的属性或修改现有属性，并返回该对象。 var obj = new Object(); Object.defineProperties(obj, { name: { value: &#39;张三&#39;, configurable: false, writable: true, enumerable: true }, age: { value: 18, configurable: true } }) console.log(obj.name, obj.age) // 张三, 18 该方法的存储器属性(setter,getter)可以实现简单的数据双向绑定 &lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;input1&quot;&gt; &lt;div&gt; 上面输入的数据是 &lt;span id=&quot;span&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; let oInput1 = document.getElementById(&#39;input1&#39;); let oSpan = document.getElementById(&#39;span&#39;); let obj = {}; Object.defineProperties(obj, { //惰性求值，get之后才有值 val1: { configurable: true,//可修改 get: function() { oInput1.value = 0; oSpan.innerHTML = 0; return 0 }, set: function(newValue) { oSpan.innerHTML = newValue } }, }) //设置默认值为0 调用get方法 oInput1.value = obj.val1; oInput1.addEventListener(&#39;keyup&#39;, function() { //调用set方法 obj.val1 = oInput1.value; }, false) &lt;/script&gt; get/set propertyName(){}对象本身的两个方法，用法和上面的get/set一样 let obj = {firstName:&quot;xx&quot;,lastName:&quot;xx&quot;, get fullName(){ return this.firstName+ this.lastName }} Array扩展Array.prototype.indexOf(value)/lastIndexOf(value)返回value在数组中出现的第一个下标和最后一下下标，没有出现则返回-1 应用场景：两个方法结合判断下标是否相等，可以用来判断数组中唯一出现的值 Array.prototype.forEach()遍历数组,前面介绍for-of时介绍了此方法的用法，这里就不介绍了。 Array.prototype.map()遍历数组返回一个新的加工后之后的数组，不改变原数组的值 Array.prototype.filter()遍历过滤出一个新的子数组，不改变原数组，返回条件为true的值 遍历方法的总结 Function扩展bind()、call()、apple()的区别 都能指定函数中的this Array.prototype.call()/Array.prototype.apply()是立即调用函数，Array.prototype.bind()是将函数返回 Array.prototype.call(obj)/Array.prototype.bind()从第二个参数开始依次传，Array.prototype.apply(obj)第二个参数是数组，传入的数据放入数组中 let obj ={name:&quot;ranan&quot;} function f(data,data2) { console.log(this); console.log(data + data2); return data+data2 } f.call(obj,33,22) //{name:&quot;ranan&quot;} 55 f.apply(obj,[33,22])//{name:&quot;ranan&quot;} 55 let bar=f.bind(obj) //bind不调用函数 bar(33,22)//{name:&quot;ranan&quot;} 55 //上面也可以写成 f.bind(obj)(33,22)//{name:&quot;ranan&quot;} 55 Function.prototype.bind(obj)作用:将函数内的this绑定为obj，并将函数返回(并不调用) 返回原函数的拷贝，我们称这个拷贝的函数为绑定函数。 将函数中的this固定为调用bind方法时的第一个参数， 绑定this之后，无论有哪个对象调用绑定函数，绑定函数中的this依旧之前绑定的第一个参数 如果绑定函数作为构造函数，已经捆绑的this会被忽略掉，this依然指向实例对象 function Person(name){ this.name = name; } var bindPerson = Person.bind({name:&quot;绑定函数&quot;}) new bindPerson(&quot;张三&quot;) // Person {name: &quot;张三&quot;} 通常用于指定回调函数的this，因为apply与call会立即调用 使用场景保持上下文的方法 var o={ f: function () { var self=this; var fff=function() { console.log(this.value); // bind(this) 中 this 指向的是o，这里也可直接写成 bind(o) }.bind(this); fff(); }, value: &quot;Hello World!&quot; }; o.f(); // Hello World！]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js异步:宏队列与微队列]]></title>
    <url>%2F2020%2F02%2F16%2F%E5%AE%8F%E9%98%9F%E5%88%97%E4%B8%8E%E5%BE%AE%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[异步执行的函数放入队列中执行。队列分为宏队列与微队列。 宏队列：用来保存执行的宏任务（回调），比如：dom事件回调，ajax回调，定时器回调微队列：用来保存执行的微任务（回调），比如：promise回调，mutation回调 1.JS为单线程引擎，必须先执行所有的初始化同步任务代码。2.每次取出第一个宏任务执行前，都要将所有的微任务执行完毕。 注:取到栈里执行，若有嵌套的情况如下列代码，执行第一个setTimeout回调时，把里面的微任务放入微队列，执行第二宏任务前，先将所有的微任务执行完毕。 setTimeout(()=&gt;{ //会立即放入宏队列 console.log(&quot;timeout callback1()&quot;); Promise.resolve(3).then( value =&gt;{ //会立即放入微队列 console.log(&quot;Promise onResolved3()&quot;,value); } ) },0) setTimeout(()=&gt;{ //会立即放入宏队列 console.log(&quot;timeout callback2()&quot;); },0) Promise.resolve(1).then( value =&gt;{ //会立即放入微队列 console.log(&quot;Promise onResolved1()&quot;,value); } ) Promise.resolve(2).then( value =&gt;{ //会立即放入微队列 console.log(&quot;Promise onResolved2()&quot;,value); } ) /* 输出:Promise onResplved(),1 Promise onResplved(),2 timeout callback1() Promise onResolved3() timeout callback2() ) */]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise面试题（深入理解调用顺序）]]></title>
    <url>%2F2020%2F02%2F16%2Fpromise%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[第一题 setTimeout(()=&gt;{ console.log(1); },0) Promise.resolve().then(()=&gt;{ console.log(2); }) Promise.resolve().then(()=&gt;{ console.log(3); }) console.log(4); /* 输出：4 2 3 1 */ 第二题 setTimeout(() =&gt; { console.log(1); }, 0) //Promise为构造函数 new Promise(resolve =&gt; { console.log(2); //同步执行 resolve()//成功 }).then(() =&gt; { //成功的回调 console.log(3); }).then(() =&gt; {//此处的then等上一个执行完之后再放入微队列执行 console.log(4); }) console.log(5);//同步执行 /* 输出:2 5 3 4 1 */ 注意： 链式的then要等前一个then执行完毕才知道状态，才可以执行。 第三题 //定义了一个返回promise的函数 const first = () =&gt; (new Promise((resolve, reject) =&gt; { console.log(1); //同步执行1 //返回promise的函数 let p = new Promise((resolve, reject) =&gt; { console.log(2); //同步执行2 //放入宏队列1 setTimeout(() =&gt; { console.log(3); resolve(4) //最后执行宏队列时状态已经修改，不再是等待，所以该行代码不执行 }, 0) resolve(5) //立刻执行，p的状态立刻成功 }) resolve(6) //first的状态变成成功 //成功的回调放入微队列1 p.then((arg) =&gt; { console.log(arg); }) })) //成功的回调放入为微队列2 first().then((arg)=&gt;{ console.log(arg); }) console.log(7);//同步执行3 /*输出 1 2 7 5 6 3 开始：输出 1 2 7 宏[3] 微[5 6] 输出微队列：5 6 输出宏队列：3 */ 第四题 //加入宏队列1 setTimeout(()=&gt;{ console.log(0); },0) new Promise((resolve,reject) =&gt;{ console.log(1); //同步执行1 resolve() //成功的回调加入微队列1 }).then(()=&gt;{ console.log(2); new Promise((resolve, reject) =&gt; { console.log(3); resolve() //成功的回调加入微队列3 }).then(()=&gt;{ console.log(4); //成功的回调加入微队列5 }).then(()=&gt;{ console.log(5); }) //成功的回调加入微队列4 }).then(()=&gt;{ console.log(6); }) new Promise((resolve, reject) =&gt; { console.log(7); // 同步执行2 resolve() //成功的回调加入微队列2 }).then(()=&gt;{ console.log(8); }) /* 输出：1 7 2 3 8 4 6 5 0 状态1：同步执行输出1 7 宏[0] 微[2 8] 状态2,执行微任务1（整个then）：输出2 3 宏[0] 微[8 4 6] 状态3,执行微任务2：输出 8 宏[0] 微[4 6] 状态4,执行微任务3：输出4 宏[0] 微[6 5] .... */ 这道题我错在6和5的顺序上面，不太懂为什么6在5前面。阅读了一篇文章之后才明白，下面是对知识点进行摘录+总结。 知识点1 当执行 then 方法时，如果前面的 promise 已经是 resolved 状态，则直接将回调放入微队列中。 注意：then方法是同步执行的，但是then中的回调是异步执行的。 在同步执行then方法时，会进行判断： 如果前面的 promise 已经是 resolved 状态，则会立即将回调推入微队列 如果前面的 promise 是 pending 状态则会将回调存储在 promise 的内部(不会被执行，也不会被放入微队列中)，一直等到 promise 被 resolve 才将回调推入微队列 知识点2 resolve的作用除了将当前的 promise 由 pending 变为 resolved，还会遍历之前通过 then 给这个 promise 注册的所有回调，将它们依次放入微队列中，很多人以为是由 then 方法来触发它保存回调，而事实上是由 promise 的 resolve 来触发的，then 方法只负责注册回调。 对于 then 方法返回的 promise 它是没有 resolve 函数的，取而代之只要 then 中回调的代码执行完毕并获得同步返回值，这个 then 返回的 promise 就算被 resolve new Promise((resolve,reject) =&gt;{ console.log(1); resolve() //第一个then }.then(()=&gt;{ ... //第二个then }).then(()=&gt;{ ... }) 首先Promise是实例化，同步执行函数，打印1，执行resolve函数，将 promise 变为 resolved，但由于此时 then 方法还未执行。由知识点2：resolve会触发保存它的回调。then是同步的，所以会依次保存第一个then和第二个then [主]外部第一个 then，外部第二个 then [微] 空 然后执行第一then,由于前面的promise已经被resolve了，所以将第一then的回调放入微队列。 [主]外部第二个 then [微]外部第一个 then的回调 但是这个回调还没有执行，所以第一then返回的promise 仍为 pending 状态，所以同步执行第二个then。由于前面的 promise 是 pending 状态，所以外2then 的回调也不会被推入微任务队列也不会执行 [主]空 [微]外一 then的回调 现在主线程空了，执行微任务，也就外一 then的回调，首先打印出2，随后实例化内部promise，打印3，执行resolve函数,遍历then保存。 new Promise((resolve,reject) =&gt;{ .... //外1 }.then(()=&gt;{ console.log(2); new Promise((resolve, reject) =&gt;{ console.log(3); resolve() }.then(()=&gt;{ //内部第一个then console.log(4); }).then(()=&gt;{ //内部第二个then console.log(5); }) } //外2 .then(()=&gt;{ ..... }) [主]内1 then 内2的then [微]空 然后执行内1的then，由于前面的 promise 已被 resolve，所以将回调放入微任务队列中。 [主]内2的then [微]内1then的回调 然后执行内2的then，因为内部第一个then的回调还未执行所以状态为pending，所以内2then 的回调和外2then 的回调一样，不注册不执行。 [主]空 [微]内1then的回调 外1的回调全部执行完毕，这里尤其注意:内2then的回调没执行，但是内2then是执行了的。外1then 返回的 promise 的状态由 pending 变为 resolved，同时遍历之前通过 then 给这个 promise 注册的所有回调，将它们的回调放入微任务队列中。 [主]空 [微]内1then的回调 外2then 的回调 主线程执行完毕，取出内1then的回调执行 [主]内1then的回调 [微]外2then 的回调 打印4，内1then返回的promise状态由 pending 变为 resolved，同时遍历之前通过 then 给这个 promise 注册的所有回调，将它们的回调放入微任务队列中。 [主] 空 [微]外2then 的回调 内2的回调 最后一点就不分析了，这就是为什么6要比5先输出的原因了。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git&GitHub]]></title>
    <url>%2F2020%2F02%2F14%2Fgit-1%2F</url>
    <content type="text"><![CDATA[git介绍结构 工作区（本身文件）：写代码 = git add =&gt; 暂存区：临时存储 = git commit =&gt; 本地库（.git）：存储历史版本 Git和代码托管中心 代码托管中心(如GitHub):帮忙维护远程库 本地库和远程库 团队内部协作 跨团队协作 外团队人员fork该团队远程库A（复制新的远程库B），clone到本地修改后push到B，之后外团队人员pull request =&gt; 该团队人 审核 =&gt; merge 远程库A的内容更新成远程库B的内容。 git命令行操作本地库初始化命令：git init效果：出现隐藏文件.git注意：.git目录中存放的是本地库相关的子目录和文件，不要删除，也不要乱修改 设置签名形式: 用户名：XXX Email地址：XXXXX 作用：区分不同开发人员的身份辨析：这里设置的签名和代码托管中心的账号、密码没有任何关系命令: 项目级别/仓库级别：仅在当前本地库起作用 git config user.name XX git config user.email XX 系统用户级别：登陆当前操作系统的用户范围， git config --global git config --global user.name XX git config --global user.email XX 级别优先级：项目级别优于系统用户级别 基本操作状态检查命令: git status作用：查看工作区、暂存区状态 移除暂存区命令: git rm –cached [filename] 添加到暂存器命令：git add[filename] 添加所有git add . 添加所有修改的git add -A 提交命令：git commit-m”commit message”[filename] 提交所有git commit -m”版本留言描述”作用：将暂存区的内容提交到本地库 查看历史任务命令： 完整形式 git log 若多屏显示控制方式：空格向下翻页 b向上翻页 q退出 以一个漂亮的格式显示 git log –pretty=oneline/git log–oneline(后面的更简洁) git reflog :索引值更简洁，其中HEAD@{移动到当前版本需要多少步} 前进后退可以配合git reflog使用本质:操作HEAD的指针，默认是指向最近的版本。基于索引值操作（推荐）: git reset –hard [局部索引值] 例（上图）：git reset–hard a6ace91使用^(异或)符号（只能后退）： git reset –hard HEAD^ 注:一个^表示后退一步，n 个表示后退 n 步使用~符号（只能后退）: git reset –hard HEAD~n 注:表示后退 n 步 reset 命令的三个参数对比–soft参数： 仅仅在本地库移动 HEAD 指针 只回退了commit的信息，如果还要提交，直接commit –mixed参数：① 在本地库移动 HEAD 指针 ② 重置暂存区 默认方式 git reset –mixed + git add . = git reset –soft –hard参数：①在本地库移动 HEAD 指针 ② 重置暂存区 ③ 重置工作区 彻底回退到某个版本，本地的源码也会变成上一个版本的内容 删除文件与恢复前提：删除前，文件存在时的状态提交到了本地库。操作：rm [filename]注：rm之后通过 git add [filename] 可把文件再次添加到缓存区 可利用 git reset –hard[指针位置] 回退到之前版本找回文件。 前提：删除的文件在暂存区，但还没有提交到本地库命令: git reset –hard HEAD（刚刚创建时） 比较文件差别命令：git diff[文件名]作用：将工作区中的文件和暂存区进行比较 命令：git diff[本地库中历史版本][文件名]作用：将工作区中的文件和本地库历史记录比较 注意:不带文件名比较多个文件 分支管理优势： 同时并行推进多个功能开发，提高开发效率 各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可 分支操作创建分支命令：git branch[分支名] 查看分支命令：git branch -v 切换分支命令：git checkout[分支名] 合并分支如把hot_fix上的修改合并到master上 第一步：切换到合并的分支上 git checkout[master]第二步：执行 merge 命令 git merge[hot_fix] 解决冲突合并时同时修改同一个文件的同一个地方 第一步:自行修改冲突文件第二步:git add[文件名]第三步:git commit-m”日志信息” 注意：此时 commit 一定不能带具体文件名 GitHub连接远程库命令： git remote-v 查看当前所有远程地址别名 git remote add [别名] [远程地址] (常用别名：origin)作用：下次上传可以直接用别名上传 推送命令：git push [别名][分支名] 克隆命令：git clone 仓库地址作用；完整的把远程库下载到本地；创建origin远程地址别名；初始化本地库。 团队成员邀请 变成团队成员就可以把自己的修改推送进入远程仓库了。 拉取pull命令: git fetch[远程库地址别名][远程分支名] git merge[远程库地址别名/远程分支名] git pull[远程库地址别名][远程分支名]作用: pull=fetch+merge。 fetch 把远程库抓取下来，并没有修改本地文件。 merge 把远程的master合并到本地的master，本地文件修改。 解决冲突要点：果不是基于GitHub远程库的最新版本所作的修改，不能推送，必须先拉取下来如若pull下来之后进入冲突状态，其余同分支冲突处理办法一样。 跨团队操作外团队人员fork该团队远程库A（复制新的远程库B、外团队人员的仓库），clone到本地修改后push到B，之后外团队人员pull request （GitHub远程库B操作）=&gt; 该团队人（GitHub远程库A） 审核 =&gt; merge 远程库A的内容更新成远程库B的内容。 SSH登陆第一步：生成ssh（在家目录）ssh-keygen ct rsa -C 邮箱账号 //注意C大写注：在主目录下生成的密钥在 /c/Users/用户名/.ssh/id_rsa 里第二步：查看并复制ssh（需在.ssh目录下执行 cd .ssh进入）cat id_rsa.pub第三步：复制密钥内容添加到 github 上 使用ssh协议上传文件到仓库 git initgit add .git commit -m “ “git remote add 别名 git@github.com:…git push -u 别名 master Git工作流在项目开发过程中使用的Git的方式 GitFlow工作流(常用)Gitflow 工作流通过为功能开发、发布准备和维护设立了独立的分支，让发布 迭代过程更流畅。严格的分支模型也为大型项目提供了一些非常必要的结构。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[富文本tinymce]]></title>
    <url>%2F2020%2F02%2F09%2F%E5%AF%8C%E6%96%87%E6%9C%ACtinymce%2F</url>
    <content type="text"><![CDATA[安装//安装tinymce-vue npm install @tinymce/tinymce-vue -S //安装tinymce,版本为5.X npm install tinymce -S //引入中文语言包 中文下载包 使用在 node_modules中找到 tinymce/skins目录，然后将skins目录拷贝到static目录下的tinymce 初始化引入基本文件 //初始化tinymce import tinymce from &#39;tinymce/tinymce&#39; import Editor from &#39;@tinymce/tinymce-vue&#39; import &#39;tinymce/themes/silver&#39; 注册组件 &lt;Editor&gt;&lt;/Editor&gt; //js components: {Editor} 初始化配置 &lt;Editor :init=&quot;init&quot;&gt;&lt;/Editor&gt; data() { return { init:{ //语言 language_url: &#39;/static/tinymce/zh_CN.js&#39;, language: &#39;zh_CN&#39;, //skin路径 skin_url: &#39;/static/tinymce/skins/ui/oxide&#39;, } } }, mounted () { tinymce.init({}) }, 初始化配置之后最基本的符文就有了，接下来丰富它的功能 数据同步 //子组件 &lt;Editor v-model=&quot;myValue&quot;&gt;&lt;/Editor&gt; data() { return { myValue: this.value } }, props: { value: { default: &#39;&#39;, type: String }, } watch: { value(newValue) { this.myValue = newValue }, myValue(newValue) { this.$emit(&#39;input&#39;, newValue) } }, //父组件 onEditorUploadSuccess为图片上传成功的回调 &lt;editor v-model=&quot;value&quot; @on-upload-success=&quot;onEditorUploadSuccess&quot; &gt;&lt;/editor&gt; 完整代码 &lt;template&gt; &lt;div&gt; &lt;Editor :init=&quot;init&quot; v-model=&quot;myValue&quot;&gt;&lt;/Editor&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; //这个是接口文件 import {ImgUpload} from &#39;@/api/notice&#39; //初始化tinymce import tinymce from &#39;tinymce/tinymce&#39; import Editor from &#39;@tinymce/tinymce-vue&#39; //引入主题 import &#39;tinymce/themes/silver&#39; /* 引入插件 */ import &#39;tinymce/plugins/image&#39; import &#39;tinymce/plugins/table&#39; import &#39;tinymce/plugins/preview&#39; import &#39;tinymce/plugins/fullscreen&#39; import &#39;tinymce/plugins/link&#39; import &#39;tinymce/plugins/code&#39; import &#39;tinymce/plugins/lists&#39; import &#39;tinymce/plugins/hr&#39; import &#39;tinymce/plugins/advlist&#39; import &#39;tinymce/plugins/paste&#39; import &#39;tinymce/plugins/importcss&#39; import &#39;tinymce/plugins/media&#39; export default { data() { return { myValue: this.value, init:{ //语言 language_url: &#39;/static/tinymce/zh_CN.js&#39;, language: &#39;zh_CN&#39;, //设置皮肤 skin_url: &#39;/static/tinymce/skins/ui/oxide&#39;, //高度 height: 400, //菜单栏 menubar: false, //隐藏商标 // branding: false, //工具栏|分类 配置插件 toolbar: `styleselect | fontselect | formatselect | fontsizeselect | forecolor backcolor | bold italic underline strikethrough | image | table | alignleft aligncenter alignright alignjustify | outdent indent | numlist bullist | preview removeformat hr | code link | undo redo | fullscreen `, //自动聚焦 auto_focus: true, //引入插件 plugins: ` paste importcss image code table advlist fullscreen link media lists hr preview`, //图片标题 image_caption: true, //上传本地图片 image_uploadtab:true, // Image imagetools_toolbar: &#39;rotateleft rotateright | flipv fliph | editimage imageoptions&#39;, // 设置Tab // tabfocus_elements: &#39;:prev,:next&#39;, // object_resizing: true, //设置可选段落样式 style_formats: [ { title: &#39;首行缩进&#39;, block: &#39;p&#39;, styles: { &#39;text-indent&#39;: &#39;2em&#39; } }, { title: &#39;行高&#39;, items: [ { title: &#39;1&#39;, styles: { &#39;line-height&#39;: &#39;1&#39; }, inline: &#39;span&#39; }, { title: &#39;1.5&#39;, styles: { &#39;line-height&#39;: &#39;1.5&#39; }, inline: &#39;span&#39; }, { title: &#39;2&#39;, styles: { &#39;line-height&#39;: &#39;2&#39; }, inline: &#39;span&#39; }, { title: &#39;2.5&#39;, styles: { &#39;line-height&#39;: &#39;2.5&#39; }, inline: &#39;span&#39; }, { title: &#39;3&#39;, styles: { &#39;line-height&#39;: &#39;3&#39; }, inline: &#39;span&#39; } ] } ], //字体列表 font_formats: ` 微软雅黑=微软雅黑; 宋体=宋体; 黑体=黑体; 仿宋=仿宋; 楷体=楷体; 隶书=隶书; 幼圆=幼圆; Andale Mono=andale mono,times; Arial=arial, helvetica, sans-serif; Arial Black=arial black, avant garde; Book Antiqua=book antiqua,palatino; Comic Sans MS=comic sans ms,sans-serif; Courier New=courier new,courier; Georgia=georgia,palatino; Helvetica=helvetica; Impact=impact,chicago; Symbol=symbol; Tahoma=tahoma,arial,helvetica,sans-serif; Terminal=terminal,monaco; Times New Roman=times new roman,times; Trebuchet MS=trebuchet ms,geneva; Verdana=verdana,geneva; Webdings=webdings; Wingdings=wingdings,zapf dingbats`, //内容样式, 在最后呈现的页面也要写入这个基本样式保证前后一致 content_style: ` * { padding:0; margin:0; } html, body { height:100%; } img { max-width:100%; display:block;height:auto; } a { text-decoration: none; } iframe { width: 100%; } p { line-height:1.6; margin: 0px; font-family:&quot;宋体&quot;; } table { word-wrap:break-word; word-break:break-all; max-width:100%; border:none; border-color:#999; } .mce-object-iframe { width:100%; box-sizing:border-box; margin:0; padding:0; } ul,ol { list-style-position:inside; } `, insert_button_items: &#39;image link | inserttable&#39;, //回车添加的标签 forced_root_block:&quot;p&quot;, //强制每行添加&lt;p&gt;标签 force_p_newlines: true, importcss_append: true, //字体大小栏选项 fontsize_formats: &#39;10px 11px 12px 14px 16px 18px 20px 24px&#39;, // paste设置 paste_data_images: true,//可以粘贴图片 paste_word_valid_elements: &#39;*[*]&#39;,//word过滤 paste_retain_style_properties:&#39;all&#39;, //允许保留word粘贴过来的格式 paste_convert_word_fake_lists: false,//禁止word的列表内容转换html的ul和ol格式 paste_merge_formats: true,//合并相似格式 nonbreaking_force_tab: false, paste_auto_cleanup_on_paste: false, statusbar: false, // 隐藏编辑器底部的状态栏 images_upload_handler: this.uploadImg//图片上传 }, } }, props: { //图片最大大小 maxSize: { default: 2097152, type: Number }, //图片可接收类型 accept: { default: &#39;image/jpeg, image/png, image/jpg, image/svg, image/gif&#39;, type: String }, //上传地址 url: { default: &#39;&#39;, type: String }, //数据 value: { default: &#39;&#39;, type: String }, }, methods: { //上传图片 uploadImg(blobInfo, success, failure) { const that = this //符合大小 if (blobInfo.blob().size &gt; this.maxSize) { failure(&#39;文件体积过大&#39;); } //符合类型 if (this.accept.indexOf(blobInfo.blob().type) &gt; -1) { let form = new FormData(); form.append(&#39;file&#39;, blobInfo.blob(), blobInfo.filename()); ImgUpload(form).then(res=&gt;{ //给父组件传值 that.$emit(&#39;on-upload-success&#39;, { res, success, failure }) }).catch(err =&gt; { failure(&#39;上传失败: &#39; + err); }) } else failure(&#39;图片格式错误&#39;); }, }, watch: { value(newValue) { this.myValue = newValue }, myValue(newValue) { this.$emit(&#39;input&#39;, newValue) } }, components: {Editor}, mounted () { tinymce.init({}) }, } &lt;/script&gt; &lt;!--scoped 样式仅仅在当前组件使用--&gt; &lt;style scoped&gt; &lt;/style&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件超市项目后台管理界面开发流程3]]></title>
    <url>%2F2020%2F02%2F06%2F%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B3%2F</url>
    <content type="text"><![CDATA[vue全局配置项目有很多重复用到的变量和方法，新建一个global/index.js来存放。具体的实现是通过在Vue的原型上添加方法和属性，也就是使用Vue.prototype，最后要在main.js引入文件`import “./global”; Messsage.vue一级导航用于显示消息通知,里面包含了两个组件，一个用于分页的ProjectPagination，一个是用于消息提醒的MessageRemind。这里实现了流程1提到的:如果有未读消息，进入管理页面后直接显示消息通知，如果没有未读消息，则显示第一个路由。 //登陆之后是先跳转到message，此时的pageEnterStatetrue=true。 if (this.pageEnterState) { //如果没有消息就跳到第一个路由 if (this.msgLen === 0) { const route = this.$store.getters.addRouter; this.$router.push(route[0].path); } else { //如果有消息就显示，tableData就是登陆时传给state的消息 this.data = this.tableData; this.isLoading = false; } this.$store.commit(&quot;SET_PAGE_ENTER_STATE&quot;, false); } else { this.loadData(); } } 分页ProjectPagination结合element-ui的pagination加上一些修改。前一篇博客中提到了父组件向子组件传值的方法，这里同时也用到了子组件向父组件传值的方法 &lt;!-- 分页器 --&gt; &lt;template&gt; &lt;el-pagination class=&quot;x-page&quot; layout=&quot;total,sizes, prev, pager, next, jumper&quot; @current-change=&quot;handleCurrentChange&quot; @size-change=&quot;handleSizeChange&quot; :current-page.sync=&quot;currentPage&quot; :page-sizes=&quot;pageSizes&quot; :page-size=&quot;pageSize&quot; :total=&quot;total&quot;&gt;&lt;/el-pagination&gt; &lt;/template&gt; &lt;script&gt; export default { name: &quot;ProjectPagination&quot;, //接收父组件传来的值 props: { //data为所有数据 data: Array, //filterData做为一个筛选容器 filterData: Array }, data() { return { //当前页数 currentPage: 1, //默认的一页显示条数 pageBase: 10 }; }, computed: { // 数据总数目 total() { return this.data.length; }, // 一页有多少条数据 pageSize() { //如果基础数据大于总数，则显示总数 let size = this.total &gt;= this.pageBase ? this.pageBase : this.total; return size; }, // 提供每页条数的选择，返回值为一个数组 pageSizes() { let count = Math.ceil(this.total / this.pageSize); let sizes = []; for (let i = 1; i &lt;= count; i++) { sizes.push(this.pageSize * i); } return sizes; } }, methods: { //pageSize改变执行，回调参数:每页条数 handleSizeChange(val) { // 获取项目条数 //子组件像父组件传值，更新filterData。 this.$emit(&quot;update:filterData&quot;, this.data.slice(0, val)); }, // 页面页数改变 handleCurrentChange(val) { // 获取下一页数据 this.$emit( &quot;update:filterData&quot;, this.data.slice((val - 1) * this.pageSize, val * this.pageSize) ); } }, created() { //发送一个update:filterData，显示pageSize个数据 this.$emit(&quot;update:filterData&quot;, this.data.slice(0, this.pageSize)); }, watch: { // 监控数据变化时获取数据 data() { this.$emit(&quot;update:filterData&quot;, this.data.slice(0, this.pageSize)); } }, //路由要求刷新 activated() { if (this.$route.meta.isRefresh) { this.currentPage = 1; } } }; &lt;/script&gt; &lt;style scoped&gt; .x-page { margin-top: 10px; float: right; } &lt;/style&gt; $emit(update: prop, “newPropVulue”)$emit(update: prop, “newPropVulue”) 这个模式，使子组件向父组件传达：更新属性，并抛出新的属性值。 从上述代码中可以看出首先更新的值要是从父组件中接收的，也就是props里面的值。其次父组件该值需要写成 &lt;ProjectPagination :data=&quot;data&quot; :filter-data=&quot;filterData&quot; @update:filter-data=&quot;filterData=$event&quot;&gt;&lt;/ProjectPagination&gt; 更简单的写法是.sync修饰符 &lt;ProjectPagination :filter-data=&quot;filterData&quot; :filter-data.sync=&quot;filterData&quot;&gt;&lt;/ProjectPagination&gt; 注意:这里有一个Vue.sync修饰符与$emit(update:xxx)写法的坑使用.sync修饰符 //有效 this.$emit(&quot;update:filterData&quot;, this.data.slice(0, val)); //无效 this.$emit(&quot;update:filter-Data&quot;, this.data.slice(0, val)); 不使用.sync修饰符 //无效 this.$emit(&quot;update:filterData&quot;, this.data.slice(0, val)); //有效 this.$emit(&quot;update:filter-Data&quot;, this.data.slice(0, val)); MessageRemind消息提醒的MessageRemind使用了element-ui的消息提醒，这里最后的实现比较容易，但是在实现的过程中遇到了一个关于路由监控的坑。 路由监听失效：需要在父路由的组件内才可以监听到子路由的信息。 Notice.vue仅管理员拥有的组件。主要有左边的导航和中间显示部分组成。显示公告列表，增删改查等实现比较容易就没有记录下来。 这里记录一个文章显示的css，超出部分滚动，但不显示滚轮 .article{ height: 100%; overflow-x:hidden; overflow-y: scroll; } // -webkit-scrollbar css3新特性 .article::-webkit-scrollbar { display: none; } 框架 &lt;template&gt; &lt;div class=&quot;notice&quot;&gt; &lt;div class=&quot;nav&quot;&gt; &lt;el-menu default-active=&quot;publish&quot; class=&quot;el-menu-vertical-demo&quot; @select=&quot;handleSelect&quot; &gt; &lt;el-menu-item index=&quot;publish&quot; &gt; &lt;i class=&quot;el-icon-edit-outline&quot;&gt;&lt;/i&gt; &lt;span slot=&quot;title&quot;&gt;发布公告&lt;/span&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;allNotice&quot;&gt; &lt;i class=&quot;el-icon-document&quot;&gt;&lt;/i&gt; &lt;span slot=&quot;title&quot;&gt;所有公告&lt;/span&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;dustbin&quot;&gt; &lt;i class=&quot;el-icon-delete&quot;&gt;&lt;/i&gt; &lt;span slot=&quot;title&quot;&gt;回收站&lt;/span&gt; &lt;/el-menu-item&gt; &lt;/el-menu&gt; &lt;/div&gt; &lt;router-view class=&quot;view&quot;&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; handleSelect(key) { let path=&#39;/notice/&#39;+key; this.$router.push({path:path}) } 富文本tinymce默认显示的是发布公告,选用的是tinymce这款富文本。 学习笔记 项目问题1表单规则验证 &lt;el-form-item label=&quot;学/工号&quot; prop=&quot;captainInformation.studentId&quot; &gt; &lt;el-input v-model.number=&quot;form.captainInformation.studentId&quot; &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; data() { return { form:{ teamName:&quot;&quot;, captainInformation:{ name:&quot;&quot;, studentId:&quot;&quot;, }, }, rules: { teamName: [ { required: true, message: &#39;请输入团队名称&#39;, trigger: &#39;blur&#39; }, { min: 3, max: 10, message: &#39;长度在 3 到 10 个字符&#39;, trigger: &#39;blur&#39; } ], //这个位置注意一定要加引号 &quot;captainInformation.studentId&quot;: [ { required: true, message: &#39;请输入学号&#39;, trigger: &#39;blur&#39; }, {type: &#39;integer&#39;, message: &#39;格式错误&#39;, trigger: &#39;blur&#39;} ], } 问题二过滤器 后台传来的数据只有分数，未评分的分数为-1，这里需要将其显示成状态已完成或未评分，并且可以根据状态筛选数据。 &lt;el-table-column prop=&quot;score&quot; sortable label=&quot;状态&quot; :filters=&quot;tags&quot; :filter-method=&quot;filterTag&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-tag disable-transitions style=&quot;font-size:12px&quot; :type=&quot;stateColor(scope.row.score)&quot;&gt;{{scope.row.score| filterState}}&lt;/el-tag&gt; &lt;/template&gt; &lt;/el-table-column&gt; //js //筛选标签 filterTag(value, row) { if (value === -1) { return row.score === -1; } else { return row.score &gt;= value; } }, //过滤器 filters: { filterState(val) { return val === -1 ? &quot;未评分&quot; : &quot;已完成&quot;; } }, 问题三返回刷新问题从详情返回列表，列表不需要刷新，而从其他页面进入列表，列表需要刷新。首先需要了解两个生命周期： // 数据缓存 beforeRouteEnter(to, from, next) { //如果不是从teamDetail来的界面需要刷新 if (![&quot;teamDetail&quot;].includes(from.name)) { to.meta.isRefresh = true; } next() }, activated() { //需要刷新的界面 if (this.$route.meta.isRefresh) { // 先重置 this.$route.meta.isRefresh = false; //重新获取数据 this.isLoading = true; this.getLoadData(); } }, 后面重复的操作比较多，多为增删查改，重复的东西将不在记录了。有关于vue我不熟悉的知识点，会重新学习了解之后更新博客。]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>软件超市</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件超市项目后台管理界面开发流程2]]></title>
    <url>%2F2020%2F01%2F31%2F%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82%E9%A1%B9%E7%9B%AE%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B2%2F</url>
    <content type="text"><![CDATA[设置权限时动态加载路由 路由分为两类，一类是静态路由（不需要登陆验证），一类是动态路由（需要登陆验证） 当用户登陆后，获取用role（权限），将role和路由表每个页面的需要的权限作比较，生成用户可访问的路由表 调用router.addRoutes(store.getters.addRouters)添加用户可访问的路由。 使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。 permission.js首先新建store/permission.js，用来控制生成的路由表。 //是否有权限访问，role为当前权限 function hasPermission(role, route) { if (route.meta &amp;&amp; route.meta.roles) { //如果该路由的meta存在，并且有要求权限 const roles = route.meta.roles; //如果路由要求的权限有当前权限，返回成功 return roles.includes(role); } else { //如果不存在说明不需要权限 return true; } } const permission ={ state: { //默认路由 routers: constantRouterMap, //添加的路由 addRouters: [] }, mutations: { SET_ROUTERS: (state, routers) =&gt; { //往数组中添加符合条件的路由 state.addRouters = routers; //符合权限的路由变成默认路由可访问。 state.routers = constantRouterMap.concat(routers); } }, actions: { //定义产生路由的方法 async GenerateRoutes({ commit }, { role }) { //返回符合权限的异步路由 const accessedRouters = await asyncRouterMap.filter(route =&gt; hasPermission(role, route) ); commit(&quot;SET_ROUTERS&quot;, accessedRouters); return accessedRouters; } } } export default permission; 这里可以把permission.js看成一个模块，因为它拥有自己的state,mutation,action。所以还需要把permission挂载在vuex里。 export default new Vuex.Store({ modules:{ permission }, state, actions, mutations, getters }); 问题一addRoutes在哪里调用登录后，获取用户的权限信息，然后筛选有权限访问的路由，再调用addRoutes添加路由。这个方法是可行的。但是不可能每次进入应用都需要登录，用户刷新浏览器又要登陆一次。所以addRoutes还是要在全局路由守卫里进行调用。 if(token){ //已经登陆了 if (to.path ===&quot;/login&quot;) next({path:&quot;/&quot;}) // else{ if (!store.getters.role){ //如果没有当前权限信息,role仅getUserInfor后可以获得 //用户登陆之后，根据缓存获取登陆信息 store.dispatch(&quot;getUserInfor&quot;).then(role=&gt;{ //产生符合权限路由的方法 store.dispatch(&quot;GenerateRoutes&quot;, { role }) .then( data =&gt; { // 生成可访问的路由表 router.addRoutes(data); next({ ...to, replace: true }); }) ..... } } } 问题一 next()的使用 首先调用next()时会直接进入to路由，不会再调用beforeEach(),所以刷新页面可能会进入无限循环，调用next(‘xxx’)后会拦截路由使得路由重定向xxx，并再次调用beforeEach()。 如果把replace设置为true，那么导航不会留下history记录，点击浏览器回退按钮不会再回到这个路由。router.addRoutes之后的next()可能会失效，因为可能next()的时候路由并没有完全add完成，next({…to}) 的时候重新指定以下刷新前的路径。 问题二 404页面404路由写在动态路由中，否则可能会有闪屏和路由为空时加载的404页面。原因是：当页面刷新，会导致vue重新实例化，路由也恢复了初始路,addRoutes 还没有添加上路由就开始跳转， 所以找不到路由就跳转到404页面了。 Layout页面Layout作为整个后台管理页面的框架，主要有Header、根据权限生成的Sidebar和中间的显示界面组成。 框架//Layout组件 &lt;div id=&quot;manage&quot;&gt; &lt;Header&gt;&lt;/Header&gt; &lt;div class=&quot;container&quot;&gt; &lt;Sidebar&gt;&lt;/Sidebar&gt; &lt;router-view class=&quot;content&quot; &gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; 通过把一级路由与二级路由的path设置成同一个，来同时加载Header组件、Sidebar组件和中间对应的显示界面 //仅用其中一个举列子 const project ={ path: { path: &quot;/projectManage&quot;, name: &quot;projectManage&quot;, component: Layout }, check: [ { path: &quot;check&quot;, name: &quot;projectCheck&quot;, component: () =&gt; import( /* webpackChunkName: &quot;ProjectCheck&quot; */ &quot;../views/projectManage/components/ProjectCheck&quot; ) }, ], } export const asyncRouterMap = [ { ...project.path, children: [ { path: project.path.path, redirect: &quot;/projectManage/check&quot;, component: () =&gt; import(/* webpackChunkName: &quot;ProjectDeveloper&quot; */ &quot;../views/projectManage/ProjectDeveloper&quot;), children: [...project.check] },] } ] 注意:这里有个简单的重定向问题我晕了好久QAQ 首先是path加/和不加/有什么区别。/xx就是根路径。下面代码去到children是/#/child而不是/#/fa/child。而不以斜杠开头的，都会被当成普通的字符串拼到当前路径的后面。 path: /fa children: { path: /child } 然后这里重新定向之后projectManage/check路由到底算几级路由？通过把redirect注释之后终于弄懂了。这里是因为children控制的是第几个router-view,第一个children控制的是第二个router-view，即使它重定向/projectManage/check,第二个router-view显示的还是ProjectDeveloper组件。 Siderbar导航图标上显示未读消息数量 主要实现是使用element-ui里面的badge组件+父子间传值实现的。这里以导航图标上显示未读消息数量为例子，后续类似操作将不做记录。 新建一个MessageNue.vue记录未处理的消息数量，作为子组件，接收父组件传来的值。这里接收两个值：customClass样式，因为这个组件会重复使用，并且不同消息显示的位置可能不同，所以关于定位的信息要单独接收。menu接收的是显示的哪一个消息。 &lt;template&gt; &lt;span class=&quot;badgebox&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;el-badge :value=&quot;getMsgN(menu)&quot; :style=&quot;customClass&quot; class=&quot;item&quot; :max=&quot;99&quot; :hidden=&quot;!getMsgN(menu)&quot;&gt;&lt;/el-badge&gt; &lt;/span&gt; &lt;/template&gt; &lt;script&gt; export default { name: &quot;MessageNum&quot;, props: { menu: Object, customClass: String }, methods: { getMsgN(menu) { return this.count[menu.path]; } }, computed: { count() { return this.$store.state.msgNum; } } }; &lt;/script&gt; //state.js //需要显示的消息数量 msgNum: { publishExamine: 0, delayExamine: 0, alterExamine: 0, undertakeExamine: 0, projectExamine: 0, porjectRun: 0, projectCheck: 0, projectFinish: 0, projectManage: 0 }, Sidebar.vue 作为父组件，把组件挂载好之后。menu值是传的动态值所以用v-bind:绑定，而customClass是一个静态值所以直接传值就行。 这里有一个命名的坑:props属性支持驼峰命名,不支持连接线命名。HTML特性是不区分大小写的，所以在HTML之中的驼峰写法要变成连接线写法。 &lt;message-num :menu=&quot;{path:router.name}&quot; custom-class=&quot;top:-12px;right:-12px&quot;&gt; &lt;i class=&quot;iconfont&quot; :class=&quot;&#39;icon-&#39;+router.meta.icon&quot;&gt;&lt;/i&gt; &lt;/message-num&gt; Header.vue主要功能有： 1.显示用户名，可退出2.如果身份是开发团队的队长，且同时有几个团队，显示当前团队，并可切换其他团队。3.点击logo的时候，可以操作侧边栏展开 ①下拉框用的是Element-ui的el-dropdown组件,下拉的时候出现退出键。 // @command=&quot;handleCommand&quot;为绑定下拉框点击事件，command为值 &lt;el-dropdown class=&quot;exit&quot; @command=&quot;handleCommand&quot; trigger=&quot;click&quot;&gt; &lt;span class=&quot;el-dropdown-link&quot;&gt; {{ username }} &lt;i class=&quot;el-icon-arrow-down el-icon--right&quot;&gt;&lt;/i&gt; &lt;/span&gt; &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt; &lt;el-dropdown-item command=&quot;exit&quot;&gt;退出&lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/el-dropdown&gt; // 退出登录或者切换用户管理界面 handleCommand(command) { console.log(command); if (command === &quot;exit&quot;) { //退出之后清除 this.exit(); }， exit() { // 退出清除缓存和登录 //登录成功之后重定向到登录页 this.$store.dispatch(&quot;Logout&quot;); } ②做第二个功能的时候，首先团队名称是通过axios获取的，并且刷新的时候还要在。所以应该把数据存在session中，同时要解决数据渲染的问题,采用了在state里面设置get和set的方法。 //state.js get teams() { let vlaue = sessionStorage.getItem(&quot;teams&quot;); return typeof vlaue === &quot;string&quot; ? JSON.parse(vlaue) : []; }, set teams(vlaue) { sessionStorage.setItem(&quot;teams&quot;, JSON.stringify(vlaue)); }, get teamId() { return sessionStorage.getItem(&quot;teamId&quot;); }, set teamId(vlaue) { sessionStorage.setItem(&quot;teamId&quot;, vlaue); }, 这里切换团队之后页面刷新用了上一篇博客提到的provide/inject组合刷新的办法。 ③第三个功能是兄弟Header和Sidebar组件的通讯，因为做这个项目主要是学习为主，所以选择了借助中央事件总线：在外部新建一个utils/eventBus.js文件。 //eventBus.js import Vue from &#39;vue&#39; export default new Vue(); //Header.vue import eventBus from &quot;../../utils/eventBus.js&quot;; extendNav() { //通过eventBus中央事件总线用$emit发送一个showNav事件 eventBus.$emit(&quot;showNav&quot;); } //Sidebar.vue mounted() { //通过eventBus中央事件总线用$on监听组件1中发送的showNav事件，第二个参数为回调函数。 eventBus.$on(&quot;showNav&quot;, this.change); }, 上述是最开始的做法，后面发现更简便的方法。主要是省略了外部的js文件，把总线放在main.js里的vue实例中 new Vue({ data:{ eventBus:new Vue() } }) 兄弟组件调用的时候,用this.$root.eventBus.$on代替eventBus.$on]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>软件超市</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件超市项目后台管理界面开发流程1]]></title>
    <url>%2F2020%2F01%2F29%2F%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82%E9%A1%B9%E7%9B%AE%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[3.3 组件编写3.3.1 Manage.vue 存放目录：src/views/Manage.vue 作用：作为Layout容器 详情：包含了Header组件与Sidebar组件 3.3.2 Login.vue 存放目录：src/views/login/Login 作用：登陆界面 详情：通过前台展示界面进入，进入时选择身份，ID的不同身份权限不一样。 具体实现 需要根据前台显示的页面获取信息： getStudentIdByRequest get请求获取登陆的学号ID getUserId?studentId= 通过登陆的studentId获取userId getRole?userId= 通过userId获取角色权限，通过不用的权限生成不同的导航栏。 getMessageByUserGet?userGet=userId 通过userId获取消息，如果有未读消息，进入管理页面后直接显示消息通知，如果没有未读消息，则显示第一个路由。 权限、登陆时效等相关（重要） 问题一：跨域问题由于vue-cli脚手架工具开发时，由于项目本身启动本地服务是需要占用一个端口的，所以必然会有跨域问题。解决办法：config/index（webpack构建下），更改开发环境下(在dev里配置)的proxyTable。将请求代理到目标域名 proxyTable: { &quot;/v1&quot;:{ target:&quot;http://software.sicau.edu.cn:8080&quot;, changeOrigin: true//是否开启代理 } }, 问题二：axios的cookie问题由于用的是学校的统一认证平台，采用的是cookie，在使用axios的时候，发现http响应头中少了Set-Cookie属性（axios隐藏了这部分）。解决办法：axios.defaults.withCredentials = true。withCredentials属性主要功能是指定跨域的请求是否应该使用证书（如cookie或授权头header） 问题三：vue组件刷新问题。（这个方法在添加删除之中比较好用，最后虽然没有采用但还是把记录下来）用vue-router重新路由到当前页面，页面是不进行刷新的。采用window.reload,或者router.go(0)刷新时，整个浏览器进行了重新加载，闪烁，体验感不好。解决办法：provide/inject组合provide：选项应该是一个对象或返回一个对象的函数。该对象包含可传递其子孙的属性。inject：一个字符串数组，或一个对象，对象的 key 是本地的绑定名 app.vue 中通过provide将父组件中的数据传给子组件 &lt;router-view v-if=&quot;isRouterAlive&quot;&gt;&lt;/router-view&gt; &lt;script&gt; export default { name: &quot;App&quot;, provide() { return { reload: this.reload } }, data() { return { isRouterAlive: true } }, methods: { reload() { this.isRouterAlive = false this.$nextTick( ()=&gt; this.isRouterAlive = true ) } } }; &lt;/script&gt; 在要使用的组件中inject:[‘reload’],调用this.reload()既可实现刷新。 问题4：错误捕获问题由于前端要根据返回的不同错误类型，进行不同的处理，在抛出问题时，不知道用async/await的错误如何捕获。解决办法：try catch只能捕获同步代码，不能捕获异步代码，在async函数内，使用await可以捕获异步代码，这里实际上是异步代码变成了同步代码。 在 async 函数内部使用 try catch 捕获异步错误 promise 内部使用 .catch 方法来捕获 promise 内部代码错误 async getRequest({commit,dispatch}){ try{ let resGetStudentIdByRequest = await getStudentIdByRequest(); if (resGetStudentIdByRequest.status==0){ ... } else throw resGetStudentIdByRequest.msg; }catch(err){ throw {err, msg: &quot;无效登录&quot;, code: 1 } } }, 问题5：token验证 ——————————————————待补充 之前的项目用的是session，偶然见看见一篇关于token的文章。https://blog.csdn.net/mydistance/article/details/84545768 点击进入管理界面时，先根据选择的不同身份，设置不同的不同的角色信息，在进加密。 进行路由拦截 //main.js router.beforeEach((to, from, next) =&gt; { let token = sessionStorage.getItem(&quot;token&quot;); if(token){...} else{ //如果没有token ,如果to.path在白名单中,则免登陆。如果不在白名单中，定向去登陆页面 (whiteList.includes(to.path)) == true ? next(): next(&quot;/login&quot;) } } 登陆时设置token //action.js //设置角色 async setRole({commit,dispatch},roleId){ //给身份加密 setRole(roleId); //设置token setToken(); }, //auth.js const verify = 45416289438485; //给角色权限加密 export const setRole = roleId =&gt; { let token = verify * roleId; sessionStorage.setItem(&quot;xxx&quot;, token); }; //设置登陆token export const setToken = () =&gt; { let token = randomString(32); sessionStorage.setItem(&quot;token&quot;, token); }; //产生随机数 function randomString(len) { len = len || 32; /****默认去掉了容易混淆的字符oOLl,9gq,Vv,Uu,I1****/ const $chars = &quot;ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678&quot;; const maxPos= $chars.length; let pwd = &quot;&quot;; for (let i = 0; i &lt; len; i++) { pwd += $chars.charAt(Math.floor(Math.random() * maxPos)); } return pwd; } 然后为了防止用户直接手动按f5刷新页面，这个时候会重新构建vue实例，而又没有重新登录，所以vuex里面的东西会清空，所以将登录后的数据存放在sessionStroage中，在刷新页面，重新构建vue实例的时候，会有判断。 问题6：button按钮添加回车事件最开始的写法，发现login方法根本没有执行，开始以为是@keyup.enter.native的问题，但是写在封装好的组件中的时候加.native才能监听原生的事件。后面发现是输入框事件，在button上面不起效果。 &lt;el-button @click=&quot;login&quot; @keyup.enter.native=&quot;login&quot; class=&quot;btn&quot; :loading=&quot;btnLoading&quot;&gt;进入管理页面&lt;/el-button&gt; 修改后，用了自定义指令的办法。 &lt;el-button @click=&quot;login&quot; v-enter=&quot;this&quot; class=&quot;btn&quot; :loading=&quot;btnLoading&quot;&gt;进入管理页面&lt;/el-button&gt; directives: { // 按enter键登录 enter(el, { value }) { document.onkeydown = e =&gt; { e = e || window.event; if (e.keyCode === 13) { value.login(); } }; } }, 问题7：封装好外部链接通过新建一个元素a，调用函数时点击a来实现外部跳转 const HOME_URL = &quot;主页&quot;; const LOGIN_URL = &quot;统一认证界面&quot;; //新建a export const goto = url =&gt; { const link = document.createElement(&quot;a&quot;); link.href = url; link.click(); }; goto.home = () =&gt; goto(HOME_URL); goto.login = () =&gt; goto(LOGIN_URL);]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>软件超市</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie、LocalStorage、sessionStorage]]></title>
    <url>%2F2020%2F01%2F29%2FCookie%E3%80%81LocalStorage%E3%80%81sessionStorage%2F</url>
    <content type="text"><![CDATA[主要区别 方法 localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等 setItem存储value sessionStorage.setItem(&quot;key&quot;, &quot;value&quot;); localStorage.setItem(&quot;key&quot;, &quot;value&quot;); getItem获取value let value = sessionStorage.getItem(&quot;key&quot;); let key = localStorage.getItem(&quot;key&quot;); removeItem删除key sessionStorage.removeItem(&quot;key&quot;); localStorage.removeItem(&quot;key&quot;); clear清除所有的key/value sessionStorage.clear(); localStorage.clear(); localStorage和sessionStorage的key和length属性实现遍历 let storage = window.localStorage; for(var i=0, len=storage.length; i&lt;len;i++){ var key = storage.key(i); var value = storage.getItem(key); console.log(key + &quot;=&quot; + value); }]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise]]></title>
    <url>%2F2020%2F01%2F08%2Fpromise%2F</url>
    <content type="text"><![CDATA[这里记录了学习promise的笔记，如果有更深刻的理解会不断更新。 Promise预备知识1.函数对象与实例对象函数对象：将函数作为对象使用实例对象：new函数产生的对象 括号左边是函数，点左边是对象 function Fn(){ //Fn函数 } const fn = new Fn() //这里的Fn是构造函数，fn是实例对象（new返回的，简称对象） Fn.prototype //Fn本身是个函数，但是使用了XX.XXX(使用了.)，把该函数作为对象来使用，所以这里的Fn是函数对象 2.两种类型的回调函数/*-----------同步回调函数--------------*/ const arr = [1,3,5] arr.forEach(item =&gt;{ //遍历回调，同步回调函数，一上来就执行，不会放入队列 console.log(item) }) //forEach是一个函数，回调函数也是一个函数。说明该回调函数是同步回调函数，等完全执行完毕之后才执行最后一个打印语句 console.log(&quot;forEach()执行完毕之后&quot;) //输出 //1，3，5 forEach()执行完毕之后 /*-----------异步回调函数--------------*/ setTimeout(()=&gt;{//异步回调函数，会放入队列中将来执行 console.log(&quot;timeout callback()&quot;) },0) console.log(&quot;setTimeout()之后&quot;) //输出 //setTimeout()之后 timeout callback() 同步回调 理解：立即执行，完全执行完了才结束，不会放入回调队列中例子：数组遍历相关的回调函数 /promise的excutor函数 异步回调 理解：不会立即执行，会放入回调队列中来执行例子：定时器回调 /ajax回调 /promise的成功与失败的回调 3.error处理错误类型 Error:所有错误的父类型子类型(常见的)：ReferenceError: 引入错误，引用的变量不存在TypeError: 数据类型不正确的错误RangeError：数据值不在其所允许的范围内。SyntaxError：语法错误 错误处理 若没有捕获error，后续的代码是不会执行的捕获错误:try{}catch(error){}抛出错误:throw error() //抛出错误，自己定义错误 function something(){ if(Date.now()%2 ===1){ console.log(&quot;当前时间为奇数,可以执行任务&quot;) }else{ //自己定义时间为偶数时为错误, 抛出的错误由调用来处理比如：打印，显示消息框等 // throw new Error(里面为传出的message) 固定格式 throw new Error(&#39;当前时间为偶数，无法执行任务&#39;) } try{ something{} } catch(error){ //error下面两个属性message与stack console.log(error.message)//错误相关信息 console.log(error.stack)//函数调用栈记录信息 } } Promise的理解和使用Promise是JS中进行异步编程的新的解决方案（旧的是纯回调的方式）从语法来说：Promise是一个构造函数从功能上说：Promise对象用来封装一个异步操作并可以获取其结果 Promise的状态 pending变为resolved（成功） pending变为rejected (失败) 说明：只有这两种变化，且一个Promise对象只能改变一次。无论是成功还是失败，都会有一个结果数据。成功的结果数据一般称为value，失败的结果数据一般称为reason //1.创建一个新的promise对象,里面传一个回调函数 const p = new Promise((resolve,reject)=&gt;{ //执行器函数 同步回调 //2.执行异步操作 setTimeout(()=&gt;{ const time = Date.now() //如果当前时间是偶数代表成功，否则代表失败 if(time%2 ==0){ //3.1 如果成功了，调用resolve(value) resolve(&quot;成功的数据,time=&quot;+time) }else{ //3.2 如果失败了，调用reject（reason） reject(&quot;成功的数据,time=&quot;+time) } },1000); }) p.then( value =&gt;{ //接收得到成功的value数据 onResolved console.log(&quot;成功的回调&quot;,value) }, reason =&gt; { //接收得到失败的reason数据 onRejected console.log(&quot;失败的回调&quot;,reason) } ) //输出 成功的回调 成功的数据,time=XXXX 优势 指令回调函数的方式更加灵活：旧的，必须在启动异步任务前指定;promise：启动异步任务 =&gt; 返回peomise对象 =&gt; 给promise对象绑定回调函数(甚至可以在异步执行之后才指定他的回调函数) 支持链式调用，可以解决回调地狱问题（回调函数嵌套调用，不便于阅读/不便于异常）。 简便写法，Promise还有一些对象方法，这里就不进行记录了。 const p1 = new Promise((resolve,reject)=&gt;{ resolve(1) }) const p2 = Promise.reject(2) p2.catch(reason=&gt;{console.log(reason)}) 几个关键问题 1.如何改变promise的状态？（1）resolve(value):如果当前是pending就会变为resolved（2）reject（reason）：如果当前是pending就会变为rejected（3）抛出异常：如果当前是pending就会被成rejected throw new Error(&quot;出错了&quot;) reason值是你抛出的东西 2.一个promise指定多个成功/失败的回调函数，都会调用吗？当promise改变为对应状态时会调用 3.改变promise状态和指定回调函数谁先执行。 new Promise((resolve,reject)=&gt;{ setTimeout(()&gt;{ resolve(1)//后改变的状态，同时指定数据，异步执行回调函数 },1000); }).then(//先指定回调函数，保存当前指定的回调函数 value=&gt;{},reason=&gt;{} ) /*---------先改状态后指定回调函数------------*/ new Promise((resolve,reject)=&gt;{ //同步回调 resolve(1)//先改变的状态，同时指定数据 ); }).then(//异步回调 value=&gt;{},reason=&gt;{}//后指定回调函数，异步执行回调函数 ) 4.promise.then()返回的新的promise的结果状态由什么决定 new Promise((resolve,reject)=&gt;{ //1.resolve(1) //2.reject(1) ); }).then( value=&gt;{ console.log(&#39;onResolved1()&#39;,value) //3.return 2 //4.return Promise.resolve(3) //5.return Promise.reject(4) //6 throw 5 },reason=&gt;{ console.log(&#39;onRejected1()&#39;,reason) } ).then( value=&gt;{ console.log(&#39;onResolved2()&#39;,value) },reason=&gt;{ console.log(&#39;onRejected2()&#39;,reason) } ) //1.输出onResolved1() 1 onResolved2() undefined //2.输出onRejected1() 1 onResolved2() undefined （ 其余情况结合1.3 1.4 1.5 1.6 ） //1.3 输出onResolved1() 1 onResolved2() 2 //1.4 输出onResolved1() 1 onResolved2() 3 //1.5 输出onResolved1() 1 onRejected2() 4 //1.6 输出onResolved1() 1 onRejected2() 5 promise异常传透和中止 当使用promise的then链式调用时，可以在最后指定失败的回调，因为没有处理异常相当于 reason =&gt; {throw reason}。会一层一层往下寻找异常处理（知道找到）。 当使用promise的then链式调用时，若想中断promise链，可一返回new Promise(()=&gt;{})返回一个处于pending的promise。 自定义promise链接：https://github.com/biubiuins/promise-/tree/master async与await1.async 函数async是’异步’的简写，用于申明这个函数是异步的。函数的返回值为Promise对象，promise对象的结果由async函数执行的返回值决定。 2.await 表达式await相当于then的语法糖。当await后面的表达式为promise，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，得到的结果就是promise成功的value。如果右侧表达不是promise，得到的结果就是它本身。 注意： await必须放在async函数里面 await只能得到成功的结果，失败的结果需用try-catch try catch只能捕获同步代码，不能捕获异步代码，在async函数内，使用await可以捕获异步代码，这里实际上是异步代码变成了同步代码。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB学习笔记]]></title>
    <url>%2F2019%2F08%2F01%2FMongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[MongoDB是非关系型数据库文档数据库，存的类似JSON的结构。 启动服务器，db存放数据库，我创建在D盘的。 mongod --dbpath D:\mongoDB\data\db /*-----默认端口号27017-----*/ mongod --dbpath D:\mongoDB\data\db --port XXX 注意两个概念： 数据库的服务器。服务器用来保存数据，mongod启动服务器 数据库的客户端。客户端用来操作服务器，对数据惊醒增删改查的操作，mongo启动 基本概念数据库：存放集合。集合：类似数组，在集合中存放文档。文档：文档是数据库中的最小单位，存储和操作内容都是文档。 基本操作use 数据库名 //进入数据库 增加插入一个放对象db..insert({数据})//db..insertOne()插入多个放数组db..insert([{},{}]) //db ..insertMang() //插入多条可以配合使用for循环 var arr =[]; for (var i=1;i&lt;=20000;i++){ arr.push({num:i}); } db.numbers.insert(arr) 查询db..find({条件})，为空查询所有。 /*----名字为张三并且年龄为28的文档,返回的是一个数组--*/ db.stus.find({name:&quot;张三&quot;,age:28}) /*----查询符合条件的第一个集合，返回的是一个对象--*/ db.stus.findOne({age:28}) /*-----返回符合条件的文档数量----*/ db.&lt;collection&gt;.find().count() MongoDB支持通过内嵌文档的属性进行查询，通过点（.）连接。但是此属性名必须是用引号。 hobby:{movies:[111,222],XXX} //查找的是hobby里面的moovies里面的值有111 db.users.find(‘hobby.movies’:&#39;111&#39;) 修改db..update(查询条件，新对象,{修改的配置选项，可选})。update默认会使用新对象来替换旧对象。所以不常用。默认情况下只会修改一个 ，实际上既可修改单个，也可修改多个。db..updateMany()。 修改多条db..updateOne()。 修改单条db.collection.replaceOne()。替换单条 常与$set结合使用来修改文档中的指定属性，没有的属性名会自动创建。unset可以删除响应属性。 db.stus.update({name:&quot;李四&quot;},{$set:{gender:&quot;女&quot;}，{add:&quot;哈哈哈&quot;}}) //若值为一个数组,$push往数组中添加。不考虑是否重复 //$addToSet 向数组中添加一个新元素。 重复的就不会添加。 db.stus.update({name:&quot;李四&quot;},{$push:{hobby.movies’:&#39;333&#39;}}) 删除db.collection.remove() 删除符合条件的所有文档，第二个参数可选：删除配置（比如只删除一个）。必须传参，但如果传递空对象，则所有文档都删除（清空集合，性能太差）db.collection.deleteMany()db.collection.deleteOne()db.collection.drop() 删除集合db.dropDatabase()删除数据库 一般数据是不会删除的，而是在数据中添加一个字段，表示是否删除]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js常用字符串操作方法总结]]></title>
    <url>%2F2019%2F07%2F16%2Fjs%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[终于忙完期末了，考研复习也慢慢走上正轨，要抽出更多的时间把以前学的东西总结下来，再在项目中实践，重新学习更深的内容。24小时完全不够用QAQ。 substring(star,stop)/slice（star,stop）最常用的就是对后台传过来的字符串进行截取处理 语法：stringObject.substring(start,stop) start 必须，并且非负整数 stop 可选，并且非负整数。如果省略，一直截取到字符串的结尾 返回一个新的字符串，包含了start处的字符，但不包括stop处的字符 语法：stringObject.slice(start,end) start 截取的片段的起始下标，如果为负数，从后往前截取（-1 指字符串的最后一个字符） end 截取的结尾的下标 返回一个新的字符串，包含了start处的字符，但不包括end处的字符 arrayObject.slice(start,end)与stringObject.slice(start,end)相似用法。注意array.splice与slice的区别在于splice方法会改变原数组并且可以向原数组中添加元素，如果有删除元素则返回是含有删除的元素的数组。 String.split()/Array.join()语法: stringObject.split(separator,howmany) 把一个字符串分割成字符串数组 separator 必须。字符或正则表达式，从该从该参数指定的地方分割 stringObject。 howmany 可选。该参数可指定返回的数组的最大长度。 返回一个字符串数组，不包括separator自身 语法： arrayObject.join(separator) 数组中的所有元素放入一个字符串。 separator 数组中的元素形成字符串时连接的符号，默认逗号。 如果把空字符串 (“”) 用作 separator，那么 stringObject 中的每个字符之间都会被分割 返回一个字符串数组 String.concat()/Array.concat()字符串的concat方法其实并不常用，连接两个字符串的时候我们常常用+来代替。这里主要是记录几个数组的连接方法。 语法:arrayObject.concat(arrayX,arrayX,……,arrayX) 添加的是数组的元素不是添加一个数组 返回一个新数组，不改变原数组 string.replace(regexp/substr,replacement) 第一个参数可以使RegExp对象或者一个字符串，第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个字符串。如果想替换所有的字符串，则必须使用正则表达式。 默认只进行第一次匹配操作的替换，想要全局替换，需要置上正则全局标识g ‘\s”是转移符号用以匹配任何空白字符，包括空格、制表符、换页符等等， string.search(regexp)/string.indexOf(searchvalue,fromindex)语法 string.indexOf(searchvalue,fromindex) searchvalue，规定检索的字符串值 fromindex 可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。 返回的检索的字符串第一次出现的位置，如果没有出现，返回-1 语法 string.search(regexp) regexp 该参数可以是需要在 stringObject 中检索的子串，也可以是需要检索的 RegExp 对象。 要执行忽略大小写的检索，追加标志 i。 返回值：stringObject 中第一个与 regexp 相匹配的子串的起始位置。 search() 方法不执行全局匹配，它将忽略标志 g。它同时忽略 regexp 的 lastIndex 属性， 语法 stringObject.match(searchvalue) stringObject.match(regexp) 返回指定的值 非全局下返回的数组包含index，input，全局模式下只返回匹配结果，没有index，input等，只有结果。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F07%2F15%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[基本语法修饰符 修饰符 描述 i 执行对大小写不敏感的匹配。 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 m 执行多行匹配。 元字符 方括号 量词 js里面的正则只有前瞻，头部的（后），尾部的（前），所以前瞻就是后面紧跟着的 匹配有贪婪模式（尽可能多的匹配），非贪婪模式（尽可能少的匹配），默认为贪婪模式，非贪婪模式需要在量词后面加？ 常用正则表达]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js遍历方法总结]]></title>
    <url>%2F2019%2F07%2F04%2Fjs%E7%9A%84%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[复习之余，把常用的遍历方法总结，方便使用的时候查看。 数组的遍历语法中有thisValue参数的，可以接收第二个参数，用来绑定回调函数内部的this变量，将回调函数内部的this对象，指向第二个参数，间接操作这个参数（一般是数组）。以map为例子 var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]; [1, 2].map(function (e) { return this[e]; }, arr) // [&#39;b&#39;, &#39;c&#39;] forEach()语法: array.forEach(function(currentValue, index, arr), thisValue) 调用数组的每个元素，并将元素传递给回调函数。 没有返回一个新数组。不能中断，对空数组是不会执行回调函数。 map()语法: array.map(function(currentValue,index,arr), thisValue) 按照原始数组元素顺序依次处理元素，结果放在一个新数组里返回。返回一个新数组，不会改变原始数组 /*------从接口得到数据------*/ const users=res.items.map(item =&gt; ({ url: item.html_url, img: item.avatar_url, name: item.login, }) ); filter()语法：array.filter(function(currentValue,index,arr), thisValue) 创建一个新的数组，指定数组中符合条件的放入新数组。返回一个新数组，按照约定条件筛选数组元素时比较常用 /*-----去重问题----*/ var arr = [1, 2, 2, 3, 4, 5, 5, 6, 7, 7,8,8,0,8,6,3,4,56,2]; var arr2 = arr.filter((x, index,self)=&gt;self.indexOf(x)===index) console.log(arr2); //[1, 2, 3, 4, 5, 6, 7, 8, 0, 56] every()/some()语法: array.every(function(currentValue,index,arr), thisValue) 对整个数组进行检查，如有一个元素满足，整个表达式返回false，且其余元素不检查。否则返回true。 不会改变原数组 语法:array.some(function(currentValue,index,arr),thisValue) 对整个数组进行检查，如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。反之返回false。 不会改变原数组 这两个方法在实际开发中，大有可用之处。比如在判定用户是否勾选了不可操作的数据，或者是否勾选了一条可以操作的数据可以使用这两个方法遍历循环数组。 reduce()/reduceRight()语法:arr.reduce(callback,[initialValue]) callback （执行数组中每个值的函数，包含四个参数） previousValue 必选。上一次调用回调返回的值，或者是提供的初始值（initialValue） currentValue 必选。数组中当前被处理的元素 index 可选。当前元素在数组中的索引。 arr 可选。当前元素所属的数组对象。 initialValue （作为第一次调用 callback 的第一个参数。） 将数组元素做“叠加”处理， 返回一个值。 reduce方向从左向右，reduceRight方向从右向左 var arr = [1, 2, 3, 4]; var sum = arr.reduce(function(prev, cur, index, arr) { console.log(prev, cur, index); return prev + cur; }) console.log(arr, sum); /*-----打印结果---*/ 1 2 1 3 3 2 6 4 3 [1, 2, 3, 4] 10 index是从1开始的，第一次的prev的值是数组的第一个值。数组长度是4，但是reduce函数循环3次。 var arr = [1, 2, 3, 4]; var sum = arr.reduce(function(prev, cur, index, arr) { console.log(prev, cur, index); return prev + cur; }，0) //注意这里设置了初始值 console.log(arr, sum); /*----打印结果----*/ 0 1 0 1 2 1 3 3 2 6 4 3 [1, 2, 3, 4] 10 这个例子index是从0开始的，第一次的prev的值是我们设置的初始值0，数组长度是4，reduce函数循环4次。 如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始 对空数组来说，不设置初始值会报错，设置了初始值不会报错，所以一般来说我们提供初始值通常更安全。 使用场景也很多，具体可以看 参考文档 对象 Object.keys() 返回一个由一个给定对象的自身可枚举属性组成的数组 Object.getOwnPropertyNames() 返回一个数组,包含对象自身的所有属性(不含Symbol属性,但是包括不可枚举属性). for in 循环遍历对象自身的和继承的可枚举属性(不含Symbol属性). for of 主要来遍历可迭代的对象（包括Array, Map, Set, arguments等），它主要用来获取对象的属性值，而for..in主要获取对象的属性名。 总结: for in遍历数组的下标类型不一样 ：for in为String，for为Number for in不适合遍历数组 对不存在项的处理：for in不存在的项不被枚举出来；for全部枚举出 遍历对象可通过hasOwnProperty()过滤掉原型里面的属性 for of输出数组中包括不存在的值在内的所有值]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[keep-alive]]></title>
    <url>%2F2019%2F06%2F29%2Fkeep-alive%2F</url>
    <content type="text"><![CDATA[&lt;keep-alive&gt;能在组件切换的过程中将状态保留在内存中，防止重复渲染DOM。 设置了keepAlive缓存的组件： 第一次进入：beforeRouterEnter -&gt;created-&gt;…-&gt;activated-&gt;…-&gt;deactivated 后续进入时：beforeRouterEnter -&gt;activated-&gt;deactivated activated和deactivated仅在keepAlive缓存的组件里被激活只有第一次进入该组件时，才会走created钩子，而需要缓存的组件中activated是每次都会走的钩子函数。 prop: include: 字符串或正则表达式。只有匹配的组件会被缓存。 exclude: 字符串或正则表达式。任何匹配的组件都不会被缓存。 在2.1.0版本Vue中 常见用法： // 组件 export default { name: &#39;test-keep-alive&#39;, data () { return { includedComponents: &quot;test-keep-alive&quot; } } } &lt;keep-alive include=&quot;test-keep-alive&quot;&gt; &lt;!-- 将缓存name为test-keep-alive的组件 --&gt; &lt;component&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;keep-alive include=&quot;a,b&quot;&gt; &lt;!-- 将缓存name为a或者b的组件，结合动态组件使用 --&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;!-- 使用正则表达式，需使用v-bind --&gt; &lt;keep-alive :include=&quot;/a|b/&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;!-- 动态判断 --&gt; &lt;keep-alive :include=&quot;includedComponents&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;keep-alive exclude=&quot;test-keep-alive&quot;&gt; &lt;!-- 将不缓存name为test-keep-alive的组件 --&gt; &lt;component&gt;&lt;/component&gt; &lt;/keep-alive&gt;]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件超市-返回刷新问题]]></title>
    <url>%2F2019%2F06%2F28%2F%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82-%E8%BF%94%E5%9B%9E%2F</url>
    <content type="text"><![CDATA[在对项目进行优化的时候，发现返回上一页的函数很多组件都会使用，于是打算把这个函数抽离出来。 在此之前需要先解决首页进入列表页面刷新，而详情页返回列表页面不刷新的问题的问题 方法一：keep-alive与vue-router配合使用实现在定义了两个字段 keepAlive:true 标识是否使用keep-alive组件字段,ifDoFresh:false标识是否刷新数据字符 /*------router/index-----*/ { path: &#39;/project&#39;, name:&#39;项目列表&#39; component:resolve =&gt; require([&quot;@/pages/Project/Project&quot;],resolve), meta: { keepAlive:true, ifDoFresh:false, showNav: true } }, 在根组件中根据keepAlive 字符判断是否使用keep-alive组件 /*------app.vue----*/ &lt;div class=&quot;main&quot;&gt; &lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;/&gt; &lt;/keep-alive&gt; &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;/&gt; &lt;/div&gt; 在目标列表页的beforeRouteEnter判断从哪个页面进入的，根据需求更改ifDoFresh变量。这里与activated联合用。 beforeRouteEnter(to,from,next){ //需要刷新的页面 if (from.name!=&quot;团队详情&quot;) { to.meta.ifDoFresh = true; } next() }, activated(){ if (this.$route.meta.ifDoFresh){ // 先重置 this.selected=0 this.$route.meta.ifDoFresh=false this.$store.dispatch(&#39;getTeam&#39;,{teamId:0}) } } 按逻辑来说这样就可以了，但是有个的问题出现了！！！！ 返回只显示一个团队了！！好气啊，不断调试中发现我团队详情的团队信息居然和我列表的团队信息存储在同一个变量里！！！！所以点进详情页后，改变了team，而keep-alive缓存的是team里的数据。我是白痴吗？？？？ 还有一个问题就是从列表到首页，在从首页到列表页，分页的缓存仍然存在。 解决办法：在分页器组件内提前判断（因为使用分页器组件时并没有传当前页码） activated(){ if (this.$route.meta.ifDoFresh) { this.currentPage = 1 } }, 方法二：keep-alive标签内部添加 keep-alive的总结]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>软件超市</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件超市-改变v-html内容的图片样式]]></title>
    <url>%2F2019%2F06%2F26%2F%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82-%E9%97%AE%E9%A2%98v-if%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在通过v-html把后台传过来的内容渲染到页面之后，发现后台传来的图片是限制了宽和高的。 通过查资料发现，这里解析是把v-html传来的数据作为了一个新的组件，所以在scoped下的style里面设置样式不起作用。那么根据原理，或许可以把scoped直接去掉，但是为了防止组件之间的样式污染，使用了其他办法。 方法一 &gt;&gt;&gt;(深度作用选择器) 或者 有些sass类的预处理器无法正确解析可以使用 /deep/ /*----html----*/ &lt;div class=&quot;announcement_img&quot; v-html=&quot;announcement.content&quot;&gt;&lt;/div&gt; /*----style----*/ .announcement_img&gt;&gt;&gt;img{ width: 100%; display: block; height: auto; } 方法二 updated周期函数中，js动态配置样式。 首先需要清楚updated周期函数在什么时候起作用，①data里面需要有该数据变量如arr ②在页面重新渲染arr完成后才进入updated。更深入的会在以后学习。 updated:function(){ console.log(&quot;1==我会先执行&quot;); this.$nextTick(function(){ //在下次 DOM 更新循环结束之后执行这个回调。在修改数据之后立即使用这个方法，获取更新后的DOM. console.log(&quot;3==我只能等页面渲染完了才会立即执行&quot;); }) console.log(&quot;2==我虽然在最后但会比$nextTick先执行&quot;) } 如果后期发现更好的或者更多的办法会重新更新。]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>软件超市</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css总结]]></title>
    <url>%2F2019%2F05%2F18%2Fcss%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在学习的过程中，对css有了更深一步的了解，把遇见过的问题、经常使用到的样式做一个总结。 清除默认样式http://yui.yahooapis.com/3.18.1/build/cssreset/cssreset-min.css 清除浮动 方法一 给受影响的盒子添加clear属性，添加了clear的属性不可以添加margin-top 方法二 浮动元素::after{ content:&quot;&quot;; display:block; height:0; visibility:hidden; clear:both } 浮动元素{ *zoom:1;//兼容IE6 } 盒子的问题 在默认布局的垂直方向上，外边距有合并现象(BFC块级，水平方向也可以，但是块级都是占一行的，而浮动成水平的 BFC的区域不会与float box重叠) 嵌套盒子时，里面的盒子设置margin-top时，父盒子一起被顶下来。 解决办法：父盒子添加border，或者overflow：hidden 图片的问题 自适应图片 max-width:100%; height:auto; display:block 设置图片img的width和height的时候，指定其中一个另外一个自动算出来 当图片宽度大于父元素宽度时，居中：父元素text-align：center,子元素：margin：0，-100% 居中浮动之后的高宽不设定则有内容撑开 居中元素有宽度 .center { width: 960px; margin-left: auto; margin-right: auto; } margin:0 auto 使用场景块级元素：给定要居中的块级元素的宽度行内元素： ①设置display:block。 ②给定要居中的行内元素的宽度。（行内元素设置成块级元素后可以对其宽高进行设置） 所有元素也可以通过对父元素设置 text-align：center；的方式来实现居中。(而对于块元素来说，对要居中的元素自身进行设置text-align:center也能实现居中——而无需对其父元素进行设置) 。 浮动、绝对定位、固定定位的盒子失效。 脱离文档流元素的水平垂直 margin:auto或者按圆点定位定在正中间，margin设置成负的宽高的一般 法二： ``` div{ width: 300px; height: 300px; position: relative; border: 1px solid #465468; } img{ position: absolute; margin: auto; top: 0; left: 0; right: 0; bottom: 0; } ``` 指定宽高元素水平居中 还可以定位到50% 50% 改变margin-left/margin-top为元素的一半定位（元素加padding，可以结合box-sizing） #test{ position:absolute; left:0; right:0; bottom:0; top:0 margin:auto; width:100px height:100px } 图片的垂直居中 //img的外部包含元素 如div div{ text-align:center; } div:after{ content:&quot;&quot;; display:inline-block; height:100% vertical-align:middle; } img{ vertical-align:middle } 其余 超出省略号 盒子不可以仅由内容撑开的时候 white-space:nowrap //不换行 overflow：hidden//超出部分截掉 text-overflow:ellipsis //省略号 禁止滚动条 html,body{ height:100% overflow:hidden }]]></content>
      <tags>
        <tag>css</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown]]></title>
    <url>%2F2019%2F05%2F15%2Fmarkdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[写博客的时候有些不常用的语法会有遗漏，今天重新学习markdown常用语法并把记录下来。 综述 兼容HTML。不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。 用于瞄点测试 基本语法标题方法一： ``` # 第一级标题 `&lt;h1&gt;` ## 第二级标题 `&lt;h2&gt;` ### 第三级标题 `&lt;h3&gt;` #### 第二四级标题 `&lt;h4&gt;` ##### 第五级标题 `&lt;h5&gt;` ###### 第六级标题 `&lt;h6&gt;` ``` 方法二： 任何数量的 = 和 - 都可以有效果。 ``` 一级标题 = 二级标题 - ``` 字体如果* 和 _ 两边都有空白的话，它们就只会被当成普通的符号如果要在文字前后直接插入普通的星号或底线，可以用反斜线。 斜体 *内容*或者_内容_ （em）加粗 **内容**或者__内容__ （strong）倾斜加粗 ***内容***删除线 ~~内容~~ 链接行内式 ``` [我的博客](https://biubiuins.github.io/) 自动生成连接 &lt;https://biubiuins.github.io/&gt; ``` 效果：我的博客自动生成连接 https://biubiuins.github.io/ 添加图片形式和链接类似。 ``` 格式：![图片描述](url) ![GitHub set up](http://zh.mweb.im/asset/img/set-up-git.gif) ``` 效果： 分割线可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。 代码块 只要简单地缩进 4 个空格或是 1 个制表符就可以。 需要和普通段落之间存在空行！ `内容` 多行代码块与语法高亮：在需要高亮的代码块的前一行及后一行使用三个单反引号`包裹，就可以了。 代码块中包含html代码。在代码区块里面， &amp; 、&lt; 和 > 会自动转成 HTML 实体 引用 在被引用的文本前加上&gt;符号，以及一个空格就可以了，如果只输入了一个&gt;符号会产生一个空白的引用。 引用可以嵌套 引用的区块内也可以使用其他的Markdown 语法 列表符号后面一定要有一个空格，起到缩进的作用。还需要注意的是在使用列表时，只要是数字后面加上英文的点，就会无意间产生列表，比如2017.12.30 这时候想表达的是日期，有些软件把它被误认为是列表。解决方式：在每个点前面加上\就可以了。 无序列表使用 *，+，- 表示无序列表。 有序列表使用数字和一个英文句点表示有序列表。 表格姓名|分数 -|- 张三|50 李四|80 效果： 姓名 分数 张三 50 李四 80 表格对齐方式：我们可以指定表格单元格的对齐方式，冒号在左边表示左对齐，右边表示有对齐，两边都有表示居中。 姓名|分数 :-|-: 张三|50 李四|80 效果： 姓名 分数 张三 50 李四 80 反斜杠Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号 常用技巧换行方法1: 连续两个以上空格+回车方法2：使用html语言换行标签 其他特殊字符unicode字符编码 内容目录在段落中填写 [TOC] 以显示全文内容的目录结构，需要独占一行才能生效。 字体样式Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3。 &lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt; &lt;font color=gray size=5&gt;color=gray&lt;/font&gt; &lt;font color=#0099ff size=5 face=&quot;黑体&quot;&gt;color=#0099ff size=5 face=&quot;黑体&quot;&lt;/font&gt; 背景色需要借助 table, tr, td 等表格标签的 bgcolor 属性来实现背景色的功能。 &lt;table&gt;&lt;tr&gt;&lt;td bgcolor=pink&gt;背景色是：pink&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 效果： 背景色是：pink 瞄点自定义瞄点 标签形式的锚点目标的id特性值中是不能含有中文字符； //建立一个跳转链接 [说明文字](#jump) //需要跳转到的位置 &lt;span id = &quot;jump&quot;&gt;跳转到的位置&lt;/span&gt; 效果：瞄点 Markdown会自动给每一个h1~h6标题生成一个锚，其id就是标题内容。如表格]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[less学习笔记]]></title>
    <url>%2F2019%2F05%2F13%2Fless%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[less 参考文章:https://segmentfault.com/a/1190000012360995 less属于css的一种预处理器（处理在浏览器运行前）,作为css的扩展，是一种动态样式语言。 注释 //开头的注释，不会被编译到css文件中，以/ /注释的内容会被编译到css文件 变量 以@开头定义变量，使用是直接 @定义的名称 变量名必须使用大括号包裹 声明变量（类比于写好的css引用）类似于混合方法 结构: @name: { 属性: 值 ;}; 使用：@name(); 使用@来申明一个变量: @pink:pink //不要添加引号 作为普通属性值只是来使用：直接使用@pink 作为选择器和属性名: @{selector的值}的形式（不常用） 作为URL：@{url} （@images:’../img’ 注意要加引号） 变量的延迟加载（一个块级域解析完再加载变量） /* Less */ @color: #999; @bgColor: skyblue;//不要添加引号 @width: 50%; #wrap { color: @color; width: @width; } /* 选择器变量 */ @mySelector: #wrap; @Wrap: wrap; @{mySelector}{ //变量名 必须使用大括号包裹 color: #999; width: 50%; } .@{Wrap}{ color:#ccc; } #@{Wrap}{ color:#666; } /* url 变量*/ @images: &quot;../img&quot;;//需要加引号 body { background: url(&quot;@{images}/dog.png&quot;);//变量名 必须使用大括号包裹 } /* 声明变量 */ @background: {background:red;}; #main{ @background(); } @Rules:{ width: 200px; height: 200px; border: solid 1px red; }; #con{ @Rules(); } /* 生成的 CSS */ #main{ background:red; } #con{ width: 200px; height: 200px; border: solid 1px red; } 变量的运算注意点： 加减法时，以第一个数据的单位为基准 乘除法时，注意单位一定要统一 less嵌套规则和html结构相似，层层嵌套&amp;代表的上一层选择器的名字 /* Less */ #header{ &amp;:after{ content:&quot;Less is more!&quot;; } .title{ font-weight:bold; } &amp;_content{//理解方式：直接把 &amp; 替换成 #header margin:20px; } } /* 生成的 CSS */ #header::after{ content:&quot;Less is more!&quot;; } #header .title{ //嵌套了 font-weight:bold; } #header_content{//没有嵌套！ margin:20px; } less中的混合 混合：将一系列的规则集引入另一个规则集中 普通混合(编译到原生css中) 不带输出的混合(加括号) 混合使用.或 #的形式来定义；声明变量使用的是@来定义，@变量名（）来使用 普通混合 最好写成后面带（）的形式 /* Less */ .card { // 等价于 .card() background: #f6f6f6; -webkit-box-shadow: 0 1px 2px rgba(151, 151, 151, .58); box-shadow: 0 1px 2px rgba(151, 151, 151, .58); } #wrap{ .card;//等价于.card(); } //其中 .card 与 .card() 是等价的。 带参数的混合注意点： Less 可以使用默认参数，如果 没有传参数，那么将使用默认参数。冒号后面的是默认值2. @arguments代表全部参数，实参列表 传的参数中必须带单位 /* Less */ .border(@a:10px,@b:50px,@c:30px,@color:#000){ border:solid 1px @color; box-shadow: @arguments;//指代的是 全部参数 } #main{ .border(0px,5px,30px,red);//必须带着单位 } #wrap{ .border(0px); } /* 命名参数 */ #wrap{ .border(@color:black); } #content{ .border;//等价于 .border() } /* 生成的 CSS */ #main{ border:solid 1px red; box-shadow:0px,5px,30px,red; } #wrap{ border:solid 1px #000; box-shadow: 0px 50px 30px #000; } #content{ border:solid 1px #000; box-shadow: 10px 50px 30px #000; } 匹配模式注意点： 第一个参数 left 要会找到方法中匹配程度最高的，如果匹配程度相同，将全部选择，并存在着样式覆盖替换。 如果匹配的参数 是变量， @_表示的会被调用任意标志的 。 /* Less */ .triangle(top,@width:20px,@color:#000){ border-color:transparent transparent @color transparent ; } .triangle(right,@width:20px,@color:#000){ border-color:transparent @color transparent transparent ; } .triangle(bottom,@width:20px,@color:#000){ border-color:@color transparent transparent transparent ; } .triangle(left,@width:20px,@color:#000){ border-color:transparent transparent transparent @color; } .triangle(@_,@width:20px,@color:#000){ border-style: solid; border-width: @width; } #main{ .triangle(left, 50px, #999) } /* 生成的 CSS */ #main{ border-color:transparent transparent transparent #999; border-style: solid; border-width: 50px; } 方法的命名规范注意点： 在 CSS 中&gt; 选择器，选择的是 儿子元素，就是 必须与父元素 有直接血源的元素。 在引入命令空间时，如使用 &gt; 选择器，父元素不能加 括号。 不得单独使用命名空间的方法 必须先引入命名空间，才能使用 其中方法。 子方法 可以使用上一层传进来的方法 /* Less */ #card(){ background: #723232; .d(@w:300px){ width: @w; #a(@h:300px){ height: @h;//可以使用上一层传进来的方法 width: @w; } } } #wrap{ #card &gt; .d &gt; #a(100px); // 父元素不能加 括号 } #main{ #card .d(); } #con{ //不得单独使用命名空间的方法 //.d() 如果前面没有引入命名空间 #card ，将会报错 #card; // 等价于 #card(); .d(20px); //必须先引入 #card } /* 生成的 CSS */ #wrap{ height:100px; width:300px; } #main{ width:300px; } #con{ width:20px; } less的继承extend 是 Less 的一个伪类。它可继承 所匹配声明中的全部样式。extend（这里放规则）是一个函数 /* Less */ //规则的定义，没有参数 .animation{ transition: all .3s ease-out; .hide{ transform:scale(0); } } #main{ &amp;:extend(.animation); } #con{ &amp;:extend(.animation .hide); } /* 生成后的 CSS */ .animation,#main{ transition: all .3s ease-out; } .animation .hide , #con{ transform:scale(0); } all全局搜索替换使用选择器匹配到的 全部声明。 /* Less */ #main{ width: 200px; } #main { &amp;:after { content:&quot;Less is good!&quot;; } } #wrap:extend(#main all) {} /* 生成的 CSS */ #main,#wrap{ width: 200px; } #main:after, #wrap:after { content: &quot;Less is good!&quot;; } 从表面 看来，extend 与 方法 最大的差别，就是 extend 是同个选择器共用同一个声明，而 方法 是使用自己的声明。 ~”XXXXX” less之中避免编译，让浏览器编译]]></content>
      <tags>
        <tag>css</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[element-ui总结]]></title>
    <url>%2F2019%2F04%2F19%2Felement-ui%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在一次项目中用到了element-ui框架，对在使用过程中遇见的问题进行总结（持续更新）。 表单1.数据为二级对象时数据为二级对象时，验证的数据要用字符串形式。 rules:{ &quot;captainInformation.name&quot;: [ { required: true, message: &#39;请输入姓名&#39;, trigger: &#39;blur&#39; }, ], } 2.动态添加的数据动态添加的输入框或表单绑定数据时注意 :prop=&quot;&#39;v-for绑定的数组.&#39; + index + &#39;.v-model绑定的变量&#39;&quot; 我是直接把验证写在标签里面的 &lt;el-form-item label=&quot;姓名&quot; :prop=&quot;&#39;memberInformation.&#39;+index+&#39;.name&#39;&quot; :rules=&quot;[ { required: true, message: &#39;请输入姓名&#39;, trigger: &#39;blur&#39; }]&quot;&gt; 增加与减少成员 //增加成员 addmember() { let newmember = { name: &quot;&quot;, studentId: &quot;&quot;, } this.form.memberInformation.push(newmember) }, //减少成员 reducemember(index) { this.form.memberInformation.splice(index, 1) }, 这个是我在项目中用到的办法，在阅读时发现了另一种情况的解决办法：https://blog.csdn.net/weixin_41041379/article/details/81908788 3.普通输入验证```js rules:{ data1:[ //必填，trigger是触发类型 { required: true, message: &#39;请输入学号&#39;, trigger: &#39;blur&#39; }, //数字类型 &#39;number&#39;, 整数: &#39;integer&#39;, 浮点数: &#39;float&#39; //使用整数的时候，首先要保证数据类型为数字，可以v-model.number绑定数据 {type: &#39;integer&#39;, message: &#39;格式错误&#39;, trigger: &#39;blur&#39;}, //长度限制 { min: 2, max: 4, message: &#39;长度在 2 到 4 个字符&#39;, trigger: &#39;blur&#39; } ] } ``` 4.手动验证 第一种是直接写在rules的里面 rules:{ data1:[ { validator:(rule,value,callback)=&gt;{ if(/^\d+$/.test(value) == false){ callback(new Error(&quot;只能输入数字&quot;)); }else{ callback(); } }, trigger: &#39;blur&#39; } } ] 第二种写法是抽离出来 //注意书写位置 data(){ let checkAge = (rule, value, callback) =&gt; { if (!value) { return callback(new Error(&#39;年龄不能为空&#39;)); } if (!Number.isInteger(value)) { callback(new Error(&#39;请输入数字值&#39;)); } else { if (value &lt; 18) { callback(new Error(&#39;必须年满18岁&#39;)); } else { callback(); } } } return { rules:{ age: [ { trigger: &#39;blur&#39;, validator: checkAge } ] } } 5.手动上传文件```html //html &lt;el-upload action ref=&quot;upload&quot; //覆盖默认的上传行为，自定义上传的实现 :http-request=&quot;finish&quot; //取消自动上传 :auto-upload=&quot;false&quot; &gt; &lt;el-button slot=&quot;trigger&quot; size=&quot;small&quot; type=&quot;primary&quot;&gt;选取文件&lt;/el-button&gt; &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;请上传您的项目功能清单&lt;/div&gt; &lt;/el-upload&gt; //js finish() { this.$refs.form.validate(valid =&gt; { // 验证成功 if (valid) { //这里的需求是必须上传文件 const file = this.$refs.upload.uploadFiles[0]; if (!file) { this.$message({ type: &quot;warning&quot;, message: &quot;请选择文件&quot; }); return; } //数据处理 let formData = new FormData(); formData.append(&quot;projectId&quot;, this.runId); formData.append(&quot;timeNode&quot;,JSON.stringify(this.form.timeNode)); formData.append(&quot;teamId&quot;, 1); formData.append(&quot;functionFile&quot;,file.raw ); //....中间的弹框确定等省略 submitApply(formData) } } } ``` 6.动态获取选项+模糊查询]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js页面属性]]></title>
    <url>%2F2018%2F12%2F18%2Fjs%E9%A1%B5%E9%9D%A2%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[页面属性 offsetWidth /offsetHeight //js对元素操作，只能获取不可以改变 //获取对象自身的宽度和高度 ，包括内容、边框和内边距，即：offsetWidth = width + border + padding box.offsetWidth //注意：和 div.style.width 的区别，其只能获取到行内的数值 div.style.width offsetLeft 和 offsetTop 距离第一个有定位的父级盒子左边和上边的距离，注意：父级盒子必须要有定位，如果没有，则最终以body为准！offsetLeft和offsetTop从从父标签的padding开始计算，不包括border。即：从子盒子边框到定位父盒子边框的距离。 offsetParent 返回当前对象的父级（带有定位）盒子，若爷爷也有则选择进近的 clientWidth/clientHeight 网页可见区域宽和高 clientLeft，clientTop 返回的是元素边框的borderWidth，如果不指定一个边框或者不定位改元素，其值就为0 document.body.scrollWidth; document.body.scrollHeight; 网页正文全文宽网页正文全文高 document.body.scrollTop; 网页被卷去的高 document.body.scrollLeft; 网页被卷去的左 区别 left和top分析： clientLeft: 左边边框的宽度；clientTop: 上边边框的宽度 offsetLeft: 当前元素距离有定位的父盒子左边的距离；offsetTop: 当前元素距离有定位的父盒子上边的距离 scrollLeft: 左边滚动的长度; scrollTop: 上边滚动的长度; width和height分析 clientWidth\/Height: 内容 + 内边距 offsetWidth\/Height: 内容 + 内边距 + 边框 scrollWidth\/Height: 滚动内容的宽度和高度]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex流程总结]]></title>
    <url>%2F2018%2F12%2F09%2Fvuex%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[对如何异步显示数据效果的编码流程进行了总结 ajaxajax请求函数，抛出接口 vuex store里面新建index完成基本配置 /* vuex最核心的管理对象store 组装模块并导出 store 的地方 */ // 首先引入Vue及Vuex import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; // 引入四个基本模块 import state from &#39;./state&#39; import mutations from &#39;./mutations&#39; import actions from &#39;./actions&#39; import getters from &#39;./getters&#39; // 一定要声明使用插件 Vue.use(Vuex) // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件 export default new Vuex.Store({ state, mutations, actions, getters }) - 现在Vue对象里面挂载store ``` import store from &#39;./store&#39; new Vue({ el: &#39;#app&#39;, components: { App }, template: &#39;&lt;App/&gt;&#39;, store //所有的组件都多了一个$store }) ``` - 在store下新建state.js state：用于存储状态对象 ``` export default { user:{} } ``` - 在store下新建mutation-types.js mutation是操作state状态的，mutation-types是存放操作state的方法名 ``` export const RECEIVE_USER_INFO = &#39;receive_user_info&#39; // 接收用户信息 ``` - 在store下新建actions.js action是通过操作mutation间接更新state的多个方法的对象 起连接作用。 异步获取数据。(注意需要引入api接口函数)把数据传给mutation。(因为mutation的方法名是放在mutation-types里面，所以注意要引入mutation-types里面对应的方法名) ``` import { reqUserInfo, } from &#39;../api&#39; import { RECEIVE_USER_INFO, } from &#39;./mutation-types&#39; // 异步获取用户信息 async getUserInfo ({commit}) { const result = await reqUserInfo() //如果请求成功，返回code=0 if (result.code === 0) { const userInfo = result.data //提交mutation //把结果{userInfo}提交给RECEIVE_USER_INFO方法 commit(RECEIVE_USER_INFO, {userInfo}) } }, ``` 参数除了commit以外，还可以有state`{commit,state}` - 在store里面新建mutations.js mutations直接对state进行操作，`[方法名](state,{param}){}` 默认第一个参数state，所以需要引入vue与方法名 ``` import Vue from &#39;vue&#39; import { RECEIVE_USER_INFO, } from &#39;./mutation-types&#39; export default { [RECEIVE_USER_INFO] (state, {userInfo}) { state.userInfo = userInfo } } ``` 使用数据 一般放在computed中进行接收，有利于state的值发生改变的时候及时响应给子组件。 mapState辅助函数 mapState返回的是一个对象 其实就是返回值:{return this.$store.XXXX} 当一个组件需要获取多个状态时候，用mapState辅助函数更为方便 ``` import { mapState } from &#39;vuex&#39; export default { computed:mapState({ //方法一：箭头函数 count: state =&gt; state.count; //方法二：传字符串参数&#39;count&#39;等同于‘state=&gt;state.count’ count:&#39;count&#39;; //方法三，使用this获取局部状态，必须使用常规函数 count(state){ return this.count } }) } ``` 当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。 ``` computed:mapState([ &quot;count&quot;]) ``` …mapState() ...mapState是state的语法糖，使用时需要从vuex中引入 ``` computed:{ ...mapState({}) } ``` mapGetters 辅助函数 mapGetters辅助函数仅仅是将store中的getter映射到局部属性 import { mapGetters } from &#39;vuex&#39; export default { // ... computed: { // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters([ &#39;doneTodosCount&#39;, &#39;anotherGetter&#39;, // ... ]) } } mapActions 类似mapState getter计算属性 ``` computed: { doneTodosCount () { return this.$store.state.todos.filter(todo =&gt; todo.done).length } } ``` 如果有多个组件需要用到这个属性，可以在store里面定义‘getter’，可以说是store的计算属性，像计算属性一样，getter的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算 const store = new Vuex.Store({ state: { todos: [ { id: 1, text: &#39;...&#39;, done: true }, { id: 2, text: &#39;...&#39;, done: false } ] }, getters: { //state作为第一个参数 doneTodos: state =&gt; { return state.todos.filter(todo =&gt; todo.done) } //可以接收其他getter作为第二个参数 doneTodosCount: (state, getters) =&gt; { return getters.doneTodos.length } //可以通过让getter返回一个函数，来实现给getter传参,对store里的数组进行查询时非常有作用 getTodoById: (state) =&gt; (id) =&gt; { return state.todos.find(todo =&gt; todo.id === id) } // store.getters.getTodoById(2) // -&gt; { id: 2, text: &#39;...&#39;, done: false } } }) //在组件中使用，同计算属性的调用，不用加括号 this.$store.getters.doneTodosCount dispatch方法 dispatch(actionName,data)分发调用action，第一个参数是方法名，第二个是数据 触发store里面的action对应方法名的函数 this.$store.dispatch(&quot;&quot;)]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[summary_js]]></title>
    <url>%2F2018%2F11%2F24%2Fsummary_js%2F</url>
    <content type="text"><![CDATA[enter回车 持续更新 在修改项目的过程中，学习到了关于表单enter键提交是否可以触发 如果type是submit，一个文本或者多个文本都会提交 如果是button，仅一个文本的时候提交 type为image的按钮，等同于type为submit的效果 用button时，fx和IE有不同的表现。radio和checkbox在FX下也会触发提交表单，在IE下不会 事件代理，事件委托利用的是冒泡原理，与事件源。还可以用来给动态添加的元素绑定事件 事件源 兼容 let e = e || window.event; var target = e.target || e.srcElement; 属性 console.log(e.target); console.log(e.target.id); console.log(e.target.tagName); console.log(e.target.nodeName); console.log(e.target.classList); console.log(e.target.className); console.log(e.target.innerHTML); console.log(e.target.innerText); js跳转https://www.cnblogs.com/Renyi-Fan/p/9130325.html js对打开的页面ULR进行跳转， location的href属性 open 方法 histoty的三个方法 location的assign方法 常规的js页面跳转 在原来的窗口中直接跳转 window.location.href=&quot;你所要跳转的页面&quot;; 在新窗口中打开页面用 window.open(&#39;你所要跳转的页面&#39;); //open属性的参数 &#39;page.html&#39; 弹出窗口的文件名；&#39;newwindow&#39; 弹出窗口的名字（不是文件名），非必须，可用空&#39;代替；height=100 窗口高度；width=500 窗口宽度；top=0 窗口距离屏幕上方的象素值；left=0 窗口距离屏幕左侧的象素值。 ##[object Object] 这个不是两个对象的意思，是对象的字符串形式，是隐式调用了Object对象的toString()方法，形式是”[object Object]”.[object objcet] 自定义的对象 没有覆盖toString方法，返回默认[object] window对象 覆盖了toString方法，显式调用返回[object Object]123 字条串 覆盖了toString方法，显式调用返回[object String] 在我做项目的时候遇见了一个问题，把对象放进cookie之后，cookie存储的格式变成了object Object,解决办法是转化成字符串之后存入,使用时再解析成json对象 JSON.parse()【从一个字符串中解析出json对象】 //定义一个字符串 var data=&#39;{&quot;name&quot;:&quot;goatling&quot;}&#39; //解析对象​ ​JSON.parse(data) 结果是： ​name:&quot;goatling&quot; JSON.stringify()【从一个对象中解析出字符串】 var data={name:&#39;goatling&#39;} JSON.stringify(data) 结果是： &#39;{&quot;name&quot;:&quot;goatling&quot;}&#39;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rem]]></title>
    <url>%2F2018%2F11%2F18%2Frem%2F</url>
    <content type="text"><![CDATA[rem rem是相对于根元素的字体大小相对单位 类似与em，不过rem是依赖根元素计算的，em是依赖父元素计算的 rem能等比例适配所有屏幕 这里有个插件flexible.js就是用rem实现的 这个button按钮的宽度为120px，高度为60px html{ font-size:20px; } .btn { width: 6rem; height: 3rem; line-height: 3rem; font-size: 1.2rem; display: inline-block; background: #06c; color: #fff; border-radius: .5rem; text-decoration: none; text-align: center; } 如果是不同分辨率下的font-size的值，应该如何计算计算之后可以用媒体查询设置html的font-size值 移动端页面自适应解决方案 不需要手动设置viewport了 原理是根据设备屏幕的DPR(设备像素比，比如dpr=2时，表示1个CSS像素由4个物理像素点组成） 动态设置 html 的font-size, 同时根据设备DPR调整页面的缩放值，进而达到高清效果。) 绝不是每个地方都要用rem，rem只适合与固定宽度 此方案也是默认1rem=100px 比如你在效果图上量取的某个按钮元素长 55px, 宽37px .myBtn { width: 0.55rem; height: 0.37rem; }]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex]]></title>
    <url>%2F2018%2F11%2F11%2Fvuex%2F</url>
    <content type="text"><![CDATA[vuex主要是状态管理，将数据统一管理(state) 模块 状态对象 stat 操作state 直接更新state的多个方法对象 mutations 操作mutations 间接更新state的多个方法对象 actions 包含多个基于state的getter计算属性的对象 getters 包含n个mutations的type名称常量 mutations-type 引入import Vuex from &#39;vuex&#39; Vue.use(Vuex) 使用共享的数据 const state={}; 建立统一数据容器，唯一的容器 let store = new Vuex.Store({ state }) store(容器)注册到实例上，main.js里面，所有的组件都会有一个属性this.$store new Vue({ store, }) 在组件中使用，加不加this都一样 {{this.$store.state.XXX}} state(单向数据流) 注意,在组件中最好不要直接更改共享的数据，共享的数据仅仅给组件染 mutation 通过mutation(管理员)来更改状态，可以在store里面设置成严格模式 strict：true，mutation不支持异步 告诉mutations需要更改,mutations相当于methodsconst mutations={ add(state,count){ //state是自动放入的，默认指的就是当前的state //操作state的属性 state.XXX +=count } } let store = new Vuex.Store({ state， mutations, strict：true }) 组件通过mutations提交,第一个参数是与mutatioons里面的方法绑定，第二个参数是自定义参数this.$store.commit(&#39;add&#39;,2) 插件打印日志 import logger from &#39;vuex/dist/logger&#39; const store = new Vuex.store({ plugins:[logger()] }) 整理src下面创建一个store文件\index.js import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; Vue.use(Vuex) import logger from &#39;vuex/dist/logger&#39; const state={}; import mutations from &#39;./mutations&#39; export default new Vuex.Store({ state， mutations, strict：true, plugins:[logger()] }) store下面再创建一个mutations.js,里面存放mutations的相关 import * as Types from &#39;mutations.types.js&#39; const mutations = { // [方法名](state,{param}){} [Types.INCREMENT](state){ state.count+=1 }, [Types.DECREMENT](state){ state.count-=1 } }; export default mutations; 宏(一般大写)store下面再创建一个mutations.types.js里面存放mutations的方法的名字，方便查找 //增加 export const INCREMENT=&#39;INCREMENT&#39; //减少 export const DECREMENT=&#39;DECREMENT&#39; 组件中引入同mutations.js中引入一样,只不过不加中括号import * as Types from ‘mutations.types.js’ Types.INCREMENTTypes.DECREMENT getters相当于computed,如果数据多了可以模仿mutations的抽离 const getters={ val(state){ state.count%2?&#39;奇数&#39;:&#39;偶数&#39; } }; export default new Vuex.store({ getters, }) //引用时 {{$store.getters.val}} actions 和后台交互的异步action，后台数据也需要修改 Action 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 引入api以及mutation-types 异步获取数据 异步获取地址 发送异步ajax请求 提交一个mutation //async 方法名({commit,参数可选}{}) // 异步获取地址 async getAddress ({commit, state}) { // 从state状态中获取到经纬度用来设置reqAddress的参数（看接口文档） const geohash = state.latitude + &#39;,&#39; + state.longitude // 1. 发送异步ajax请求 const result = await reqAddress(geohash) // 2. 根据结果提交一个mutation commit(RECEIVE_ADDRESS, {address: result.data}) },]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stylus]]></title>
    <url>%2F2018%2F10%2F29%2Fstylus%2F</url>
    <content type="text"><![CDATA[stylus学习笔记 冒号可选，分号可选，逗号可选，括号可选 缩进与空格很重要 body color white 父级引用 &amp; textarea input color #A7A7A7 &amp;:hover color #000 //等于 textarea, input { color: #a7a7a7; } textarea:hover, input:hover { color: #000; } 变量 属性查找 @ #logo position: absolute top: 50% left: 50% width: 150px height: 80px margin-left: -(@width / 2) margin-top: -(@height / 2) 运算符 范围 .. 包含界限 …包含开头不包含结尾 存在操作符in 实例检查 is a 条件赋值：?= := 变量定义：is defined 混合书写 方法]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[demo_vue-book]]></title>
    <url>%2F2018%2F10%2F27%2Fvue-book%2F</url>
    <content type="text"><![CDATA[vue-book 接下来会学习vuex，在学习一门预处理语言，之后用我学过的所有东西做一个练习的项目vue学习之后，用vue-cli做的一个练习。这是学习vue的过程中走通了一遍流程，但还有很多功能没有实现 上拉下拉刷新 图片的懒加载 打包之后如何上线 vuex的学习 如何连接数据库等 github:https://github.com/biubiuins/vue-book 安装依赖 npm install vue npm install -g webpack npm install -g vue-cli npm install less less-loader axios vuex bootstrap 目录 build 打包后的脚本文件 src 源码文件 mock后台代码，模拟数据 src/api 代表的是所有的接口,获取数据给前端调用 src/base 基础组件 src/components 页面组件实现路由根据页面划分了5个页面组件 首页 Home.vue 列表 List.vue 收藏 Collect.vue 添加 Add.vue 详情 Detail.vue 配置路由，配置路由映射表并new个实例,挂载在根组件上，router-view显示在App.vuerouter/index.js Vue.use()是用来安装Vue插件 import Vue from &#39;vue&#39; import Router from &#39;vue-router&#39; Vue.use(Router); 这里用了模板，将会另外写一篇，关于前端的模板与node的 导航base/Tab.vuescoped 表示是当前组件的样式，并不是全局的 &lt;style scoped lang=&quot;less&quot;&gt; less预处理语言，学习之后会写一篇博客 点击导航之后会通过to跳转页面，并且样式改变这里需要注意/home 确切激活，仅仅这个路径有效。router-link-exact-active/home /home/a 都可以。router-link-active &lt;router-link to=&quot;/add&quot;&gt; &lt;i class=&quot;iconfont icon-add&quot;&gt;&lt;/i&gt;&lt;span&gt;添加&lt;/span&gt; &lt;/router-link&gt; 基础组件Tab挂载在App.vue上（导航很多页面都需要），并在App.vue上写全局的样式，清除默认样式。新学习到的清除输入框和按钮的默认样式 input，button{appearance:none;} App.vue的组件中有name: &#39;App&#39;，这里name: &#39;app&#39; 相当于一个全局 ID。可以不写，写了可以提供更好的调试信息。页面渲染也是在App.vue中实现的 图标http://www.iconfont.cn/home/index?spm=a313x.7781069.1998910419.2图标打包好了之后在index.html中引入\iconfont是必须类名表明是个icon，后面根据页面选择 &lt;i class=&quot;iconfont icon-shouye&quot;&gt;&lt;/i&gt;&lt;span&gt;首页&lt;/span&gt; 头部base/Mheader.vue头部的标题不是全部一样的，并且比如首页是没有返回键的，所以这里用到的插槽和父组件给子组件传值这里用Home.vue-Mheader.vue为例 在父组件上挂载Mheader.vue &lt;Mheader.vue&gt;首页，首页需要显示出来，需要在子组件Mheader.vue中放个匿名插槽接收 父组件需要传递一个值告诉子组件是否显示返回键。子组件接收back，不需要验证的时候用数组，需要验证的时候用对象。&lt;i class=&quot;iconfont icon-fanhui&quot; v-if=&quot;back&quot;&gt;&lt;/i&gt; ... props:{ back:{type:Boolean,default:false} } 点击返回键，返回上一个操作this.$router.go(-1); 扩展一下,back也可以返回。this.$router.back() 强制跳转页面，在后面追加，点返回还可以回去。this.$router.push(‘/XXX’) 路由替换，将原来的替换。this.$router.replace(‘/XXX’)轮播图base/Swiper.vue安装依赖npm install vue-awesome-swiper --save-dev 在main.js中引入vue-awesome-swiper插件import VueAwesomeSwiper from &#39;vue-awesome-swiper&#39; import &#39;swiper/dist/css/swiper.css&#39; Vue.use(VueAwesomeSwiper) 后台获取图片信息mock/sliders.js 存放图片连接mock/server.js 配置服务器url.parse()可以将一个完整的URL地址，分为很多部分，常用的有：host、port、pathname、path、query。let sliders = require(&#39;./sliders&#39;) http.createServer((req,res)=&gt;{ let{pathname,query} = url.parse(req.url); if (pathname === &#39;/sliders&#39;){ res.setHeader(&#39;Content-Type&#39;,&#39;application/json;charset=utf-8&#39;) res.end(JSON.stringify(sliders)) } } 但是当前段发起ajax请求的时候，是8080端口请求3000端口的数据，所以有跨域的问题，这里需要在服务器中加入跨域头res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,Content-Length, Authorization, Accept,X-Requested-With&quot;); res.setHeader(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;); res.setHeader(&quot;X-Powered-By&quot;,&#39; 3.2.1&#39;) if(req.method==&quot;OPTIONS&quot;) return res.end();/*让options请求快速返回*/ 轮播图的api import axios from &#39;axios&#39;; //设置基本的默认请求路径 axios.defaults.baseURL =&#39;http://localhost:3000&#39;; //获取轮播图数据 export let getSliders=()=&gt;{ //因为设置了了efaults.baseURL，所以它请求的路径其实是http://localhost:3000/sliders,返回的是一个promise对象 return axios.get(&#39;/sliders&#39;) } axios 笔记待整理 前端获取数据获取的数据父子组件传值，传给子组件，子组件渲染出图片如果给接收到的data一个新的名字 slider {data：slider} async created(){ let {data} = await getSliders().then() this.sliders=data }, async/await 已整理 热门图书/删除图书 先写服务端，确保数据能正常返回 增加api方法，实现调取数据的功能 在哪个组件中应用这个api，如果是一个基础组件需要这些数据，在使用这个组件的父级中调用这个方法，将数据传递给基础组件 详情页面如果用对象作为to的属性，并且使用了参数，必须给路由起个名字，通过名字跳转router/index.js {path:&#39;/detail/:bid&#39;,component:Detail,name:&#39;detail&#39;} component/List.vue需要配置路径参数，点击哪个li跳转哪个详情这是跳转用到router-link，把之前的li改为router-link， params是路径参数 循环组件，需要加上key router-link是a标签，这里需要的是li，在taf里面修改&lt;router-link v-for=&quot;(book,index) in books&quot; :to=&quot;{name:&#39;detail&#39;,params:{bid:book.bookId}}&quot; :key=&quot;index&quot; tag=&quot;li&quot; &gt; 因为点击li跳转，删除按钮也在li里面，所以这个应该阻止删除按钮冒泡&lt;button @click.stop=&quot;remove(book.bookId)&quot;&gt;删除&lt;/button&gt; component/Detail.vue//获取通过传过来的参数 $route.params.XXX 获取当前id的图书信息渲染到界面。 问题一: 当修改的时候，价格原本是数字，修改之后会变成字符串,加上数字的修饰符 ``` &lt;input type=&quot;text&quot; v-model.number=&quot;book.bookPrice&quot; id=&quot;bookPrice&quot;&gt; ``` 问题二修改url的时候，页面没有刷新，因为模板已经渲染出来了，不会在走created办法。所以，需要监控url的变化，路径参数发生变化，通过监控参数的变化来发送ajax watch:{ //路径参数发生变化，通过监控参数的变化来发送ajax $route(){ this.getData() ; } } 问题三如果没有找到对应id的书，那返回的是空对象，如果是空，需要跳转回列表页Object.keys()，该方法返回一个数组,里面是对象的所有属性。如果是空对象那么返回一个空数组。 Object.keys(this.book).length&gt;0?void 0:this.$ruoter.push(&#39;/List&#39;) 处理一下url,server.js查询book的条件变一下 if (!isNaN(id)) 数据改变之后，需要用put更新数据PUT：参数1：url:/book?id=3参数2：请求体发送server.js获取put/post请求体中的数据使用这两个事件就可以获取来自服务器端的响应内容。 data，数据传递时触发， end，没有更多数据提供时触发let str = &quot;&quot;; res.on(&#39;data&#39;,(chunk)=&gt;{ str += chunk; }); res.on(&#39;end&#39;,()=&gt;{ console.log(str); }); 添加页面同详情页面 优化与其他功能loading轮播图和热门图书是分开获取的，这里改成一起获取api/index return axios.all([getSliders(),getHotBook()]) 数据返回的是一个数组，里面是两个promise对象。 新建base/Loading.vue,挂载在Home.vuehttps://www.cnblogs.com/lhb25/p/loading-spinners-animated-with-css3.html 实现页面缓存分页面缓存，路由元信息。在配置路由映射的时候有meta(备注)属性,这条对象可以通过this.$route获取 {path:&#39;/home&#39;,component:Home,meta:{keepAlive:true}}, 修改APP.vue,写两个router-view，一个用于，显示缓存的，一个用于显示一般的 &lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; &lt;Tab&gt;&lt;/Tab&gt; &lt;/div&gt; &lt;/template&gt; 实现路由动画给router-view外面包裹一个标签,注意点：一个只能包裹一个标签写css样式 .fadeIn-enter{ opacity: 0; } .fadeIn-enter-active{ transition:all 0.3s; } .fadeIn-leave-active{ transition: all 0.3s; opacity: 0; } 下拉加载更多打包上线history路由在路由中改变mode:’history’ 标题router/indexmeta:{title:XXX}main.js全局钩子，在进入路由之前每一次都会执行此方法。有拦截的作用router.beforeEach(function(from.to,next){ document.title = to.meta.title; next();});]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[express学习笔记]]></title>
    <url>%2F2018%2F10%2F12%2Fexpress%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[express 学习笔记 搭建简单服务器//express() 是一个由 express 模块导出的入口（top-level）函数 let express = require(&#39;express&#39;); //创建一个express应用实例名app let app = express(); // 设置端口号：3000 //process.env.PORT：读取当前目录下环境变量port的值 let port = process.env.PORT || 3000 ; //在端口号上开启服务 app.listen(port,function () { console.log(&quot;server start&quot;+port); }); app.listen(port, [hostname], [backlog], [callback])类似于node中的http.Server.listen() // 设置端口号：3000 //process.env.PORT：读取当前目录下环境变量port的值 let port = process.env.PORT || 3000 ; //在端口号上开启服务 app.listen(port,function () { console.log(&quot;server start&quot;+port); }); 服务器启动时候，默认端口3000：node app.js设置端口8080：PORT=8080 node app.js app.set(name,value)//设置 views 文件夹为存放视图文件的目录, 即存放模板文件的地方,__dirname 为全局变量,存储当前正在执行的脚本所在的目录。 app.set(&#39;views&#39;, path.join(__dirname, &#39;views&#39;)); app.set(&quot;views&quot;,&quot;./views&quot;); //设置使用的模板引擎 app.set(&#39;view engine&#39;, &#39;ejs’) app.set(&quot;view engine&quot;,&quot;jade&quot;) npm install --save express-art-template //设置art模板引擎，后缀为art app.engine(&#39;art&#39;, require(&#39;express-art-template&#39;)); app.get(name)返回name的value值 //实例一 app.get(&#39;title&#39;); // =&gt; undefined app.set(&#39;title&#39;, &#39;My Site&#39;); app.get(&#39;title&#39;); // =&gt; &quot;My Site&quot; //实例二 app.set(&#39;port&#39;, process.env.PORT || 3000); var server = app.listen(app.get(&#39;port&#39;), function() { console.log(&quot;server start&quot;+port); }); app.get(path, callback [, callback …])app.all(path, callback [, callback …])这种方法就像标准的app.METHOD()方法, 除了它匹配所有HTTP动词。访问path路径的所有方法执行的回调函数. //* 表示匹配所有的路径 app.all(&#39;*&#39;, function(req, res){ res.end(req.method + &#39;user&#39;) } //一般放在最后面防止前面的被覆盖 请求与响应//Express 应用使用回调函数的参数： request 和 response 对象来处理请求和响应的数据。 app.get(&#39;/&#39;, function(req, res){ res.send(&#39;hello world&#39;); res.status(404).send(错误请求)//访问这个路径是设定状态码为404 //通过res.send（）接口向客户端发送hello world，send只能响应一次，意思是只能出现一个send }) res.send（）只能出现一次如果要响应多次，用node原生的write和end，但是如果只有write会处于一个挂起状态 app.get(&#39;/&#39;, function(req, res){ res.write(&#39;hello world&#39;); res.write(&#39;hello world&#39;); }) res.send有结束响应的作用 res.write没有结束响应的作用，需要res.end结束中间件挂起response下表中响应对象（res）的方法向客户端返回响应，终结请求响应的循环。如果在路由句柄中一个方法也不调用，来自客户端的请求会一直挂起。res.render()//设置 views 文件夹为存放视图文件的目录, 即存放模板文件的地方,__dirname 为全局变量,存储当前正在执行的脚本所在的目录。 app.set(&#39;views&#39;, path.join(__dirname, &#39;views&#39;)); app.set(&quot;views&quot;,&quot;./views&quot;); //第一个是渲染的views文件夹下面的index，第二个是传递的数据,注意需要设置模板引擎 res.render(&quot;index&quot;,{},function(){}) res.setHeader()//Content-Type的作用 该实体头的作用是让服务器告诉浏览器它发送的数据属于什么文件类型。 res.setHeader(&quot;Content-Type&quot;,&#39;text/html;charset=utf-8&#39;) res.redirect()调用redirect()方法后，其后的代码都不会被执行。而使用redirect()设置的状态码不是301或302也不会发生跳转res.redirect([status,] path) //重定义到path所指定的URL，重定向时可以同时指定HTTP状态码，不指定状态码默认为302 res.location()location()方法本质上是调用了ServerResponse对象的setHeader()方法，但并没有设置状态码。使用location()设置头信息，而不设置状态码或状态码不是301或302，并不会发生重定向res.location(path) requestreq.query处理 get 请求，获取 get 请求参数// GET /search?q=tobi+ferret req.query.q // =&gt; &quot;tobi ferret&quot; // GET /shoes?order=desc&amp;shoe[color]=blue&amp;shoe[type]=converse req.query.order // =&gt; &quot;desc&quot; req.query.shoe.color // =&gt; &quot;blue&quot; req.query.shoe.type // =&gt; &quot;converse&quot; req.body处理 post 请求，获取 post 请求体// POST user[name]=tobi&amp;user[email]=tobi@learnboost.com req.body.user.name // =&gt; &quot;tobi&quot; req.body.user.email // =&gt; &quot;tobi@learnboost.com&quot; // POST { &quot;name&quot;: &quot;tobi&quot; } req.body.name // =&gt; &quot;tobi&quot; req.params处理 /:xxx 形式的 get 或 post 请求，获取请求参数// GET /user/tj req.params.name // =&gt; &quot;tj&quot; // GET /file/javascripts/jquery.js req.params[0] // =&gt; &quot;javascripts/jquery.js&quot; req.param(name)处理 get 和 post 请求，但查找优先级由高到低为 req.params→req.body→req.query// ?name=tobi req.param(&#39;name&#39;) // =&gt; &quot;tobi&quot; // POST name=tobi req.param(&#39;name&#39;) // =&gt; &quot;tobi&quot; // /user/tobi for /user/:name req.param(&#39;name&#39;) // =&gt; &quot;tobi&quot; 中间件用于客户端与服务器路由匹配之前的中间操作，正常中间件放在路由上面，中间件通过next()往下走。app.use（[path],function）利用express托管静态文件node.js不能通过目录来引入文件，而express可以，public为静态目录//设置public文件夹为存放静态文件的目录。 let path=require(&quot;path&quot;) //ex4里面唯一的内置中间件 app.use(express.static(path.join(__dirname, &#39;public&#39;))); 一个中间件处理器，请求来了，让那些中间件先处理一遍 没有挂载路径的中间件，应用的每个请求都会执行该中间件 挂载至 /path 的中间件，任何指向 /path 的请求都会执行它app.use(&quot;/name&quot;,function(req,res,next){ res.setHeader(&quot;Content-Type&quot;,&#39;text/html;charset=utf-8&#39;) next(); }) app.get(&quot;/name/n&quot;,function(req,res){ }) //也可以匹配到，在执行get请求/name/n时先执行上面的中间件 错误中间件错误处理中间件和其他中间件定义类似，只是必须要使用 4 个参数(err, req, res, next)。即使不需要 next 对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。遇见错误之后直接执行错误中间件。错误处理中间件应当在在其他 app.use() 和路由调用之后才能加载，一般放在路由的最底部，比如：var bodyParser = require(&#39;body-parser&#39;); var methodOverride = require(&#39;method-override&#39;); app.use(bodyParser()); app.use(methodOverride()); app.use(function(err, req, res, next) { // 业务逻辑 console.error(err.stack); res.status(500).send(&#39;Something broke!&#39;); }); 应用生成器`js//安装$ npm install express-generator -g//view=XXX 使用引擎名字 myapp项目名称$ express –view=pug myapp//安装所有依赖$ cd myapp$ npm install //启动myapp项目$ set DEBUG=myapp:* &amp; npm start `我的石墨文档链接：https://shimo.im/docs/TXeewzaE8Jsdgn0I/练习的简易聊天室连接：https://github.com/biubiuins/demo_chat]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[project_email]]></title>
    <url>%2F2018%2F10%2F11%2Fproject-email%2F</url>
    <content type="text"><![CDATA[邮件收发项目大二上开始学html，css，js之后做的暑假做的前端页面，很感谢老师可以给一个练手的机会，在做的过程中发现了很多问题，以及项目完成之后的收获。&nbsp;&nbsp;&nbsp;&nbsp;虽然是一个很简单的界面，但是之前学习的时候不太仔细，也没有demo练习，还是做的磕磕绊绊，还好最后做的差不多了。TAT&nbsp;&nbsp;针对过程中的问题，阅读了很多关于语法规范的文章，js，jq又重新学习了一遍（练习了很多），大二下期基本在学习之中度过的。希望在以后的项目中可以有所进步，彻底的实现前后端分离！！！ 项目相关 完成时间：大二上期寒假 2018-3月左右 bootsrap框架，layui框架，jquery 项目不足 语法不规范，复用性不强，后面修改过一次感觉修改起来很复杂 js不熟练，项目之后大二下期又重新开始学习了一遍js，并写了总结 (https://biubiuins.github.io/2018/10/11/summary-2018-9/) 技术不足，没有实现前后端分离 主要功能 首页 http://mailroom.sicau.edu.cn/email/public/ bootsrap做了响应式，用了ajax请求数据 管理页面（需要登陆仅提供图片） 实现全选与批量删除 点击已取之后，重新获取数据（保证筛选邮件之后点击已取仍显示的是筛选之后的邮件) 邮件类型默认显示上一次选择的类型，可输入筛选的下拉框 超级管理员界面实现了原生js模态框，并做了根据屏幕居中]]></content>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[summary-2018.9]]></title>
    <url>%2F2018%2F10%2F11%2Fsummary-2018-9%2F</url>
    <content type="text"><![CDATA[summary-2018-9 这是在学会搭建博客之后的第一篇博客，以前学习的时候也有记笔记，所以把之前学习笔记上面整理的常见的功能、封装以及遇到的问题写出来，这篇仅限于js，jq。现在正在学习vue，希望在过段时间，自己也能写出关于vue学习的总结。在此之前还需要了解markdown的语法TAT 原来的笔记记录在石墨文档，https://shimo.im/docs/c8YrJy4obNICaWiS/ ID处理/** 获取id */ function $(id) { return typeof id === &quot;string&quot; ? document.getElementById(id) : null; } 动画匀速动画//元素，目标，步数 function constant(obj, target, speed) { // 1. 清除定时器 clearInterval(obj.timer); //2.判断方向 //如果现在的距离小于目标值,则往右，否则向左 let dir =obj.offsetLeft&lt;target?speed:-speed; //3. 设置定时器 obj.timer = setInterval(function () { obj.style.left = obj.offsetLeft + dir + &quot;px&quot;; //若超出目标值或者不到目标值 //最后相减的值取绝对值后，总是小于步数的 //Math.abs(dir)||speed if(Math.abs(target-obj.offsetLeft)&lt;Math.abs(dir)){ clearInterval(obj.timer); //根据目标值板正 obj.style.left =target+&#39;px&#39;; } }, 20); } 缓动动画function buffer(obj, json, fn) { // 1. 清除定时器 clearInterval(obj.timer); var begin = 0, end = 0; // 2. 设置定时器 obj.timer = setInterval(function () { // 2.0 旗帜, 决定动画是否结束 let flag = true; // 2.1 遍历 for(let k in json){ // 2.2.-1 求出起始值 和 结束值 if(k === &#39;opacity&#39;){ // 透明度 begin = parseInt( parseFloat(getCssAttr(obj, k)) * 100); end = parseInt(parseFloat(json[k]) * 100); }else if(k === &#39;scrollTop&#39;){ // 滚动到头部 begin = obj.scrollTop; end = parseInt(json[k]); }else { // 正常情况 begin = parseInt(getCssAttr(obj, k)); end = parseInt(json[k]); } // 2.2.0 求出步长 //步长公式 let step = (end - begin) * 0.2; step = step &gt;=0 ? Math.ceil(step) : Math.floor(step); // 2.2.1 计算起始位置 if(k === &#39;opacity&#39;){ obj.style.opacity = (begin + step) / 100; obj.style.filter = &#39;alpha(opacity=&#39; + (begin + end)+&#39;)&#39;; // 针对IE }else if(k === &#39;scrollTop&#39;){ obj.scrollTop = begin + step; }else if(k === &#39;zIndex&#39;){ obj.style[k] = json[k]; }else { obj.style[k] = begin + step + &#39;px&#39;; } // 2.2.2 判断 if(begin !== end){ flag = false; } } // 3.0 结束动画 if(flag){ clearInterval(obj.timer); // 开启动画组中的下一组动画 if(fn){ // 判断有没有这个函数 fn(); } } }, 60); } js获取CSS利用 [] 访问属性 元素.style[“属性”]; //这种语法的好处就是可以动态的传递参数作为属性 //只能获取行类标签 var h = &#39;height&#39;; box.style[h] = 300 + &#39;px&#39;; //获取外部css或页内的css function getStyleAttr(obj, attr) { if(obj.currentStyle){ // IE 和 opera return obj.currentStyle[attr]; }else { //window.getComputedStyle(&quot;元素&quot;, &quot;伪类&quot;) （ 注意：两个选项是必须的，没有伪类 用 null 替代 ） //也可以点选，但是为了传递参数作为属性 return window.getComputedStyle(obj, null)[attr]; } } 定时器 在定时器事件前，先设置接收定时器的变量指向null 在定时器事件里，先要清除定时器再设置定时器，先清除是防止定时器累加轮播第一种这种不适合多图function slider (sliderid,olStyleClassName,imgWidth,speed,second) { //高级排他 //lastIndex 选中的小圆点样式 currentIndex 小圆点索引 picIndex 图片索引 let lastIndex=0,currentIndex=0,picIndex=0; // 1. 获取需要的标签 let ul=$(sliderid).children[0]; let ol=$(sliderid).children[1]; let list=ul.children; let olList= ol.children; // 2.克隆最后一个li标签 ul.appendChild(list[0].cloneNode(true)); // 3.动态创建小圆点 for(let i= 0;i&lt;list.length-1;i++){ let li =document.createElement(&quot;li&quot;); ol.appendChild(li); } //4.第一个小圆点选中 olList[0].className=olStyleClassName; //5.监听每个li的进入事件 for(let i= 0;i&lt;olList.length;i++){ //5.1 每一个li绑定自己的事件 olList[i].onmouseover=function () { //先清除之前的选中状态，在把当前选中的索引给lastIndex lastIndex=currentIndex; olList[lastIndex].className=&quot;&quot;; this.className=olStyleClassName; lastIndex=i; //5.2图片动起来 constant(ul,-(i * imgWidth),speed); currentIndex=picIndex=i; }; } //6.定时器 let timer; timer = setInterval(autoPlay, second); // 7. 清除和设置定时器 $(sliderid).onmouseover = function () { clearInterval(timer); }; $(sliderid).onmouseout = function () { timer = setInterval(autoPlay, second); }; function autoPlay(){ picIndex++; currentIndex++; //如果图片到了最后一张 if (picIndex &gt; list.length - 1) { ul.style.left = 0; //从第二张图片开始 picIndex = 1; } constant(ul, -(picIndex * imgWidth), speed); //小原点的选中 if (currentIndex &gt; olList.length - 1) { currentIndex = 0; } for (let i=0;i&lt;olList.length;i++){ olList[i].className=&quot;&quot;; } olList[currentIndex].className=olStyleClassName; } } 第二种两个图片宽度的位置，第一个位置显示（当前），第二位置隐藏第三种改变透明度，循环一遍让所有的opacity动画为0，然后当前为opacity动画为1，索引++、function opacityAutoPlay(ulid,speed) { // 1. 获取所有的li标签 var lis = $(ulid).getElementsByTagName(&quot;li&quot;); var index = 0; // 2. 开始定时器 setInterval(function () { // 2.1 改变透明度 for(let i=0; i&lt;lis.length; i++){ let singerLi = lis[i]; buffer(singerLi, {opacity: 0}, null); } buffer(lis[index], {opacity: 1}, null); // 2.2 索引++ index++; if(index === lis.length){ index = 0; } }, speed); } 瀑布流 父盒子居中 Math.floor(屏幕宽度/子盒子宽度)=cols 子盒子的宽度*cols=父盒子的宽度 margin:0 auto; 子盒子定位第一行不变，其他子盒子接在第一行最矮的盒子的后面（反复） 拿到所有盒子的高度。把第一行的盒子的高度放在一个数组里面（i&lt;cols,heightArr[]) 在剩下的盒子里面(i&gt;=cols),找出第一行最矮的盒子的高度（Math.min(…heightArr)||Math.min.apply(this.height)）2.1 找出最矮盒子的索引(遍历heightArr[],找出和第二步盒子高度一样的i返回)2.2 剩下盒子定位（left=第2.1步的索引*子盒子宽度，top=最矮的盒子高度）2.3 更新最矮盒子的高度 （heightArr[最矮盒子的高度]+=当前盒子的高度） 滚动加载图片 监听窗口的滚动，滚动到你需要的位置加载 js window.onload = function () { // 1. 实现瀑布流布局 waterFull(&quot;main&quot;, &quot;box&quot;); // 2. 动态加载图片 window.onscroll = function () { if(checkWillLoadImage()){ // 2.1 造数据 var dataArr = [ {&quot;src&quot;: &quot;img04.jpg&quot;}, {&quot;src&quot;: &quot;img06.jpg&quot;}, {&quot;src&quot;: &quot;img08.jpg&quot;}, {&quot;src&quot;: &quot;img09.jpg&quot;}, {&quot;src&quot;: &quot;img10.jpg&quot;}, {&quot;src&quot;: &quot;img12.jpg&quot;}, {&quot;src&quot;: &quot;img14.jpg&quot;}, {&quot;src&quot;: &quot;img16.jpg&quot;}, {&quot;src&quot;: &quot;img18.jpg&quot;} ]; // 2.2 创建元素 for(var i=0; i&lt;dataArr.length; i++){ var newBox = document.createElement(&quot;div&quot;); newBox.className = &quot;box&quot;; $(&quot;main&quot;).appendChild(newBox); var newPic = document.createElement(&quot;div&quot;); newPic.className = &quot;pic&quot;; newBox.appendChild(newPic); var newImg = document.createElement(&quot;img&quot;); newImg.src = &quot;images/&quot; + dataArr[i].src; newPic.appendChild(newImg); } // 2.3 重新布局 waterFull(&quot;main&quot;, &quot;box&quot;); } } }; /** * 实现瀑布流布局 */ function waterFull(parent, child) { // 1. 父盒子居中 // 1.1 获取所有的盒子 var allBox = $(parent).getElementsByClassName(child); // 1.2 获取子盒子的宽度 var boxWidth = allBox[0].offsetWidth; // 1.3 获取屏幕的宽度 var screenW = document.documentElement.clientWidth; // 1.4 求出列数 var cols = parseInt(screenW / boxWidth); // 1.5 父盒子居中 $(parent).style.width = cols * boxWidth + &#39;px&#39;; $(parent).style.margin = &quot;0 // 2. 子盒子的定位 // 2.1 定义高度数组 var heightArr = [], boxHeight = 0, minBoxHeight = 0, minBoxIndex = 0; // 2.2 遍历子盒子 for (var i = 0; i &lt; allBox.length; i++) { // 2.2.1 求出每一个子盒子的高度 boxHeight = allBox[i].offsetHeight; // 2.2.2 取出第一行盒子的高度放入高度数组 if (i &lt; cols) { // 第一行 heightArr.push(boxHeight); } else { // 剩余行 // 1. 取出最矮的盒子高度 // minBoxHeight = _.min(heightArr); minBoxHeight=Math.min(...heightArr); // 2. 求出最矮盒子对应的索引 minBoxIndex = getMinBoxIndex(heightArr, minBoxHeight); // 3. 子盒子定位 allBox[i].style.position = &quot;absolute&quot;; allBox[i].style.left = minBoxIndex * boxWidth + &#39;px&#39;; allBox[i].style.top = minBoxHeight + &#39;px&#39;; // 4. 更新数组中的高度 heightArr[minBoxIndex] += boxHeight; } } console.log(heightArr, minBoxHeight, minBoxIndex); } /** * 获取数组中最矮盒子高度的索引 * @param arr * @param val * @returns {number} */ function getMinBoxIndex(arr, val) { for(var i=0; i&lt;arr.length; i++){ if(arr[i] === val){ return i; } } } /** * 判断是否具备加载图片的条件 */ function checkWillLoadImage() { // 1. 获取最后一个盒子 var allBox = document.getElementsByClassName(&quot;box&quot;); var lastBox = allBox[allBox.length - 1]; // 2. 求出最后一个盒子自身高度的一半 + offsetTop var lastBoxDis = lastBox.offsetHeight * 0.5 + lastBox.offsetTop; // 3. 求出屏幕的高度 var screenW = document.body.clientHeight || document.documentElement.clientHeight; // 4. 求出页面偏离浏览器的高度 var scrollTop = scroll().top; return lastBoxDis &lt;= screenW + scrollTop; } jq //当页面加载完毕 $(window).on(&#39;load&#39;,function () { //1.实现瀑布流布局 waterFall(); //2.滚动加载 $(window).on(&#39;scroll&#39;,function () { //判断是否加载 if (checkWillLoad()) { ////创造假数据 var data = {&#39;dataImg&#39;:[{&#39;img&#39;:&#39;23.jpg&#39;},{&#39;img&#39;:&#39;24.jpg&#39;},{&#39;img&#39;:&#39;25.jpg&#39;},{&#39;img&#39;:&#39;26.jpg&#39;},{&#39;img&#39;:&#39;27.jpg&#39;},{&#39;img&#39;:&#39;28.jpg&#39;}]}; //遍历创建盒子 $.each(data.dataImg,function (index,value) { //创建一个div标签 设置它的类为&#39;box&#39; 添加到&#39;main&#39;里面去 var newBox = $(&#39;&lt;div&gt;&#39;).addClass(&#39;box&#39;).appendTo($(&#39;#main&#39;)); var newPic = $(&#39;&lt;div&gt;&#39;).addClass(&#39;pic&#39;).appendTo($(newBox)); //创建img 取出遍历的对象value的img属性对应的值 $(&#39;&lt;img&gt;&#39;).attr(&#39;src&#39;,&#39;images/&#39;+$(value).attr(&#39;img&#39;)).appendTo($(newPic)); }) //1.实现瀑布流布局 waterFall(); } }); }); //实现瀑布流布局 function waterFall () { //拿到所有的盒子 var allBox = $(&#39;#main &gt; .box&#39;); //取出其中一个盒子的宽度 var boxWidth = $(allBox).eq(0).outerWidth(); //取出屏幕的高度 var screenWidth = $(window).width(); //求出列数 //取整函数取整 var cols = Math.floor( screenWidth/boxWidth); //父标签居中 $(&#39;#main&#39;).css({ &#39;width&#39;:cols * boxWidth + &#39;px&#39;, &#39;margin&#39;:&#39;0 auto&#39; }); //对子盒子定位 var heightArr = []; //遍历 $.each(allBox,function (index,value) { //取出单独盒子的高度 var boxHeight = $(value).outerHeight(); //判断是否第一行 if(index &lt; cols) { heightArr[index] = boxHeight; } else //剩余的盒子要瀑布流布局 { //求出最矮的盒子高度 var minBoxHeight = Math.min.apply(null,heightArr); //取出最矮高度对应的索引 封装了js的这个方法 var minBoxIndex = $.inArray(minBoxHeight,heightArr); //定位 $(value).css({ &#39;position&#39;:&#39;absolute&#39;, &#39;top&#39;:minBoxHeight + &#39;px&#39;, &#39;left&#39;:minBoxIndex * boxWidth + &#39;px&#39; }); //更新数组中最矮的高度 heightArr[minBoxIndex] += boxHeight; } }) } //判断是否符合加载条件 function checkWillLoad() { //直接取出最后一个盒子 var lastBox = $(&#39;#main &gt; div&#39;).last(); //取出最后一个盒子高度的一半 + 头部偏离的位置 var lastBoxDis = $(lastBox).outerHeight() + $(lastBox).offset().top; //求出浏览器的高度 var clientHeight = $(window).height(); //求出页面偏离浏览器高度 var scrollTopHeight = $(window).scrollTop(); //比较返回 return lastBoxDis &lt;= clientHeight + scrollTopHeight; } margin:0 auto 块级元素 给定要居中的块级元素的宽度。 所有元素也可以通过对父元素设置text-align：center；的方式来实现居中。而对于块元素来说，对要居中的元素自身进行设置text-align:center也能实现居中 margin:0 auto;可以使盒子居中，text-align:center;可以使文本居中，节流onresize举列子窗口大小一变化就执行，太过灵敏，所以需要阻止//使用定时器 var timer = null; window.onresize = function () { clearTimeout(timer); // 节流 timer = setTimeout(function () { waterFull(&#39;main&#39;, &#39;box&#39;); }, 200); } //封装之后的 function throttle(fn, delay) { var timer = null; return function () { clearTimeout(timer); timer = setTimeout(fn, delay); } } apply/call这个面试中常考到，现在只做初步了解(https://www.cnblogs.com/gaowx/p/4837687.html ) 改变函数的this指向 apply可以改变传递给函数参数的形式 Datefunction newDate(){ //声明日期对象，里面可以设置参数表示其他时间 let date =new Date(); //获取时间里面的年 date.getFullYear() //月0-11 date.getMonth()+1 //日1-31 date.getDate() //获取星期0-6 data.Day //设置某一天 date.setDate（day） //时0-23 date.getHours() //分0-59 date.getMinutes() //秒0-59 date.getSeconds() //获取毫秒 date.getMilliSeconds() //时间戳 date.getTime() } ms转化时间 cookie封装封装成插件，引入该文件后，$.addCookie(key,value,day,path,domain)来引用 ;(function ($,window) { $.extend({ addCookie: function addCookie(key,value,day,path,domain){ //1.处理默认保存的路径 var index=window.location.pathname.lastIndexOf(&#39;/&#39;); var currentPath=window.location.pathname.slice(0,index) path=path||currentPath //2.处理默认domain domain=domain||document.domain //3.处理默认的过期时间 if(!day){ document.cookie=key+&quot;=&quot;+value+&quot;;path=&quot;+path+&quot;;domain=&quot;+domain+&#39;;&#39; } else{ var date =new Date(); date.setDate(date.getDate()+day) document.cookie=key+&quot;=&quot;+value+&quot;;expires=&quot;+date.toGMTString()+&quot;;path=&quot;+path+&quot;;domain=&quot;+domain+&#39;;&#39; } }, getCookie: function getCookie(key){ var res=document.cookie.split(&#39;;&#39;) for(var i=0;i&lt;res.length;i++){ //把key和value切割 var temp=res[i].split(&#39;=&#39;) //前后可能有空格，把空格删除 if(temp[0].trim()===key){ return temp[1] } } }, delCookie: function delCookie(key, path) { //默认情况下只能删除默认路径中保存的cookie，如果要删除指定路径保存的cookie，要把路径值传出去 //设置过期时间为-1 addCookie(key, getCookie(key), -1, path) } }); })(jQuery,window); 动态添加的元素绑定事件 delegate$(&#39;ul&#39;).delegate(&#39;li&#39;,&#39;click&#39;,function(){ //操作的还是li }) onclick事件在动态添加数据的时候，就给元素绑定onclick事件 on（）常用//把动态添加的元素写在on里面，如果调用的函数是外部定义好的，则在调用的时候不加（） //不然会跳过点击事件直接执行函数 $(&quot;父元素或祖辈元素&quot;).on(&quot;click&quot;,&quot;动态添加的元素&quot;,function(){ $(this).css(&quot;border&quot;,&quot;5px solid #000&quot;); } 其他清除默认样式http://yui.yahooapis.com/3.18.1/build/cssreset/cssreset-min.css下拉框//拿到select对象： var myselect=document.getElementById(&quot;select&quot;); //拿到选中项的索引 var index=myselect.selectedIndex ; // selectedIndex代表的是你所选中项的index //拿到选中项options的value： myselect.options[index].value; //拿到选中项options的text： myselect.options[index].text; //拿到选中项的其他值，比如这里的url： myselect.options[index].getAttribute(&#39;url&#39;); //jquery var options=$(“#select option:selected”); //获取选中的项 alert(options.val()); //拿到选中项的值 alert(options.text()); //拿到选中项的文本 alert(options.attr(&#39;url&#39;)); //拿到选中项的url值 //设置 //设置value为pxx的项选中 $(&quot;.selector&quot;).val(&quot;pxx&quot;) //设置text为pxx的项选中 $(&quot;.selector&quot;).find(&quot;option[text=&#39;pxx&#39;]&quot;).attr(&quot;selected&quot;,true) H5 datalistdatalist 只是列表赋值取值还是通过input.样式等都在input上操作https://www.zhangxinxu.com/wordpress/2013/03/html5-datalist-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8-%E5%8F%AF%E8%A1%8C%E6%80%A7/邮箱的自动补全HTML代码：邮箱：&lt;input type=&quot;email&quot; id=&quot;email&quot; list=&quot;emailList&quot; name=&quot;off_autocomplete&quot; /&gt; &lt;datalist id=&quot;emailList&quot;&gt; //其中*为占位符，当文本框输入内容的时候，*替换成邮箱地址的前半部分，于是，动态邮件地址提示的效果就实现了 &lt;option value=&quot;*@qq.com&quot;&gt; &lt;option value=&quot;*@163.com&quot;&gt; &lt;option value=&quot;*@gmail.com&quot;&gt; &lt;option value=&quot;*@yahoo.com.cn&quot;&gt; &lt;option value=&quot;*@126.com&quot;&gt; &lt;/datalist&gt; JS代码：var eleList = document.getElementById(&quot;emailList&quot;) , eleMail = document.getElementById(&quot;email&quot;) , htmlListInit = &#39;&#39;, arrEmailList = []; if (eleMail &amp;&amp; eleList &amp;&amp; (htmlListInit = eleList.innerHTML) !== &#39;&#39;) { // 得到类似[&quot;qq.com&quot;, &quot;163.com&quot;, &quot;gmail.com&quot;, ...]的数据 arrEmailList = [].slice.call(eleList.getElementsByTagName(&quot;option&quot;)).map(function(option) { return option.value.replace(&quot;*@&quot;, &quot;&quot;); }); eleMail.fnListReplace = function() { var arrValue = this.value.trim().split(&quot;@&quot;); // 修复FireFox浏览器下无限input问题 // 如果值不完全匹配某option值，执行动态替换 if (arrValue.length !== 2 || arrEmailList.indexOf(arrValue[1]) === -1) { eleList.innerHTML = htmlListInit.replace(/\*/g, arrValue[0]); } return this; }; // 绑定输入事件侦听 eleMail.addEventListener(&quot;input&quot;, function() { this.fnListReplace.call(this); }, false); // 载入即匹配 eleMail.fnListReplace.call(eleMail).focus(); } else { eleList = document.createElement(&quot;datalist&quot;); eleList.innerHTML = &#39;&lt;p class=sorry&gt;抱歉，当前浏览器不支持HTML5 datalist.&lt;/p&gt;&#39;; eleMail.parentNode.appendChild(eleList); } jquery.editable-select控件引入jquery.editable-select.cssjquery.editable-select.js调用方法$(&#39;#editable-select&#39;).editableSelect({ bg_iframe: true, //是否加iframe case_sensitive: false, items_then_scroll: 10 ,//设置下拉选项的数目 isFilter:false/true, //是否根据条件过滤下拉选项 onCreate:, //当输入时触发 onShow：, //当下拉时触发 onHide：, //当下拉框隐藏时触发 onSelect：, //当下拉框中的选项被选中时触发 effects:default/slide/fade， //动画效果 duration： //动画效果的时间 });]]></content>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
</search>
