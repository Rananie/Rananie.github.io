<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[less学习笔记]]></title>
    <url>%2F2019%2F05%2F13%2Fless%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[less 参考文章:https://segmentfault.com/a/1190000012360995 less属于css的一种预处理器（处理在浏览器运行前）,作为css的扩展，是一种动态样式语言。 注释 //开头的注释，不会被编译到css文件中，以/ /注释的内容会被编译到css文件 变量 以@开头定义变量，使用是直接 @定义的名称 变量名必须使用大括号包裹 声明变量（类比于写好的css引用）类似于混合方法 结构: @name: { 属性: 值 ;}; 使用：@name(); 使用@来申明一个变量: @pink:pink //不要添加引号 作为普通属性值只是来使用：直接使用@pink 作为选择器和属性名: @{selector的值}的形式（不常用） 作为URL：@{url} （@images:’../img’ 注意要加引号） 变量的延迟加载（一个块级域解析完再加载变量） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* Less */@color: #999;@bgColor: skyblue;//不要添加引号@width: 50%;#wrap &#123; color: @color; width: @width;&#125;/* 选择器变量 */ @mySelector: #wrap; @Wrap: wrap; @&#123;mySelector&#125;&#123; //变量名 必须使用大括号包裹 color: #999; width: 50%; &#125; .@&#123;Wrap&#125;&#123; color:#ccc; &#125; #@&#123;Wrap&#125;&#123; color:#666; &#125; /* url 变量*/ @images: &quot;../img&quot;;//需要加引号 body &#123; background: url(&quot;@&#123;images&#125;/dog.png&quot;);//变量名 必须使用大括号包裹 &#125;/* 声明变量 */ @background: &#123;background:red;&#125;; #main&#123; @background(); &#125; @Rules:&#123; width: 200px; height: 200px; border: solid 1px red; &#125;; #con&#123; @Rules(); &#125; /* 生成的 CSS */ #main&#123; background:red; &#125; #con&#123; width: 200px; height: 200px; border: solid 1px red; &#125; 变量的运算注意点： 加减法时，以第一个数据的单位为基准 乘除法时，注意单位一定要统一 less嵌套规则和html结构相似，层层嵌套&amp;代表的上一层选择器的名字 12345678910111213141516171819202122/* Less */#header&#123; &amp;:after&#123; content:&quot;Less is more!&quot;; &#125; .title&#123; font-weight:bold; &#125; &amp;_content&#123;//理解方式：直接把 &amp; 替换成 #header margin:20px; &#125;&#125;/* 生成的 CSS */#header::after&#123; content:&quot;Less is more!&quot;;&#125;#header .title&#123; //嵌套了 font-weight:bold;&#125;#header_content&#123;//没有嵌套！ margin:20px;&#125; less中的混合 混合：将一系列的规则集引入另一个规则集中 普通混合(编译到原生css中) 不带输出的混合(加括号) 混合使用.或 #的形式来定义；声明变量使用的是@来定义，@变量名（）来使用 普通混合 最好写成后面带（）的形式 12345678910/* Less */ .card &#123; // 等价于 .card() background: #f6f6f6; -webkit-box-shadow: 0 1px 2px rgba(151, 151, 151, .58); box-shadow: 0 1px 2px rgba(151, 151, 151, .58); &#125; #wrap&#123; .card;//等价于.card(); &#125; //其中 .card 与 .card() 是等价的。 带参数的混合注意点： Less 可以使用默认参数，如果 没有传参数，那么将使用默认参数。冒号后面的是默认值2. @arguments代表全部参数，实参列表 传的参数中必须带单位 1234567891011121314151617181920212223242526272829303132/* Less */ .border(@a:10px,@b:50px,@c:30px,@color:#000)&#123; border:solid 1px @color; box-shadow: @arguments;//指代的是 全部参数 &#125; #main&#123; .border(0px,5px,30px,red);//必须带着单位 &#125; #wrap&#123; .border(0px); &#125; /* 命名参数 */ #wrap&#123; .border(@color:black); &#125; #content&#123; .border;//等价于 .border() &#125; /* 生成的 CSS */ #main&#123; border:solid 1px red; box-shadow:0px,5px,30px,red; &#125; #wrap&#123; border:solid 1px #000; box-shadow: 0px 50px 30px #000; &#125; #content&#123; border:solid 1px #000; box-shadow: 10px 50px 30px #000; &#125; 匹配模式注意点： 第一个参数 left 要会找到方法中匹配程度最高的，如果匹配程度相同，将全部选择，并存在着样式覆盖替换。 如果匹配的参数 是变量， @_表示的会被调用任意标志的 。 123456789101112131415161718192021222324252627/* Less */ .triangle(top,@width:20px,@color:#000)&#123; border-color:transparent transparent @color transparent ; &#125; .triangle(right,@width:20px,@color:#000)&#123; border-color:transparent @color transparent transparent ; &#125; .triangle(bottom,@width:20px,@color:#000)&#123; border-color:@color transparent transparent transparent ; &#125; .triangle(left,@width:20px,@color:#000)&#123; border-color:transparent transparent transparent @color; &#125; .triangle(@_,@width:20px,@color:#000)&#123; border-style: solid; border-width: @width; &#125; #main&#123; .triangle(left, 50px, #999) &#125; /* 生成的 CSS */ #main&#123; border-color:transparent transparent transparent #999; border-style: solid; border-width: 50px; &#125; 方法的命名规范注意点： 在 CSS 中&gt; 选择器，选择的是 儿子元素，就是 必须与父元素 有直接血源的元素。 在引入命令空间时，如使用 &gt; 选择器，父元素不能加 括号。 不得单独使用命名空间的方法 必须先引入命名空间，才能使用 其中方法。 子方法 可以使用上一层传进来的方法 123456789101112131415161718192021222324252627282930313233343536/* Less */#card()&#123; background: #723232; .d(@w:300px)&#123; width: @w; #a(@h:300px)&#123; height: @h;//可以使用上一层传进来的方法 width: @w; &#125; &#125;&#125;#wrap&#123; #card &gt; .d &gt; #a(100px); // 父元素不能加 括号&#125;#main&#123; #card .d();&#125;#con&#123; //不得单独使用命名空间的方法 //.d() 如果前面没有引入命名空间 #card ，将会报错 #card; // 等价于 #card(); .d(20px); //必须先引入 #card&#125;/* 生成的 CSS */#wrap&#123; height:100px; width:300px;&#125;#main&#123; width:300px;&#125;#con&#123; width:20px;&#125; less的继承extend 是 Less 的一个伪类。它可继承 所匹配声明中的全部样式。extend（这里放规则）是一个函数 12345678910111213141516171819202122/* Less *///规则的定义，没有参数.animation&#123; transition: all .3s ease-out; .hide&#123; transform:scale(0); &#125;&#125;#main&#123; &amp;:extend(.animation);&#125;#con&#123; &amp;:extend(.animation .hide);&#125;/* 生成后的 CSS */.animation,#main&#123; transition: all .3s ease-out;&#125;.animation .hide , #con&#123; transform:scale(0);&#125; all全局搜索替换使用选择器匹配到的 全部声明。 123456789101112131415161718/* Less */#main&#123; width: 200px;&#125;#main &#123; &amp;:after &#123; content:&quot;Less is good!&quot;; &#125;&#125;#wrap:extend(#main all) &#123;&#125;/* 生成的 CSS */#main,#wrap&#123; width: 200px;&#125;#main:after, #wrap:after &#123; content: &quot;Less is good!&quot;;&#125; 从表面 看来，extend 与 方法 最大的差别，就是 extend 是同个选择器共用同一个声明，而 方法 是使用自己的声明。 ## less避免编译 ~&quot;XXXXX&quot; less之中避免编译，让浏览器编译]]></content>
      <tags>
        <tag>css</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[element-ui总结]]></title>
    <url>%2F2019%2F04%2F19%2Felement-ui%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在一次项目中用到了element-ui框架，对在使用过程中遇见的问题进行总结（持续更新）。 表单1.数据为二级对象时数据为二级对象时，验证的数据要用字符串形式。 12345rules:&#123; "captainInformation.name": [ &#123; required: true, message: '请输入姓名', trigger: 'blur' &#125;, ], &#125; 2.动态添加的数据动态添加的输入框或表单绑定数据时注意 :prop=&quot;&#39;v-for绑定的数组.&#39; + index + &#39;.v-model绑定的变量&#39;&quot; 我是直接把验证写在标签里面的 1&lt;el-form-item label=&quot;姓名&quot; :prop=&quot;&apos;memberInformation.&apos;+index+&apos;.name&apos;&quot; :rules=&quot;[ &#123; required: true, message: &apos;请输入姓名&apos;, trigger: &apos;blur&apos; &#125;]&quot;&gt; 增加与减少成员 123456789101112//增加成员 addmember() &#123; let newmember = &#123; name: &quot;&quot;, studentId: &quot;&quot;, &#125; this.form.memberInformation.push(newmember) &#125;, //减少成员 reducemember(index) &#123; this.form.memberInformation.splice(index, 1) &#125;, 这个是我在项目中用到的办法，在阅读时发现了另一种情况的解决办法：https://blog.csdn.net/weixin_41041379/article/details/81908788 3.普通输入验证1234567891011rules:&#123;data1:[//必填，trigger是触发类型&#123; required: true, message: '请输入学号', trigger: 'blur' &#125;,//数字类型 'number', 整数: 'integer', 浮点数: 'float'//使用整数的时候，首先要保证数据类型为数字，可以v-model.number绑定数据&#123;type: 'integer', message: '格式错误', trigger: 'blur'&#125;,//长度限制&#123; min: 2, max: 4, message: '长度在 2 到 4 个字符', trigger: 'blur' &#125;]&#125; 4.手动验证 第一种是直接写在rules的里面 1234567891011rules:&#123;data1:[ &#123; validator:(rule,value,callback)=&gt;&#123; if(/^\d+$/.test(value) == false)&#123; callback(new Error(&quot;只能输入数字&quot;)); &#125;else&#123; callback(); &#125; &#125;, trigger: &apos;blur&apos; &#125;&#125;] 第二种写法是抽离出来 1234567891011121314151617181920212223//注意书写位置 data()&#123; let checkAge = (rule, value, callback) =&gt; &#123; if (!value) &#123; return callback(new Error(&apos;年龄不能为空&apos;)); &#125; if (!Number.isInteger(value)) &#123; callback(new Error(&apos;请输入数字值&apos;)); &#125; else &#123; if (value &lt; 18) &#123; callback(new Error(&apos;必须年满18岁&apos;)); &#125; else &#123; callback(); &#125; &#125; &#125; return &#123; rules:&#123; age: [ &#123; trigger: &apos;blur&apos;, validator: checkAge &#125; ] &#125; &#125; 5.手动上传文件12345678910111213141516171819202122232425262728293031323334353637//html &lt;el-upload action ref="upload" //覆盖默认的上传行为，自定义上传的实现 :http-request="finish" //取消自动上传 :auto-upload="false" &gt; &lt;el-button slot="trigger" size="small" type="primary"&gt;选取文件&lt;/el-button&gt; &lt;div slot="tip" class="el-upload__tip"&gt;请上传您的项目功能清单&lt;/div&gt; &lt;/el-upload&gt;//js finish() &#123; this.$refs.form.validate(valid =&gt; &#123; // 验证成功 if (valid) &#123; //这里的需求是必须上传文件 const file = this.$refs.upload.uploadFiles[0]; if (!file) &#123; this.$message(&#123; type: "warning", message: "请选择文件" &#125;); return; &#125; //数据处理 let formData = new FormData(); formData.append("projectId", this.runId); formData.append("timeNode",JSON.stringify(this.form.timeNode)); formData.append("teamId", 1); formData.append("functionFile",file.raw ); //....中间的弹框确定等省略 submitApply(formData) &#125; &#125; &#125; 6.动态获取选项+模糊查询]]></content>
      <tags>
        <tag>vue</tag>
        <tag>库</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[order2]]></title>
    <url>%2F2019%2F03%2F30%2Forder2%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[css总结]]></title>
    <url>%2F2019%2F03%2F28%2Fcss%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[CSS总结在学习的过程中，对css有了更深一步的了解，把遇见过的问题以及经常使用到的样式做一个总结。 清除默认样式http://yui.yahooapis.com/3.18.1/build/cssreset/cssreset-min.css 清除浮动 方法一 给受影响的盒子添加clear属性，添加了clear的属性不可以添加margin-top 方法二 12345678910浮动元素::after&#123; content:&quot;&quot;; display:block; height:0; visibility:hidden; clear:both&#125;浮动元素&#123; *zoom:1;//兼容IE6&#125; 盒子的问题 在默认布局的垂直方向上，外边距有合并现象 嵌套盒子时，里面的盒子设置margin-top时，父盒子一起被顶下来。 解决办法：父盒子添加border，或者overflow：hidden 在默认布局的垂直方向上，外边距有合并现象 图片的问题 自适应图片 123max-width:100%;height:auto;display:block 设置图片img的width和height的时候，指定其中一个另外一个自动算出来 当图片宽度大于父元素宽度时，居中：父元素text-align：center,子元素：margin：0，-100% 居中 居中元素有宽度 12345 .center &#123;width: 960px;margin-left: auto;margin-right: auto; &#125; margin:0 auto 使用场景块级元素：给定要居中的块级元素的宽度行内元素： ①设置display:block。 ②给定要居中的行内元素的宽度。（行内元素设置成块级元素后可以对其宽高进行设置） 注：①所有元素也可以通过对父元素设置 text-align：center；的方式来实现居中。(而对于块元素来说，对要居中的元素自身进行设置text-align:center也能实现居中——而无需对其父元素进行设置) 。 ②浮动、绝对定位、固定定位的盒子失效。 脱离文档流元素的水平垂直 margin:auto或者按圆点定位定在正中间，margin设置成负的宽高的一般 1234567891011121314div&#123; width: 300px; height: 300px; position: relative; border: 1px solid #465468; &#125; img&#123; position: absolute; margin: auto; top: 0; left: 0; right: 0; bottom: 0; &#125;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端—点餐(前端)1]]></title>
    <url>%2F2019%2F03%2F28%2Forder1%2F</url>
    <content type="text"><![CDATA[学习了vue之后，用vue全家桶进行了项目练习。此篇博客记录开发流程。 1.创建客户端项目1.1 使用 vue-cli(脚手架)搭建项目123vue init webpack ordercd ordernpm run dev (启动) 1.2 项目结构分析 order |– build : webpack 相关的配置文件夹(基本不需要修改) |– config: webpack 相关的配置文件夹(基本不需要修改) |– index.js: 指定的后台服务的端口号和静态资源文件夹 |– node_modules |– src : 源码文件夹 |– main.js: 应用入口 js （初始化vue实例并使用需要的插件 ） |– static: 静态资源文件夹 |– .babelrc: babel 的配置文件 |– .editorconfig: 通过编辑器的编码/格式进行一定的配置 |– .gitignore: git 版本管理忽略的配置 |– index.html: 默认的主渲染页面文件 |– package.json: 应用包配置文件 |– README.md: 应用描述说明的 readme 文件 1.3 编码测试与打包发布项目 编码测试 npm run dev 编码, 自动编译打包(HMR), 查看效果 config/index/ 修改autoOpenBrowser: true后可以自动开启 打包发布 npm run build npm install -g serve serve dist 2. 开发资源准备2.1 字体图片 生成项目图标的Font Class地址添加到index.html 2.2 依赖安装 安装stylus依赖包1npm install stylus stylus-loader --save-dev 在common文件夹下新建stylus文件夹 在stylus文件加下面新建mixins.styl文件 注意在组件内编写样式时要声明lang和rel 1&lt;style lang="stylus" rel="stylesheet/stylus"&gt; 安装element-ui框架1npm i element-ui -S 在main.js中引入123import ElementUI from &apos;element-ui&apos;;import &apos;element-ui/lib/theme-chalk/index.css&apos;;Vue.use(ElementUI); 2.3 移动端 Fastclick 当用户一次点击屏幕之后，浏览器并不能立刻判断用户是要进行双击缩放，还是想要进行单击操作。因此，iOS Safari 就等待 300 毫秒，以判断用户是否再次点击了屏幕。 于是，300 毫秒延迟就这么诞生了。 安装fastclick库 解决点击响应延时 0.3s 问题 1npm install fastclick --save 在main.js中引入，并绑定到body 12import FastClick from 'fastclick'FastClick.attach(document.body); viewport 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt; 2.4 浏览器样式重置 在项目主目录下的static文件夹内新建css文件夹 在css文件夹内新建重置样式文件reset.css 在index.html 中引入 1&lt;link rel="stylesheet" href="/static/css/reset.css"&gt; 3. vue组件化3.1分析整个项目的Vue组件结构 页面底部的FooterGuide组件只是用来放pages里的组件的容器，所以它不是路由组件 页面最上面的标题栏在我们的项目中属于路由组件的组成部分（与中间内容部分在一起） 但每个路由组件中都有最顶部的组件且相似度很高，所以可以将其抽取成为一个单独的组件]]></content>
      <tags>
        <tag>vue</tag>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fiddle]]></title>
    <url>%2F2019%2F01%2F21%2Ffiddle%2F</url>
    <content type="text"><![CDATA[fiddle学习笔记简介fiddlefiddle是Web调试工具，相当于代理服务器，先到fiddle再到目标服务器 截获http/https请求并查看 伪造请求 测试性能 两种代理模式 流模式(streaming):实时，更接近与浏览器本身的工作 缓冲模式(buffering):等待所有数据都准备好了，才返回。 可控制最后的服务器响应 使用场景 开发环境host配置 前后端接口调试 线上bugfix 性能分析与优化 使用工具条常用功能 气泡：捕捉到的会话添加备注 replay：请求回放 ×：清空监控面板 GO：调试Debug，res，req请求断点 stream：模式切换 decode：解压请求 any process：过滤请求 find：查找 clear cache：清空浏览器缓存 textWizard：编码/解码 tearoff：面板分离 MSDN：MSDN搜索 状态栏 黑色的框：命令行 Capturing: 控制fiddle是否工作 监控面板的使用 statistics：反应性能上的指标。RTT：往返时间。show chart：数据可视化 inspectors:对请求进行解包 AutoResponder:文件代理，比如需要服务器返回的文件，使用本地文件做代理。 Composer:前后端接口连调（把一个会话拖进去，可以进行修改，伪造请求） 常用功能 host配置：让服务器指向本地 1. tools-host 2. 激活这个功能 3. 在最后修改至本地的地址 文件代理 请求模拟，前后端接口链调 网络限速 参考资料：https://www.cnblogs.com/conquerorren/p/8472285.html]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js页面属性]]></title>
    <url>%2F2018%2F12%2F18%2Fjs%E9%A1%B5%E9%9D%A2%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[页面属性 offsetWidth /offsetHeight 12345//js对元素操作，只能获取不可以改变//获取对象自身的宽度和高度 ，包括内容、边框和内边距，即：offsetWidth = width + border + paddingbox.offsetWidth//注意：和 div.style.width 的区别，其只能获取到行内的数值div.style.width offsetLeft 和 offsetTop 距离第一个有定位的父级盒子左边和上边的距离，注意：父级盒子必须要有定位，如果没有，则最终以body为准！offsetLeft和offsetTop从从父标签的padding开始计算，不包括border。即：从子盒子边框到定位父盒子边框的距离。 offsetParent 返回当前对象的父级（带有定位）盒子，若爷爷也有则选择进近的 clientWidth/clientHeight 网页可见区域宽和高 clientLeft，clientTop 返回的是元素边框的borderWidth，如果不指定一个边框或者不定位改元素，其值就为0 document.body.scrollWidth; document.body.scrollHeight; 网页正文全文宽网页正文全文高 document.body.scrollTop; 网页被卷去的高 document.body.scrollLeft; 网页被卷去的左 区别 left和top分析： clientLeft: 左边边框的宽度；clientTop: 上边边框的宽度 offsetLeft: 当前元素距离有定位的父盒子左边的距离；offsetTop: 当前元素距离有定位的父盒子上边的距离 scrollLeft: 左边滚动的长度; scrollTop: 上边滚动的长度; width和height分析 clientWidth\/Height: 内容 + 内边距 offsetWidth\/Height: 内容 + 内边距 + 边框 scrollWidth\/Height: 滚动内容的宽度和高度]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wepig总结1]]></title>
    <url>%2F2018%2F12%2F14%2Fwepig2%2F</url>
    <content type="text"><![CDATA[在编写项目的过程中，遇到了很多不会的地方，通过查找资料学习到了很多新的知识，所以把记录了下来。 学习总结router的传参 传参及获取参数 1path:&apos;/user/:name&apos; :name表示接收的参数 123$router.params.name//url后面跟了?参数，用query获取$router.query.age 链接追加 1&lt;router-link to=&quot;more&quot; append&gt;&lt;/router-link&gt; append表示在当前的页面路径后面添加more name 指定该条路由的名字 12//给名叫user的路由传参this.router.push(&#123;name:&apos;user&apos;,params:&#123;传递的参数&#125;) 视图命名当一个组件的界面有两个的 的时候，可以通过给其命名name=XXX，区分显示的是哪一个 在路由页面映射的时候，是 components ，不在是component了。 1234567&#123;path:&quot;/user&quot;,components:&#123; 视图一的名字:对应显示的组件 视图二的名字:对应显示的组件&#125;&#125; vue导航守卫参考文章:https://blog.csdn.net/weixin_39398244/article/details/83342761 全局前置守卫 router.beforeEach常常用于权限和状态的检验 当从一个路由跳转到另一个路由 之前 触发此守卫，任何路由跳转都会触发。 123456789const router = new VueRouter(&#123;...&#125;)router.beforeEach((to,from,next)=&gt;&#123; //... //这是获取准备去的地址 to.path==.. //匹配访问路径，会从父级一层一层下去 to.marched==&#125;) 每个守卫都有三个参数to：这是你要跳去的路由对象from：这是你要离开的路由对象next：是一个方法，接收参数，这个方法必须调用，否则就不能跳转 - next() 跳转 - next(false) 中断跳转 - next({path:&quot;/&quot;}) 中断当前跳转，跳转到新的路径 全局后置钩子 router.afterEach钩子不会接收next函数，也不会改变导航本身。12router.afterEach((to, from) =&gt; &#123; // ... 路由独享守卫 beforeEnter这个守卫是写在路由里面的，只有当进入这个路由时才会调用的，这些守卫与全局前置守卫的方法参数是一样的。 123456789101112const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/foo&apos;, component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // ... &#125; &#125; ]&#125;) 组件内守卫 beforeRouteEnter，beforeRouteUpdate，beforeRouteLeave这三个守卫是写在组件里，beforeRouteEnter守卫 不能 访问 this，因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。 不过，你可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。其他两个都可以用this。 1234567891011121314151617const Foo = &#123; template: `...`, beforeRouteEnter (to, from, next) &#123; // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！获取组件实例 `this` // 因为当守卫执行前，组件实例还没被创建 &#125;, beforeRouteUpdate (to, from, next) &#123; // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` &#125;, beforeRouteLeave (to, from, next) &#123; // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` &#125; 完整导航流程。 导航被触发。 在失活的组件里调用离开守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫 (2.5+)。 导航被确认。 调用全局的 afterEach 钩子。 触发 DOM 更新。 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。 meta路由元信息：定义路由的时候可以配置mate字段 12345678910111213141516const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/foo&apos;, component: Foo, children: [ &#123; path: &apos;bar&apos;, component: Bar, // a meta field meta: &#123; requiresAuth: true &#125; &#125; ] &#125; ]&#125;) 访问/foo/bar这个URL将会匹配 父路由记录 以及 字路由记录一个路由匹配到的所有路由记录会暴露为$route对象 (还有在导航守卫中的路由对象) 的 $route.matched 数组。因此，我们需要遍历 $route.matched 来检查路由记录中的 meta 字段。 常常用于不同页面的标题显示，或者原网页的head标签内容里面的东西]]></content>
      <tags>
        <tag>vue</tag>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wepig]]></title>
    <url>%2F2018%2F12%2F14%2Fwepig%2F</url>
    <content type="text"><![CDATA[记录项目实现的流程 项目流程]]></content>
      <tags>
        <tag>vue</tag>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex流程总结]]></title>
    <url>%2F2018%2F12%2F09%2Fvuex%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[对如何异步显示数据效果的编码流程进行了总结 ajaxajax请求函数，抛出接口 vuex store里面新建index完成基本配置 123456789101112131415161718192021222324/*vuex最核心的管理对象store组装模块并导出 store 的地方 */// 首先引入Vue及Vueximport Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;// 引入四个基本模块import state from &apos;./state&apos;import mutations from &apos;./mutations&apos;import actions from &apos;./actions&apos;import getters from &apos;./getters&apos;// 一定要声明使用插件Vue.use(Vuex)// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件export default new Vuex.Store(&#123; state, mutations, actions, getters&#125;) 现在Vue对象里面挂载store 1234567import store from &apos;./store&apos;new Vue(&#123; el: &apos;#app&apos;, components: &#123; App &#125;, template: &apos;&lt;App/&gt;&apos;, store //所有的组件都多了一个$store&#125;) 在store下新建state.js state：用于存储状态对象 123export default &#123;user:&#123;&#125;&#125; 在store下新建mutation-types.js mutation是操作state状态的，mutation-types是存放操作state的方法名 1export const RECEIVE_USER_INFO = &apos;receive_user_info&apos; // 接收用户信息 在store下新建actions.js action是通过操作mutation间接更新state的多个方法的对象 起连接作用。 异步获取数据。(注意需要引入api接口函数)把数据传给mutation。(因为mutation的方法名是放在mutation-types里面，所以注意要引入mutation-types里面对应的方法名) 123456789101112131415161718import &#123;reqUserInfo,&#125; from &apos;../api&apos;import &#123; RECEIVE_USER_INFO,&#125; from &apos;./mutation-types&apos; // 异步获取用户信息 async getUserInfo (&#123;commit&#125;) &#123; const result = await reqUserInfo() //如果请求成功，返回code=0 if (result.code === 0) &#123; const userInfo = result.data //提交mutation //把结果&#123;userInfo&#125;提交给RECEIVE_USER_INFO方法 commit(RECEIVE_USER_INFO, &#123;userInfo&#125;) &#125; &#125;, 参数除了commit以外，还可以有state{commit,state} 在store里面新建mutations.js mutations直接对state进行操作，[方法名](state,{param}){} 默认第一个参数state，所以需要引入vue与方法名 123456789import Vue from &apos;vue&apos;import &#123; RECEIVE_USER_INFO, &#125; from &apos;./mutation-types&apos;export default &#123; [RECEIVE_USER_INFO] (state, &#123;userInfo&#125;) &#123; state.userInfo = userInfo &#125; &#125; 使用数据 一般放在computed中进行接收，有利于state的值发生改变的时候及时响应给子组件。 mapState辅助函数mapState返回的是一个对象 其实就是返回值:{return this.$store.XXXX} 当一个组件需要获取多个状态时候，用mapState辅助函数更为方便 1234567891011121314import &#123; mapState &#125; from &apos;vuex&apos;export default &#123;computed:mapState(&#123;//方法一：箭头函数count: state =&gt; state.count;//方法二：传字符串参数&apos;count&apos;等同于‘state=&gt;state.count’count:&apos;count&apos;;//方法三，使用this获取局部状态，必须使用常规函数count(state)&#123; return this.count&#125;&#125;)&#125; 当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。 1computed:mapState([ &quot;count&quot;]) …mapState() ...mapState是state的语法糖，使用时需要从vuex中引入 123computed:&#123;...mapState(&#123;&#125;)&#125; mapGetters 辅助函数 mapGetters辅助函数仅仅是将store中的getter映射到局部属性 12345678910111213import &#123; mapGetters &#125; from &apos;vuex&apos;export default &#123; // ... computed: &#123; // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters([ &apos;doneTodosCount&apos;, &apos;anotherGetter&apos;, // ... ]) &#125;&#125; mapActions 类似mapState getter计算属性 12345computed: &#123; doneTodosCount () &#123; return this.$store.state.todos.filter(todo =&gt; todo.done).length &#125; &#125; 如果有多个组件需要用到这个属性，可以在store里面定义‘getter’，可以说是store的计算属性，像计算属性一样，getter的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算 1234567891011121314151617181920212223242526272829 const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: &apos;...&apos;, done: true &#125;, &#123; id: 2, text: &apos;...&apos;, done: false &#125; ] &#125;, getters: &#123; //state作为第一个参数 doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; //可以接收其他getter作为第二个参数 doneTodosCount: (state, getters) =&gt; &#123; return getters.doneTodos.length &#125; //可以通过让getter返回一个函数，来实现给getter传参,对store里的数组进行查询时非常有作用 getTodoById: (state) =&gt; (id) =&gt; &#123; return state.todos.find(todo =&gt; todo.id === id) &#125; //store.getters.getTodoById(2) // -&gt; &#123; id: 2, text: &apos;...&apos;, done: false &#125; &#125; &#125;) //在组件中使用，同计算属性的调用，不用加括号 this.$store.getters.doneTodosCount dispatch方法 dispatch(actionName,data)分发调用action，第一个参数是方法名，第二个是数据 触发store里面的action对应方法名的函数 1this.$store.dispatch(&quot;&quot;)]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[summary_js]]></title>
    <url>%2F2018%2F11%2F24%2Fsummary_js%2F</url>
    <content type="text"><![CDATA[enter回车 持续更新 在修改项目的过程中，学习到了关于表单enter键提交是否可以触发 如果type是submit，一个文本或者多个文本都会提交 如果是button，仅一个文本的时候提交 type为image的按钮，等同于type为submit的效果 用button时，fx和IE有不同的表现。radio和checkbox在FX下也会触发提交表单，在IE下不会 事件代理，事件委托利用的是冒泡原理，与事件源。还可以用来给动态添加的元素绑定事件 事件源 兼容 12let e = e || window.event;var target = e.target || e.srcElement; 属性 12345678console.log(e.target);console.log(e.target.id);console.log(e.target.tagName);console.log(e.target.nodeName); console.log(e.target.classList);console.log(e.target.className);console.log(e.target.innerHTML);console.log(e.target.innerText); es6 箭头函数 回调函数为匿名函数时，回调函数的this会指向window，需要对回调函数bind(this)。回调函数为箭头函数时，回调函数的this会指向他的直接上层，本例中指向obj,objx。回调函数就是一个参数，将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数。这个过程就叫做回调。 不绑定this箭头函数的this其实就是在定义的时候就确定好的，以后不管怎么调用这个箭头函数，箭头函数的this始终为定义时的this 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。所以说在箭头函数中的this指向是固定的 最好不要用箭头函数作为对象的方法。 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 箭头函数还有一个比较有特点的地方就是其不绑定arguments,或者用rest参数代替 但是如果在箭头函数需要参数时，可以使用剩余参数来取代arguments 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。123var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;; 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 12345// 报错let getTempItem = id =&gt; &#123; id: id, name: &quot;Temp&quot; &#125;;// 不报错let getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;); es6 module模块通过export抛出，import引入 export 抛出一个变量 12345//写法一export let firstName = 'Michael';//写法二let firstName = 'Michael';export &#123;firstName&#125;; as关键字重命名 1234function v1() &#123; ... &#125;export &#123; v1 as streamV1,&#125;; 抛出默认 1export default xxx import 接收一个变量 1import &#123;firstName&#125; from &apos;./profile.js&apos;; as关键字重命名 1import &#123; firstName as surname &#125; from &apos;./profile.js&apos;; import命令输入的变量都是只读的，因为它的本质是输入接口，不可以修改 整体加载 1import * as XXX from &apos;./profile.js&apos;; 引入默认抛出的接口，可以自己随便命名 js跳转https://www.cnblogs.com/Renyi-Fan/p/9130325.html js对打开的页面ULR进行跳转， location的href属性 open 方法 histoty的三个方法 location的assign方法 常规的js页面跳转 在原来的窗口中直接跳转 1window.location.href=&quot;你所要跳转的页面&quot;; 在新窗口中打开页面用 12window.open(&apos;你所要跳转的页面&apos;);//open属性的参数 &apos;page.html&apos; 弹出窗口的文件名；&apos;newwindow&apos; 弹出窗口的名字（不是文件名），非必须，可用空&apos;代替；height=100 窗口高度；width=500 窗口宽度；top=0 窗口距离屏幕上方的象素值；left=0 窗口距离屏幕左侧的象素值。 ##[object Object] 这个不是两个对象的意思，是对象的字符串形式，是隐式调用了Object对象的toString()方法，形式是”[object Object]”.[object objcet] 自定义的对象 没有覆盖toString方法，返回默认[object] window对象 覆盖了toString方法，显式调用返回[object Object]123 字条串 覆盖了toString方法，显式调用返回[object String] 在我做项目的时候遇见了一个问题，把对象放进cookie之后，cookie存储的格式变成了object Object,解决办法是转化成字符串之后存入,使用时再解析成json对象 JSON.parse()【从一个字符串中解析出json对象】 123456//定义一个字符串var data=&apos;&#123;&quot;name&quot;:&quot;goatling&quot;&#125;&apos;//解析对象​​JSON.parse(data)结果是：​name:&quot;goatling&quot; JSON.stringify()【从一个对象中解析出字符串】 1234var data=&#123;name:&apos;goatling&apos;&#125;JSON.stringify(data)结果是：&apos;&#123;&quot;name&quot;:&quot;goatling&quot;&#125;&apos;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rem]]></title>
    <url>%2F2018%2F11%2F18%2Frem%2F</url>
    <content type="text"><![CDATA[rem rem是相对于根元素的字体大小相对单位 类似与em，不过rem是依赖根元素计算的，em是依赖父元素计算的 rem能等比例适配所有屏幕 这里有个插件flexible.js就是用rem实现的 这个button按钮的宽度为120px，高度为60px 123456789101112131415html&#123; font-size:20px;&#125;.btn &#123; width: 6rem; height: 3rem; line-height: 3rem; font-size: 1.2rem; display: inline-block; background: #06c; color: #fff; border-radius: .5rem; text-decoration: none; text-align: center;&#125; 如果是不同分辨率下的font-size的值，应该如何计算计算之后可以用媒体查询设置html的font-size值 移动端页面自适应解决方案 不需要手动设置viewport了 原理是根据设备屏幕的DPR(设备像素比，比如dpr=2时，表示1个CSS像素由4个物理像素点组成） 动态设置 html 的font-size, 同时根据设备DPR调整页面的缩放值，进而达到高清效果。) 绝不是每个地方都要用rem，rem只适合与固定宽度 此方案也是默认1rem=100px 比如你在效果图上量取的某个按钮元素长 55px, 宽37px 1234.myBtn &#123; width: 0.55rem; height: 0.37rem;&#125;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex]]></title>
    <url>%2F2018%2F11%2F11%2Fvuex%2F</url>
    <content type="text"><![CDATA[vuex主要是状态管理，将数据统一管理(state) 模块 状态对象 stat 操作state 直接更新state的多个方法对象 mutations 操作mutations 间接更新state的多个方法对象 actions 包含多个基于state的getter计算属性的对象 getters 包含n个mutations的type名称常量 mutations-type 引入12import Vuex from 'vuex'Vue.use(Vuex) 使用共享的数据1const state=&#123;&#125;; 建立统一数据容器，唯一的容器123let store = new Vuex.Store(&#123; state&#125;) store(容器)注册到实例上，main.js里面，所有的组件都会有一个属性this.$store123new Vue(&#123;store,&#125;) 在组件中使用，加不加this都一样1&#123;&#123;this.$store.state.XXX&#125;&#125; state(单向数据流) 注意,在组件中最好不要直接更改共享的数据，共享的数据仅仅给组件染 mutation 通过mutation(管理员)来更改状态，可以在store里面设置成严格模式 strict：true，mutation不支持异步 告诉mutations需要更改,mutations相当于methods 123456789101112const mutations=&#123; add(state,count)&#123; //state是自动放入的，默认指的就是当前的state //操作state的属性 state.XXX +=count &#125;&#125;let store = new Vuex.Store(&#123;state，mutations,strict：true&#125;) 组件通过mutations提交,第一个参数是与mutatioons里面的方法绑定，第二个参数是自定义参数 1this.$store.commit(&apos;add&apos;,2) 插件打印日志1234import logger from &apos;vuex/dist/logger&apos;const store = new Vuex.store(&#123; plugins:[logger()]&#125;) 整理src下面创建一个store文件\index.js 123456789101112import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)import logger from 'vuex/dist/logger'const state=&#123;&#125;;import mutations from './mutations'export default new Vuex.Store(&#123; state， mutations, strict：true, plugins:[logger()] &#125;) store下面再创建一个mutations.js,里面存放mutations的相关123456789101112import * as Types from &apos;mutations.types.js&apos;const mutations = &#123; // [方法名](state,&#123;param&#125;)&#123;&#125;[Types.INCREMENT](state)&#123; state.count+=1&#125;,[Types.DECREMENT](state)&#123; state.count-=1&#125;&#125;;export default mutations; 宏(一般大写)store下面再创建一个mutations.types.js里面存放mutations的方法的名字，方便查找1234//增加export const INCREMENT=&apos;INCREMENT&apos;//减少export const DECREMENT=&apos;DECREMENT&apos; 组件中引入同mutations.js中引入一样,只不过不加中括号import * as Types from ‘mutations.types.js’ Types.INCREMENTTypes.DECREMENT getters相当于computed,如果数据多了可以模仿mutations的抽离12345678910const getters=&#123; val(state)&#123; state.count%2?&apos;奇数&apos;:&apos;偶数&apos; &#125;&#125;;export default new Vuex.store(&#123;getters,&#125;)//引用时&#123;&#123;$store.getters.val&#125;&#125; actions 和后台交互的异步action，后台数据也需要修改 Action 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 引入api以及mutation-types 异步获取数据 异步获取地址 发送异步ajax请求 提交一个mutation 12345678910 //async 方法名(&#123;commit,参数可选&#125;&#123;&#125;)// 异步获取地址 async getAddress (&#123;commit, state&#125;) &#123; // 从state状态中获取到经纬度用来设置reqAddress的参数（看接口文档） const geohash = state.latitude + &apos;,&apos; + state.longitude // 1. 发送异步ajax请求 const result = await reqAddress(geohash) // 2. 根据结果提交一个mutation commit(RECEIVE_ADDRESS, &#123;address: result.data&#125;) &#125;,]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stylus]]></title>
    <url>%2F2018%2F10%2F29%2Fstylus%2F</url>
    <content type="text"><![CDATA[stylus学习笔记 冒号可选，分号可选，逗号可选，括号可选 缩进与空格很重要 12body color white 父级引用 &amp; 1234567891011121314textareainput color #A7A7A7 &amp;:hover color #000//等于textarea, input &#123; color: #a7a7a7; &#125; textarea:hover, input:hover &#123; color: #000; &#125; 变量 属性查找 @ 12345678#logo position: absolute top: 50% left: 50% width: 150px height: 80px margin-left: -(@width / 2) margin-top: -(@height / 2) 运算符 范围 .. 包含界限 …包含开头不包含结尾 存在操作符in 实例检查 is a 条件赋值：?= := 变量定义：is defined 混合书写 方法]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[demo_vue-book]]></title>
    <url>%2F2018%2F10%2F27%2Fvue-book%2F</url>
    <content type="text"><![CDATA[vue-book 接下来会学习vuex，在学习一门预处理语言，之后用我学过的所有东西做一个练习的项目vue学习之后，用vue-cli做的一个练习。这是学习vue的过程中走通了一遍流程，但还有很多功能没有实现 上拉下拉刷新 图片的懒加载 打包之后如何上线 vuex的学习 如何连接数据库等 github:https://github.com/biubiuins/vue-book 安装依赖 npm install vue npm install -g webpack npm install -g vue-cli npm install less less-loader axios vuex bootstrap 目录 build 打包后的脚本文件 src 源码文件 mock后台代码，模拟数据 src/api 代表的是所有的接口,获取数据给前端调用 src/base 基础组件 src/components 页面组件实现路由根据页面划分了5个页面组件 首页 Home.vue 列表 List.vue 收藏 Collect.vue 添加 Add.vue 详情 Detail.vue 配置路由，配置路由映射表并new个实例,挂载在根组件上，router-view显示在App.vuerouter/index.js Vue.use()是用来安装Vue插件123import Vue from 'vue'import Router from 'vue-router'Vue.use(Router); 这里用了模板，将会另外写一篇，关于前端的模板与node的 导航base/Tab.vuescoped 表示是当前组件的样式，并不是全局的1&lt;style scoped lang=&quot;less&quot;&gt; less预处理语言，学习之后会写一篇博客 点击导航之后会通过to跳转页面，并且样式改变这里需要注意/home 确切激活，仅仅这个路径有效。router-link-exact-active/home /home/a 都可以。router-link-active123&lt;router-link to=&quot;/add&quot;&gt;&lt;i class=&quot;iconfont icon-add&quot;&gt;&lt;/i&gt;&lt;span&gt;添加&lt;/span&gt;&lt;/router-link&gt; 基础组件Tab挂载在App.vue上（导航很多页面都需要），并在App.vue上写全局的样式，清除默认样式。新学习到的清除输入框和按钮的默认样式1input，button&#123;appearance:none;&#125; App.vue的组件中有name: &#39;App&#39;，这里name: &#39;app&#39; 相当于一个全局 ID。可以不写，写了可以提供更好的调试信息。页面渲染也是在App.vue中实现的 图标http://www.iconfont.cn/home/index?spm=a313x.7781069.1998910419.2图标打包好了之后在index.html中引入\iconfont是必须类名表明是个icon，后面根据页面选择1&lt;i class=&quot;iconfont icon-shouye&quot;&gt;&lt;/i&gt;&lt;span&gt;首页&lt;/span&gt; 头部base/Mheader.vue头部的标题不是全部一样的，并且比如首页是没有返回键的，所以这里用到的插槽和父组件给子组件传值这里用Home.vue-Mheader.vue为例 在父组件上挂载Mheader.vue &lt;Mheader.vue&gt;首页，首页需要显示出来，需要在子组件Mheader.vue中放个匿名插槽接收 父组件需要传递一个值告诉子组件是否显示返回键。子组件接收back，不需要验证的时候用数组，需要验证的时候用对象。 12345 &lt;i class=&quot;iconfont icon-fanhui&quot; v-if=&quot;back&quot;&gt;&lt;/i&gt;...props:&#123; back:&#123;type:Boolean,default:false&#125; &#125; 点击返回键，返回上一个操作 1this.$router.go(-1); 扩展一下,back也可以返回。this.$router.back() 强制跳转页面，在后面追加，点返回还可以回去。this.$router.push(‘/XXX’) 路由替换，将原来的替换。this.$router.replace(‘/XXX’)轮播图base/Swiper.vue安装依赖1npm install vue-awesome-swiper --save-dev 在main.js中引入vue-awesome-swiper插件123import VueAwesomeSwiper from &apos;vue-awesome-swiper&apos;import &apos;swiper/dist/css/swiper.css&apos;Vue.use(VueAwesomeSwiper) 后台获取图片信息mock/sliders.js 存放图片连接mock/server.js 配置服务器url.parse()可以将一个完整的URL地址，分为很多部分，常用的有：host、port、pathname、path、query。12345678let sliders = require(&apos;./sliders&apos;)http.createServer((req,res)=&gt;&#123;let&#123;pathname,query&#125; = url.parse(req.url); if (pathname === &apos;/sliders&apos;)&#123; res.setHeader(&apos;Content-Type&apos;,&apos;application/json;charset=utf-8&apos;) res.end(JSON.stringify(sliders)) &#125;&#125; 但是当前段发起ajax请求的时候，是8080端口请求3000端口的数据，所以有跨域的问题，这里需要在服务器中加入跨域头12345res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,Content-Length, Authorization, Accept,X-Requested-With&quot;);res.setHeader(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;);res.setHeader(&quot;X-Powered-By&quot;,&apos; 3.2.1&apos;)if(req.method==&quot;OPTIONS&quot;) return res.end();/*让options请求快速返回*/ 轮播图的api12345678import axios from 'axios';//设置基本的默认请求路径axios.defaults.baseURL ='http://localhost:3000';//获取轮播图数据export let getSliders=()=&gt;&#123; //因为设置了了efaults.baseURL，所以它请求的路径其实是http://localhost:3000/sliders,返回的是一个promise对象 return axios.get('/sliders')&#125; axios 笔记待整理 前端获取数据获取的数据父子组件传值，传给子组件，子组件渲染出图片如果给接收到的data一个新的名字 slider {data：slider}1234async created()&#123; let &#123;data&#125; = await getSliders().then() this.sliders=data&#125;, async/await 已整理 热门图书/删除图书 先写服务端，确保数据能正常返回 增加api方法，实现调取数据的功能 在哪个组件中应用这个api，如果是一个基础组件需要这些数据，在使用这个组件的父级中调用这个方法，将数据传递给基础组件 详情页面如果用对象作为to的属性，并且使用了参数，必须给路由起个名字，通过名字跳转router/index.js1&#123;path:&apos;/detail/:bid&apos;,component:Detail,name:&apos;detail&apos;&#125; component/List.vue需要配置路径参数，点击哪个li跳转哪个详情这是跳转用到router-link，把之前的li改为router-link， params是路径参数 循环组件，需要加上key router-link是a标签，这里需要的是li，在taf里面修改1&lt;router-link v-for=&quot;(book,index) in books&quot; :to=&quot;&#123;name:&apos;detail&apos;,params:&#123;bid:book.bookId&#125;&#125;&quot; :key=&quot;index&quot; tag=&quot;li&quot; &gt; 因为点击li跳转，删除按钮也在li里面，所以这个应该阻止删除按钮冒泡1&lt;button @click.stop=&quot;remove(book.bookId)&quot;&gt;删除&lt;/button&gt; component/Detail.vue12//获取通过传过来的参数$route.params.XXX 获取当前id的图书信息渲染到界面。 问题一: 当修改的时候，价格原本是数字，修改之后会变成字符串,加上数字的修饰符 1&lt;input type=&quot;text&quot; v-model.number=&quot;book.bookPrice&quot; id=&quot;bookPrice&quot;&gt; 问题二修改url的时候，页面没有刷新，因为模板已经渲染出来了，不会在走created办法。所以，需要监控url的变化，路径参数发生变化，通过监控参数的变化来发送ajax 123456watch:&#123;//路径参数发生变化，通过监控参数的变化来发送ajax$route()&#123; this.getData() ; &#125;&#125; 问题三如果没有找到对应id的书，那返回的是空对象，如果是空，需要跳转回列表页Object.keys()，该方法返回一个数组,里面是对象的所有属性。如果是空对象那么返回一个空数组。 1Object.keys(this.book).length&gt;0?void 0:this.$ruoter.push(&apos;/List&apos;) 处理一下url,server.js查询book的条件变一下 1if (!isNaN(id)) 数据改变之后，需要用put更新数据PUT：参数1：url:/book?id=3参数2：请求体发送server.js获取put/post请求体中的数据使用这两个事件就可以获取来自服务器端的响应内容。 data，数据传递时触发， end，没有更多数据提供时触发1234567let str = &quot;&quot;; res.on(&apos;data&apos;,(chunk)=&gt;&#123; str += chunk; &#125;); res.on(&apos;end&apos;,()=&gt;&#123; console.log(str); &#125;); 添加页面同详情页面 优化与其他功能loading轮播图和热门图书是分开获取的，这里改成一起获取api/index1return axios.all([getSliders(),getHotBook()]) 数据返回的是一个数组，里面是两个promise对象。 新建base/Loading.vue,挂载在Home.vuehttps://www.cnblogs.com/lhb25/p/loading-spinners-animated-with-css3.html 实现页面缓存分页面缓存，路由元信息。在配置路由映射的时候有meta(备注)属性,这条对象可以通过this.$route获取1&#123;path:&apos;/home&apos;,component:Home,meta:&#123;keepAlive:true&#125;&#125;, 修改APP.vue,写两个router-view，一个用于，显示缓存的，一个用于显示一般的123456789&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; &lt;Tab&gt;&lt;/Tab&gt; &lt;/div&gt;&lt;/template&gt; 实现路由动画给router-view外面包裹一个标签,注意点：一个只能包裹一个标签写css样式12345678910.fadeIn-enter&#123; opacity: 0;&#125;.fadeIn-enter-active&#123; transition:all 0.3s;&#125;.fadeIn-leave-active&#123; transition: all 0.3s; opacity: 0;&#125; 下拉加载更多打包上线history路由在路由中改变mode:’history’ 标题router/indexmeta:{title:XXX}main.js全局钩子，在进入路由之前每一次都会执行此方法。有拦截的作用router.beforeEach(function(from.to,next){ document.title = to.meta.title; next();});]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP 简括]]></title>
    <url>%2F2018%2F10%2F24%2Fhttp%E7%AE%80%E6%8B%AC%2F</url>
    <content type="text"><![CDATA[http一次完整的HTTP请求需要7个步骤 建立TCP连接 Web浏览器向Web服务器发送请求命令 一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。 Web浏览器发送请求头信息 浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。 Web服务器应答 客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码 Web服务器发送应答头信息 正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。 Web服务器向浏览器发送数据 Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。 Web服务器关闭TCP连接一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：Connection:keep-alive，TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。 http协议的特点①通信流程：断开式（无状态） 断开式：http协议每次响应完成后，会断开与客户端的连接 无状态：由于服务器断开了之前的连接，就无法知晓连接间的关系。 ②内容格式：消息头和消息体 HTTP请求方法 OPTIONS返回服务器针对特定资源所支持的HTML请求方法 或web服务器发送*测试服务器功能。询问支持的方法。 HEAD 类似get，但只返回响应头。 常用于查看某个页面的状态 GET 获取资源 GET方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。 使用GET方法时，请求参数和对应的值附加在URL后面，利用一个问号（“?”）代表URL的结尾与请求参数的开始 POST 向指定资源提交数据进行处理请求（提交表单、上传文件） 将请求参数封装在HTTP请求数据中，以名称/值的形式出现 PUT向指定资源位置上上传其最新内容 DELETE请求服务器删除 TRACE 回显服务器收到的请求，用于测试和诊断 CONNECTHTTP/1.1协议中能够将连接改为管道方式的代理服务器 get 和 post区别get请求无消息体，只能携带少量数据post请求有消息体，可以携带大量数据get请求将数据放在url地址中post请求将数据放在消息体中 HTTP状态码 1xx：相关信息 2xx：操作成功 3xx：重定向 4xx：客户端错误 5xx：服务器错误GET安全且幂等获取表示变更时获取表示（缓存） 200（OK） - 表示已在响应中发出 204（无内容） - 资源有空表示 301（Moved Permanently） - 资源的URI已被更新 303（See Other） - 其他（如，负载均衡） 304（not modified）- 资源未更改（缓存） 400 （bad request）- 指代坏请求（如，参数错误） 404 （not found）- 资源不存在 406 （not acceptable）- 服务端不支持所需表示 500 （internal server error）- 通用错误响应 503 （Service Unavailable）- 服务端当前无法处理请求POST创建子资源部分更新资源 如果没有被修改，则不过更新资源（乐观锁） 200（OK）- 如果现有资源已被更改 201（created）- 如果新资源被创建 202（accepted）- 已接受处理请求但尚未完成（异步处理） 301（Moved Permanently）- 资源的URI被更新 303（See Other）- 其他（如，负载均衡） 400（bad request）- 指代坏请求 404 （not found）- 资源不存在 406 （not acceptable）- 服务端不支持所需表示 409 （conflict）- 通用冲突 412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突） 415 （unsupported media type）- 接受到的表示不受支持 500 （internal server error）- 通用错误响应 503 （Service Unavailable）- 服务当前无法处理请求 PUT通过替换的方式更新资源 200 （OK）- 如果已存在资源被更改 201 （created）- 如果新资源被创建 301（Moved Permanently）- 资源的URI已更改 303 （See Other）- 其他（如，负载均衡） 400 （bad request）- 指代坏请求 404 （not found）- 资源不存在 406 （not acceptable）- 服务端不支持所需表示 409 （conflict）- 通用冲突 412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突） 415 （unsupported media type）- 接受到的表示不受支持 500 （internal server error）- 通用错误响应 503 （Service Unavailable）- 服务当前无法处理请求 DELETE不安全但幂等删除资源 200 （OK）- 资源已被删除 301 （Moved Permanently）- 资源的URI已更改 303 （See Other）- 其他，如负载均衡 400 （bad request）- 指代坏请求 404 （not found）- 资源不存在 409 （conflict）- 通用冲突 500 （internal server error）- 通用错误响应 503 （Service Unavailable）- 服务端当前无法处理请求 http的请求部分 请求方法（GET/POST）、URI、协议/版本 请求头(Request Header) 空行 请求正文 https://blog.csdn.net/chen1403876161/article/details/51546653| 请求头 | 说明 | 实列|| —— | —— |——|| Accept |这个头信息指定浏览器或其他客户端可以处理的 MIME 类型|Accept:application/json, text/plain, /||Accept-Encoding|浏览器能够进行解码的数据编码方式|Accept-Encoding:gzip, deflate, br||Accept-Language| 这个头信息指定客户端的首选语言，在这种情况下，Servlet 会产生多种语言的结果|Accept-Language:zh-CN,zh;q=0.8||Accept-Charset|浏览器可接受的字符集|||Connection|这个头信息指示客户端是否可以处理持久 HTTP 连接。持久连接允许客户端或其他浏览器通过单个请求来检索多个文件|Connection:keep-alive||Host|指定请求资源的Intenet主机和端口号（服务器，向谁请求）|Host:localhost:3000||Referer|这个头信息指示所指向的 Web 页的 URL。例如，如果您在网页 1，点击一个链接到网页 2，当浏览器请求网页 2 时，网页 1 的 URL 就会包含在 Referer 头信息中。||User-Agent|这个头信息识别发出请求的浏览器或其他客户端，并可以向不同类型的浏览器返回不同的内容。||Content-Length|这个头信息只适用于 POST 请求，并给出 POST 数据的大小（以字节为单位）。|Content-Length:60||Content-Type|用于post请求|Content-Type：application/json;charset=UTF-8||Authorization|授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中|| HTTP content-type application/x-www-form-urlencoded 这应该是最常见的 POST 提交数据的方式了。中默认的encType，form表单数据被编码为 key/value格式发送到服务器（表单默认的提交数据的格式） multipart/form-data 需要在表单中进行文件上传时，就需要使用该格式 application/jsonJSON数据格式 HTTP响应头信息 状态行 响应头(Response Header) 空行 响应正文 其他一般的在上面的连接中可以看到，这里整理了平时遇到的跨域问题 跨域的响应头123456res.setHeader("Access-Control-Allow-Origin", "*"); res.setHeader("Access-Control-Allow-Headers", "Content-Type,Content-Length, Authorization, Accept,X-Requested-With"); res.setHeader("Access-Control-Allow-Methods","PUT,POST,GET,DELETE,OPTIONS"); res.setHeader("X-Powered-By",' 3.2.1') res.setHeader("Content-Type", "application/json;charset=utf-8"); if(req.method=="OPTIONS") return res.end();/*让options请求快速返回*/]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise/axios/async/await]]></title>
    <url>%2F2018%2F10%2F22%2Fpromise-axios%2F</url>
    <content type="text"><![CDATA[axios/promise/async/await这里整理axios时，把牵扯到的基础promise学习了，更深一步的以后再深入。axios跨域的问题等之后再整理，这篇仅仅是一些简单的基础 promise用法：可以将异步操作以同步操作的流程表达处理，避免层层嵌套回调函数promise对象有三种状态，对象的状态不受外界影响 pending 进行中 fulfilled 已成功 rejected 已失败 并且一旦状态改变，就不会再变，任何时候都可以得到这个结果,这时称为resolved(已定型)。状态改变只有两种可能 pending到fulfilled pending到rejected Promise实例生成以后，then方法有2个参数，第一个函数接收resolved状态的执行，第二个参数接收reject状态的执行。且then的执行结果也会返回一个Promise对象。12345promise.then(function(value) &#123; // success,resolved时调用&#125;, function(error) &#123; // failure rejected时调用&#125;); axios基于promise用于浏览器和node.js的http客户端 特点 支持浏览器和node.js 支持promise 能拦截请求和响应 能转换请求和响应数据 能取消请求 自动转换JSON数据 浏览器端支持防止CSRF(跨站请求伪造) 使用1import axios from &apos;axios&apos;; 请求get请求123axios.get(url).then(res=&gt;&#123;&#125;).catch(error=&gt;&#123;&#125;) .then访问成功12345//打印的是object对象//data，status，statusText，headers，comfigXXXX.then(res=&gt;&#123;console.log(res)&#125;)//打印的是promise对象XXXX.then() .catch捕获错误 传参1axios.get(url,&#123;params:&#123;&#125;&#125;) 常用配置全局默认路径1axios.defaults.baseURL =&apos;http://localhost:3000&apos;; 拦截器在请求或者返回被then或者catch处理之前对它们进行拦截12345678910111213141516// 添加请求拦截器axios.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 return config; &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;);// 添加响应拦截器axios.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 return response; &#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error); &#125;); async/awaitES7 提出的async 函数，终于让 JavaScript 对于异步操作有了终极解决方案。async作为一个关键字放到函数前面，表示函数是一个异步函数，异步函数也就意味着该函数的执行不会阻塞后面代码的执行。 内置执行器。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，调用方式跟普通函数的调用一样 返回值是 Promise。async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用 写异步代码就像写同步代码一样了，不用不断的回调了。 语法async 函数返回一个 Promise 对象async 函数内部 return 返回的值是个Promise 对象。当调用该函数时，内部会调用Promise.solve() 方法把它转化成一个promise 对象作为返回12345678async function timeout() &#123; return &apos;hello world&apos;&#125;console.log(timeout());console.log(&apos;虽然在后面，但是我先执行&apos;);//输出//Promise&#123;&#125;//虽然在后面，但是我先执行 async 函数内部 return 返回的值。会成为 then 方法回调函数的参数。只有当 async 函数内部的异步操作都执行完，才会执行 then 方法的回调。12345678910 async function timeout() &#123; return &apos;hello world&apos; &#125; timeout().then(result =&gt; &#123; console.log(result); &#125;) console.log(&apos;虽然在后面，但是我先执行&apos;); //输出 //虽然在后面，但是我先执行 //hello world 如果 async 函数内部抛出异常，则会导致返回的 Promise 对象状态变为 reject 状态。抛出的错误而会被 catch 方法回调函数接收到。12345async function e()&#123; throw new Error(&apos;error&apos;);&#125;e().then(v =&gt; console.log(v)).catch( e =&gt; console.log(e)); await await 后面放置的就是返回promise对象的一个表达式。await 表示等一下，先执行await后面的代码，等后面的promise对象执行完毕，再继续像下执行。 正常情况下，await 命令后面跟着的是 Promise，如果不是的话，也会被转换成一个 立即 resolve 的 Promise1234 async function f() &#123; return await 1&#125;;f().then( (v) =&gt; console.log(v)) // 1]]></content>
      <tags>
        <tag>vue</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[demo_todoList]]></title>
    <url>%2F2018%2F10%2F13%2Ftodolist%2F</url>
    <content type="text"><![CDATA[demo_todoList 功能 将数据循坏到页面 敲回车时添加新数据（需要添加isSelected属性） 删除功能 计算当前没有被选中的，选中的有删除样式 双击任务可以修改任务,已经完成的不可以 自定义输入框聚焦 回车或者失去焦点的时候修改成功 计算属性 根据hash展示todolist 数据永久化，hash单页刷新 收获watch 监控todos的变化,当变化时更新数据 watch:todos(){} 只能监控一层的数据变化（删减） watch:todos:handler(){},deep:true 深度监控directivess 自定义指令，指令是操作的dom XXX(el,bindings){} 名字需要和v-XXX的相同，el指代的是当前的dom，bindings参数 github: https://github.com/biubiuins/demo_todolist]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2F2018%2F10%2F12%2Fgit%2F</url>
    <content type="text"><![CDATA[git的基本操作 初次配置第一步需要配置用户名和邮箱地址，因为git为每一次提交记录名字和邮箱地址12$ git config --global user.name &apos;runoob&apos;$ git config --global user.email test@runoob.com ssh key 生成一对shh key（id_rsa私钥，id_rsa.pub公钥） 1ssh-keygen 注：在主目录下生成的密钥在 /c/Users/用户名/.ssh/id_rsa 里 查看公钥内容（需在.ssh目录下执行） 1cat id_rsa.pub 复制密钥内容添加到 github 上 使用ssh协议上传文件到仓库 12345git initgit add .git commit -m &quot; &quot;git remote add origin git@github.com:...git push -u origin master 注：若在创建新仓库时有readme.md 文件会上传失败 新建版本库 git里面先进入新建库的文件夹下 初始化库初始化目录，目录下回出现一个.git的目录，该目录包含了资源的所有元数据 12git initgit init 目录名 添加文件到暂存区将当前目录下几个文件纳入版本控制，需要先用git add 命令告诉git开始对这些文件进行跟踪 123git add .//添加当前项目的所有文件git add README //添加名为README的文件git add -A 所有修改的内容添加到缓存区 增加到版本库中使用 git add 命令将想要快照的内容写入缓存区， 而执行 git commit -m将缓存区内容添加到仓库中。 12git commit -a 跳过这一步git commit -m&quot;版本留言描述&quot; 连接远程仓库（现在GitHub上面新建仓库） 1git remote add origin 仓库地址 讲本地仓库推送到远程库上 12git pushgit push -u origin master //首次执行，说明上传到仓库的master分支上 问题：![rejected] master -&gt; master (fetch first)解决办法：1. 先执行git pull.然后再执行git push –force origin master替换原先的 git push -u origin master 从远程库克隆先把别人的fork进自己的库里面 克隆仓库到指定目录 123//自己在本地进入需要克隆进的文件夹下执行下面第一条指令git clone 仓库地址git clone 仓库地址 本地目录 add commit push 删除文件 本地删除文件 123//或者直接在文件管理器中把没用的文件删了//需要git进入文件夹下$ rm test.txt Git知道你删除了文件，这个时候只是本地删除了文件，而版本库里面还有文件，所以可以恢复文件 1$ git checkout -- test.txt 远程库删除文件 1git rm test.txt 记得还需要commit 我的石墨文档：https://shimo.im/docs/2Eg0gszciPEQBPxG/]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[express学习笔记]]></title>
    <url>%2F2018%2F10%2F12%2Fexpress%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[express 学习笔记 搭建简单服务器1234567891011//express() 是一个由 express 模块导出的入口（top-level）函数let express = require('express');//创建一个express应用实例名applet app = express();// 设置端口号：3000//process.env.PORT：读取当前目录下环境变量port的值let port = process.env.PORT || 3000 ;//在端口号上开启服务app.listen(port,function () &#123; console.log("server start"+port);&#125;); app.listen(port, [hostname], [backlog], [callback])类似于node中的http.Server.listen()1234567// 设置端口号：3000//process.env.PORT：读取当前目录下环境变量port的值let port = process.env.PORT || 3000 ;//在端口号上开启服务app.listen(port,function () &#123; console.log("server start"+port);&#125;); 服务器启动时候，默认端口3000：node app.js设置端口8080：PORT=8080 node app.js app.set(name,value)123456789//设置 views 文件夹为存放视图文件的目录, 即存放模板文件的地方,__dirname 为全局变量,存储当前正在执行的脚本所在的目录。app.set('views', path.join(__dirname, 'views'));app.set("views","./views");//设置使用的模板引擎app.set('view engine', 'ejs’)app.set("view engine","jade")npm install --save express-art-template//设置art模板引擎，后缀为artapp.engine('art', require('express-art-template')); app.get(name)返回name的value值1234567891011//实例一app.get('title');// =&gt; undefinedapp.set('title', 'My Site');app.get('title');// =&gt; "My Site"//实例二app.set('port', process.env.PORT || 3000);var server = app.listen(app.get('port'), function() &#123; console.log("server start"+port);&#125;); app.get(path, callback [, callback …])app.all(path, callback [, callback …])这种方法就像标准的app.METHOD()方法, 除了它匹配所有HTTP动词。访问path路径的所有方法执行的回调函数.12345//* 表示匹配所有的路径app.all('*', function(req, res)&#123; res.end(req.method + 'user')&#125;//一般放在最后面防止前面的被覆盖 请求与响应123456//Express 应用使用回调函数的参数： request 和 response 对象来处理请求和响应的数据。app.get('/', function(req, res)&#123; res.send('hello world'); res.status(404).send(错误请求)//访问这个路径是设定状态码为404 //通过res.send（）接口向客户端发送hello world，send只能响应一次，意思是只能出现一个send&#125;) res.send（）只能出现一次如果要响应多次，用node原生的write和end，但是如果只有write会处于一个挂起状态1234app.get('/', function(req, res)&#123; res.write('hello world'); res.write('hello world');&#125;) res.send有结束响应的作用 res.write没有结束响应的作用，需要res.end结束中间件挂起response下表中响应对象（res）的方法向客户端返回响应，终结请求响应的循环。如果在路由句柄中一个方法也不调用，来自客户端的请求会一直挂起。res.render()12345//设置 views 文件夹为存放视图文件的目录, 即存放模板文件的地方,__dirname 为全局变量,存储当前正在执行的脚本所在的目录。app.set('views', path.join(__dirname, 'views'));app.set("views","./views");//第一个是渲染的views文件夹下面的index，第二个是传递的数据,注意需要设置模板引擎res.render("index",&#123;&#125;,function()&#123;&#125;) res.setHeader()12//Content-Type的作用 该实体头的作用是让服务器告诉浏览器它发送的数据属于什么文件类型。res.setHeader(&quot;Content-Type&quot;,&apos;text/html;charset=utf-8&apos;) res.redirect()调用redirect()方法后，其后的代码都不会被执行。而使用redirect()设置的状态码不是301或302也不会发生跳转12res.redirect([status,] path)//重定义到path所指定的URL，重定向时可以同时指定HTTP状态码，不指定状态码默认为302 res.location()location()方法本质上是调用了ServerResponse对象的setHeader()方法，但并没有设置状态码。使用location()设置头信息，而不设置状态码或状态码不是301或302，并不会发生重定向1res.location(path) request req.query处理 get 请求，获取 get 请求参数12345678910// GET /search?q=tobi+ferretreq.query.q// =&gt; "tobi ferret"// GET /shoes?order=desc&amp;shoe[color]=blue&amp;shoe[type]=conversereq.query.order// =&gt; "desc"req.query.shoe.color// =&gt; "blue"req.query.shoe.type// =&gt; "converse" req.body处理 post 请求，获取 post 请求体12345678// POST user[name]=tobi&amp;user[email]=tobi@learnboost.comreq.body.user.name// =&gt; "tobi"req.body.user.email// =&gt; "tobi@learnboost.com"// POST &#123; "name": "tobi" &#125;req.body.name// =&gt; "tobi" req.params处理 /:xxx 形式的 get 或 post 请求，获取请求参数123456// GET /user/tjreq.params.name// =&gt; "tj"// GET /file/javascripts/jquery.jsreq.params[0]// =&gt; "javascripts/jquery.js" req.param(name)处理 get 和 post 请求，但查找优先级由高到低为 req.params→req.body→req.query123456789// ?name=tobireq.param('name')// =&gt; "tobi"// POST name=tobireq.param('name')// =&gt; "tobi"// /user/tobi for /user/:namereq.param('name')// =&gt; "tobi" 中间件用于客户端与服务器路由匹配之前的中间操作，正常中间件放在路由上面，中间件通过next()往下走。 app.use（[path],function）利用express托管静态文件node.js不能通过目录来引入文件，而express可以，public为静态目录1234//设置public文件夹为存放静态文件的目录。let path=require("path")//ex4里面唯一的内置中间件app.use(express.static(path.join(__dirname, 'public'))); 一个中间件处理器，请求来了，让那些中间件先处理一遍 没有挂载路径的中间件，应用的每个请求都会执行该中间件 挂载至 /path 的中间件，任何指向 /path 的请求都会执行它1234567app.use(&quot;/name&quot;,function(req,res,next)&#123;res.setHeader(&quot;Content-Type&quot;,&apos;text/html;charset=utf-8&apos;)next();&#125;)app.get(&quot;/name/n&quot;,function(req,res)&#123;&#125;)//也可以匹配到，在执行get请求/name/n时先执行上面的中间件 错误中间件错误处理中间件和其他中间件定义类似，只是必须要使用 4 个参数(err, req, res, next)。即使不需要 next 对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。遇见错误之后直接执行错误中间件。错误处理中间件应当在在其他 app.use() 和路由调用之后才能加载，一般放在路由的最底部，比如：123456789var bodyParser = require('body-parser');var methodOverride = require('method-override');app.use(bodyParser());app.use(methodOverride());app.use(function(err, req, res, next) &#123; // 业务逻辑 console.error(err.stack); res.status(500).send('Something broke!');&#125;); 应用生成器12345678910//安装$ npm install express-generator -g//view=XXX 使用引擎名字 myapp项目名称$ express --view=pug myapp//安装所有依赖$ cd myapp$ npm install//启动myapp项目$ set DEBUG=myapp:* &amp; npm start 我的石墨文档链接：https://shimo.im/docs/TXeewzaE8Jsdgn0I/练习的简易聊天室连接：https://github.com/biubiuins/demo_chat]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[project_email]]></title>
    <url>%2F2018%2F10%2F11%2Fproject-email%2F</url>
    <content type="text"><![CDATA[邮件收发项目大二上开始学html，css，js之后做的暑假做的前端页面，很感谢老师可以给一个练手的机会，在做的过程中发现了很多问题，以及项目完成之后的收获。&nbsp;&nbsp;&nbsp;&nbsp;虽然是一个很简单的界面，但是之前学习的时候不太仔细，也没有demo练习，还是做的磕磕绊绊，还好最后做的差不多了。TAT&nbsp;&nbsp;针对过程中的问题，阅读了很多关于语法规范的文章，js，jq又重新学习了一遍（练习了很多），大二下期基本在学习之中度过的。希望在以后的项目中可以有所进步，彻底的实现前后端分离！！！ 项目相关 完成时间：大二上期寒假 2018-3月左右 bootsrap框架，layui框架，jquery 项目不足 语法不规范，复用性不强，后面修改过一次感觉修改起来很复杂 js不熟练，项目之后大二下期又重新开始学习了一遍js，并写了总结 (https://biubiuins.github.io/2018/10/11/summary-2018-9/) 技术不足，没有实现前后端分离 主要功能 首页 http://mailroom.sicau.edu.cn/email/public/ bootsrap做了响应式，用了ajax请求数据 管理页面（需要登陆仅提供图片） 实现全选与批量删除 点击已取之后，重新获取数据（保证筛选邮件之后点击已取仍显示的是筛选之后的邮件) 邮件类型默认显示上一次选择的类型，可输入筛选的下拉框 超级管理员界面实现了原生js模态框，并做了根据屏幕居中]]></content>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[summary-2018.9]]></title>
    <url>%2F2018%2F10%2F11%2Fsummary-2018-9%2F</url>
    <content type="text"><![CDATA[summary-2018-9 这是在学会搭建博客之后的第一篇博客，以前学习的时候也有记笔记，所以把之前学习笔记上面整理的常见的功能、封装以及遇到的问题写出来，这篇仅限于js，jq。现在正在学习vue，希望在过段时间，自己也能写出关于vue学习的总结。在此之前还需要了解markdown的语法TAT 原来的笔记记录在石墨文档，https://shimo.im/docs/c8YrJy4obNICaWiS/ ID处理1234/** 获取id */function $(id) &#123; return typeof id === "string" ? document.getElementById(id) : null;&#125; 动画匀速动画1234567891011121314151617181920//元素，目标，步数function constant(obj, target, speed) &#123; // 1. 清除定时器 clearInterval(obj.timer); //2.判断方向 //如果现在的距离小于目标值,则往右，否则向左 let dir =obj.offsetLeft&lt;target?speed:-speed; //3. 设置定时器 obj.timer = setInterval(function () &#123; obj.style.left = obj.offsetLeft + dir + "px"; //若超出目标值或者不到目标值 //最后相减的值取绝对值后，总是小于步数的 //Math.abs(dir)||speed if(Math.abs(target-obj.offsetLeft)&lt;Math.abs(dir))&#123; clearInterval(obj.timer); //根据目标值板正 obj.style.left =target+'px'; &#125; &#125;, 20);&#125; 缓动动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function buffer(obj, json, fn) &#123; // 1. 清除定时器 clearInterval(obj.timer); var begin = 0, end = 0; // 2. 设置定时器 obj.timer = setInterval(function () &#123; // 2.0 旗帜, 决定动画是否结束 let flag = true; // 2.1 遍历 for(let k in json)&#123; // 2.2.-1 求出起始值 和 结束值 if(k === 'opacity')&#123; // 透明度 begin = parseInt( parseFloat(getCssAttr(obj, k)) * 100); end = parseInt(parseFloat(json[k]) * 100); &#125;else if(k === 'scrollTop')&#123; // 滚动到头部 begin = obj.scrollTop; end = parseInt(json[k]); &#125;else &#123; // 正常情况 begin = parseInt(getCssAttr(obj, k)); end = parseInt(json[k]); &#125; // 2.2.0 求出步长 //步长公式 let step = (end - begin) * 0.2; step = step &gt;=0 ? Math.ceil(step) : Math.floor(step); // 2.2.1 计算起始位置 if(k === 'opacity')&#123; obj.style.opacity = (begin + step) / 100; obj.style.filter = 'alpha(opacity=' + (begin + end)+')'; // 针对IE &#125;else if(k === 'scrollTop')&#123; obj.scrollTop = begin + step; &#125;else if(k === 'zIndex')&#123; obj.style[k] = json[k]; &#125;else &#123; obj.style[k] = begin + step + 'px'; &#125; // 2.2.2 判断 if(begin !== end)&#123; flag = false; &#125; &#125; // 3.0 结束动画 if(flag)&#123; clearInterval(obj.timer); // 开启动画组中的下一组动画 if(fn)&#123; // 判断有没有这个函数 fn(); &#125; &#125; &#125;, 60);&#125; js获取CSS利用 [] 访问属性 元素.style[“属性”];1234567891011121314//这种语法的好处就是可以动态的传递参数作为属性//只能获取行类标签 var h = 'height'; box.style[h] = 300 + 'px';//获取外部css或页内的cssfunction getStyleAttr(obj, attr) &#123; if(obj.currentStyle)&#123; // IE 和 opera return obj.currentStyle[attr]; &#125;else &#123; //window.getComputedStyle("元素", "伪类") （ 注意：两个选项是必须的，没有伪类 用 null 替代 ） //也可以点选，但是为了传递参数作为属性 return window.getComputedStyle(obj, null)[attr]; &#125;&#125; 定时器 在定时器事件前，先设置接收定时器的变量指向null 在定时器事件里，先要清除定时器再设置定时器，先清除是防止定时器累加轮播第一种这种不适合多图1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162function slider (sliderid,olStyleClassName,imgWidth,speed,second) &#123; //高级排他 //lastIndex 选中的小圆点样式 currentIndex 小圆点索引 picIndex 图片索引 let lastIndex=0,currentIndex=0,picIndex=0; // 1. 获取需要的标签 let ul=$(sliderid).children[0]; let ol=$(sliderid).children[1]; let list=ul.children; let olList= ol.children; // 2.克隆最后一个li标签 ul.appendChild(list[0].cloneNode(true)); // 3.动态创建小圆点 for(let i= 0;i&lt;list.length-1;i++)&#123; let li =document.createElement("li"); ol.appendChild(li); &#125; //4.第一个小圆点选中 olList[0].className=olStyleClassName; //5.监听每个li的进入事件 for(let i= 0;i&lt;olList.length;i++)&#123; //5.1 每一个li绑定自己的事件 olList[i].onmouseover=function () &#123; //先清除之前的选中状态，在把当前选中的索引给lastIndex lastIndex=currentIndex; olList[lastIndex].className=""; this.className=olStyleClassName; lastIndex=i; //5.2图片动起来 constant(ul,-(i * imgWidth),speed); currentIndex=picIndex=i; &#125;; &#125; //6.定时器 let timer; timer = setInterval(autoPlay, second); // 7. 清除和设置定时器 $(sliderid).onmouseover = function () &#123; clearInterval(timer); &#125;; $(sliderid).onmouseout = function () &#123; timer = setInterval(autoPlay, second); &#125;; function autoPlay()&#123; picIndex++; currentIndex++; //如果图片到了最后一张 if (picIndex &gt; list.length - 1) &#123; ul.style.left = 0; //从第二张图片开始 picIndex = 1; &#125; constant(ul, -(picIndex * imgWidth), speed); //小原点的选中 if (currentIndex &gt; olList.length - 1) &#123; currentIndex = 0; &#125; for (let i=0;i&lt;olList.length;i++)&#123; olList[i].className=""; &#125; olList[currentIndex].className=olStyleClassName; &#125;&#125; 第二种两个图片宽度的位置，第一个位置显示（当前），第二位置隐藏 第三种改变透明度，循环一遍让所有的opacity动画为0，然后当前为opacity动画为1，索引++、12345678910111213141516171819function opacityAutoPlay(ulid,speed) &#123; // 1. 获取所有的li标签 var lis = $(ulid).getElementsByTagName("li"); var index = 0; // 2. 开始定时器 setInterval(function () &#123; // 2.1 改变透明度 for(let i=0; i&lt;lis.length; i++)&#123; let singerLi = lis[i]; buffer(singerLi, &#123;opacity: 0&#125;, null); &#125; buffer(lis[index], &#123;opacity: 1&#125;, null); // 2.2 索引++ index++; if(index === lis.length)&#123; index = 0; &#125; &#125;, speed);&#125; 瀑布流 父盒子居中 Math.floor(屏幕宽度/子盒子宽度)=cols 子盒子的宽度*cols=父盒子的宽度 margin:0 auto; 子盒子定位第一行不变，其他子盒子接在第一行最矮的盒子的后面（反复） 拿到所有盒子的高度。把第一行的盒子的高度放在一个数组里面（i&lt;cols,heightArr[]) 在剩下的盒子里面(i&gt;=cols),找出第一行最矮的盒子的高度（Math.min(…heightArr)||Math.min.apply(this.height)）2.1 找出最矮盒子的索引(遍历heightArr[],找出和第二步盒子高度一样的i返回)2.2 剩下盒子定位（left=第2.1步的索引*子盒子宽度，top=最矮的盒子高度）2.3 更新最矮盒子的高度 （heightArr[最矮盒子的高度]+=当前盒子的高度） 滚动加载图片 监听窗口的滚动，滚动到你需要的位置加载 js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 window.onload = function () &#123; // 1. 实现瀑布流布局 waterFull("main", "box"); // 2. 动态加载图片 window.onscroll = function () &#123; if(checkWillLoadImage())&#123; // 2.1 造数据 var dataArr = [ &#123;"src": "img04.jpg"&#125;, &#123;"src": "img06.jpg"&#125;, &#123;"src": "img08.jpg"&#125;, &#123;"src": "img09.jpg"&#125;, &#123;"src": "img10.jpg"&#125;, &#123;"src": "img12.jpg"&#125;, &#123;"src": "img14.jpg"&#125;, &#123;"src": "img16.jpg"&#125;, &#123;"src": "img18.jpg"&#125; ]; // 2.2 创建元素 for(var i=0; i&lt;dataArr.length; i++)&#123; var newBox = document.createElement("div"); newBox.className = "box"; $("main").appendChild(newBox); var newPic = document.createElement("div"); newPic.className = "pic"; newBox.appendChild(newPic); var newImg = document.createElement("img"); newImg.src = "images/" + dataArr[i].src; newPic.appendChild(newImg); &#125; // 2.3 重新布局 waterFull("main", "box"); &#125; &#125;&#125;;/** * 实现瀑布流布局 */function waterFull(parent, child) &#123; // 1. 父盒子居中 // 1.1 获取所有的盒子 var allBox = $(parent).getElementsByClassName(child); // 1.2 获取子盒子的宽度 var boxWidth = allBox[0].offsetWidth; // 1.3 获取屏幕的宽度 var screenW = document.documentElement.clientWidth; // 1.4 求出列数 var cols = parseInt(screenW / boxWidth); // 1.5 父盒子居中 $(parent).style.width = cols * boxWidth + 'px'; $(parent).style.margin = "0 // 2. 子盒子的定位 // 2.1 定义高度数组 var heightArr = [], boxHeight = 0, minBoxHeight = 0, minBoxIndex = 0; // 2.2 遍历子盒子 for (var i = 0; i &lt; allBox.length; i++) &#123; // 2.2.1 求出每一个子盒子的高度 boxHeight = allBox[i].offsetHeight; // 2.2.2 取出第一行盒子的高度放入高度数组 if (i &lt; cols) &#123; // 第一行 heightArr.push(boxHeight); &#125; else &#123; // 剩余行 // 1. 取出最矮的盒子高度 // minBoxHeight = _.min(heightArr); minBoxHeight=Math.min(...heightArr); // 2. 求出最矮盒子对应的索引 minBoxIndex = getMinBoxIndex(heightArr, minBoxHeight); // 3. 子盒子定位 allBox[i].style.position = "absolute"; allBox[i].style.left = minBoxIndex * boxWidth + 'px'; allBox[i].style.top = minBoxHeight + 'px'; // 4. 更新数组中的高度 heightArr[minBoxIndex] += boxHeight; &#125; &#125; console.log(heightArr, minBoxHeight, minBoxIndex);&#125;/** * 获取数组中最矮盒子高度的索引 * @param arr * @param val * @returns &#123;number&#125; */function getMinBoxIndex(arr, val) &#123; for(var i=0; i&lt;arr.length; i++)&#123; if(arr[i] === val)&#123; return i; &#125; &#125;&#125;/** * 判断是否具备加载图片的条件 */function checkWillLoadImage() &#123; // 1. 获取最后一个盒子 var allBox = document.getElementsByClassName("box"); var lastBox = allBox[allBox.length - 1]; // 2. 求出最后一个盒子自身高度的一半 + offsetTop var lastBoxDis = lastBox.offsetHeight * 0.5 + lastBox.offsetTop; // 3. 求出屏幕的高度 var screenW = document.body.clientHeight || document.documentElement.clientHeight; // 4. 求出页面偏离浏览器的高度 var scrollTop = scroll().top; return lastBoxDis &lt;= screenW + scrollTop;&#125; jq123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//当页面加载完毕$(window).on('load',function () &#123;//1.实现瀑布流布局waterFall();//2.滚动加载$(window).on('scroll',function () &#123;//判断是否加载if (checkWillLoad())&#123;////创造假数据var data = &#123;'dataImg':[&#123;'img':'23.jpg'&#125;,&#123;'img':'24.jpg'&#125;,&#123;'img':'25.jpg'&#125;,&#123;'img':'26.jpg'&#125;,&#123;'img':'27.jpg'&#125;,&#123;'img':'28.jpg'&#125;]&#125;;//遍历创建盒子$.each(data.dataImg,function (index,value)&#123;//创建一个div标签 设置它的类为'box' 添加到'main'里面去var newBox = $('&lt;div&gt;').addClass('box').appendTo($('#main')); var newPic = $('&lt;div&gt;').addClass('pic').appendTo($(newBox)); //创建img 取出遍历的对象value的img属性对应的值 $('&lt;img&gt;').attr('src','images/'+$(value).attr('img')).appendTo($(newPic)); &#125;) //1.实现瀑布流布局 waterFall(); &#125; &#125;); &#125;); //实现瀑布流布局 function waterFall () &#123; //拿到所有的盒子 var allBox = $('#main &gt; .box'); //取出其中一个盒子的宽度 var boxWidth = $(allBox).eq(0).outerWidth(); //取出屏幕的高度 var screenWidth = $(window).width(); //求出列数 //取整函数取整 var cols = Math.floor( screenWidth/boxWidth); //父标签居中 $('#main').css(&#123; 'width':cols * boxWidth + 'px', 'margin':'0 auto' &#125;); //对子盒子定位 var heightArr = []; //遍历 $.each(allBox,function (index,value) &#123; //取出单独盒子的高度 var boxHeight = $(value).outerHeight(); //判断是否第一行 if(index &lt; cols) &#123; heightArr[index] = boxHeight; &#125; else //剩余的盒子要瀑布流布局 &#123; //求出最矮的盒子高度 var minBoxHeight = Math.min.apply(null,heightArr); //取出最矮高度对应的索引 封装了js的这个方法 var minBoxIndex = $.inArray(minBoxHeight,heightArr); //定位 $(value).css(&#123; 'position':'absolute', 'top':minBoxHeight + 'px', 'left':minBoxIndex * boxWidth + 'px' &#125;); //更新数组中最矮的高度 heightArr[minBoxIndex] += boxHeight; &#125; &#125;) &#125; //判断是否符合加载条件 function checkWillLoad() &#123; //直接取出最后一个盒子 var lastBox = $('#main &gt; div').last(); //取出最后一个盒子高度的一半 + 头部偏离的位置 var lastBoxDis = $(lastBox).outerHeight() + $(lastBox).offset().top; //求出浏览器的高度 var clientHeight = $(window).height(); //求出页面偏离浏览器高度 var scrollTopHeight = $(window).scrollTop(); //比较返回 return lastBoxDis &lt;= clientHeight + scrollTopHeight; &#125; margin:0 auto 块级元素 给定要居中的块级元素的宽度。 所有元素也可以通过对父元素设置text-align：center；的方式来实现居中。而对于块元素来说，对要居中的元素自身进行设置text-align:center也能实现居中 margin:0 auto;可以使盒子居中，text-align:center;可以使文本居中，节流onresize举列子窗口大小一变化就执行，太过灵敏，所以需要阻止1234567891011121314151617//使用定时器var timer = null;window.onresize = function () &#123; clearTimeout(timer); // 节流 timer = setTimeout(function () &#123; waterFull('main', 'box'); &#125;, 200);&#125;//封装之后的function throttle(fn, delay) &#123; var timer = null; return function () &#123; clearTimeout(timer); timer = setTimeout(fn, delay); &#125;&#125; apply/call这个面试中常考到，现在只做初步了解(https://www.cnblogs.com/gaowx/p/4837687.html ) 改变函数的this指向 apply可以改变传递给函数参数的形式Date123456789101112131415161718192021222324function newDate()&#123; //声明日期对象，里面可以设置参数表示其他时间 let date =new Date(); //获取时间里面的年 date.getFullYear() //月0-11 date.getMonth()+1 //日1-31 date.getDate() //获取星期0-6 data.Day //设置某一天 date.setDate（day） //时0-23 date.getHours() //分0-59 date.getMinutes() //秒0-59 date.getSeconds() //获取毫秒 date.getMilliSeconds() //时间戳 date.getTime()&#125; ms转化时间 cookie封装封装成插件，引入该文件后，$.addCookie(key,value,day,path,domain)来引用1234567891011121314151617181920212223242526272829303132333435363738394041;(function ($,window) &#123; $.extend(&#123; addCookie: function addCookie(key,value,day,path,domain)&#123; //1.处理默认保存的路径 var index=window.location.pathname.lastIndexOf('/'); var currentPath=window.location.pathname.slice(0,index) path=path||currentPath //2.处理默认domain domain=domain||document.domain //3.处理默认的过期时间 if(!day)&#123; document.cookie=key+"="+value+";path="+path+";domain="+domain+';' &#125; else&#123; var date =new Date(); date.setDate(date.getDate()+day) document.cookie=key+"="+value+";expires="+date.toGMTString()+";path="+path+";domain="+domain+';' &#125; &#125;, getCookie: function getCookie(key)&#123; var res=document.cookie.split(';') for(var i=0;i&lt;res.length;i++)&#123; //把key和value切割 var temp=res[i].split('=') //前后可能有空格，把空格删除 if(temp[0].trim()===key)&#123; return temp[1] &#125; &#125; &#125;, delCookie: function delCookie(key, path) &#123; //默认情况下只能删除默认路径中保存的cookie，如果要删除指定路径保存的cookie，要把路径值传出去 //设置过期时间为-1 addCookie(key, getCookie(key), -1, path) &#125; &#125;);&#125;)(jQuery,window); 动态添加的元素绑定事件 delegate 123$(&apos;ul&apos;).delegate(&apos;li&apos;,&apos;click&apos;,function()&#123;//操作的还是li&#125;) onclick事件在动态添加数据的时候，就给元素绑定onclick事件 on（）常用 12345//把动态添加的元素写在on里面，如果调用的函数是外部定义好的，则在调用的时候不加（）//不然会跳过点击事件直接执行函数$(&quot;父元素或祖辈元素&quot;).on(&quot;click&quot;,&quot;动态添加的元素&quot;,function()&#123;$(this).css(&quot;border&quot;,&quot;5px solid #000&quot;);&#125; 其他清除默认样式http://yui.yahooapis.com/3.18.1/build/cssreset/cssreset-min.css 下拉框1234567891011121314151617181920//拿到select对象：var myselect=document.getElementById("select");//拿到选中项的索引var index=myselect.selectedIndex ; // selectedIndex代表的是你所选中项的index//拿到选中项options的value：myselect.options[index].value;//拿到选中项options的text：myselect.options[index].text;//拿到选中项的其他值，比如这里的url： myselect.options[index].getAttribute('url');//jqueryvar options=$(“#select option:selected”); //获取选中的项alert(options.val()); //拿到选中项的值alert(options.text()); //拿到选中项的文本alert(options.attr('url')); //拿到选中项的url值//设置//设置value为pxx的项选中$(".selector").val("pxx")//设置text为pxx的项选中$(".selector").find("option[text='pxx']").attr("selected",true) H5 datalistdatalist 只是列表赋值取值还是通过input.样式等都在input上操作https://www.zhangxinxu.com/wordpress/2013/03/html5-datalist-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8-%E5%8F%AF%E8%A1%8C%E6%80%A7/ 邮箱的自动补全HTML代码：123456789邮箱：&lt;input type=&quot;email&quot; id=&quot;email&quot; list=&quot;emailList&quot; name=&quot;off_autocomplete&quot; /&gt;&lt;datalist id=&quot;emailList&quot;&gt;//其中*为占位符，当文本框输入内容的时候，*替换成邮箱地址的前半部分，于是，动态邮件地址提示的效果就实现了 &lt;option value=&quot;*@qq.com&quot;&gt; &lt;option value=&quot;*@163.com&quot;&gt; &lt;option value=&quot;*@gmail.com&quot;&gt; &lt;option value=&quot;*@yahoo.com.cn&quot;&gt; &lt;option value=&quot;*@126.com&quot;&gt;&lt;/datalist&gt; JS代码：12345678910111213141516171819202122232425262728var eleList = document.getElementById("emailList") , eleMail = document.getElementById("email") , htmlListInit = '', arrEmailList = [];if (eleMail &amp;&amp; eleList &amp;&amp; (htmlListInit = eleList.innerHTML) !== '') &#123; // 得到类似["qq.com", "163.com", "gmail.com", ...]的数据 arrEmailList = [].slice.call(eleList.getElementsByTagName("option")).map(function(option) &#123; return option.value.replace("*@", ""); &#125;); eleMail.fnListReplace = function() &#123; var arrValue = this.value.trim().split("@"); // 修复FireFox浏览器下无限input问题 // 如果值不完全匹配某option值，执行动态替换 if (arrValue.length !== 2 || arrEmailList.indexOf(arrValue[1]) === -1) &#123; eleList.innerHTML = htmlListInit.replace(/\*/g, arrValue[0]); &#125; return this; &#125;; // 绑定输入事件侦听 eleMail.addEventListener("input", function() &#123; this.fnListReplace.call(this); &#125;, false); // 载入即匹配 eleMail.fnListReplace.call(eleMail).focus();&#125; else &#123; eleList = document.createElement("datalist"); eleList.innerHTML = '&lt;p class=sorry&gt;抱歉，当前浏览器不支持HTML5 datalist.&lt;/p&gt;'; eleMail.parentNode.appendChild(eleList);&#125; jquery.editable-select控件引入jquery.editable-select.cssjquery.editable-select.js调用方法123456789101112$('#editable-select').editableSelect(&#123; bg_iframe: true, //是否加iframe case_sensitive: false, items_then_scroll: 10 ,//设置下拉选项的数目 isFilter:false/true, //是否根据条件过滤下拉选项 onCreate:, //当输入时触发 onShow：, //当下拉时触发 onHide：, //当下拉框隐藏时触发 onSelect：, //当下拉框中的选项被选中时触发 effects:default/slide/fade， //动画效果 duration： //动画效果的时间&#125;);]]></content>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
</search>
