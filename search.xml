<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js页面属性]]></title>
    <url>%2F2018%2F12%2F18%2Fjs%E9%A1%B5%E9%9D%A2%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[页面属性 offsetWidth /offsetHeight 12345//js对元素操作，只能获取不可以改变//获取对象自身的宽度和高度 ，包括内容、边框和内边距，即：offsetWidth = width + border + paddingbox.offsetWidth//注意：和 div.style.width 的区别，其只能获取到行内的数值div.style.width offsetLeft 和 offsetTop 距离第一个有定位的父级盒子左边和上边的距离，注意：父级盒子必须要有定位，如果没有，则最终以body为准！offsetLeft和offsetTop从从父标签的padding开始计算，不包括border。即：从子盒子边框到定位父盒子边框的距离。 offsetParent 返回当前对象的父级（带有定位）盒子，若爷爷也有则选择进近的 clientWidth/clientHeight 网页可见区域宽和高 clientLeft，clientTop 返回的是元素边框的borderWidth，如果不指定一个边框或者不定位改元素，其值就为0 document.body.scrollWidth; document.body.scrollHeight; 网页正文全文宽网页正文全文高 document.body.scrollTop; 网页被卷去的高 document.body.scrollLeft; 网页被卷去的左 区别 left和top分析： clientLeft: 左边边框的宽度；clientTop: 上边边框的宽度 offsetLeft: 当前元素距离有定位的父盒子左边的距离；offsetTop: 当前元素距离有定位的父盒子上边的距离 scrollLeft: 左边滚动的长度; scrollTop: 上边滚动的长度; width和height分析 clientWidth\/Height: 内容 + 内边距 offsetWidth\/Height: 内容 + 内边距 + 边框 scrollWidth\/Height: 滚动内容的宽度和高度]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-shop5]]></title>
    <url>%2F2018%2F12%2F18%2Fvue-shop5%2F</url>
    <content type="text"><![CDATA[异步显示ShopGoods数据 完成了头部的ShopHeader，接下来是点餐部分的ShopGoods组件。此组件是一个比较复杂的路由组件，主要包含了3个部分：ShopCart组件（底部的购物车）、CartControl组件（购物车里的加减商品按钮组件）、Food组件（点击商品图片查看详细信息的弹窗） 另外还使用了第三方库 better-scroll: 处理UI 滑动 左右结构的模版布局 12345678910111213141516171819202122232425262728293031323334 &lt;div class="goods"&gt; &lt;!-- 左侧的菜单选项--&gt; &lt;div class="menu-wrapper" ref="menuWrapper"&gt; &lt;!-- 菜单对应的是食物分类列表--&gt; &lt;ul&gt; &lt;li&gt;折扣&lt;/li&gt; &lt;li&gt;优惠&lt;/li&gt; &lt;li&gt;爽口凉菜&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- 右侧的食物列表--&gt; &lt;div class="foods-wrapper" ref="foodsWrapper"&gt; &lt;!-- 右侧的食物列表是根据左侧的分类列表展现的--&gt; &lt;!-- 所以右侧是在一个分类标题列表里面嵌套着各类食物列表--&gt; &lt;ul&gt; &lt;li class="food-list-hook"&gt; &lt;h1 class="title"&gt;折扣&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;南瓜粥&lt;/li&gt; &lt;li&gt;红豆薏米美肤粥&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class="food-list-hook"&gt; &lt;h1 class="title"&gt;优惠&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;红枣山药&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;其他分类...&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; 请求并读取数据进行模版渲染 12345678910import &#123;mapState&#125; from 'vuex'export default &#123; mounted () &#123; // 使用 axios 请求 mockjs 提供的接口 this.$store.dispatch('getShopGoods') &#125;, computed: &#123; ...mapState(['goods']) &#125;&#125; 1234567&lt;li class="menu-item" v-for="(good, index) in goods" :key="index"&gt;&lt;span class="text bottom-border-1px"&gt; &lt;img class="icon" :src="good.icon" v-if="good.icon"&gt; &#123;&#123;good.name&#125;&#125;&lt;/span&gt;&lt;/li&gt;&lt;!-- 右侧的模版渲染同上--&gt; 完成用户交互功能 修改当前食品分类的样式 当滑动右侧食品列表时，更新左侧的当前分类 点击左侧某个分类，右侧列表滑动到指定位置 12&lt;!--current是标识当前分类的class 而它的值应该是一个计算后的布尔值--&gt;&lt;li class="menu-item" :class="&#123;current: index===currentIndex&#125;" &gt;&lt;/li&gt; 设计计算属性：currentIndex 根据哪些数据来进行计算？ 既然要实现左右两侧的联动，那么首先要获取一些位置信息。 scrollY: 右侧食品列表滑动的Y轴坐标（滑动过程中实时变化） tops: 所有右侧分类标题到屏幕顶部的距离，即li的top值组成的数组 （列表第一次显示后就不再变化） 在滑动过程中，实时收集scrollY 列表第一次显示后，收集tops 实现currentIndex的计算逻辑 使用better-scroll实现回弹滑动 npm install --save better-scroll 中文官网 12345678910111213141516import BScroll from 'better-scroll'// 要考虑列表显示之后创建BScroll实例的时机//（参考12.2解决swiper的bug，之前使用watch和nextTick来监听数据更新）// 这里使用另一种方法 通过action的回调函数来通知组件数据已经更新mounted() &#123; this.$store.dispatch('getShopGoods', () =&gt; &#123;// 数据更新后执行 this.$nextTick(() =&gt; &#123; // 列表数据更新显示后执行 new BScroll('.menu-wrapper', &#123; click: true &#125;) new BScroll('.foods-wrapper', &#123; click: true &#125;) &#125;) &#125;) &#125;, 1234567891011//同时也要修改getShopGoods这个action// 异步获取商家商品列表async getShopGoods (&#123;commit&#125;, callback) &#123; const result = await reqShopGoods() if (result.code === 0) &#123; const goods = result.data commit(RECEIVE_GOODS, &#123;goods&#125;) // 数据更新了, 通知一下组件 callback &amp;&amp; callback() &#125;&#125; 收集scrollY和tops 12345678910111213141516171819// 要收集滚动的数据，那么就要利用betterScroll对象来监听滚动事件_initScroll() &#123; // 列表显示之后创建 new BScroll('.menu-wrapper', &#123; click: true &#125;) // 根据文档配置scroll选项 this.foodsScroll = new BScroll('.foods-wrapper', &#123; probeType: 2, // 因为惯性滑动不会触发 click: true &#125;) // 给右侧列表绑定scroll监听 this.foodsScroll.on('scroll', (&#123;x, y&#125;) =&gt; &#123; console.log(x, y) this.scrollY = Math.abs(y) &#125;)&#125; // 将其封装为初始化滚动的方法 12345678910111213141516171819// 初始化tops_initTops() &#123; // 1. 初始化tops const tops = [] let top = 0 // 第一个li的top为0 tops.push(top) // 2. 收集 // 在foods列表下找到所有分类的li const lis = this.$refs.foodsUl.getElementsByClassName('food-list-hook') // ★把伪数组变成真数组 Array.prototype.slice.call(lis).forEach(li =&gt; &#123; top += li.clientHeight tops.push(top) &#125;) // 3. 更新数据 this.tops = tops&#125; 完成计算属性currentIndex的逻辑 1234567891011121314151617181920currentIndex () &#123; // 初始和相关数据发生了变化 // 得到条件数据 const &#123;scrollY, tops&#125; = this // 根据条件计算产生一个结果 const index = tops.findIndex((top, index) =&gt; &#123; // scrollY&gt;=当前top &amp;&amp; scrollY&lt;下一个top return scrollY &gt;= top &amp;&amp; scrollY &lt; tops[index + 1] &#125;) // 返回结果(也就是当前的scrollY值属于第几个li区间) return index&#125;// 此时可以实现滑动右侧列表更新左侧当前分类// 但如果快速滑动则会出现因为惯性滑动不能正确收集scrollY值的bug// 解决方法一：将probeType的值改为3 但如果不想实现监听惯性滑动触发大量事件，则需要计算滑动结束时的scrollY值来确定当前分类// 在_initScroll里给右侧列表绑定scroll结束的监听this.foodsScroll.on('scrollEnd', (&#123;x, y&#125;) =&gt; &#123; console.log('scrollEnd', x, y) this.scrollY = Math.abs(y)&#125;) 实现点击左侧分类滑动右侧食物列表 12&lt;!--首先为li绑定click事件--&gt;&lt;li class="menu-item" :class="&#123;current: index===currentIndex&#125;" @click="clickMenuItem(index)"&gt;&lt;/li&gt; 12345678clickMenuItem (index) &#123; // 得到目标位置的scrollY const scrollY = this.tops[index] // 立即更新scrollY(让点击的分类项成为当前分类) this.scrollY = scrollY // 平滑滑动右侧列表 better-scroll里的方法 this.foodsScroll.scrollTo(0, -scrollY, 300)&#125;]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wepig总结1]]></title>
    <url>%2F2018%2F12%2F14%2Fwepig2%2F</url>
    <content type="text"><![CDATA[在编写项目的过程中，遇到了很多不会的地方，通过查找资料学习到了很多新的知识，所以把记录了下来。 学习总结router的传参 传参及获取参数 1path:&apos;/user/:name&apos; :name表示接收的参数 123$router.params.name//url后面跟了?参数，用query获取$router.query.age 链接追加 1&lt;router-link to=&quot;more&quot; append&gt;&lt;/router-link&gt; append表示在当前的页面路径后面添加more name 指定该条路由的名字 12//给名叫user的路由传参this.router.push(&#123;name:&apos;user&apos;,params:&#123;传递的参数&#125;) 视图命名当一个组件的界面有两个的 的时候，可以通过给其命名name=XXX，区分显示的是哪一个 在路由页面映射的时候，是 components ，不在是component了。 1234567&#123;path:&quot;/user&quot;,components:&#123; 视图一的名字:对应显示的组件 视图二的名字:对应显示的组件&#125;&#125; vue导航守卫参考文章:https://blog.csdn.net/weixin_39398244/article/details/83342761 全局前置守卫 router.beforeEach常常用于权限和状态的检验 当从一个路由跳转到另一个路由 之前 触发此守卫，任何路由跳转都会触发。 123456789const router = new VueRouter(&#123;...&#125;)router.beforeEach((to,from,next)=&gt;&#123; //... //这是获取准备去的地址 to.path==.. //匹配访问路径，会从父级一层一层下去 to.marched==&#125;) 每个守卫都有三个参数to：这是你要跳去的路由对象from：这是你要离开的路由对象next：是一个方法，接收参数，这个方法必须调用，否则就不能跳转 - next() 跳转 - next(false) 中断跳转 - next({path:&quot;/&quot;}) 中断当前跳转，跳转到新的路径 全局后置钩子 router.afterEach钩子不会接收next函数，也不会改变导航本身。12router.afterEach((to, from) =&gt; &#123; // ... 路由独享守卫 beforeEnter这个守卫是写在路由里面的，只有当进入这个路由时才会调用的，这些守卫与全局前置守卫的方法参数是一样的。 123456789101112const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/foo&apos;, component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // ... &#125; &#125; ]&#125;) 组件内守卫 beforeRouteEnter，beforeRouteUpdate，beforeRouteLeave这三个守卫是写在组件里，beforeRouteEnter守卫 不能 访问 this，因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。 不过，你可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。其他两个都可以用this。 1234567891011121314151617const Foo = &#123; template: `...`, beforeRouteEnter (to, from, next) &#123; // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！获取组件实例 `this` // 因为当守卫执行前，组件实例还没被创建 &#125;, beforeRouteUpdate (to, from, next) &#123; // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` &#125;, beforeRouteLeave (to, from, next) &#123; // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` &#125; 完整导航流程。 导航被触发。 在失活的组件里调用离开守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫 (2.5+)。 导航被确认。 调用全局的 afterEach 钩子。 触发 DOM 更新。 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。 meta路由元信息：定义路由的时候可以配置mate字段 12345678910111213141516const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/foo&apos;, component: Foo, children: [ &#123; path: &apos;bar&apos;, component: Bar, // a meta field meta: &#123; requiresAuth: true &#125; &#125; ] &#125; ]&#125;) 访问/foo/bar这个URL将会匹配 父路由记录 以及 字路由记录一个路由匹配到的所有路由记录会暴露为$route对象 (还有在导航守卫中的路由对象) 的 $route.matched 数组。因此，我们需要遍历 $route.matched 来检查路由记录中的 meta 字段。 常常用于不同页面的标题显示，或者原网页的head标签内容里面的东西]]></content>
      <tags>
        <tag>project</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wepig]]></title>
    <url>%2F2018%2F12%2F14%2Fwepig%2F</url>
    <content type="text"><![CDATA[记录项目实现的流程 项目流程]]></content>
      <tags>
        <tag>project</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex流程总结]]></title>
    <url>%2F2018%2F12%2F09%2Fvuex%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[对如何异步显示数据效果的编码流程进行了总结 ajaxajax请求函数，抛出接口 vuex store里面新建index完成基本配置 123456789101112131415161718192021222324/*vuex最核心的管理对象store组装模块并导出 store 的地方 */// 首先引入Vue及Vueximport Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;// 引入四个基本模块import state from &apos;./state&apos;import mutations from &apos;./mutations&apos;import actions from &apos;./actions&apos;import getters from &apos;./getters&apos;// 一定要声明使用插件Vue.use(Vuex)// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件export default new Vuex.Store(&#123; state, mutations, actions, getters&#125;) 现在Vue对象里面挂载store 1234567import store from &apos;./store&apos;new Vue(&#123; el: &apos;#app&apos;, components: &#123; App &#125;, template: &apos;&lt;App/&gt;&apos;, store //所有的组件都多了一个$store&#125;) 在store下新建state.js state：用于存储状态对象 123export default &#123;user:&#123;&#125;&#125; 在store下新建mutation-types.js mutation是操作state状态的，mutation-types是存放操作state的方法名 1export const RECEIVE_USER_INFO = &apos;receive_user_info&apos; // 接收用户信息 在store下新建actions.js action是通过操作mutation间接更新state的多个方法的对象 起连接作用。 异步获取数据。(注意需要引入api接口函数)把数据传给mutation。(因为mutation的方法名是放在mutation-types里面，所以注意要引入mutation-types里面对应的方法名) 123456789101112131415161718import &#123;reqUserInfo,&#125; from &apos;../api&apos;import &#123; RECEIVE_USER_INFO,&#125; from &apos;./mutation-types&apos; // 异步获取用户信息 async getUserInfo (&#123;commit&#125;) &#123; const result = await reqUserInfo() //如果请求成功，返回code=0 if (result.code === 0) &#123; const userInfo = result.data //提交mutation //把结果&#123;userInfo&#125;提交给RECEIVE_USER_INFO方法 commit(RECEIVE_USER_INFO, &#123;userInfo&#125;) &#125; &#125;, 参数除了commit以外，还可以有state{commit,state} 在store里面新建mutations.js mutations直接对state进行操作，[方法名](state,{param}){} 默认第一个参数state，所以需要引入vue与方法名 123456789import Vue from &apos;vue&apos;import &#123; RECEIVE_USER_INFO, &#125; from &apos;./mutation-types&apos;export default &#123; [RECEIVE_USER_INFO] (state, &#123;userInfo&#125;) &#123; state.userInfo = userInfo &#125; &#125; 使用数据 一般放在computed中进行接收，有利于state的值发生改变的时候及时响应给子组件。 mapState辅助函数 **mapState返回的是一个对象** 其实就是返回值:{return this.$store.XXXX} 当一个组件需要获取多个状态时候，用mapState辅助函数更为方便 1234567891011121314import &#123; mapState &#125; from &apos;vuex&apos;export default &#123;computed:mapState(&#123;//方法一：箭头函数count: state =&gt; state.count;//方法二：传字符串参数&apos;count&apos;等同于‘state=&gt;state.count’count:&apos;count&apos;;//方法三，使用this获取局部状态，必须使用常规函数count(state)&#123; return this.count&#125;&#125;)&#125; 当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。 1computed:mapState([ &quot;count&quot;]) …mapState() ...mapState是state的语法糖，使用时需要从vuex中引入 123computed:&#123;...mapState(&#123;&#125;)&#125; mapGetters 辅助函数 mapGetters辅助函数仅仅是将store中的getter映射到局部属性 12345678910111213import &#123; mapGetters &#125; from &apos;vuex&apos;export default &#123; // ... computed: &#123; // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters([ &apos;doneTodosCount&apos;, &apos;anotherGetter&apos;, // ... ]) &#125;&#125; mapActions 类似mapState getter计算属性 12345computed: &#123; doneTodosCount () &#123; return this.$store.state.todos.filter(todo =&gt; todo.done).length &#125; &#125; 如果有多个组件需要用到这个属性，可以在store里面定义‘getter’，可以说是store的计算属性，像计算属性一样，getter的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算 1234567891011121314151617181920212223242526272829 const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: &apos;...&apos;, done: true &#125;, &#123; id: 2, text: &apos;...&apos;, done: false &#125; ] &#125;, getters: &#123; //state作为第一个参数 doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; //可以接收其他getter作为第二个参数 doneTodosCount: (state, getters) =&gt; &#123; return getters.doneTodos.length &#125; //可以通过让getter返回一个函数，来实现给getter传参,对store里的数组进行查询时非常有作用 getTodoById: (state) =&gt; (id) =&gt; &#123; return state.todos.find(todo =&gt; todo.id === id) &#125; //store.getters.getTodoById(2) // -&gt; &#123; id: 2, text: &apos;...&apos;, done: false &#125; &#125; &#125;) //在组件中使用，同计算属性的调用，不用加括号 this.$store.getters.doneTodosCount dispatch方法 dispatch(actionName,data)分发调用action，第一个参数是方法名，第二个是数据 触发store里面的action对应方法名的函数 1this.$store.dispatch(&quot;&quot;)]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[demo_vue-shop4]]></title>
    <url>%2F2018%2F12%2F05%2Fvue-shop4%2F</url>
    <content type="text"><![CDATA[vue实战项目外卖4商家店铺界面通过点击商家列表(ShopList)里的某一项进入商家店铺的一级路由界面(Shop.vue)，商家店铺界面包括顶部的一个头部的一般组件(ShopHeader.vue)和下面三个可以切换的路由子组件(ShopGoods、ShopInfo、ShopRatings) 在router文件夹下的index.js文件中将路由组件注册成路由 1234567891011121314151617181920&#123; path: '/shop', component: Shop, children: [&#123; path: '/shop/goods', component: ShopGoods &#125;, &#123; path: '/shop/ratings', component: ShopRatings &#125;, &#123; path: '/shop/info', component: ShopInfo &#125;, &#123; path: '', redirect: '/shop/goods' &#125;]&#125; 在ShopList.vue中为商家列表添加点击事件 12345&lt;ul class="shop_list" v-if="shops.length"&gt; &lt;li class="shop_li border-1px" v-for="(shop,index) in shops" :key="index" @click="$router.push('/shop')"&gt; ... &lt;/li&gt;&lt;/ul&gt; Shop.vue中引入各路由组件然后在模版中使用 12345678910111213141516171819&lt;div&gt; &lt;ShopHeader&gt;&lt;/ShopHeader&gt; &lt;div class="tab"&gt; &lt;div class="tab-item"&gt; &lt;!-- 使用replace的方式进行路由切换 （路由懒加载） --&gt; &lt;router-link to="/shop/goods" replace&gt;点餐 &lt;/router-link&gt; &lt;/div&gt; &lt;div class="tab-item"&gt; &lt;router-link to="/shop/ratings" replace&gt;评价 &lt;/router-link&gt; &lt;/div&gt; &lt;div class="tab-item"&gt; &lt;router-link to="/shop/info" replace&gt;商家 &lt;/router-link&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 缓存路由组件对象 --&gt; &lt;keep-alive&gt; &lt;router-view/&gt; &lt;/keep-alive&gt;&lt;/div&gt; Json模拟数据设计json数据的结构 商家店铺界面包括点餐、评价、和商家信息三个部分的数据(头部显示的数据也是商家信息)，而且这三个方面的数据直接没有顺序关系，可以使用对象结构来存储它们。 12345678910111213141516171819202122// 点餐数据里包括各种不同分类的食品，可以用数组goods[]来存放这些数据对象(没有顺序关系但属于同一类型)// 每一类食品除了分类名称name还有一个foods数据来存放这一类的食品// foods数组内的每个对象都是一个食品实例&#123; "goods":[ &#123; name: "精选套餐", foods: [ &#123; name: "南瓜粥", price: 9 &#125; ] &#125; ], "ratings":[ &#123;&#125; ], "info":｛｝&#125;// 评价数据都属于同一类型，可以使用数组来存放[&#123;评价一&#125;,&#123;评价二&#125;..]// 商家信息数据没有顺序，可以统一保存到对象内 将设计好的data.json模拟数据保存在mock文件夹内 使用mockjs模拟数据接口 生成随机数据，拦截Ajax请求 1npm install --save mockjs 在mock文件夹下定义mockServer文件配置mock模拟数据的接口 1234567891011121314/*使用mockjs提供mock数据接口, */import Mock from 'mockjs'import data from './data.json'// 返回goods的接口，第一个参数是访问的路径，第二个是返回的数据（现在并不是随机的，data文件已经写好）Mock.mock('/goods', &#123;code: 0, data: data.goods&#125;)// 返回ratings的接口Mock.mock('/ratings', &#123;code: 0, data: data.ratings&#125;)// 返回info的接口Mock.mock('/info', &#123;code: 0, data: data.info&#125;)// export default ??? 不需要向外暴露任何数据, 只需要保存能执行即可 在main.js中加载mockServer文件即可 1import './mock/mockServer.js' ajax请求mockjs模拟的数据 api/index.js中定义ajax请求方法 123456789101112/* * 获取商家信息(下列请求由mock拦截并返回 不需要代理 所以没有加api，api开头的路径被设置了代理) */export const reqShopInfo = () =&gt; ajax('/info')/** * 获取商家评价数组 */export const reqShopRatings = () =&gt; ajax('/ratings')/** * 获取商家商品数组 */export const reqShopGoods = () =&gt; ajax('/goods') 再写一套用来管理从后台接收到的数据vuex配置 12345678910111213141516171819202122232425262728293031323334353637383940// 1. stategoods: [], // 商品列表ratings: [], // 商家评价列表info: &#123;&#125; // 商家信息// 2. mutations-typeexport const RECEIVE_GOODS = 'receive_goods' // 接收商品数组export const RECEIVE_RATINGS = 'receive_ratings' // 接收商家评价数组export const RECEIVE_INFO = 'receive_info' // 接收商家信息// 3. mutations[RECEIVE_INFO] (state, &#123;info&#125;) &#123; state.info = info&#125;,[RECEIVE_RATINGS] (state, &#123;ratings&#125;) &#123; state.ratings = ratings&#125;,[RECEIVE_GOODS] (state, &#123;goods&#125;) &#123; state.goods = goods&#125;// 4. action// 异步获取商家信息 async getShopInfo (&#123;commit&#125;) &#123; const result = await reqShopInfo() if (result.code === 0) &#123; const info = result.data commit(RECEIVE_INFO, &#123;info&#125;) &#125; &#125;, // 异步获取商家商品列表 async getShopGoods (&#123;commit&#125;) &#123; const result = await reqShopGoods() if (result.code === 0) &#123; const goods = result.data commit(RECEIVE_GOODS, &#123;goods&#125;) &#125; &#125; 在shop.vue中测试获取商家信息数据 1234 // 可以在控制台的vuex中查看到info数据mounted () &#123;this.$store.dispatch('getShopInfo') &#125; ShopHeader模板 已经可以获取到mock的模拟数据，接下来开始修改商家界面的头部模板 修改完模版和样式代码，然后读取vuex里的数据 123456import &#123;mapState&#125; from 'vuex'export default &#123; computed: &#123; ...mapState(['info']) &#125;&#125; 并将info里的数据渲染到模版中，其中有几点需要注意 为nav动态绑定背景style(删除原来的样式里的背景图片) 1:style="&#123;backgroundImage: `url($&#123;info.bgImg&#125;)`&#125;" 在style里定义三种不同颜色的优惠活动的类名并放进数组，然后把它们和info.supports.type关联起来 123456data () &#123; return &#123; // 注意顺序要与info的type对应 supportClasses: ['activity-green', 'activity-red', 'activity-orange'] &#125;&#125; 12&lt;div class="activity" :class="supportClasses[info.supports[0].type]"&gt;&lt;/div&gt; 这样写会报一个错误Error in render: &quot;TypeError: Cannot read property &#39;0&#39; of undefined&quot;因为vuex的数据是异步的，而页面刚加载时info为空对象，info.supports不存在，为undefined。所以再取它下标为0的值会报这个错误。(二级表达式info.bgImg并不会报错) 使用v-if来避免没有数据时也会解析模版 1&lt;div class="shop-header-discounts" v-if="info.supports" @click="toggleSupportShow"&gt;&lt;/div&gt; 利用shopShow和supportShow来标识模态框和优惠活动列表是否显示，同时定义切换显隐的方法 123456789101112131415data () &#123; return &#123; ... shopShow: false, supportShow: false &#125;&#125;，methods: &#123; toggleShopShow () &#123; this.shopShow = !this.shopShow &#125;, toggleSupportShow () &#123; this.supportShow = !this.supportShow &#125;&#125; 可以为弹窗添加一个transition动画(activity-sheet一样) 123&lt;transition name="fade"&gt; &lt;div class="shop-brief-modal" v-show="shopShow"&gt;&lt;/div&gt;&lt;/transition&gt; 然后找到shop-brief-modal的样式 添加动画过程 1234567&amp;.fade-enter-active, &amp;.fade-leave-active &#123; transition: opacity 0.5s; &#125;&amp;.fade-enter, &amp;.fade-leave-to &#123; opacity: 0; &#125;]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[summary_js]]></title>
    <url>%2F2018%2F11%2F24%2Fsummary_js%2F</url>
    <content type="text"><![CDATA[enter回车 持续更新 在修改项目的过程中，学习到了关于表单enter键提交是否可以触发 如果type是submit，一个文本或者多个文本都会提交 如果是button，仅一个文本的时候提交 type为image的按钮，等同于type为submit的效果 用button时，fx和IE有不同的表现。radio和checkbox在FX下也会触发提交表单，在IE下不会 事件代理，事件委托利用的是冒泡原理，与事件源。还可以用来给动态添加的元素绑定事件 事件源 兼容 12let e = e || window.event;var target = e.target || e.srcElement; 属性 12345678console.log(e.target);console.log(e.target.id);console.log(e.target.tagName);console.log(e.target.nodeName); console.log(e.target.classList);console.log(e.target.className);console.log(e.target.innerHTML);console.log(e.target.innerText); es6 箭头函数 回调函数为匿名函数时，回调函数的this会指向window，需要对回调函数bind(this)。回调函数为箭头函数时，回调函数的this会指向他的直接上层，本例中指向obj,objx。回调函数就是一个参数，将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数。这个过程就叫做回调。 不绑定this箭头函数的this其实就是在定义的时候就确定好的，以后不管怎么调用这个箭头函数，箭头函数的this始终为定义时的this 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。所以说在箭头函数中的this指向是固定的 最好不要用箭头函数作为对象的方法。 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 箭头函数还有一个比较有特点的地方就是其不绑定arguments,或者用rest参数代替 但是如果在箭头函数需要参数时，可以使用剩余参数来取代arguments 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。123var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;; 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 12345// 报错let getTempItem = id =&gt; &#123; id: id, name: &quot;Temp&quot; &#125;;// 不报错let getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;); es6 module模块通过export抛出，import引入 export 抛出一个变量 12345//写法一export let firstName = 'Michael';//写法二let firstName = 'Michael';export &#123;firstName&#125;; as关键字重命名 1234function v1() &#123; ... &#125;export &#123; v1 as streamV1,&#125;; 抛出默认 1export default xxx import 接收一个变量 1import &#123;firstName&#125; from &apos;./profile.js&apos;; as关键字重命名 1import &#123; firstName as surname &#125; from &apos;./profile.js&apos;; import命令输入的变量都是只读的，因为它的本质是输入接口，不可以修改 整体加载 1import * as XXX from &apos;./profile.js&apos;; 引入默认抛出的接口，可以自己随便命名 js跳转https://www.cnblogs.com/Renyi-Fan/p/9130325.html js对打开的页面ULR进行跳转， location的href属性 open 方法 histoty的三个方法 location的assign方法 常规的js页面跳转 在原来的窗口中直接跳转 1window.location.href=&quot;你所要跳转的页面&quot;; 在新窗口中打开页面用 12window.open(&apos;你所要跳转的页面&apos;);//open属性的参数 &apos;page.html&apos; 弹出窗口的文件名；&apos;newwindow&apos; 弹出窗口的名字（不是文件名），非必须，可用空&apos;代替；height=100 窗口高度；width=500 窗口宽度；top=0 窗口距离屏幕上方的象素值；left=0 窗口距离屏幕左侧的象素值。 ##[object Object] 这个不是两个对象的意思，是对象的字符串形式，是隐式调用了Object对象的toString()方法，形式是”[object Object]”.[object objcet] 自定义的对象 没有覆盖toString方法，返回默认[object] window对象 覆盖了toString方法，显式调用返回[object Object]123 字条串 覆盖了toString方法，显式调用返回[object String] 在我做项目的时候遇见了一个问题，把对象放进cookie之后，cookie存储的格式变成了object Object,解决办法是转化成字符串之后存入,使用时再解析成json对象 JSON.parse()【从一个字符串中解析出json对象】 123456//定义一个字符串var data=&apos;&#123;&quot;name&quot;:&quot;goatling&quot;&#125;&apos;//解析对象​​JSON.parse(data)结果是：​name:&quot;goatling&quot; JSON.stringify()【从一个对象中解析出字符串】 1234var data=&#123;name:&apos;goatling&apos;&#125;JSON.stringify(data)结果是：&apos;&#123;&quot;name&quot;:&quot;goatling&quot;&#125;&apos;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rem]]></title>
    <url>%2F2018%2F11%2F18%2Frem%2F</url>
    <content type="text"><![CDATA[rem rem是相对于根元素的字体大小相对单位 类似与em，不过rem是依赖根元素计算的，em是依赖父元素计算的 rem能等比例适配所有屏幕 这里有个插件flexible.js就是用rem实现的 这个button按钮的宽度为120px，高度为60px 123456789101112131415html&#123; font-size:20px;&#125;.btn &#123; width: 6rem; height: 3rem; line-height: 3rem; font-size: 1.2rem; display: inline-block; background: #06c; color: #fff; border-radius: .5rem; text-decoration: none; text-align: center;&#125; 如果是不同分辨率下的font-size的值，应该如何计算计算之后可以用媒体查询设置html的font-size值 移动端页面自适应解决方案 不需要手动设置viewport了 原理是根据设备屏幕的DPR(设备像素比，比如dpr=2时，表示1个CSS像素由4个物理像素点组成） 动态设置 html 的font-size, 同时根据设备DPR调整页面的缩放值，进而达到高清效果。) 绝不是每个地方都要用rem，rem只适合与固定宽度 此方案也是默认1rem=100px 比如你在效果图上量取的某个按钮元素长 55px, 宽37px 1234.myBtn &#123; width: 0.55rem; height: 0.37rem;&#125;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[demo_vue-shop3]]></title>
    <url>%2F2018%2F11%2F16%2Fvue-shop3%2F</url>
    <content type="text"><![CDATA[vue实战项目外卖3实现登陆注册功能模块界面效果及交互功能说明界面相关效果 切换登陆方式 手机号合法检查 倒计时效果 切换显示或隐藏密码 前台验证提示 前后台交互功能 动态一次性图形验证码 动态一次性短信验证码 短信登陆 密码登陆 获取用户信息,实现自动登陆 退出登陆 效果一：切换登陆方式 既然要切换登陆方式，就需要一个变量来标识这两种方式 12345 data () &#123;return &#123; loginWay: false // true代表短信登陆, false代表密码&#125; &#125; 动态绑定a标签的class和点击事件来实现点击切换样式 1234 &lt;div class="login_header_title"&gt;&lt;a href="javascript:;" :class="&#123;on: loginWay&#125;" @click="loginWay=true"&gt;短信登录&lt;/a&gt;&lt;a href="javascript:;" :class="&#123;on: !loginWay&#125;" @click="loginWay=false"&gt;密码登录&lt;/a&gt; &lt;/div&gt; 同时实现下面的表单登陆框自动切换 12345678910&lt;div class="login_content"&gt;&lt;form&gt; &lt;div :class="&#123;on: loginWay&#125;"&gt; 短信登陆的input... &lt;/div&gt; &lt;div :class="&#123;on: !loginWay&#125;"&gt; 密码登陆的input... &lt;/div&gt;&lt;/form&gt;&lt;/div&gt; 效果二：手机号合法检查 既然是要对手机号格式进行检查就要为其绑定数据 12&lt;!--v-model的值最好按照api文档里要求的字段来命名--&gt;&lt;input type="tel" maxlength="11" placeholder="手机号" v-model="phone"&gt; 根据手机号格式是否正确来动态的为获取验证码添加一个类名right_phone 1&lt;button disabled="disabled" class="get_verification" :class="&#123;right_phone:rightPhone&#125;"&gt;获取验证码&lt;/button&gt; right_phone的值是根据phone来确定的，所以应该是一个计算属性 123456computed: &#123; rightPhone () &#123; // 利用正则对手机号进行匹配，返回布尔值 return /^1\d&#123;10&#125;$/.test(this.phone) &#125;&#125; 此时button的disabled也应该根据rightPhone的返回值来确定 1&lt;button :disabled="!rightPhone" class="get_verification" :class="&#123;right_phone:rightPhone&#125;"&gt;获取验证码&lt;/button&gt; 在style部分加入新定义的right_phone样式 1234.get_verification ... &amp;.right_phone color black 效果三：30s倒计时 点击获取验证码之后会显示30s倒计时的效果并发送获取验证码的请求 注意要阻止点击button的默认提交表单事件，所以用`@click.prevent` 1&lt;button :disabled="!rightPhone" class="get_verification" :class="&#123;right_phone:rightPhone&#125;" @click.prevent="getCode"&gt;获取验证码&lt;/button&gt; 在data里定义定时变量computeTime，然后感觉时间判断显示的内容 1&lt;button class="get_verification"&gt;&#123;&#123;computeTime&gt;0 ? `($&#123;computeTime&#125;s)已发送` : '获取验证码'&#125;&#125;&lt;/button&gt; 然后在methods里定义定时器 1234567891011121314151617methods: &#123; getCode () &#123; // 如果当前没有计时!this.computeTime等于this.computeTime === 0 if(!this.computeTime) &#123; // 启动倒计时 this.computeTime = 30 this.intervalId = setInterval(() =&gt; &#123; this.computeTime-- if(this.computeTime &lt;= 0) &#123; // 停止计时 clearInterval(this.intervalId) &#125; &#125;, 1000) &#125; // 发送ajax请求（向指定手机号发送验证码短信） &#125; &#125; 效果四： 密码的显示隐藏 利用两个type不同的input来实现密码的显示隐藏 在data里定义showPwd(默认为false)控制两者的显隐，同时使用v-model绑定数据pwd 12345&lt;section class="login_verification"&gt; &lt;input type="text" maxlength="8" placeholder="密码" v-if="showPwd" v-model="pwd"&gt; &lt;input type="password" maxlength="8" placeholder="密码" v-else v-model="pwd"&gt; ...&lt;/section&gt; 为滑块区域添加点击监听，用来切换showPwd的值 同时切换滑块的各种样式 1234&lt;div class="switch_button" :class="showPwd?'on':'off'" @click="showPwd=!showPwd"&gt; &lt;div class="switch_circle" :class="&#123;right: showPwd&#125;"&gt;&lt;/div&gt; &lt;span class="switch_text"&gt;&#123;&#123;showPwd ? 'abc' : '...'&#125;&#125;&lt;/span&gt;&lt;/div&gt; 添加必要的style 1234&gt;.switch_circle ... &amp;.right transform translateX(30px) 效果五：前台表单验证 首先阻止点击登录button的默认提交表单事件 123&lt;form @submit.prevent = "login"&gt; ...&lt;/form&gt; 在methods里定义login方法并收集表单数据(即为未使用v-model绑定data的input添加data) 12345678data () &#123; return &#123; ... name: '', // 用户名 code: '', // 短信验证码 captcha: '', // 图形验证码 &#125;&#125; 在login里根据不同的登录方式对收集的数据进行检查 1234567891011if(this.loginWay) &#123; // 短信登陆 if(!this.rightPhone) &#123; // 手机号不正确 return &#125; else if(!/^\d&#123;6&#125;$/.test(code)) &#123; // 验证必须是6位数字 return &#125;&#125;else &#123; // 密码登陆 ...&#125; 要将验证失败的提示信息显示出来，可以使用自定义AlertTip弹窗组件(开发中可以用第三方插件) 12345678import AlertTip from '../../components/AlertTip/AlertTip.vue'...export default &#123; ... components: &#123; AlertTip &#125;&#125; 为AlertTip定义状态数据 1234567data () &#123; return &#123; ... alertText: '', // 提示文本 alertShow: false, // 是否显示警告框 &#125;&#125; 在页面中放置弹窗组件 1234&lt;section&gt; ... &lt;AlertTip :alertText="alertText" v-show="alertShow" @closeTip="closeTip"/&gt;&lt;/section&gt; 抽取显示弹窗和关闭弹窗的方法，并在login方法和AlertTip中使用 1234567891011121314151617181920showAlert (alertText) &#123; this.alertShow = true this.alertText = alertText&#125;,closeTip () &#123; this.alertShow = false this.alertText = ''&#125;,login () &#123; if(this.loginWay) &#123; // 短信登陆 if(!this.rightPhone) &#123; // 手机号不正确 this.showAlert('手机号不正确') return &#125; else if(!/^\d&#123;6&#125;$/.test(code)) &#123; this.showAlert('验证必须是6位数字') return &#125; &#125;...&#125; 功能一：图形验证码 根据API文档，动态一次性图形验证码的接口为http://localhost:4000/captcha 同时为这个img添加点击事件，让其可以点击重新发送请求，刷新图片 1&lt;img class="get_verification" src="http://localhost:4000/captcha" alt="captcha" @click="getCaptcha" ref="captcha"&gt; 为这个img元素添加ref属性，方便在getCaptcha中使用 利用时间戳使其每次加载时的请求参数不一样 1234getCaptcha () &#123; // 每次指定的src要不一样 this.$refs.captcha.src = 'http://localhost:4000/captcha?time='+Date.now()&#125; 功能二：短信验证码 利用第三方短信验证码平台(容联云通讯)提供的接口来实现 先在服务端项目将自己的sid与token填入util文件夹下的sms_util.js文件 再在客户端的登录组件中引入接口请求函数(这是为了方便处理，同样也可以在action里调用) 1import &#123;reqSendCode, reqSmsLogin, reqPwdLogin&#125; from '../../api' 在getCode方法里进行调用 1234567891011121314151617// 请求返回的是promise对象，所以用到了async awaitasync getCode () &#123; ... // 发送ajax请求(向指定手机号发送验证码短信) const result = await reqSendCode(this.phone) if(result.code===1) &#123; // 手机号验证失败 // 显示提示 this.showAlert(result.msg) // 停止计时 if(this.computeTime) &#123; this.computeTime = 0 clearInterval(this.intervalId) this.intervalId = undefined &#125; &#125;&#125;// 只要手机号填写正确 短信验证码也可以在服务端的控制台中查看 功能三：短信与密码登录 在login方法里完成短信和密码登录的aiax请求 12345678910async login () &#123; let result // 保存登录成功后返回的数据 ... // 发送ajax请求短信登陆 result = await reqSmsLogin(phone, code) ... // 发送ajax请求密码登陆 result = await reqPwdLogin(&#123;name, pwd, captcha&#125;) ...&#125; 点击登录发送请求的同时停止计时器，然后将请求的结果进行处理 123456789101112131415161718192021 ...// 停止计时if(this.computeTime) &#123; this.computeTime = 0 clearInterval(this.intervalId) this.intervalId = undefined&#125;// 根据结果数据处理if(result.code===0) &#123; // 成功 const user = result.data // 将user信息保存到vuex的state // todo // 去个人中心界面 this.$router.replace('/profile')&#125; else &#123; // 显示新的图片验证码 this.getCaptcha() // 显示警告提示 const msg = result.msg this.showAlert(msg)&#125; 测试用的用户名: abc，密码: 123。 功能四：获取用户信息,实现自动登陆1. 将用户信息保存到vuex 在state中添加用户信息的状态数据userInfo 1userInfo: &#123;&#125; // 用户信息 在mutation-types中定义常量 1export const RECEIVE_USER_INFO = 'receive_user_info' // 接收用户信息 在mutations文件中增加改变state的方法 1234 //先import引入RECEIVE_USER_INFO [RECEIVE_USER_INFO] (state, &#123;userInfo&#125;) &#123; state.userInfo = userInfo&#125; 在actions文件中增加同步用户信息的方法 因为之前已经异步获取了用户信息，所以这里将用户信息state更新的操作是同步的 12345// 要先引入RECEIVE_USER_INFO这个mutation// 同步记录用户信息 recordUser (&#123;commit&#125;, userInfo) &#123; commit(RECEIVE_USER_INFO, &#123;userInfo&#125;) &#125; 在Login组件中调用这个action 12// 将user保存到vuex的statethis.$store.dispatch('recordUser',user) 之后可以在个人中心Profile页面读取并显示用户信息userInfo 12345import &#123;mapState&#125; from 'vuex'...computed: &#123; ...mapState(['userInfo'])&#125; 1&lt;p class="user-info-top"&gt;&#123;&#123;userInfo.name || '登录/注册'&#125;&#125;&lt;/p&gt; 2. 更新登录后的个人中心界面 使用用户名和密码登录时显示用户名和绑定的手机号信息 使用手机号登录时只需要显示手机号 根据用户是否登录来定义a标签不同的路由 1234567891011&lt;!--userinfo路由对应的页面暂时未做--&gt;&lt;router-link :to="userInfo._id ? '/userinfo': '/login'"&gt; ... &lt;div class="user-info"&gt; &lt;p class="user-info-top" v-if="!userInfo.phone" &gt; &#123;&#123;userInfo.name || '登录/注册'&#125;&#125;&lt;/p&gt; &lt;p&gt; ... &lt;span class="icon-mobile-number"&gt;&#123;&#123;userInfo.phone || '暂无绑定手机号'&#125;&#125;&lt;/span&gt; &lt;/p&gt; &lt;/div&gt;&lt;/router-link&gt; 同时要注意首页Msite顶部的信息也要进行更改 123456789&lt;router-link class="header_login" slot="right" :to="userInfo._id ? '/userinfo': '/login'"&gt; &lt;span class="header_login_text" v-if="!userInfo._id"&gt; 登录|注册 &lt;/span&gt; &lt;!--如果已经登录则显示一个icon--&gt; &lt;span class="header_login_text" v-else&gt; &lt;i class="iconfont icon-yonghuming"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/router-link&gt; 3. 完成自动登录功能 服务器端的routes文件夹下的index.js中已经定义了返回用户信息的方法 123456789101112131415161718// 其中她将用户的userid取出来放入一个session会话中router.get('/userinfo', function (req, res) &#123; // 取出userid const userid = req.session.userid // 查询 UserModel.findOne(&#123;_id: userid&#125;, _filter, function (err, user) &#123; // 如果没有, 返回错误提示 if (!user) &#123; // 清除浏览器保存的userid的cookie delete req.session.userid res.send(&#123;code: 1, msg: '请先登陆'&#125;) &#125; else &#123; // 如果有, 返回user res.send(&#123;code: 0, data: user&#125;) &#125; &#125;)&#125;) 服务端的app.js中已经定义了这个用户登录的session会话的维持时间为24h 123456app.use(session(&#123; secret: '12345', cookie: &#123;maxAge: 1000*60*60*24 &#125;, //设置maxAge是80000ms，即80s后session和相应的cookie失效过期 resave: false, saveUninitialized: true,&#125;)); api中的对应接口已经完成 12// 获取用户信息(根据会话)export const reqUserInfo = () =&gt; ajax(BASE_URL + '/userinfo') 在action中定义一个方法来调用这个接口 12345678// 异步获取用户信息(先引入reqUserInfo接口)async getUserInfo (&#123;commit&#125;) &#123; const result = await reqUserInfo() if (result.code === 0) &#123; const userInfo = result.data commit(RECEIVE_USER_INFO, &#123;userInfo&#125;) &#125; &#125; 最后在App.vue中引入action并触发 12345678async mounted () &#123; ... // this.getAddress() this.getUserInfo() &#125;,methods: &#123; ...mapActions(['getUserInfo']) &#125; 功能五：退出登录 用户登录后在个人中心页面添加一个退出登录的按钮 下载安装mint-ui来实现 12// 安装mint-uinpm install --save mint-ui 实现自动按需打包 12// 安装工具包npm install --save-dev babel-pulgin-component 修改.babeirc 1234567// 配置"plugins": ["transform-runtime",["component", [ &#123; "libraryName": "mint-ui", "style": true &#125;]]] 引入并注册使用mint-ui的标签组件 12345// 在入口的main.js引入Buttonimport &#123;Button&#125; from 'mint-ui'// 注册全局组件Vue.component(Button.name, Button) 在Profile页面中使用mint-ui的标签 1234&lt;section class="profile_my_order border-1px"&gt; &lt;!--只有用户登录之后才会显示 同时绑定点击事件--&gt; &lt;mt-button type="danger" style="width: 100%" v-if="userInfo._id" @click="logout"&gt;退出登录&lt;/mt-button&gt;&lt;/section&gt; 引入mint-ui的confirm确认和toast文本提示框 1234567891011121314import &#123; MessageBox, Toast &#125; from 'mint-ui'logout () &#123; MessageBox.confirm('确认退出吗?').then( action =&gt; &#123; // 请求退出 this.$store.dispatch('logout') Toast('登出完成') &#125;, action =&gt; &#123; console.log('取消登录') &#125; )&#125; 在actions.js中定义退出登录的方法 123456// 首先引入api的index.js中定义的reqLogout接口和mutation// 异步登出async logout (&#123;commit&#125;) &#123; const result = await reqLogout() if (result.code === 0) &#123; commit(RESET_USER_INFO)&#125;&#125; 12345678//同时改动下列两个文件//mutations-types文件export const RESET_USER_INFO = 'receive_user_info' // 重置用户信息//mutations文件[RESET_USER_INFO] (state) &#123; state.userInfo = &#123;&#125; &#125;]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[demo_vue-shop2]]></title>
    <url>%2F2018%2F11%2F11%2Fvue-shop2%2F</url>
    <content type="text"><![CDATA[vue实战项目外卖2ajax请求问题分析： 目前为止运行的所有页面都是静态页面 接下来先测试使用封装的ajax接口请求函数来异步获取数据 123456789101112// 先在App.vue中引入封装的接口函数import &#123;reqCategorys&#125; from './api'// 然后再调用接口，测试打印数据export default &#123; async mounted () &#123; const result = await reqCategorys() console.log(result) &#125;, components: &#123; FooterGuide &#125;&#125; 报错了，跨域问题。8080的端口在请求4000端口的数据，然后在api文件夹下的index.js中修改测试 1234// 定义BASE_URLconst BASE_URL = 'http://local:4000'// 然后修改请求接口的urlexport const reqCategorys = () =&gt; ajax(BASE_URL + '/index_category') 跨域是浏览器的限制。解决办法：1.服务器告诉浏览器允许跨域 2.蒙蔽浏览器的双眼 配置代理并测试接口： 除了设置让服务器允许跨域的方法之外，还可以通过配置代理实现跨域请求 在项目config文件夹下的index.js文件里设置代理配置表 12345678910111213141516171819 // Paths // 静态资源文件夹 assetsSubDirectory: 'static', // 发布路径assetsPublicPath: '/',// 代理配置表，在这里可以配置特定的请求代理到对应的API接口// 例如将'localhost:8080/api/xxx'代理到'www.example.com/api/xxx'proxyTable: &#123; '/api': &#123; // 匹配所有以 '/api'开头的请求路径 target: 'http://localhost:4000', // 代理目标的基础路径 // secure: false, // 如果是https接口，需要配置这个参数 changeOrigin: true, // 支持跨域 pathRewrite: &#123; // 重写路径: 去掉路径中开头的'/api' '^/api': '' &#125; &#125; &#125;, 修改api文件夹index.js里接口函数的请求路径 123456// const BASE_URL = 'http://local:4000'const BASE_URL = '/api'export const reqAddress = geohash =&gt; ajax(`$&#123;BASE_URL&#125;/position/$&#123;geohash&#125;`)export const reqCategorys = () =&gt; ajax(BASE_URL + '/index_category')// 下面修改后的接口省略... 因为修改了项目的config文件，所以需要重启项目npm run dev 此时可以在控制台看到跨域请求到的数据{code: 0, data: Array(16)} vuex管理状态 安装Vuexnpm install vuex --save用来管理从后台获取的状态数据 以下代码以首页Msite为例 11.1 创建Store(核心仓库) 在项目的store文件夹下新建index.js 1234567891011121314151617181920/*vuex最核心的管理对象store*/// 首先引入Vue及Vueximport Vue from 'vue'import Vuex from 'vuex'// 引入四个基本模块import state from './state'import mutations from './mutations'import actions from './actions'import getters from './getters'// 一定要声明使用插件Vue.use(Vuex)// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件export default new Vuex.Store(&#123;state,mutations,actions,getters&#125;) 模块对象 状态对象 state 操作state 直接更新state的多个方法对象 mutations 操作mutations 间接更新state的多个方法对象 actions 包含多个基于state的getter计算属性的对象 getters 包含n个mutations的type名称常量 mutations-type State 分析整理出项目首页Msite中有哪些状态需要管理，然后写入state.js 在之前应该定位，这里直接保存当前状态 12345678910/*状态对象 state*/export default &#123; latitude: 40.10038, // 纬度 longitude: 116.36867, // 经度 address: &#123;&#125;, // 地址相关信息对象 categorys: [], // 食品分类数组 shops: [] // 商家数组&#125; Mutation 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation 每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler) 我们可以使用常量替代 Mutation 事件类型，新建mutations-types文件 123456/*包含n个mutation的type名称常量 */export const RECEIVE_ADDRESS = 'receive_address' // 接收地址信息export const RECEIVE_CATEGORYS = 'receive_categorys' // 接收分类数组export const RECEIVE_SHOPS = 'receive_shops' // 接收商家数组 然后在mutations.js文件内引入使用 (注意书写格式[ ]) 1234567891011121314151617 /* vuex 的 mutations 模块 */ import &#123;RECEIVE_ADDRESS,RECEIVE_CATEGORYS,RECEIVE_SHOPS&#125; from './mutation-types' // [方法名](state,&#123;param&#125;)&#123;&#125; export default &#123; [RECEIVE_ADDRESS](state, &#123;address&#125;) &#123; state.address = address&#125;,[RECEIVE_CATEGORYS](state, &#123;categorys&#125;) &#123; state.categorys = categorys&#125;,[RECEIVE_SHOPS](state, &#123;shops&#125;) &#123; state.shops = shops&#125; &#125; 而回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数 Action 和后台交互的异步action， Action 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 12345678910111213141516171819202122232425262728293031 // Action:通过操作mutation间接更新state的多个方法的对象 // 注意要引入api接口函数 import &#123;reqAddress, reqCategorys, reqShops&#125; from '../api' import &#123;RECEIVE_ADDRESS, RECEIVE_CATEGORYS, RECEIVE_SHOPS&#125; from './mutation-types' export default &#123; // 异步获取地址 async getAddress (&#123;commit, state&#125;) &#123; // 从state状态中获取到经纬度用来设置reqAddress的参数（看接口文档） const geohash = state.latitude + ',' + state.longitude // 1. 发送异步ajax请求 const result = await reqAddress(geohash) // 2. 根据结果提交一个mutation //因为mutation.js里面的函数接收的参数是&#123;address&#125; commit(RECEIVE_ADDRESS, &#123;address: result.data&#125;)&#125;,// 异步获取分类列表async getCategorys (&#123;commit&#125;) &#123; const result = await reqCategorys() commit(RECEIVE_CATEGORYS, &#123;categorys: result.data&#125;)&#125;,// 异步获取商家列表async getShops (&#123;commit, state&#125;) &#123; // 对象的解构赋值 const &#123;latitude, longitude&#125; = state // 注意参数的顺序 const result = aowait reqShops(&#123;latitude, longitude&#125;) commit(RECEIVE_SHOPS, &#123;shops: result.data&#125;)&#125; &#125; 至此已经完成了首页状态数据的vuex设置 异步获取并显示数据 在项目中注册store 123456//项目的main.js文件import store from './store'new Vue(&#123; store&#125;) 测试异步获取当前地址数据 123456// 地址信息要尽早的获取，所以请求可以写在App.vue中// 首先删除之前测试使用封装的ajax接口的代码async mounted () &#123; // 通过this.$store.dispatch 方法触发调用Action this.$store.dispatch('getAddress')&#125; 运行项目，在浏览器控制台里打开vue开发工具，切换到vuex，可以看到通过vuex异步获取的状态数据 除了这种方法调用action，还可以使用mapActions语法糖 12345678import &#123;mapActions&#125; from 'vuex'async mounted () &#123; this.getAddress()&#125;methods: &#123; ...mapActions(['getAddress'])&#125; 读取并显示获取到的当前地址数据 首页Msite组件中显示地址信息 123456// 利用mapState语法糖去读取state对象import &#123;mapState&#125; from 'vuex'computed: &#123; ...mapState(['address'])&#125; 123&lt;HeaderTop :title="address.name"&gt;// 将静态地址信息换成异步获取的地址数据 注意:title为绑定数据&lt;/HeaderTop&gt; 完成Msite页面异步显示食品分类轮播列表 上面已经完成了首页当前地址信息的获取与显示，接下来是完成Msite.vue中的食品分类的轮播图 mounted方法中通过this.$store.dispatch调用Action来获取异步数据 12345// 忘记Actuon里对应的方法名时查看Action.jsmounted () &#123; this.$store.dispatch('getCategorys') ...&#125; 通过mapState语法糖来读取获取到的异步数据 1234// 忘记state名时查看State.jscomputed: &#123; ...mapState(['address', 'categorys'])&#125; 分析template结构并处理categorys数据 轮播图应该在数组数据显示之后才能显示 业务分析： 此时获取到的categorys是所有食品类别的一维数组，而如果要完成轮播图，需要将其变成这种[[page1], [page2], [page3]]二维数组categorysArr。 比如本项目中有两页轮播图，一页为8个数据。应该把categorys数组处理成[[data1 - 8], [data1 - 8]]这种数据格式 123456//template&lt;div class="swiper-slide" v-for="(pages,index) in categorysArr" :key="index"&gt; &lt;a href="javascript:" class="(data,index) in pages" :key="index"&gt; ...... &lt;/a&gt;&lt;/div&gt; 利用计算属性将categorys处理成期望的数据结构categorysArr 1234567891011121314151617181920212223242526272829computed () &#123; ...mapState(['address', 'categorys']), /* 根据categorys一维数组生成一个2维数组 小数组中的元素个数最大是8 */ categorysArr () &#123; // 1.先从当前组件中得到所有食品分类的一维数组 const &#123;categorys&#125; = this // 2.准备一个空的二维数组--categorysArr const arr = [] // 3.准备一个小数组--pages(最大长度为8) let minArr = [] // 4.遍历categorys得到处理后的二维数组catagorysArr categorys.forEach(data =&gt; &#123; // 如果当前小数组(pages)已经满了, 创建一个新的 if (minArr.length === 8) &#123; minArr = [] &#125; // 如果minArr是空的, 将小数组(pages)保存到大数组(categorysArr)中 if (minArr.length === 0) &#123; arr.push(minArr) &#125; // 将当前分类信息保存到小数组(pages)中 minArr.push(data) &#125;) return arr &#125;&#125; 注意第4步forEach里的逻辑顺序 1.为什么当minArr数组的长度为0时就将它与大数组关联起来，不是等它存满(8个)？ 因为有可能categorys里的数据个数不为8的倍数，最后一个minArr内的数据不足8个。 2.为什么先判断minArr的长度为8的情况再判断等于0的情况？ 因为先判断minArr的长度为0，将其放入大数组中与大数组关联起来，那么等到当前这个minArr填充完成之后新建的小数组则无法与大数组关联起来。 所以先判断长度为8的情况，再判断数组长度为0的情况。就可以确保之前的minArr填充完成后，新建的minArr都可以被放到大数组里与大数组关联起来。 除了上面的方式处理categorys，也可以采用分割数组的方法。 12345678categorysArr () &#123; const &#123;categorys&#125; = this const arr = [] for (let i = 0,len = categorys.length;i &lt; len; i += 8)&#123; arr.push(categorys.slice(i, i + 8)) &#125; return arr&#125; 将数据显示到页面上 123456// 因为食品分类的图片信息都有一个baseImageUrl所以在data里定义data () &#123; return &#123; baseImageUrl: 'https://fuss10.elemecdn.com' &#125;&#125;, 123456789&lt;!--通过v-for循环渲染data的信息 注意src为绑定数据--&gt;&lt;div class="swiper-slide" v-for="(pages,index) in categorysArr" :key="index"&gt; &lt;a href="javascript:" class="link_to_food" v-for="(data,index) in pages" :key="index"&gt; &lt;div class="food_container"&gt; &lt;img :src="baseImageUrl+data.image_url"&gt; &lt;/div&gt; &lt;span&gt;&#123;&#123;data.title&#125;&#125;&lt;/span&gt; &lt;/a&gt;&lt;/div&gt; 使用watch与$nextTick解决轮播的Bug 分页器Swiper其实应该是在轮播列表显示(即categorys数组有了数据)以后才初始化。 最开始categorys为空数组，有了数据才会显示轮播列表，而要监视categorys的数据变化，就要用到watch。 123456789101112131415// 新建watch 监听categoryswatch: &#123; categorys (value) &#123; // categorys数组中有数据了 // 但界面还没有异步更新 new Swiper('.swiper-container', &#123; autoplay: true, // 如果需要分页器 pagination: &#123; el: '.swiper-pagination', clickable: true &#125; &#125;) &#125;&#125;// 删除mounted中的new Swiper...代码 但其实state里的状态数据改变（categorys接收数据）与异步更新界面（显示轮播列表）是两个步骤。所以需要等一等，界面完成异步更新后才可以进行Swiper的初始化。 123456789101112// 使用setTimeout可以实现效果, 但是时机不准确setTimeout(() =&gt; &#123; // 创建一个Swiper实例对象, 来实现轮播 new Swiper('.swiper-container', &#123; autoplay: true, // 如果需要分页器 pagination: &#123; el: '.swiper-pagination', clickable: true &#125; &#125;)&#125;, 100) 利用vm.$nextTick( [callback] )来实现等待界面完成异步更新就立即创建Swiper对象 nextTick将回调延迟到下次DOM更新循环之后执行 在修改数据之后立即使用它，然后等待DOM更新 12345678910// 在修改数据之后立即使用它，然后等待 DOM 更新。this.$nextTick(() =&gt; &#123; // 一旦完成界面更新, 立即执行回调 new Swiper('.swiper-container', &#123; autoplay: true, pagination: &#123; el: '.swiper-pagination', clickable: true &#125;&#125;) 异步显示商家列表 在Msite的mounted中获取异步数据 1this.$store.dispatch('getShops') 在ShopList.vue中引入mapState，在computed中读取状态数据 123456 import &#123;mapState&#125; from 'vuex' export default &#123; computed: &#123; ...mapState(['shops'])&#125; &#125; 修改template并添加data 12345 data () &#123;return &#123; baseImgUrl: 'http://owoccema2.bkt.clouddn.com/show/MintShop/' &#125; &#125; 12345678910111213141516171819 &lt;li class="shop_li border-1px" v-for="(shop,index) in shops" :key="index"&gt;&lt;a&gt; &lt;div class="shop_left"&gt; &lt;img class="shop_img" :src="baseImgUrl + shop.image_path"&gt; &lt;/div&gt; &lt;div class="shop_right"&gt; &lt;section class="shop_detail_header"&gt; &lt;h4 class="shop_title ellipsis"&gt;&#123;&#123;shop.name&#125;&#125;&lt;/h4&gt; &lt;ul class="shop_detail_ul"&gt; ... &lt;/ul&gt; &lt;/section&gt; &lt;section class="shop_rating_order"&gt; &lt;section class="shop_rating_order_left"&gt; ... &lt;/section&gt; &lt;/div&gt;&lt;/a&gt; &lt;/li&gt; 开发评分Star组件 不仅在首页的商家列表中有五颗星星的评分部分，商家信息的评价区域也有star评分，所以可以把它抽取成一个可复用的一般组件。 在components文件夹下新建Star文件夹，然后将原本在ShopList文件夹下的images文件夹里的stars移动到新建的Star文件夹里并重命名为images 在Star文件夹里新建Star.vue并将ShopList.vue中评分部分的模版和样式剪切进去，注意修改图片路径 1234567&lt;div class="star star-24"&gt; &lt;span class="star-item on"&gt;&lt;/span&gt; &lt;span class="star-item on"&gt;&lt;/span&gt; &lt;span class="star-item on"&gt;&lt;/span&gt; &lt;span class="star-item half"&gt;&lt;/span&gt; &lt;span class="star-item off"&gt;&lt;/span&gt;&lt;/div&gt; 根据类名为组件设置属性props和计算属性 1234567891011121314151617181920212223242526272829303132333435// 类名常量const CLASS_ON = 'on'const CLASS_HALF = 'half'const CLASS_OFF = 'off'export default &#123; props: &#123; score: Number, size: Number &#125;, computed: &#123; /* 3.2: 3 + 0 + 2 4.7: 4 + 1 + 0 */ // 该方法产生一个数组starArr来表示on half off类名的span数量（总长度为5） starClasses () &#123; const &#123;score&#125; = this const starArr = [] // 向starArr中添加n个CLASS_ON const scoreInteger = Math.floor(score) for (let i = 0; i &lt; scoreInteger; i++) &#123; starArr.push(CLASS_ON) &#125; // 向starArr中添加0/1个CLASS_HALF if(score*10-scoreInteger*10&gt;=5) &#123; starArr.push(CLASS_HALF) &#125; // 向starArr中添加n个CLASS_OFF while(starArr.length&lt;5) &#123; starArr.push(CLASS_OFF) &#125; return starArr &#125; &#125;&#125; 修改template模版 123&lt;div class="star" :class="'star-'+size"&gt; &lt;span class="star-item" v-for="(sc, index) in starClasses" :class="sc" :key="index"&gt;&lt;/span&gt;&lt;/div&gt; 在ShopList中import引入并注册使用 1&lt;Star :score="shop.rating" :size="24"&gt;&lt;/Star&gt; 使用svg显示页面加载中提示界面 目前首页的内容数据已经可以异步获取并显示，但在数据还未加载完成时，为了优化用户体验，应该给出页面加载中的提示界面。 首先将svg资源图片放入相应的Msite和ShopList的images文件夹里 然后修改模版的显示条件 123456&lt;!--Msite--&gt;&lt;div class="swiper-container" v-if="categorys.length"&gt; ...&lt;/div&gt;//没有数据的时候显示图片&lt;img src="./images/msite_back.svg" alt="back" v-else&gt; 12345678910&lt;!--ShopList--&gt;&lt;ul class="shop_list" v-if="shops.length"&gt; ...&lt;/ul&gt;&lt;!-- 循环显示6个svg图片 --&gt;&lt;ul v-else&gt; &lt;li v-for="item in 6" :key="item"&gt; &lt;img src="./images/shop_back.svg" alt="back"&gt; &lt;/li&gt;&lt;/ul&gt;]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex]]></title>
    <url>%2F2018%2F11%2F11%2Fvuex%2F</url>
    <content type="text"><![CDATA[vuex主要是状态管理，将数据统一管理(state) 模块 状态对象 stat 操作state 直接更新state的多个方法对象 mutations 操作mutations 间接更新state的多个方法对象 actions 包含多个基于state的getter计算属性的对象 getters 包含n个mutations的type名称常量 mutations-type 引入12import Vuex from 'vuex'Vue.use(Vuex) 使用共享的数据1const state=&#123;&#125;; 建立统一数据容器，唯一的容器123let store = new Vuex.Store(&#123; state&#125;) store(容器)注册到实例上，main.js里面，所有的组件都会有一个属性this.$store123new Vue(&#123;store,&#125;) 在组件中使用，加不加this都一样1&#123;&#123;this.$store.state.XXX&#125;&#125; state(单向数据流) 注意,在组件中最好不要直接更改共享的数据，共享的数据仅仅给组件染 mutation 通过mutation(管理员)来更改状态，可以在store里面设置成严格模式 strict：true，mutation不支持异步 告诉mutations需要更改,mutations相当于methods 123456789101112const mutations=&#123; add(state,count)&#123; //state是自动放入的，默认指的就是当前的state //操作state的属性 state.XXX +=count &#125;&#125;let store = new Vuex.Store(&#123;state，mutations,strict：true&#125;) 组件通过mutations提交,第一个参数是与mutatioons里面的方法绑定，第二个参数是自定义参数 1this.$store.commit(&apos;add&apos;,2) 插件打印日志1234import logger from &apos;vuex/dist/logger&apos;const store = new Vuex.store(&#123; plugins:[logger()]&#125;) 整理src下面创建一个store文件\index.js 123456789101112import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)import logger from 'vuex/dist/logger'const state=&#123;&#125;;import mutations from './mutations'export default new Vuex.Store(&#123; state， mutations, strict：true, plugins:[logger()] &#125;) store下面再创建一个mutations.js,里面存放mutations的相关123456789101112import * as Types from &apos;mutations.types.js&apos;const mutations = &#123; // [方法名](state,&#123;param&#125;)&#123;&#125;[Types.INCREMENT](state)&#123; state.count+=1&#125;,[Types.DECREMENT](state)&#123; state.count-=1&#125;&#125;;export default mutations; 宏(一般大写)store下面再创建一个mutations.types.js里面存放mutations的方法的名字，方便查找1234//增加export const INCREMENT=&apos;INCREMENT&apos;//减少export const DECREMENT=&apos;DECREMENT&apos; 组件中引入同mutations.js中引入一样,只不过不加中括号import * as Types from ‘mutations.types.js’ Types.INCREMENTTypes.DECREMENT getters相当于computed,如果数据多了可以模仿mutations的抽离12345678910const getters=&#123; val(state)&#123; state.count%2?&apos;奇数&apos;:&apos;偶数&apos; &#125;&#125;;export default new Vuex.store(&#123;getters,&#125;)//引用时&#123;&#123;$store.getters.val&#125;&#125; actions 和后台交互的异步action，后台数据也需要修改 Action 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 引入api以及mutation-types 异步获取数据 异步获取地址 发送异步ajax请求 提交一个mutation 12345678910 //async 方法名(&#123;commit,参数可选&#125;&#123;&#125;)// 异步获取地址 async getAddress (&#123;commit, state&#125;) &#123; // 从state状态中获取到经纬度用来设置reqAddress的参数（看接口文档） const geohash = state.latitude + &apos;,&apos; + state.longitude // 1. 发送异步ajax请求 const result = await reqAddress(geohash) // 2. 根据结果提交一个mutation commit(RECEIVE_ADDRESS, &#123;address: result.data&#125;) &#125;,]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[demo_vue-shop1]]></title>
    <url>%2F2018%2F10%2F30%2Fvue-shop1%2F</url>
    <content type="text"><![CDATA[vue实战项目外卖1技术栈前段数据处理/交互/组件化 vue全家桶/技术栈 vue vue-router vuex mint-ui vue-lazyload vue-scroller 滑动库 vue-scroller better-scroll swiper 日期处理 moment date-fns 前后台交互 mock数据：mockjs 接口测试：postman ajax请求 axios 模块化 ES6 babel 项目构建/工程化 webpack vue-cli css预编译器 stylus 后台 node express mongodb 前端路由一级路由 首页 /miste Miste.vue 搜索 /search Search.vue 订单 /order Order.vue 个人 /profile Profile.vue 登陆 /login Login.vue(不适用底部导航) 商家 /shop Shop.vue(不适用底部导航) 二级导航 商家商品 /goods ShopGoods.vue 商家评价 /ratings ShopRatings.vue 商家信息 /info ShopInfo.vue 搭建项目1vue init webpack my-project 结构分析 |– build : webpack 相关的配置文件夹(基本不需要修改) |– config: webpack 相关的配置文件夹(基本不需要修改) index.js: 指定的后台服务的端口号和静态资源文件夹 |– node_modules |– src : 源码文件夹 |– main.js: 应用入口 js （初始化vue实例并使用需要的插件 ） |– static: 静态资源文件夹 |– .babelrc: babel 的配置文件 |– .editorconfig: 通过编辑器的编码/格式进行一定的配置 |– .eslintignore: eslint 检查忽略的配置 |– .eslintrc.js: eslint 检查的配置 |– .gitignore: git 版本管理忽略的配置 |– index.html: 默认的主渲染页面文件 |– package.json: 应用包配置文件 |– README.md: 应用描述说明的 readme 文件 编码测试与打包发布项目 编码测试npm run dev访问: http://localhost:8080编码, 自动编译打包(HMR), 查看效果 打包发布npm run build//服务器管理npm install -g serveserve dist访问: http://localhost:5000 字体图标准备使用阿里的图标库http://www.iconfont.cn/home/index?spm=a313x.7781069.1998910419.2生成的资源:http://at.alicdn.com/t/font_726904_68moeoeirj3.css 项目目录 src api 与后台交互模板文件夹 common 通用资源文件夹，如fonts/img/stylus components 非路由组件文件夹 filters 自定义过滤器模块文件夹 mock 模拟数据接口文件夹 pages 路由组件文件夹 router 路由器文件夹 store vuex相关模块文件夹 App.vue 应用组件，根组件 main.js 入口js stylus安装1npm install stylus stylus-loader --save-dev 使用12&lt;style lang=&apos;stylus&apos; rel=&apos;stylesheet/stylus&apos;&gt;&lt;/style&gt; 在common文件夹下新建stylus文件夹 在stylus文件加下面新建mixins.styl文件 分析整个项目的 vue 组件结构 |– components————非路由组件文件夹 |– FooterGuide—————底部组件文件夹 |– FooterGuide.vue——–底部组件 vue |– pages—————–路由组件文件夹 |– Msite—————首页组件文件夹 |– Msite.vue——–首页组件 vue |– Search—————-搜索组件文件夹 |– Search.vue———搜索组件 vue |– Order————–订单组件文件夹 |– Order.vue——-订单组件 vue |– Profile————–个人组件文件夹 |– Profile.vue——-个人组件 vue |– App.vue—————应用根组件 vue |– main.js—————应用入口 js 页面底部的FooterGuide组件只是用来放pages里的组件的容器，所以它不是路由组件 页面最上面的标题栏在我们的项目中属于路由组件的组成部分（与中间内容部分在一起） 但每个路由组件中都有最顶部的组件且相似度很高，所以可以将其抽取成为一个单独的组件 编写网页样式重置在项目主目录下的static文件夹内新建css文件夹 在css文件夹内新建重置样式文件reset.css 在index.html 中引入 1&lt;link rel="stylesheet" href="/static/css/reset.css"&gt; 移动端 meta 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no&quot;&gt; Fastclick 当用户一次点击屏幕之后，浏览器并不能立刻判断用户是要进行双击缩放，还是想要进行单击操作。因此，iOS Safari 就等待 300 毫秒，以判断用户是否再次点击了屏幕。 于是，300 毫秒延迟就这么诞生了。 安装fastclick库 解决点击响应延时 0.3s 问题 1npm install fastclick --save 在main.js中引入，并绑定到body 12import FastClick from 'fastclick'FastClick.attach(document.body); 路由引入组件普通引入1import Msite from '../pages/Msite/Msite.vue' 动态引入1&#123;path:'/msite',component:()=&gt; import('.../pages/Msite/Msite.vue')&#125; 在App.vue里使用router-view引入底部导航FooterFuide，映射成标签，渲染到页面上1234567891011121314//1.import FooterGuide from './components/FooterGuide/FooterGuide.vue'//2export default &#123; name: 'App', templates:&#123;FooterGuide&#125;&#125;//3&lt;template&gt; &lt;div id="app"&gt; &lt;router-view&gt; &lt;/router-view&gt; &lt;FooterGuide&gt;&lt;/FooterGuide&gt; &lt;/div&gt;&lt;/template&gt; FooterGuide.vueHeaderTop.vue因为基本每个组件的头部样式都类似，只有内容有区别，所以把它抽离出来。页面分析 中间有一个固定的标题栏，只是用在不同的路由组件中显示的内容不同 标题栏两侧可能有搜索框之类的部分（Msite）也可能没有 此组件为非路由组件的公用组件（所以在Components文件夹内）实现 标题栏两侧是否有其他部分，要用到slot插槽进行组件间通信 slot 通信是标签, 而不是单纯的数据 中间标题栏接收的文本可以用props 代码：123456789&lt;template&gt; &lt;header class=&quot;header&quot;&gt; &lt;slot name=&quot;left&quot;&gt;&lt;/slot&gt; &lt;span class=&quot;header_title&quot;&gt; &lt;span class=&quot;header_title_text ellipsis&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/span&gt; &lt;/span&gt; &lt;slot name=&quot;right&quot;&gt;&lt;/slot&gt; &lt;/header&gt;&lt;/template&gt; props 传递数据 父组件传值 1&lt;HeaderTop title="四川农业大学(雅安市雨城区)"&gt;&lt;/HeaderTop&gt; 子组件接收 123props:&#123; title:String &#125; 插槽 传递标签插槽用于显示父组件使用子组件时，中间内容的显示命名插槽 子组件插槽命名 1&lt;slot name=&quot;left&quot;&gt;&lt;/slot&gt; 父组件匹配插槽 1&lt;span slot=&quot;left&quot;&gt; Msite.vueSwiper 轮播文档: Swiper官方文档安装1npm install --save swiper 引入12import Swiper from &apos;swiper&apos;import &apos;swiper/dist/css/swiper.min.css&apos; ShopList.vue抽离出一个组件 Login.vue 利用@click=&quot;$router.back()&quot;实现点击页面的箭头返回上一级路由/Profile的功能 已确定底部的四个路由组件需要显示Footer部分 而Login组件为一级路由组件，且不需要显示底部的FooterGuide导航组件 所以为路由组件添加meta元数据来标识是否显示Footer,v-show=&quot;$route.meta.showFooter&quot;·来判断是否显示 123456&#123; path: '/msite', component: Msite, meta: &#123; showFooter: true &#125; 后台应用 整个项目为前后端分离的项目：mintshop-client 与 mintshop-server 后台应用负责处理前台应用提交的请求, 并给前台应用返回 json 数据 前台应用负责展现数据, 与用户交互, 与后台应用交互数据库 确保启动 mongodb 服务 进入mintshop-server文件夹，启动服务器应用: npm start 封装ajax请求函数新建两个文件api/ajax.jsapi/index.js 为了实现统一向后端发送请求数据，所以需要封装一个ajax请求函数 引入axios,axios返回的是一个promise对象1import axios from 'axios' 之前调用请求函数，返回的是response,现在想实现请求函数之后直接返回response.data 12345678910111213141516171819202122232425262728293031323334353637/** * 向外部暴漏一个函数 ajax * @param &#123;*&#125; url 请求路径，默认为空 * @param &#123;*&#125; data 请求参数，默认为空对象 * @param &#123;*&#125; type 请求方法，默认为GET */export default function ajax (url = '', data = &#123;&#125;, type = 'GET') &#123; // 返回值 Promise对象 （异步返回的数据是response.data，而不是response） return new Promise(function (resolve, reject) &#123; // （利用axios）异步执行ajax请求 let promise // 这个内部的promise用来保存axios的返回值(promise对象) if (type === 'GET') &#123; // 准备 url query 参数数据 let dataStr = '' // 数据拼接字符串，将data连接到url Object.keys(data).forEach(key =&gt; &#123; dataStr += key + '=' + data[key] + '&amp;' &#125;) if (dataStr !== '') &#123; dataStr = dataStr.substring(0, dataStr.lastIndexOf('&amp;')) url = url + '?' + dataStr &#125; // 发送 get 请求 promise = axios.get(url) &#125; else &#123; // 发送 post 请求 promise = axios.post(url, data) &#125; promise.then(response =&gt; &#123; // 成功回调resolve() resolve(response.data) &#125;) .catch(error =&gt; &#123; // 失败回调reject() reject(error) &#125;) &#125;)&#125; 封装接口请求函数 有了发送请求数据的ajax函数，还需要封装一些与后台交互的接口函数 根据接口文档来定义接口请求函数 这个接口函数返回的仍然是promise 在路径里面的是路径参数，通过第二个参数传过去的query参数]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reset.css]]></title>
    <url>%2F2018%2F10%2F29%2Freset-css%2F</url>
    <content type="text"><![CDATA[浏览器的样式重置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** * Eric Meyer&apos;s Reset CSS v2.0 (http://meyerweb.com/eric/tools/css/reset/) * http://cssreset.com */html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,b, u, i, center,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td,article, aside, canvas, details, embed,figure, figcaption, footer, header,menu, nav, output, ruby, section, summary,time, mark, audio, video, input &#123; margin: 0; padding: 0; border: 0; font-size: 100%; font-weight: normal; vertical-align: baseline;&#125;/* HTML5 display-role reset for older browsers */article, aside, details, figcaption, figure,footer, header, menu, nav, section &#123; display: block;&#125;body &#123; line-height: 1;&#125;blockquote, q &#123; quotes: none;&#125;blockquote:before, blockquote:after,q:before, q:after &#123; content: none;&#125;table &#123; border-collapse: collapse; border-spacing: 0;&#125;/* custom */a &#123; color: #7e8c8d; text-decoration: none; -webkit-backface-visibility: hidden;&#125;li &#123; list-style: none;&#125;::-webkit-scrollbar &#123; width: 5px; height: 5px;&#125;::-webkit-scrollbar-track-piece &#123; background-color: rgba(0, 0, 0, 0.2); -webkit-border-radius: 6px;&#125;::-webkit-scrollbar-thumb:vertical &#123; height: 5px; background-color: rgba(125, 125, 125, 0.7); -webkit-border-radius: 6px;&#125;::-webkit-scrollbar-thumb:horizontal &#123; width: 5px; background-color: rgba(125, 125, 125, 0.7); -webkit-border-radius: 6px;&#125;html, body &#123; width: 100%; height: 100%;&#125;body &#123; -webkit-text-size-adjust: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0);&#125;/*显示省略号*/.ellipsis&#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stylus]]></title>
    <url>%2F2018%2F10%2F29%2Fstylus%2F</url>
    <content type="text"><![CDATA[stylus学习笔记 冒号可选，分号可选，逗号可选，括号可选 缩进与空格很重要 12body color white 父级引用 &amp; 1234567891011121314textareainput color #A7A7A7 &amp;:hover color #000//等于textarea, input &#123; color: #a7a7a7; &#125; textarea:hover, input:hover &#123; color: #000; &#125; 变量 属性查找 @ 12345678#logo position: absolute top: 50% left: 50% width: 150px height: 80px margin-left: -(@width / 2) margin-top: -(@height / 2) 运算符 范围 .. 包含界限 …包含开头不包含结尾 存在操作符in 实例检查 is a 条件赋值：?= := 变量定义：is defined 混合书写 方法]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[demo_vue-book]]></title>
    <url>%2F2018%2F10%2F27%2Fvue-book%2F</url>
    <content type="text"><![CDATA[vue-book 接下来会学习vuex，在学习一门预处理语言，之后用我学过的所有东西做一个练习的项目vue学习之后，用vue-cli做的一个练习。这是学习vue的过程中走通了一遍流程，但还有很多功能没有实现 上拉下拉刷新 图片的懒加载 打包之后如何上线 vuex的学习 如何连接数据库等 github:https://github.com/biubiuins/vue-book 安装依赖 npm install vue npm install -g webpack npm install -g vue-cli npm install less less-loader axios vuex bootstrap 目录 build 打包后的脚本文件 src 源码文件 mock后台代码，模拟数据 src/api 代表的是所有的接口,获取数据给前端调用 src/base 基础组件 src/components 页面组件实现路由根据页面划分了5个页面组件 首页 Home.vue 列表 List.vue 收藏 Collect.vue 添加 Add.vue 详情 Detail.vue 配置路由，配置路由映射表并new个实例,挂载在根组件上，router-view显示在App.vuerouter/index.js Vue.use()是用来安装Vue插件123import Vue from 'vue'import Router from 'vue-router'Vue.use(Router); 这里用了模板，将会另外写一篇，关于前端的模板与node的 导航base/Tab.vuescoped 表示是当前组件的样式，并不是全局的1&lt;style scoped lang=&quot;less&quot;&gt; less预处理语言，学习之后会写一篇博客 点击导航之后会通过to跳转页面，并且样式改变这里需要注意/home 确切激活，仅仅这个路径有效。router-link-exact-active/home /home/a 都可以。router-link-active123&lt;router-link to=&quot;/add&quot;&gt;&lt;i class=&quot;iconfont icon-add&quot;&gt;&lt;/i&gt;&lt;span&gt;添加&lt;/span&gt;&lt;/router-link&gt; 基础组件Tab挂载在App.vue上（导航很多页面都需要），并在App.vue上写全局的样式，清除默认样式。新学习到的清除输入框和按钮的默认样式1input，button&#123;appearance:none;&#125; App.vue的组件中有name: &#39;App&#39;，这里name: &#39;app&#39; 相当于一个全局 ID。可以不写，写了可以提供更好的调试信息。页面渲染也是在App.vue中实现的 图标http://www.iconfont.cn/home/index?spm=a313x.7781069.1998910419.2图标打包好了之后在index.html中引入\iconfont是必须类名表明是个icon，后面根据页面选择1&lt;i class=&quot;iconfont icon-shouye&quot;&gt;&lt;/i&gt;&lt;span&gt;首页&lt;/span&gt; 头部base/Mheader.vue头部的标题不是全部一样的，并且比如首页是没有返回键的，所以这里用到的插槽和父组件给子组件传值这里用Home.vue-Mheader.vue为例 在父组件上挂载Mheader.vue &lt;Mheader.vue&gt;首页，首页需要显示出来，需要在子组件Mheader.vue中放个匿名插槽接收 父组件需要传递一个值告诉子组件是否显示返回键。子组件接收back，不需要验证的时候用数组，需要验证的时候用对象。 12345 &lt;i class=&quot;iconfont icon-fanhui&quot; v-if=&quot;back&quot;&gt;&lt;/i&gt;...props:&#123; back:&#123;type:Boolean,default:false&#125; &#125; 点击返回键，返回上一个操作 1this.$router.go(-1); 扩展一下,back也可以返回。this.$router.back() 强制跳转页面，在后面追加，点返回还可以回去。this.$router.push(‘/XXX’) 路由替换，将原来的替换。this.$router.replace(‘/XXX’)轮播图base/Swiper.vue安装依赖1npm install vue-awesome-swiper --save-dev 在main.js中引入vue-awesome-swiper插件123import VueAwesomeSwiper from &apos;vue-awesome-swiper&apos;import &apos;swiper/dist/css/swiper.css&apos;Vue.use(VueAwesomeSwiper) 后台获取图片信息mock/sliders.js 存放图片连接mock/server.js 配置服务器url.parse()可以将一个完整的URL地址，分为很多部分，常用的有：host、port、pathname、path、query。12345678let sliders = require(&apos;./sliders&apos;)http.createServer((req,res)=&gt;&#123;let&#123;pathname,query&#125; = url.parse(req.url); if (pathname === &apos;/sliders&apos;)&#123; res.setHeader(&apos;Content-Type&apos;,&apos;application/json;charset=utf-8&apos;) res.end(JSON.stringify(sliders)) &#125;&#125; 但是当前段发起ajax请求的时候，是8080端口请求3000端口的数据，所以有跨域的问题，这里需要在服务器中加入跨域头12345res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,Content-Length, Authorization, Accept,X-Requested-With&quot;);res.setHeader(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;);res.setHeader(&quot;X-Powered-By&quot;,&apos; 3.2.1&apos;)if(req.method==&quot;OPTIONS&quot;) return res.end();/*让options请求快速返回*/ 轮播图的api12345678import axios from 'axios';//设置基本的默认请求路径axios.defaults.baseURL ='http://localhost:3000';//获取轮播图数据export let getSliders=()=&gt;&#123; //因为设置了了efaults.baseURL，所以它请求的路径其实是http://localhost:3000/sliders,返回的是一个promise对象 return axios.get('/sliders')&#125; axios 笔记待整理 前端获取数据获取的数据父子组件传值，传给子组件，子组件渲染出图片如果给接收到的data一个新的名字 slider {data：slider}1234async created()&#123; let &#123;data&#125; = await getSliders().then() this.sliders=data&#125;, async/await 已整理 热门图书/删除图书 先写服务端，确保数据能正常返回 增加api方法，实现调取数据的功能 在哪个组件中应用这个api，如果是一个基础组件需要这些数据，在使用这个组件的父级中调用这个方法，将数据传递给基础组件 详情页面如果用对象作为to的属性，并且使用了参数，必须给路由起个名字，通过名字跳转router/index.js1&#123;path:&apos;/detail/:bid&apos;,component:Detail,name:&apos;detail&apos;&#125; component/List.vue需要配置路径参数，点击哪个li跳转哪个详情这是跳转用到router-link，把之前的li改为router-link， params是路径参数 循环组件，需要加上key router-link是a标签，这里需要的是li，在taf里面修改1&lt;router-link v-for=&quot;(book,index) in books&quot; :to=&quot;&#123;name:&apos;detail&apos;,params:&#123;bid:book.bookId&#125;&#125;&quot; :key=&quot;index&quot; tag=&quot;li&quot; &gt; 因为点击li跳转，删除按钮也在li里面，所以这个应该阻止删除按钮冒泡1&lt;button @click.stop=&quot;remove(book.bookId)&quot;&gt;删除&lt;/button&gt; component/Detail.vue12//获取通过传过来的参数$route.params.XXX 获取当前id的图书信息渲染到界面。 问题一: 当修改的时候，价格原本是数字，修改之后会变成字符串,加上数字的修饰符 1&lt;input type=&quot;text&quot; v-model.number=&quot;book.bookPrice&quot; id=&quot;bookPrice&quot;&gt; 问题二修改url的时候，页面没有刷新，因为模板已经渲染出来了，不会在走created办法。所以，需要监控url的变化，路径参数发生变化，通过监控参数的变化来发送ajax 123456watch:&#123;//路径参数发生变化，通过监控参数的变化来发送ajax$route()&#123; this.getData() ; &#125;&#125; 问题三如果没有找到对应id的书，那返回的是空对象，如果是空，需要跳转回列表页Object.keys()，该方法返回一个数组,里面是对象的所有属性。如果是空对象那么返回一个空数组。 1Object.keys(this.book).length&gt;0?void 0:this.$ruoter.push(&apos;/List&apos;) 处理一下url,server.js查询book的条件变一下 1if (!isNaN(id)) 数据改变之后，需要用put更新数据PUT：参数1：url:/book?id=3参数2：请求体发送server.js获取put/post请求体中的数据使用这两个事件就可以获取来自服务器端的响应内容。 data，数据传递时触发， end，没有更多数据提供时触发1234567let str = &quot;&quot;; res.on(&apos;data&apos;,(chunk)=&gt;&#123; str += chunk; &#125;); res.on(&apos;end&apos;,()=&gt;&#123; console.log(str); &#125;); 添加页面同详情页面 优化与其他功能loading轮播图和热门图书是分开获取的，这里改成一起获取api/index1return axios.all([getSliders(),getHotBook()]) 数据返回的是一个数组，里面是两个promise对象。 新建base/Loading.vue,挂载在Home.vuehttps://www.cnblogs.com/lhb25/p/loading-spinners-animated-with-css3.html 实现页面缓存分页面缓存，路由元信息。在配置路由映射的时候有meta(备注)属性,这条对象可以通过this.$route获取1&#123;path:&apos;/home&apos;,component:Home,meta:&#123;keepAlive:true&#125;&#125;, 修改APP.vue,写两个router-view，一个用于，显示缓存的，一个用于显示一般的123456789&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; &lt;Tab&gt;&lt;/Tab&gt; &lt;/div&gt;&lt;/template&gt; 实现路由动画给router-view外面包裹一个标签,注意点：一个只能包裹一个标签写css样式12345678910.fadeIn-enter&#123; opacity: 0;&#125;.fadeIn-enter-active&#123; transition:all 0.3s;&#125;.fadeIn-leave-active&#123; transition: all 0.3s; opacity: 0;&#125; 下拉加载更多打包上线history路由在路由中改变mode:’history’ 标题router/indexmeta:{title:XXX}main.js全局钩子，在进入路由之前每一次都会执行此方法。有拦截的作用router.beforeEach(function(from.to,next){ document.title = to.meta.title; next();});]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP 简括]]></title>
    <url>%2F2018%2F10%2F24%2Fhttp%E7%AE%80%E6%8B%AC%2F</url>
    <content type="text"><![CDATA[http一次完整的HTTP请求需要7个步骤 建立TCP连接 Web浏览器向Web服务器发送请求命令 一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。 Web浏览器发送请求头信息 浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。 Web服务器应答 客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码 Web服务器发送应答头信息 正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。 Web服务器向浏览器发送数据 Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。 Web服务器关闭TCP连接一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：Connection:keep-alive，TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。 http协议的特点①通信流程：断开式（无状态） 断开式：http协议每次响应完成后，会断开与客户端的连接 无状态：由于服务器断开了之前的连接，就无法知晓连接间的关系。 ②内容格式：消息头和消息体 HTTP请求方法 OPTIONS返回服务器针对特定资源所支持的HTML请求方法 或web服务器发送*测试服务器功能。询问支持的方法。 HEAD 类似get，但只返回响应头。 常用于查看某个页面的状态 GET 获取资源 GET方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。 使用GET方法时，请求参数和对应的值附加在URL后面，利用一个问号（“?”）代表URL的结尾与请求参数的开始 POST 向指定资源提交数据进行处理请求（提交表单、上传文件） 将请求参数封装在HTTP请求数据中，以名称/值的形式出现 PUT向指定资源位置上上传其最新内容 DELETE请求服务器删除 TRACE 回显服务器收到的请求，用于测试和诊断 CONNECTHTTP/1.1协议中能够将连接改为管道方式的代理服务器 get 和 post区别get请求无消息体，只能携带少量数据post请求有消息体，可以携带大量数据get请求将数据放在url地址中post请求将数据放在消息体中 HTTP状态码 1xx：相关信息 2xx：操作成功 3xx：重定向 4xx：客户端错误 5xx：服务器错误GET安全且幂等获取表示变更时获取表示（缓存） 200（OK） - 表示已在响应中发出 204（无内容） - 资源有空表示 301（Moved Permanently） - 资源的URI已被更新 303（See Other） - 其他（如，负载均衡） 304（not modified）- 资源未更改（缓存） 400 （bad request）- 指代坏请求（如，参数错误） 404 （not found）- 资源不存在 406 （not acceptable）- 服务端不支持所需表示 500 （internal server error）- 通用错误响应 503 （Service Unavailable）- 服务端当前无法处理请求POST创建子资源部分更新资源 如果没有被修改，则不过更新资源（乐观锁） 200（OK）- 如果现有资源已被更改 201（created）- 如果新资源被创建 202（accepted）- 已接受处理请求但尚未完成（异步处理） 301（Moved Permanently）- 资源的URI被更新 303（See Other）- 其他（如，负载均衡） 400（bad request）- 指代坏请求 404 （not found）- 资源不存在 406 （not acceptable）- 服务端不支持所需表示 409 （conflict）- 通用冲突 412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突） 415 （unsupported media type）- 接受到的表示不受支持 500 （internal server error）- 通用错误响应 503 （Service Unavailable）- 服务当前无法处理请求 PUT通过替换的方式更新资源 200 （OK）- 如果已存在资源被更改 201 （created）- 如果新资源被创建 301（Moved Permanently）- 资源的URI已更改 303 （See Other）- 其他（如，负载均衡） 400 （bad request）- 指代坏请求 404 （not found）- 资源不存在 406 （not acceptable）- 服务端不支持所需表示 409 （conflict）- 通用冲突 412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突） 415 （unsupported media type）- 接受到的表示不受支持 500 （internal server error）- 通用错误响应 503 （Service Unavailable）- 服务当前无法处理请求 DELETE不安全但幂等删除资源 200 （OK）- 资源已被删除 301 （Moved Permanently）- 资源的URI已更改 303 （See Other）- 其他，如负载均衡 400 （bad request）- 指代坏请求 404 （not found）- 资源不存在 409 （conflict）- 通用冲突 500 （internal server error）- 通用错误响应 503 （Service Unavailable）- 服务端当前无法处理请求 http的请求部分 请求方法（GET/POST）、URI、协议/版本 请求头(Request Header) 空行 请求正文 https://blog.csdn.net/chen1403876161/article/details/51546653| 请求头 | 说明 | 实列|| —— | —— |——|| Accept |这个头信息指定浏览器或其他客户端可以处理的 MIME 类型|Accept:application/json, text/plain, /||Accept-Encoding|浏览器能够进行解码的数据编码方式|Accept-Encoding:gzip, deflate, br||Accept-Language| 这个头信息指定客户端的首选语言，在这种情况下，Servlet 会产生多种语言的结果|Accept-Language:zh-CN,zh;q=0.8||Accept-Charset|浏览器可接受的字符集|||Connection|这个头信息指示客户端是否可以处理持久 HTTP 连接。持久连接允许客户端或其他浏览器通过单个请求来检索多个文件|Connection:keep-alive||Host|指定请求资源的Intenet主机和端口号（服务器，向谁请求）|Host:localhost:3000||Referer|这个头信息指示所指向的 Web 页的 URL。例如，如果您在网页 1，点击一个链接到网页 2，当浏览器请求网页 2 时，网页 1 的 URL 就会包含在 Referer 头信息中。||User-Agent|这个头信息识别发出请求的浏览器或其他客户端，并可以向不同类型的浏览器返回不同的内容。||Content-Length|这个头信息只适用于 POST 请求，并给出 POST 数据的大小（以字节为单位）。|Content-Length:60||Content-Type|用于post请求|Content-Type：application/json;charset=UTF-8||Authorization|授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中|| HTTP content-type application/x-www-form-urlencoded 这应该是最常见的 POST 提交数据的方式了。中默认的encType，form表单数据被编码为 key/value格式发送到服务器（表单默认的提交数据的格式） multipart/form-data 需要在表单中进行文件上传时，就需要使用该格式 application/jsonJSON数据格式 HTTP响应头信息 状态行 响应头(Response Header) 空行 响应正文 其他一般的在上面的连接中可以看到，这里整理了平时遇到的跨域问题 跨域的响应头123456res.setHeader("Access-Control-Allow-Origin", "*"); res.setHeader("Access-Control-Allow-Headers", "Content-Type,Content-Length, Authorization, Accept,X-Requested-With"); res.setHeader("Access-Control-Allow-Methods","PUT,POST,GET,DELETE,OPTIONS"); res.setHeader("X-Powered-By",' 3.2.1') res.setHeader("Content-Type", "application/json;charset=utf-8"); if(req.method=="OPTIONS") return res.end();/*让options请求快速返回*/]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise/axios/async/await]]></title>
    <url>%2F2018%2F10%2F22%2Fpromise-axios%2F</url>
    <content type="text"><![CDATA[axios/promise/async/await这里整理axios时，把牵扯到的基础promise学习了，更深一步的以后再深入。axios跨域的问题等之后再整理，这篇仅仅是一些简单的基础 promise用法：可以将异步操作以同步操作的流程表达处理，避免层层嵌套回调函数promise对象有三种状态，对象的状态不受外界影响 pending 进行中 fulfilled 已成功 rejected 已失败 并且一旦状态改变，就不会再变，任何时候都可以得到这个结果,这时称为resolved(已定型)。状态改变只有两种可能 pending到fulfilled pending到rejected Promise实例生成以后，then方法有2个参数，第一个函数接收resolved状态的执行，第二个参数接收reject状态的执行。且then的执行结果也会返回一个Promise对象。12345promise.then(function(value) &#123; // success,resolved时调用&#125;, function(error) &#123; // failure rejected时调用&#125;); axios基于promise用于浏览器和node.js的http客户端 特点 支持浏览器和node.js 支持promise 能拦截请求和响应 能转换请求和响应数据 能取消请求 自动转换JSON数据 浏览器端支持防止CSRF(跨站请求伪造) 使用1import axios from &apos;axios&apos;; 请求get请求123axios.get(url).then(res=&gt;&#123;&#125;).catch(error=&gt;&#123;&#125;) .then访问成功12345//打印的是object对象//data，status，statusText，headers，comfigXXXX.then(res=&gt;&#123;console.log(res)&#125;)//打印的是promise对象XXXX.then() .catch捕获错误 传参1axios.get(url,&#123;params:&#123;&#125;&#125;) 常用配置全局默认路径1axios.defaults.baseURL =&apos;http://localhost:3000&apos;; 拦截器在请求或者返回被then或者catch处理之前对它们进行拦截12345678910111213141516// 添加请求拦截器axios.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 return config; &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;);// 添加响应拦截器axios.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 return response; &#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error); &#125;); async/awaitES7 提出的async 函数，终于让 JavaScript 对于异步操作有了终极解决方案。async作为一个关键字放到函数前面，表示函数是一个异步函数，异步函数也就意味着该函数的执行不会阻塞后面代码的执行。 内置执行器。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，调用方式跟普通函数的调用一样 返回值是 Promise。async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用 写异步代码就像写同步代码一样了，不用不断的回调了。 语法async 函数返回一个 Promise 对象async 函数内部 return 返回的值是个Promise 对象。当调用该函数时，内部会调用Promise.solve() 方法把它转化成一个promise 对象作为返回12345678async function timeout() &#123; return &apos;hello world&apos;&#125;console.log(timeout());console.log(&apos;虽然在后面，但是我先执行&apos;);//输出//Promise&#123;&#125;//虽然在后面，但是我先执行 async 函数内部 return 返回的值。会成为 then 方法回调函数的参数。只有当 async 函数内部的异步操作都执行完，才会执行 then 方法的回调。12345678910 async function timeout() &#123; return &apos;hello world&apos; &#125; timeout().then(result =&gt; &#123; console.log(result); &#125;) console.log(&apos;虽然在后面，但是我先执行&apos;); //输出 //虽然在后面，但是我先执行 //hello world 如果 async 函数内部抛出异常，则会导致返回的 Promise 对象状态变为 reject 状态。抛出的错误而会被 catch 方法回调函数接收到。12345async function e()&#123; throw new Error(&apos;error&apos;);&#125;e().then(v =&gt; console.log(v)).catch( e =&gt; console.log(e)); await await 后面放置的就是返回promise对象的一个表达式。await 表示等一下，先执行await后面的代码，等后面的promise对象执行完毕，再继续像下执行。 正常情况下，await 命令后面跟着的是 Promise，如果不是的话，也会被转换成一个 立即 resolve 的 Promise1234 async function f() &#123; return await 1&#125;;f().then( (v) =&gt; console.log(v)) // 1]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[demo_todoList]]></title>
    <url>%2F2018%2F10%2F13%2Ftodolist%2F</url>
    <content type="text"><![CDATA[demo_todoList 功能 将数据循坏到页面 敲回车时添加新数据（需要添加isSelected属性） 删除功能 计算当前没有被选中的，选中的有删除样式 双击任务可以修改任务,已经完成的不可以 自定义输入框聚焦 回车或者失去焦点的时候修改成功 计算属性 根据hash展示todolist 数据永久化，hash单页刷新 收获watch 监控todos的变化,当变化时更新数据 watch:todos(){} 只能监控一层的数据变化（删减） watch:todos:handler(){},deep:true 深度监控directivess 自定义指令，指令是操作的dom XXX(el,bindings){} 名字需要和v-XXX的相同，el指代的是当前的dom，bindings参数 github: https://github.com/biubiuins/demo_todolist]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2F2018%2F10%2F12%2Fgit%2F</url>
    <content type="text"><![CDATA[git的基本操作 初次配置第一步需要配置用户名和邮箱地址，因为git为每一次提交记录名字和邮箱地址12$ git config --global user.name &apos;runoob&apos;$ git config --global user.email test@runoob.com ssh key 生成一对shh key（id_rsa私钥，id_rsa.pub公钥） 1ssh-keygen 注：在主目录下生成的密钥在 /c/Users/用户名/.ssh/id_rsa 里 查看公钥内容（需在.ssh目录下执行） 1cat id_rsa.pub 复制密钥内容添加到 github 上 使用ssh协议上传文件到仓库 12345git initgit add .git commit -m &quot; &quot;git remote add origin git@github.com:...git push -u origin master 注：若在创建新仓库时有readme.md 文件会上传失败 新建版本库 git里面先进入新建库的文件夹下 初始化库初始化目录，目录下回出现一个.git的目录，该目录包含了资源的所有元数据 12git initgit init 目录名 添加文件到暂存区将当前目录下几个文件纳入版本控制，需要先用git add 命令告诉git开始对这些文件进行跟踪 123git add .//添加当前项目的所有文件git add README //添加名为README的文件git add -A 所有修改的内容添加到缓存区 增加到版本库中使用 git add 命令将想要快照的内容写入缓存区， 而执行 git commit -m将缓存区内容添加到仓库中。 12git commit -a 跳过这一步git commit -m&quot;版本留言描述&quot; 连接远程仓库（现在GitHub上面新建仓库） 1git remote add origin 仓库地址 讲本地仓库推送到远程库上 12git pushgit push -u origin master //首次执行，说明上传到仓库的master分支上 问题：![rejected] master -&gt; master (fetch first)解决办法：1. 先执行git pull.然后再执行git push –force origin master替换原先的 git push -u origin master 从远程库克隆先把别人的fork进自己的库里面 克隆仓库到指定目录 123//自己在本地进入需要克隆进的文件夹下执行下面第一条指令git clone 仓库地址git clone 仓库地址 本地目录 add commit push 删除文件 本地删除文件 123//或者直接在文件管理器中把没用的文件删了//需要git进入文件夹下$ rm test.txt Git知道你删除了文件，这个时候只是本地删除了文件，而版本库里面还有文件，所以可以恢复文件 1$ git checkout -- test.txt 远程库删除文件 1git rm test.txt 记得还需要commit 我的石墨文档：https://shimo.im/docs/2Eg0gszciPEQBPxG/]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[express学习笔记]]></title>
    <url>%2F2018%2F10%2F12%2Fexpress%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[express 学习笔记 搭建简单服务器1234567891011//express() 是一个由 express 模块导出的入口（top-level）函数let express = require('express');//创建一个express应用实例名applet app = express();// 设置端口号：3000//process.env.PORT：读取当前目录下环境变量port的值let port = process.env.PORT || 3000 ;//在端口号上开启服务app.listen(port,function () &#123; console.log("server start"+port);&#125;); app.listen(port, [hostname], [backlog], [callback])类似于node中的http.Server.listen()1234567// 设置端口号：3000//process.env.PORT：读取当前目录下环境变量port的值let port = process.env.PORT || 3000 ;//在端口号上开启服务app.listen(port,function () &#123; console.log("server start"+port);&#125;); 服务器启动时候，默认端口3000：node app.js设置端口8080：PORT=8080 node app.js app.set(name,value)123456789//设置 views 文件夹为存放视图文件的目录, 即存放模板文件的地方,__dirname 为全局变量,存储当前正在执行的脚本所在的目录。app.set('views', path.join(__dirname, 'views'));app.set("views","./views");//设置使用的模板引擎app.set('view engine', 'ejs’)app.set("view engine","jade")npm install --save express-art-template//设置art模板引擎，后缀为artapp.engine('art', require('express-art-template')); app.get(name)返回name的value值1234567891011//实例一app.get('title');// =&gt; undefinedapp.set('title', 'My Site');app.get('title');// =&gt; "My Site"//实例二app.set('port', process.env.PORT || 3000);var server = app.listen(app.get('port'), function() &#123; console.log("server start"+port);&#125;); app.get(path, callback [, callback …])app.all(path, callback [, callback …])这种方法就像标准的app.METHOD()方法, 除了它匹配所有HTTP动词。访问path路径的所有方法执行的回调函数.12345//* 表示匹配所有的路径app.all('*', function(req, res)&#123; res.end(req.method + 'user')&#125;//一般放在最后面防止前面的被覆盖 请求与响应123456//Express 应用使用回调函数的参数： request 和 response 对象来处理请求和响应的数据。app.get('/', function(req, res)&#123; res.send('hello world'); res.status(404).send(错误请求)//访问这个路径是设定状态码为404 //通过res.send（）接口向客户端发送hello world，send只能响应一次，意思是只能出现一个send&#125;) res.send（）只能出现一次如果要响应多次，用node原生的write和end，但是如果只有write会处于一个挂起状态1234app.get('/', function(req, res)&#123; res.write('hello world'); res.write('hello world');&#125;) res.send有结束响应的作用 res.write没有结束响应的作用，需要res.end结束中间件挂起response下表中响应对象（res）的方法向客户端返回响应，终结请求响应的循环。如果在路由句柄中一个方法也不调用，来自客户端的请求会一直挂起。res.render()12345//设置 views 文件夹为存放视图文件的目录, 即存放模板文件的地方,__dirname 为全局变量,存储当前正在执行的脚本所在的目录。app.set('views', path.join(__dirname, 'views'));app.set("views","./views");//第一个是渲染的views文件夹下面的index，第二个是传递的数据,注意需要设置模板引擎res.render("index",&#123;&#125;,function()&#123;&#125;) res.setHeader()12//Content-Type的作用 该实体头的作用是让服务器告诉浏览器它发送的数据属于什么文件类型。res.setHeader(&quot;Content-Type&quot;,&apos;text/html;charset=utf-8&apos;) res.redirect()调用redirect()方法后，其后的代码都不会被执行。而使用redirect()设置的状态码不是301或302也不会发生跳转12res.redirect([status,] path)//重定义到path所指定的URL，重定向时可以同时指定HTTP状态码，不指定状态码默认为302 res.location()location()方法本质上是调用了ServerResponse对象的setHeader()方法，但并没有设置状态码。使用location()设置头信息，而不设置状态码或状态码不是301或302，并不会发生重定向1res.location(path) request req.query处理 get 请求，获取 get 请求参数12345678910// GET /search?q=tobi+ferretreq.query.q// =&gt; "tobi ferret"// GET /shoes?order=desc&amp;shoe[color]=blue&amp;shoe[type]=conversereq.query.order// =&gt; "desc"req.query.shoe.color// =&gt; "blue"req.query.shoe.type// =&gt; "converse" req.body处理 post 请求，获取 post 请求体12345678// POST user[name]=tobi&amp;user[email]=tobi@learnboost.comreq.body.user.name// =&gt; "tobi"req.body.user.email// =&gt; "tobi@learnboost.com"// POST &#123; "name": "tobi" &#125;req.body.name// =&gt; "tobi" req.params处理 /:xxx 形式的 get 或 post 请求，获取请求参数123456// GET /user/tjreq.params.name// =&gt; "tj"// GET /file/javascripts/jquery.jsreq.params[0]// =&gt; "javascripts/jquery.js" req.param(name)处理 get 和 post 请求，但查找优先级由高到低为 req.params→req.body→req.query123456789// ?name=tobireq.param('name')// =&gt; "tobi"// POST name=tobireq.param('name')// =&gt; "tobi"// /user/tobi for /user/:namereq.param('name')// =&gt; "tobi" 中间件用于客户端与服务器路由匹配之前的中间操作，正常中间件放在路由上面，中间件通过next()往下走。 app.use（[path],function）利用express托管静态文件node.js不能通过目录来引入文件，而express可以，public为静态目录1234//设置public文件夹为存放静态文件的目录。let path=require("path")//ex4里面唯一的内置中间件app.use(express.static(path.join(__dirname, 'public'))); 一个中间件处理器，请求来了，让那些中间件先处理一遍 没有挂载路径的中间件，应用的每个请求都会执行该中间件 挂载至 /path 的中间件，任何指向 /path 的请求都会执行它1234567app.use(&quot;/name&quot;,function(req,res,next)&#123;res.setHeader(&quot;Content-Type&quot;,&apos;text/html;charset=utf-8&apos;)next();&#125;)app.get(&quot;/name/n&quot;,function(req,res)&#123;&#125;)//也可以匹配到，在执行get请求/name/n时先执行上面的中间件 错误中间件错误处理中间件和其他中间件定义类似，只是必须要使用 4 个参数(err, req, res, next)。即使不需要 next 对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。遇见错误之后直接执行错误中间件。错误处理中间件应当在在其他 app.use() 和路由调用之后才能加载，一般放在路由的最底部，比如：123456789var bodyParser = require('body-parser');var methodOverride = require('method-override');app.use(bodyParser());app.use(methodOverride());app.use(function(err, req, res, next) &#123; // 业务逻辑 console.error(err.stack); res.status(500).send('Something broke!');&#125;); 应用生成器12345678910//安装$ npm install express-generator -g//view=XXX 使用引擎名字 myapp项目名称$ express --view=pug myapp//安装所有依赖$ cd myapp$ npm install//启动myapp项目$ set DEBUG=myapp:* &amp; npm start 我的石墨文档链接：https://shimo.im/docs/TXeewzaE8Jsdgn0I/练习的简易聊天室连接：https://github.com/biubiuins/demo_chat]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[project_email]]></title>
    <url>%2F2018%2F10%2F11%2Fproject-email%2F</url>
    <content type="text"><![CDATA[邮件收发项目大二上开始学html，css，js之后做的暑假做的前端页面，很感谢老师可以给一个练手的机会，在做的过程中发现了很多问题，以及项目完成之后的收获。&nbsp;&nbsp;&nbsp;&nbsp;虽然是一个很简单的界面，但是之前学习的时候不太仔细，也没有demo练习，还是做的磕磕绊绊，还好最后做的差不多了。TAT&nbsp;&nbsp;针对过程中的问题，阅读了很多关于语法规范的文章，js，jq又重新学习了一遍（练习了很多），大二下期基本在学习之中度过的。希望在以后的项目中可以有所进步，彻底的实现前后端分离！！！ 项目相关 完成时间：大二上期寒假 2018-3月左右 bootsrap框架，layui框架，jquery 项目不足 语法不规范，复用性不强，后面修改过一次感觉修改起来很复杂 js不熟练，项目之后大二下期又重新开始学习了一遍js，并写了总结 (https://biubiuins.github.io/2018/10/11/summary-2018-9/) 技术不足，没有实现前后端分离 主要功能 首页 http://mailroom.sicau.edu.cn/email/public/ bootsrap做了响应式，用了ajax请求数据 管理页面（需要登陆仅提供图片） 实现全选与批量删除 点击已取之后，重新获取数据（保证筛选邮件之后点击已取仍显示的是筛选之后的邮件) 邮件类型默认显示上一次选择的类型，可输入筛选的下拉框 超级管理员界面实现了原生js模态框，并做了根据屏幕居中]]></content>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[summary-2018.9]]></title>
    <url>%2F2018%2F10%2F11%2Fsummary-2018-9%2F</url>
    <content type="text"><![CDATA[summary-2018-9 这是在学会搭建博客之后的第一篇博客，以前学习的时候也有记笔记，所以把之前学习笔记上面整理的常见的功能、封装以及遇到的问题写出来，这篇仅限于js，jq。现在正在学习vue，希望在过段时间，自己也能写出关于vue学习的总结。在此之前还需要了解markdown的语法TAT 原来的笔记记录在石墨文档，https://shimo.im/docs/c8YrJy4obNICaWiS/ ID处理1234/** 获取id */function $(id) &#123; return typeof id === "string" ? document.getElementById(id) : null;&#125; 动画匀速动画1234567891011121314151617181920//元素，目标，步数function constant(obj, target, speed) &#123; // 1. 清除定时器 clearInterval(obj.timer); //2.判断方向 //如果现在的距离小于目标值,则往右，否则向左 let dir =obj.offsetLeft&lt;target?speed:-speed; //3. 设置定时器 obj.timer = setInterval(function () &#123; obj.style.left = obj.offsetLeft + dir + "px"; //若超出目标值或者不到目标值 //最后相减的值取绝对值后，总是小于步数的 //Math.abs(dir)||speed if(Math.abs(target-obj.offsetLeft)&lt;Math.abs(dir))&#123; clearInterval(obj.timer); //根据目标值板正 obj.style.left =target+'px'; &#125; &#125;, 20);&#125; 缓动动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function buffer(obj, json, fn) &#123; // 1. 清除定时器 clearInterval(obj.timer); var begin = 0, end = 0; // 2. 设置定时器 obj.timer = setInterval(function () &#123; // 2.0 旗帜, 决定动画是否结束 let flag = true; // 2.1 遍历 for(let k in json)&#123; // 2.2.-1 求出起始值 和 结束值 if(k === 'opacity')&#123; // 透明度 begin = parseInt( parseFloat(getCssAttr(obj, k)) * 100); end = parseInt(parseFloat(json[k]) * 100); &#125;else if(k === 'scrollTop')&#123; // 滚动到头部 begin = obj.scrollTop; end = parseInt(json[k]); &#125;else &#123; // 正常情况 begin = parseInt(getCssAttr(obj, k)); end = parseInt(json[k]); &#125; // 2.2.0 求出步长 //步长公式 let step = (end - begin) * 0.2; step = step &gt;=0 ? Math.ceil(step) : Math.floor(step); // 2.2.1 计算起始位置 if(k === 'opacity')&#123; obj.style.opacity = (begin + step) / 100; obj.style.filter = 'alpha(opacity=' + (begin + end)+')'; // 针对IE &#125;else if(k === 'scrollTop')&#123; obj.scrollTop = begin + step; &#125;else if(k === 'zIndex')&#123; obj.style[k] = json[k]; &#125;else &#123; obj.style[k] = begin + step + 'px'; &#125; // 2.2.2 判断 if(begin !== end)&#123; flag = false; &#125; &#125; // 3.0 结束动画 if(flag)&#123; clearInterval(obj.timer); // 开启动画组中的下一组动画 if(fn)&#123; // 判断有没有这个函数 fn(); &#125; &#125; &#125;, 60);&#125; js获取CSS利用 [] 访问属性 元素.style[“属性”];1234567891011121314//这种语法的好处就是可以动态的传递参数作为属性//只能获取行类标签 var h = 'height'; box.style[h] = 300 + 'px';//获取外部css或页内的cssfunction getStyleAttr(obj, attr) &#123; if(obj.currentStyle)&#123; // IE 和 opera return obj.currentStyle[attr]; &#125;else &#123; //window.getComputedStyle("元素", "伪类") （ 注意：两个选项是必须的，没有伪类 用 null 替代 ） //也可以点选，但是为了传递参数作为属性 return window.getComputedStyle(obj, null)[attr]; &#125;&#125; 定时器 在定时器事件前，先设置接收定时器的变量指向null 在定时器事件里，先要清除定时器再设置定时器，先清除是防止定时器累加轮播第一种这种不适合多图1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162function slider (sliderid,olStyleClassName,imgWidth,speed,second) &#123; //高级排他 //lastIndex 选中的小圆点样式 currentIndex 小圆点索引 picIndex 图片索引 let lastIndex=0,currentIndex=0,picIndex=0; // 1. 获取需要的标签 let ul=$(sliderid).children[0]; let ol=$(sliderid).children[1]; let list=ul.children; let olList= ol.children; // 2.克隆最后一个li标签 ul.appendChild(list[0].cloneNode(true)); // 3.动态创建小圆点 for(let i= 0;i&lt;list.length-1;i++)&#123; let li =document.createElement("li"); ol.appendChild(li); &#125; //4.第一个小圆点选中 olList[0].className=olStyleClassName; //5.监听每个li的进入事件 for(let i= 0;i&lt;olList.length;i++)&#123; //5.1 每一个li绑定自己的事件 olList[i].onmouseover=function () &#123; //先清除之前的选中状态，在把当前选中的索引给lastIndex lastIndex=currentIndex; olList[lastIndex].className=""; this.className=olStyleClassName; lastIndex=i; //5.2图片动起来 constant(ul,-(i * imgWidth),speed); currentIndex=picIndex=i; &#125;; &#125; //6.定时器 let timer; timer = setInterval(autoPlay, second); // 7. 清除和设置定时器 $(sliderid).onmouseover = function () &#123; clearInterval(timer); &#125;; $(sliderid).onmouseout = function () &#123; timer = setInterval(autoPlay, second); &#125;; function autoPlay()&#123; picIndex++; currentIndex++; //如果图片到了最后一张 if (picIndex &gt; list.length - 1) &#123; ul.style.left = 0; //从第二张图片开始 picIndex = 1; &#125; constant(ul, -(picIndex * imgWidth), speed); //小原点的选中 if (currentIndex &gt; olList.length - 1) &#123; currentIndex = 0; &#125; for (let i=0;i&lt;olList.length;i++)&#123; olList[i].className=""; &#125; olList[currentIndex].className=olStyleClassName; &#125;&#125; 第二种两个图片宽度的位置，第一个位置显示（当前），第二位置隐藏 第三种改变透明度，循环一遍让所有的opacity动画为0，然后当前为opacity动画为1，索引++、12345678910111213141516171819function opacityAutoPlay(ulid,speed) &#123; // 1. 获取所有的li标签 var lis = $(ulid).getElementsByTagName("li"); var index = 0; // 2. 开始定时器 setInterval(function () &#123; // 2.1 改变透明度 for(let i=0; i&lt;lis.length; i++)&#123; let singerLi = lis[i]; buffer(singerLi, &#123;opacity: 0&#125;, null); &#125; buffer(lis[index], &#123;opacity: 1&#125;, null); // 2.2 索引++ index++; if(index === lis.length)&#123; index = 0; &#125; &#125;, speed);&#125; 瀑布流 父盒子居中 Math.floor(屏幕宽度/子盒子宽度)=cols 子盒子的宽度*cols=父盒子的宽度 margin:0 auto; 子盒子定位第一行不变，其他子盒子接在第一行最矮的盒子的后面（反复） 拿到所有盒子的高度。把第一行的盒子的高度放在一个数组里面（i&lt;cols,heightArr[]) 在剩下的盒子里面(i&gt;=cols),找出第一行最矮的盒子的高度（Math.min(…heightArr)||Math.min.apply(this.height)）2.1 找出最矮盒子的索引(遍历heightArr[],找出和第二步盒子高度一样的i返回)2.2 剩下盒子定位（left=第2.1步的索引*子盒子宽度，top=最矮的盒子高度）2.3 更新最矮盒子的高度 （heightArr[最矮盒子的高度]+=当前盒子的高度） 滚动加载图片 监听窗口的滚动，滚动到你需要的位置加载 js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 window.onload = function () &#123; // 1. 实现瀑布流布局 waterFull("main", "box"); // 2. 动态加载图片 window.onscroll = function () &#123; if(checkWillLoadImage())&#123; // 2.1 造数据 var dataArr = [ &#123;"src": "img04.jpg"&#125;, &#123;"src": "img06.jpg"&#125;, &#123;"src": "img08.jpg"&#125;, &#123;"src": "img09.jpg"&#125;, &#123;"src": "img10.jpg"&#125;, &#123;"src": "img12.jpg"&#125;, &#123;"src": "img14.jpg"&#125;, &#123;"src": "img16.jpg"&#125;, &#123;"src": "img18.jpg"&#125; ]; // 2.2 创建元素 for(var i=0; i&lt;dataArr.length; i++)&#123; var newBox = document.createElement("div"); newBox.className = "box"; $("main").appendChild(newBox); var newPic = document.createElement("div"); newPic.className = "pic"; newBox.appendChild(newPic); var newImg = document.createElement("img"); newImg.src = "images/" + dataArr[i].src; newPic.appendChild(newImg); &#125; // 2.3 重新布局 waterFull("main", "box"); &#125; &#125;&#125;;/** * 实现瀑布流布局 */function waterFull(parent, child) &#123; // 1. 父盒子居中 // 1.1 获取所有的盒子 var allBox = $(parent).getElementsByClassName(child); // 1.2 获取子盒子的宽度 var boxWidth = allBox[0].offsetWidth; // 1.3 获取屏幕的宽度 var screenW = document.documentElement.clientWidth; // 1.4 求出列数 var cols = parseInt(screenW / boxWidth); // 1.5 父盒子居中 $(parent).style.width = cols * boxWidth + 'px'; $(parent).style.margin = "0 // 2. 子盒子的定位 // 2.1 定义高度数组 var heightArr = [], boxHeight = 0, minBoxHeight = 0, minBoxIndex = 0; // 2.2 遍历子盒子 for (var i = 0; i &lt; allBox.length; i++) &#123; // 2.2.1 求出每一个子盒子的高度 boxHeight = allBox[i].offsetHeight; // 2.2.2 取出第一行盒子的高度放入高度数组 if (i &lt; cols) &#123; // 第一行 heightArr.push(boxHeight); &#125; else &#123; // 剩余行 // 1. 取出最矮的盒子高度 // minBoxHeight = _.min(heightArr); minBoxHeight=Math.min(...heightArr); // 2. 求出最矮盒子对应的索引 minBoxIndex = getMinBoxIndex(heightArr, minBoxHeight); // 3. 子盒子定位 allBox[i].style.position = "absolute"; allBox[i].style.left = minBoxIndex * boxWidth + 'px'; allBox[i].style.top = minBoxHeight + 'px'; // 4. 更新数组中的高度 heightArr[minBoxIndex] += boxHeight; &#125; &#125; console.log(heightArr, minBoxHeight, minBoxIndex);&#125;/** * 获取数组中最矮盒子高度的索引 * @param arr * @param val * @returns &#123;number&#125; */function getMinBoxIndex(arr, val) &#123; for(var i=0; i&lt;arr.length; i++)&#123; if(arr[i] === val)&#123; return i; &#125; &#125;&#125;/** * 判断是否具备加载图片的条件 */function checkWillLoadImage() &#123; // 1. 获取最后一个盒子 var allBox = document.getElementsByClassName("box"); var lastBox = allBox[allBox.length - 1]; // 2. 求出最后一个盒子自身高度的一半 + offsetTop var lastBoxDis = lastBox.offsetHeight * 0.5 + lastBox.offsetTop; // 3. 求出屏幕的高度 var screenW = document.body.clientHeight || document.documentElement.clientHeight; // 4. 求出页面偏离浏览器的高度 var scrollTop = scroll().top; return lastBoxDis &lt;= screenW + scrollTop;&#125; jq123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//当页面加载完毕$(window).on('load',function () &#123;//1.实现瀑布流布局waterFall();//2.滚动加载$(window).on('scroll',function () &#123;//判断是否加载if (checkWillLoad())&#123;////创造假数据var data = &#123;'dataImg':[&#123;'img':'23.jpg'&#125;,&#123;'img':'24.jpg'&#125;,&#123;'img':'25.jpg'&#125;,&#123;'img':'26.jpg'&#125;,&#123;'img':'27.jpg'&#125;,&#123;'img':'28.jpg'&#125;]&#125;;//遍历创建盒子$.each(data.dataImg,function (index,value)&#123;//创建一个div标签 设置它的类为'box' 添加到'main'里面去var newBox = $('&lt;div&gt;').addClass('box').appendTo($('#main')); var newPic = $('&lt;div&gt;').addClass('pic').appendTo($(newBox)); //创建img 取出遍历的对象value的img属性对应的值 $('&lt;img&gt;').attr('src','images/'+$(value).attr('img')).appendTo($(newPic)); &#125;) //1.实现瀑布流布局 waterFall(); &#125; &#125;); &#125;); //实现瀑布流布局 function waterFall () &#123; //拿到所有的盒子 var allBox = $('#main &gt; .box'); //取出其中一个盒子的宽度 var boxWidth = $(allBox).eq(0).outerWidth(); //取出屏幕的高度 var screenWidth = $(window).width(); //求出列数 //取整函数取整 var cols = Math.floor( screenWidth/boxWidth); //父标签居中 $('#main').css(&#123; 'width':cols * boxWidth + 'px', 'margin':'0 auto' &#125;); //对子盒子定位 var heightArr = []; //遍历 $.each(allBox,function (index,value) &#123; //取出单独盒子的高度 var boxHeight = $(value).outerHeight(); //判断是否第一行 if(index &lt; cols) &#123; heightArr[index] = boxHeight; &#125; else //剩余的盒子要瀑布流布局 &#123; //求出最矮的盒子高度 var minBoxHeight = Math.min.apply(null,heightArr); //取出最矮高度对应的索引 封装了js的这个方法 var minBoxIndex = $.inArray(minBoxHeight,heightArr); //定位 $(value).css(&#123; 'position':'absolute', 'top':minBoxHeight + 'px', 'left':minBoxIndex * boxWidth + 'px' &#125;); //更新数组中最矮的高度 heightArr[minBoxIndex] += boxHeight; &#125; &#125;) &#125; //判断是否符合加载条件 function checkWillLoad() &#123; //直接取出最后一个盒子 var lastBox = $('#main &gt; div').last(); //取出最后一个盒子高度的一半 + 头部偏离的位置 var lastBoxDis = $(lastBox).outerHeight() + $(lastBox).offset().top; //求出浏览器的高度 var clientHeight = $(window).height(); //求出页面偏离浏览器高度 var scrollTopHeight = $(window).scrollTop(); //比较返回 return lastBoxDis &lt;= clientHeight + scrollTopHeight; &#125; margin:0 auto 块级元素 给定要居中的块级元素的宽度。 所有元素也可以通过对父元素设置text-align：center；的方式来实现居中。而对于块元素来说，对要居中的元素自身进行设置text-align:center也能实现居中 margin:0 auto;可以使盒子居中，text-align:center;可以使文本居中，节流onresize举列子窗口大小一变化就执行，太过灵敏，所以需要阻止1234567891011121314151617//使用定时器var timer = null;window.onresize = function () &#123; clearTimeout(timer); // 节流 timer = setTimeout(function () &#123; waterFull('main', 'box'); &#125;, 200);&#125;//封装之后的function throttle(fn, delay) &#123; var timer = null; return function () &#123; clearTimeout(timer); timer = setTimeout(fn, delay); &#125;&#125; apply/call这个面试中常考到，现在只做初步了解(https://www.cnblogs.com/gaowx/p/4837687.html ) 改变函数的this指向 apply可以改变传递给函数参数的形式Date123456789101112131415161718192021222324function newDate()&#123; //声明日期对象，里面可以设置参数表示其他时间 let date =new Date(); //获取时间里面的年 date.getFullYear() //月0-11 date.getMonth()+1 //日1-31 date.getDate() //获取星期0-6 data.Day //设置某一天 date.setDate（day） //时0-23 date.getHours() //分0-59 date.getMinutes() //秒0-59 date.getSeconds() //获取毫秒 date.getMilliSeconds() //时间戳 date.getTime()&#125; ms转化时间 cookie封装封装成插件，引入该文件后，$.addCookie(key,value,day,path,domain)来引用1234567891011121314151617181920212223242526272829303132333435363738394041;(function ($,window) &#123; $.extend(&#123; addCookie: function addCookie(key,value,day,path,domain)&#123; //1.处理默认保存的路径 var index=window.location.pathname.lastIndexOf('/'); var currentPath=window.location.pathname.slice(0,index) path=path||currentPath //2.处理默认domain domain=domain||document.domain //3.处理默认的过期时间 if(!day)&#123; document.cookie=key+"="+value+";path="+path+";domain="+domain+';' &#125; else&#123; var date =new Date(); date.setDate(date.getDate()+day) document.cookie=key+"="+value+";expires="+date.toGMTString()+";path="+path+";domain="+domain+';' &#125; &#125;, getCookie: function getCookie(key)&#123; var res=document.cookie.split(';') for(var i=0;i&lt;res.length;i++)&#123; //把key和value切割 var temp=res[i].split('=') //前后可能有空格，把空格删除 if(temp[0].trim()===key)&#123; return temp[1] &#125; &#125; &#125;, delCookie: function delCookie(key, path) &#123; //默认情况下只能删除默认路径中保存的cookie，如果要删除指定路径保存的cookie，要把路径值传出去 //设置过期时间为-1 addCookie(key, getCookie(key), -1, path) &#125; &#125;);&#125;)(jQuery,window); 动态添加的元素绑定事件 delegate 123$(&apos;ul&apos;).delegate(&apos;li&apos;,&apos;click&apos;,function()&#123;//操作的还是li&#125;) onclick事件在动态添加数据的时候，就给元素绑定onclick事件 on（）常用 12345//把动态添加的元素写在on里面，如果调用的函数是外部定义好的，则在调用的时候不加（）//不然会跳过点击事件直接执行函数$(&quot;父元素或祖辈元素&quot;).on(&quot;click&quot;,&quot;动态添加的元素&quot;,function()&#123;$(this).css(&quot;border&quot;,&quot;5px solid #000&quot;);&#125; 其他清除默认样式http://yui.yahooapis.com/3.18.1/build/cssreset/cssreset-min.css 下拉框1234567891011121314151617181920//拿到select对象：var myselect=document.getElementById("select");//拿到选中项的索引var index=myselect.selectedIndex ; // selectedIndex代表的是你所选中项的index//拿到选中项options的value：myselect.options[index].value;//拿到选中项options的text：myselect.options[index].text;//拿到选中项的其他值，比如这里的url： myselect.options[index].getAttribute('url');//jqueryvar options=$(“#select option:selected”); //获取选中的项alert(options.val()); //拿到选中项的值alert(options.text()); //拿到选中项的文本alert(options.attr('url')); //拿到选中项的url值//设置//设置value为pxx的项选中$(".selector").val("pxx")//设置text为pxx的项选中$(".selector").find("option[text='pxx']").attr("selected",true) H5 datalistdatalist 只是列表赋值取值还是通过input.样式等都在input上操作https://www.zhangxinxu.com/wordpress/2013/03/html5-datalist-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8-%E5%8F%AF%E8%A1%8C%E6%80%A7/ 邮箱的自动补全HTML代码：123456789邮箱：&lt;input type=&quot;email&quot; id=&quot;email&quot; list=&quot;emailList&quot; name=&quot;off_autocomplete&quot; /&gt;&lt;datalist id=&quot;emailList&quot;&gt;//其中*为占位符，当文本框输入内容的时候，*替换成邮箱地址的前半部分，于是，动态邮件地址提示的效果就实现了 &lt;option value=&quot;*@qq.com&quot;&gt; &lt;option value=&quot;*@163.com&quot;&gt; &lt;option value=&quot;*@gmail.com&quot;&gt; &lt;option value=&quot;*@yahoo.com.cn&quot;&gt; &lt;option value=&quot;*@126.com&quot;&gt;&lt;/datalist&gt; JS代码：12345678910111213141516171819202122232425262728var eleList = document.getElementById("emailList") , eleMail = document.getElementById("email") , htmlListInit = '', arrEmailList = [];if (eleMail &amp;&amp; eleList &amp;&amp; (htmlListInit = eleList.innerHTML) !== '') &#123; // 得到类似["qq.com", "163.com", "gmail.com", ...]的数据 arrEmailList = [].slice.call(eleList.getElementsByTagName("option")).map(function(option) &#123; return option.value.replace("*@", ""); &#125;); eleMail.fnListReplace = function() &#123; var arrValue = this.value.trim().split("@"); // 修复FireFox浏览器下无限input问题 // 如果值不完全匹配某option值，执行动态替换 if (arrValue.length !== 2 || arrEmailList.indexOf(arrValue[1]) === -1) &#123; eleList.innerHTML = htmlListInit.replace(/\*/g, arrValue[0]); &#125; return this; &#125;; // 绑定输入事件侦听 eleMail.addEventListener("input", function() &#123; this.fnListReplace.call(this); &#125;, false); // 载入即匹配 eleMail.fnListReplace.call(eleMail).focus();&#125; else &#123; eleList = document.createElement("datalist"); eleList.innerHTML = '&lt;p class=sorry&gt;抱歉，当前浏览器不支持HTML5 datalist.&lt;/p&gt;'; eleMail.parentNode.appendChild(eleList);&#125; jquery.editable-select控件引入jquery.editable-select.cssjquery.editable-select.js调用方法123456789101112$('#editable-select').editableSelect(&#123; bg_iframe: true, //是否加iframe case_sensitive: false, items_then_scroll: 10 ,//设置下拉选项的数目 isFilter:false/true, //是否根据条件过滤下拉选项 onCreate:, //当输入时触发 onShow：, //当下拉时触发 onHide：, //当下拉框隐藏时触发 onSelect：, //当下拉框中的选项被选中时触发 effects:default/slide/fade， //动画效果 duration： //动画效果的时间&#125;);]]></content>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
</search>
