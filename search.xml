<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTTP 简括]]></title>
    <url>%2F2018%2F10%2F24%2Fhttp%E7%AE%80%E6%8B%AC%2F</url>
    <content type="text"><![CDATA[http一次完整的HTTP请求需要7个步骤 建立TCP连接 Web浏览器向Web服务器发送请求命令 一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。 Web浏览器发送请求头信息 浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。 Web服务器应答 客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码 Web服务器发送应答头信息 正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。 Web服务器向浏览器发送数据 Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。 Web服务器关闭TCP连接一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：Connection:keep-alive，TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。 http协议的特点①通信流程：断开式（无状态） 断开式：http协议每次响应完成后，会断开与客户端的连接 无状态：由于服务器断开了之前的连接，就无法知晓连接间的关系。 ②内容格式：消息头和消息体 HTTP请求方法 OPTIONS返回服务器针对特定资源所支持的HTML请求方法 或web服务器发送*测试服务器功能。询问支持的方法。 HEAD 类似get，但只返回响应头。 常用于查看某个页面的状态 GET 获取资源 GET方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。 使用GET方法时，请求参数和对应的值附加在URL后面，利用一个问号（“?”）代表URL的结尾与请求参数的开始 POST 向指定资源提交数据进行处理请求（提交表单、上传文件） 将请求参数封装在HTTP请求数据中，以名称/值的形式出现 PUT向指定资源位置上上传其最新内容 DELETE请求服务器删除 TRACE 回显服务器收到的请求，用于测试和诊断 CONNECTHTTP/1.1协议中能够将连接改为管道方式的代理服务器 get 和 post区别get请求无消息体，只能携带少量数据post请求有消息体，可以携带大量数据get请求将数据放在url地址中post请求将数据放在消息体中 HTTP状态码 1xx：相关信息 2xx：操作成功 3xx：重定向 4xx：客户端错误 5xx：服务器错误GET安全且幂等获取表示变更时获取表示（缓存） 200（OK） - 表示已在响应中发出 204（无内容） - 资源有空表示 301（Moved Permanently） - 资源的URI已被更新 303（See Other） - 其他（如，负载均衡） 304（not modified）- 资源未更改（缓存） 400 （bad request）- 指代坏请求（如，参数错误） 404 （not found）- 资源不存在 406 （not acceptable）- 服务端不支持所需表示 500 （internal server error）- 通用错误响应 503 （Service Unavailable）- 服务端当前无法处理请求POST创建子资源部分更新资源 如果没有被修改，则不过更新资源（乐观锁） 200（OK）- 如果现有资源已被更改 201（created）- 如果新资源被创建 202（accepted）- 已接受处理请求但尚未完成（异步处理） 301（Moved Permanently）- 资源的URI被更新 303（See Other）- 其他（如，负载均衡） 400（bad request）- 指代坏请求 404 （not found）- 资源不存在 406 （not acceptable）- 服务端不支持所需表示 409 （conflict）- 通用冲突 412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突） 415 （unsupported media type）- 接受到的表示不受支持 500 （internal server error）- 通用错误响应 503 （Service Unavailable）- 服务当前无法处理请求 PUT通过替换的方式更新资源 200 （OK）- 如果已存在资源被更改 201 （created）- 如果新资源被创建 301（Moved Permanently）- 资源的URI已更改 303 （See Other）- 其他（如，负载均衡） 400 （bad request）- 指代坏请求 404 （not found）- 资源不存在 406 （not acceptable）- 服务端不支持所需表示 409 （conflict）- 通用冲突 412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突） 415 （unsupported media type）- 接受到的表示不受支持 500 （internal server error）- 通用错误响应 503 （Service Unavailable）- 服务当前无法处理请求 DELETE不安全但幂等删除资源 200 （OK）- 资源已被删除 301 （Moved Permanently）- 资源的URI已更改 303 （See Other）- 其他，如负载均衡 400 （bad request）- 指代坏请求 404 （not found）- 资源不存在 409 （conflict）- 通用冲突 500 （internal server error）- 通用错误响应 503 （Service Unavailable）- 服务端当前无法处理请求 http的请求部分 请求方法（GET/POST）、URI、协议/版本 请求头(Request Header) 空行 请求正文 https://blog.csdn.net/chen1403876161/article/details/51546653| 请求头 | 说明 | 实列|| —— | —— |——|| Accept |这个头信息指定浏览器或其他客户端可以处理的 MIME 类型|Accept:application/json, text/plain, /||Accept-Encoding|浏览器能够进行解码的数据编码方式|Accept-Encoding:gzip, deflate, br||Accept-Language| 这个头信息指定客户端的首选语言，在这种情况下，Servlet 会产生多种语言的结果|Accept-Language:zh-CN,zh;q=0.8||Accept-Charset|浏览器可接受的字符集|||Connection|这个头信息指示客户端是否可以处理持久 HTTP 连接。持久连接允许客户端或其他浏览器通过单个请求来检索多个文件|Connection:keep-alive||Host|指定请求资源的Intenet主机和端口号（服务器，向谁请求）|Host:localhost:3000||Referer|这个头信息指示所指向的 Web 页的 URL。例如，如果您在网页 1，点击一个链接到网页 2，当浏览器请求网页 2 时，网页 1 的 URL 就会包含在 Referer 头信息中。||User-Agent|这个头信息识别发出请求的浏览器或其他客户端，并可以向不同类型的浏览器返回不同的内容。||Content-Length|这个头信息只适用于 POST 请求，并给出 POST 数据的大小（以字节为单位）。|Content-Length:60||Content-Type|用于post请求|Content-Type：application/json;charset=UTF-8||Authorization|授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中|| HTTP content-type application/x-www-form-urlencoded 这应该是最常见的 POST 提交数据的方式了。中默认的encType，form表单数据被编码为 key/value格式发送到服务器（表单默认的提交数据的格式） multipart/form-data 需要在表单中进行文件上传时，就需要使用该格式 application/jsonJSON数据格式 HTTP响应头信息 状态行 响应头(Response Header) 空行 响应正文 其他一般的在上面的连接中可以看到，这里整理了平时遇到的跨域问题 跨域的响应头123456res.setHeader("Access-Control-Allow-Origin", "*"); res.setHeader("Access-Control-Allow-Headers", "Content-Type,Content-Length, Authorization, Accept,X-Requested-With"); res.setHeader("Access-Control-Allow-Methods","PUT,POST,GET,DELETE,OPTIONS"); res.setHeader("X-Powered-By",' 3.2.1') res.setHeader("Content-Type", "application/json;charset=utf-8"); if(req.method=="OPTIONS") return res.end();/*让options请求快速返回*/]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise/axios/async/await]]></title>
    <url>%2F2018%2F10%2F22%2Fpromise-axios%2F</url>
    <content type="text"><![CDATA[axios/promise/async/await这里整理axios时，把牵扯到的基础promise学习了，更深一步的以后再深入。axios跨域的问题等之后再整理，这篇仅仅是一些简单的基础 promise用法：可以将异步操作以同步操作的流程表达处理，避免层层嵌套回调函数promise对象有三种状态，对象的状态不受外界影响 pending 进行中 fulfilled 已成功 rejected 已失败 并且一旦状态改变，就不会再变，任何时候都可以得到这个结果,这时称为resolved(已定型)。状态改变只有两种可能 pending到fulfilled pending到rejected Promise实例生成以后，then方法有2个参数，第一个函数接收resolved状态的执行，第二个参数接收reject状态的执行。且then的执行结果也会返回一个Promise对象。12345promise.then(function(value) &#123; // success,resolved时调用&#125;, function(error) &#123; // failure rejected时调用&#125;); axios基于promise用于浏览器和node.js的http客户端 特点 支持浏览器和node.js 支持promise 能拦截请求和响应 能转换请求和响应数据 能取消请求 自动转换JSON数据 浏览器端支持防止CSRF(跨站请求伪造) 使用1import axios from &apos;axios&apos;; 请求get请求123axios.get(url).then(res=&gt;&#123;&#125;).catch(error=&gt;&#123;&#125;) .then访问成功12345//打印的是object对象//data，status，statusText，headers，comfigXXXX.then(res=&gt;&#123;console.log(res)&#125;)//打印的是promise对象XXXX.then() .catch捕获错误 传参1axios.get(url,&#123;params:&#123;&#125;&#125;) 常用配置全局默认路径1axios.defaults.baseURL =&apos;http://localhost:3000&apos;; 拦截器在请求或者返回被then或者catch处理之前对它们进行拦截12345678910111213141516// 添加请求拦截器axios.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 return config; &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;);// 添加响应拦截器axios.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 return response; &#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error); &#125;); async/awaitES7 提出的async 函数，终于让 JavaScript 对于异步操作有了终极解决方案。async作为一个关键字放到函数前面，表示函数是一个异步函数，异步函数也就意味着该函数的执行不会阻塞后面代码的执行。 内置执行器。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，调用方式跟普通函数的调用一样 返回值是 Promise。async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用 写异步代码就像写同步代码一样了，不用不断的回调了。 语法async 函数返回一个 Promise 对象async 函数内部 return 返回的值是个Promise 对象。当调用该函数时，内部会调用Promise.solve() 方法把它转化成一个promise 对象作为返回12345678async function timeout() &#123; return &apos;hello world&apos;&#125;console.log(timeout());console.log(&apos;虽然在后面，但是我先执行&apos;);//输出//Promise&#123;&#125;//虽然在后面，但是我先执行 async 函数内部 return 返回的值。会成为 then 方法回调函数的参数。只有当 async 函数内部的异步操作都执行完，才会执行 then 方法的回调。12345678910 async function timeout() &#123; return &apos;hello world&apos; &#125; timeout().then(result =&gt; &#123; console.log(result); &#125;) console.log(&apos;虽然在后面，但是我先执行&apos;); //输出 //虽然在后面，但是我先执行 //hello world 如果 async 函数内部抛出异常，则会导致返回的 Promise 对象状态变为 reject 状态。抛出的错误而会被 catch 方法回调函数接收到。12345async function e()&#123; throw new Error(&apos;error&apos;);&#125;e().then(v =&gt; console.log(v)).catch( e =&gt; console.log(e)); await await 后面放置的就是返回promise对象的一个表达式。await 表示等一下，先执行await后面的代码，等后面的promise对象执行完毕，再继续像下执行。 正常情况下，await 命令后面跟着的是 Promise，如果不是的话，也会被转换成一个 立即 resolve 的 Promise1234 async function f() &#123; return await 1&#125;;f().then( (v) =&gt; console.log(v)) // 1]]></content>
      <tags>
        <tag>vue</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[demo_todoList]]></title>
    <url>%2F2018%2F10%2F13%2Ftodolist%2F</url>
    <content type="text"><![CDATA[demo_todoList 功能 将数据循坏到页面 敲回车时添加新数据（需要添加isSelected属性） 删除功能 计算当前没有被选中的，选中的有删除样式 双击任务可以修改任务,已经完成的不可以 自定义输入框聚焦 回车或者失去焦点的时候修改成功 计算属性 根据hash展示todolist 数据永久化，hash单页刷新 收获watch 监控todos的变化,当变化时更新数据 watch:todos(){} 只能监控一层的数据变化（删减） watch:todos:handler(){},deep:true 深度监控directivess 自定义指令，指令是操作的dom XXX(el,bindings){} 名字需要和v-XXX的相同，el指代的是当前的dom，bindings参数 github: https://github.com/biubiuins/demo_todolist]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2F2018%2F10%2F12%2Fgit%2F</url>
    <content type="text"><![CDATA[git的基本操作 初次配置第一步需要配置用户名和邮箱地址，因为git为每一次提交记录名字和邮箱地址12$ git config --global user.name &apos;runoob&apos;$ git config --global user.email test@runoob.com ssh key 生成一对shh key（id_rsa私钥，id_rsa.pub公钥） 1ssh-keygen 注：在主目录下生成的密钥在 /c/Users/用户名/.ssh/id_rsa 里 查看公钥内容（需在.ssh目录下执行） 1cat id_rsa.pub 复制密钥内容添加到 github 上 使用ssh协议上传文件到仓库 12345git initgit add .git commit -m &quot; &quot;git remote add origin git@github.com:...git push -u origin master 注：若在创建新仓库时有readme.md 文件会上传失败 新建版本库 git里面先进入新建库的文件夹下 初始化库初始化目录，目录下回出现一个.git的目录，该目录包含了资源的所有元数据 12git initgit init 目录名 添加文件到暂存区将当前目录下几个文件纳入版本控制，需要先用git add 命令告诉git开始对这些文件进行跟踪 123git add .//添加当前项目的所有文件git add README //添加名为README的文件git add -A 所有修改的内容添加到缓存区 增加到版本库中使用 git add 命令将想要快照的内容写入缓存区， 而执行 git commit -m将缓存区内容添加到仓库中。 12git commit -a 跳过这一步git commit -m&quot;版本留言描述&quot; 连接远程仓库（现在GitHub上面新建仓库） 1git remote add origin 仓库地址 讲本地仓库推送到远程库上 12git pushgit push -u origin master //首次执行，说明上传到仓库的master分支上 问题：![rejected] master -&gt; master (fetch first)解决办法：1. 先执行git pull.然后再执行git push –force origin master替换原先的 git push -u origin master 从远程库克隆先把别人的fork进自己的库里面 克隆仓库到指定目录 123//自己在本地进入需要克隆进的文件夹下执行下面第一条指令git clone 仓库地址git clone 仓库地址 本地目录 add commit push 删除文件 本地删除文件 123//或者直接在文件管理器中把没用的文件删了//需要git进入文件夹下$ rm test.txt Git知道你删除了文件，这个时候只是本地删除了文件，而版本库里面还有文件，所以可以恢复文件 1$ git checkout -- test.txt 远程库删除文件 1git rm test.txt 记得还需要commit 我的石墨文档：https://shimo.im/docs/2Eg0gszciPEQBPxG/]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[express学习笔记]]></title>
    <url>%2F2018%2F10%2F12%2Fexpress%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[express 学习笔记 搭建简单服务器1234567891011//express() 是一个由 express 模块导出的入口（top-level）函数let express = require('express');//创建一个express应用实例名applet app = express();// 设置端口号：3000//process.env.PORT：读取当前目录下环境变量port的值let port = process.env.PORT || 3000 ;//在端口号上开启服务app.listen(port,function () &#123; console.log("server start"+port);&#125;); app.listen(port, [hostname], [backlog], [callback])类似于node中的http.Server.listen()1234567// 设置端口号：3000//process.env.PORT：读取当前目录下环境变量port的值let port = process.env.PORT || 3000 ;//在端口号上开启服务app.listen(port,function () &#123; console.log("server start"+port);&#125;); 服务器启动时候，默认端口3000：node app.js设置端口8080：PORT=8080 node app.js app.set(name,value)123456789//设置 views 文件夹为存放视图文件的目录, 即存放模板文件的地方,__dirname 为全局变量,存储当前正在执行的脚本所在的目录。app.set('views', path.join(__dirname, 'views'));app.set("views","./views");//设置使用的模板引擎app.set('view engine', 'ejs’)app.set("view engine","jade")npm install --save express-art-template//设置art模板引擎，后缀为artapp.engine('art', require('express-art-template')); app.get(name)返回name的value值1234567891011//实例一app.get('title');// =&gt; undefinedapp.set('title', 'My Site');app.get('title');// =&gt; "My Site"//实例二app.set('port', process.env.PORT || 3000);var server = app.listen(app.get('port'), function() &#123; console.log("server start"+port);&#125;); app.get(path, callback [, callback …])app.all(path, callback [, callback …])这种方法就像标准的app.METHOD()方法, 除了它匹配所有HTTP动词。访问path路径的所有方法执行的回调函数.12345//* 表示匹配所有的路径app.all('*', function(req, res)&#123; res.end(req.method + 'user')&#125;//一般放在最后面防止前面的被覆盖 请求与响应123456//Express 应用使用回调函数的参数： request 和 response 对象来处理请求和响应的数据。app.get('/', function(req, res)&#123; res.send('hello world'); res.status(404).send(错误请求)//访问这个路径是设定状态码为404 //通过res.send（）接口向客户端发送hello world，send只能响应一次，意思是只能出现一个send&#125;) res.send（）只能出现一次如果要响应多次，用node原生的write和end，但是如果只有write会处于一个挂起状态1234app.get('/', function(req, res)&#123; res.write('hello world'); res.write('hello world');&#125;) res.send有结束响应的作用 res.write没有结束响应的作用，需要res.end结束中间件挂起response下表中响应对象（res）的方法向客户端返回响应，终结请求响应的循环。如果在路由句柄中一个方法也不调用，来自客户端的请求会一直挂起。res.render()12345//设置 views 文件夹为存放视图文件的目录, 即存放模板文件的地方,__dirname 为全局变量,存储当前正在执行的脚本所在的目录。app.set('views', path.join(__dirname, 'views'));app.set("views","./views");//第一个是渲染的views文件夹下面的index，第二个是传递的数据,注意需要设置模板引擎res.render("index",&#123;&#125;,function()&#123;&#125;) res.setHeader()12//Content-Type的作用 该实体头的作用是让服务器告诉浏览器它发送的数据属于什么文件类型。res.setHeader(&quot;Content-Type&quot;,&apos;text/html;charset=utf-8&apos;) res.redirect()调用redirect()方法后，其后的代码都不会被执行。而使用redirect()设置的状态码不是301或302也不会发生跳转12res.redirect([status,] path)//重定义到path所指定的URL，重定向时可以同时指定HTTP状态码，不指定状态码默认为302 res.location()location()方法本质上是调用了ServerResponse对象的setHeader()方法，但并没有设置状态码。使用location()设置头信息，而不设置状态码或状态码不是301或302，并不会发生重定向1res.location(path) request req.query处理 get 请求，获取 get 请求参数12345678910// GET /search?q=tobi+ferretreq.query.q// =&gt; "tobi ferret"// GET /shoes?order=desc&amp;shoe[color]=blue&amp;shoe[type]=conversereq.query.order// =&gt; "desc"req.query.shoe.color// =&gt; "blue"req.query.shoe.type// =&gt; "converse" req.body处理 post 请求，获取 post 请求体12345678// POST user[name]=tobi&amp;user[email]=tobi@learnboost.comreq.body.user.name// =&gt; "tobi"req.body.user.email// =&gt; "tobi@learnboost.com"// POST &#123; "name": "tobi" &#125;req.body.name// =&gt; "tobi" req.params处理 /:xxx 形式的 get 或 post 请求，获取请求参数123456// GET /user/tjreq.params.name// =&gt; "tj"// GET /file/javascripts/jquery.jsreq.params[0]// =&gt; "javascripts/jquery.js" req.param(name)处理 get 和 post 请求，但查找优先级由高到低为 req.params→req.body→req.query123456789// ?name=tobireq.param('name')// =&gt; "tobi"// POST name=tobireq.param('name')// =&gt; "tobi"// /user/tobi for /user/:namereq.param('name')// =&gt; "tobi" 中间件用于客户端与服务器路由匹配之前的中间操作，正常中间件放在路由上面，中间件通过next()往下走。 app.use（[path],function）利用express托管静态文件node.js不能通过目录来引入文件，而express可以，public为静态目录1234//设置public文件夹为存放静态文件的目录。let path=require("path")//ex4里面唯一的内置中间件app.use(express.static(path.join(__dirname, 'public'))); 一个中间件处理器，请求来了，让那些中间件先处理一遍 没有挂载路径的中间件，应用的每个请求都会执行该中间件 挂载至 /path 的中间件，任何指向 /path 的请求都会执行它1234567app.use(&quot;/name&quot;,function(req,res,next)&#123;res.setHeader(&quot;Content-Type&quot;,&apos;text/html;charset=utf-8&apos;)next();&#125;)app.get(&quot;/name/n&quot;,function(req,res)&#123;&#125;)//也可以匹配到，在执行get请求/name/n时先执行上面的中间件 错误中间件错误处理中间件和其他中间件定义类似，只是必须要使用 4 个参数(err, req, res, next)。即使不需要 next 对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。遇见错误之后直接执行错误中间件。错误处理中间件应当在在其他 app.use() 和路由调用之后才能加载，一般放在路由的最底部，比如：123456789var bodyParser = require('body-parser');var methodOverride = require('method-override');app.use(bodyParser());app.use(methodOverride());app.use(function(err, req, res, next) &#123; // 业务逻辑 console.error(err.stack); res.status(500).send('Something broke!');&#125;); 应用生成器12345678910//安装$ npm install express-generator -g//view=XXX 使用引擎名字 myapp项目名称$ express --view=pug myapp//安装所有依赖$ cd myapp$ npm install//启动myapp项目$ set DEBUG=myapp:* &amp; npm start 我的石墨文档链接：https://shimo.im/docs/TXeewzaE8Jsdgn0I/练习的简易聊天室连接：https://github.com/biubiuins/demo_chat]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[project_email]]></title>
    <url>%2F2018%2F10%2F11%2Fproject-email%2F</url>
    <content type="text"><![CDATA[邮件收发项目大二上开始学html，css，js之后做的暑假做的前端页面，很感谢老师可以给一个练手的机会，在做的过程中发现了很多问题，以及项目完成之后的收获。&nbsp;&nbsp;&nbsp;&nbsp;虽然是一个很简单的界面，但是之前学习的时候不太仔细，也没有demo练习，还是做的磕磕绊绊，还好最后做的差不多了。TAT&nbsp;&nbsp;针对过程中的问题，阅读了很多关于语法规范的文章，js，jq又重新学习了一遍（练习了很多），大二下期基本在学习之中度过的。希望在以后的项目中可以有所进步，彻底的实现前后端分离！！！ 项目相关 完成时间：大二上期寒假 2018-3月左右 bootsrap框架，layui框架，jquery 项目不足 语法不规范，复用性不强，后面修改过一次感觉修改起来很复杂 js不熟练，项目之后大二下期又重新开始学习了一遍js，并写了总结 (https://biubiuins.github.io/2018/10/11/summary-2018-9/) 技术不足，没有实现前后端分离 主要功能 首页 http://mailroom.sicau.edu.cn/email/public/ bootsrap做了响应式，用了ajax请求数据 管理页面（需要登陆仅提供图片） 实现全选与批量删除 点击已取之后，重新获取数据（保证筛选邮件之后点击已取仍显示的是筛选之后的邮件) 邮件类型默认显示上一次选择的类型，可输入筛选的下拉框 超级管理员界面实现了原生js模态框，并做了根据屏幕居中]]></content>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[summary-2018.9]]></title>
    <url>%2F2018%2F10%2F11%2Fsummary-2018-9%2F</url>
    <content type="text"><![CDATA[summary-2018-9 这是在学会搭建博客之后的第一篇博客，以前学习的时候也有记笔记，所以把之前学习笔记上面整理的常见的功能、封装以及遇到的问题写出来，这篇仅限于js，jq。现在正在学习vue，希望在过段时间，自己也能写出关于vue学习的总结。在此之前还需要了解markdown的语法TAT 原来的笔记记录在石墨文档，https://shimo.im/docs/c8YrJy4obNICaWiS/ ID处理1234/** 获取id */function $(id) &#123; return typeof id === "string" ? document.getElementById(id) : null;&#125; 动画匀速动画1234567891011121314151617181920//元素，目标，步数function constant(obj, target, speed) &#123; // 1. 清除定时器 clearInterval(obj.timer); //2.判断方向 //如果现在的距离小于目标值,则往右，否则向左 let dir =obj.offsetLeft&lt;target?speed:-speed; //3. 设置定时器 obj.timer = setInterval(function () &#123; obj.style.left = obj.offsetLeft + dir + "px"; //若超出目标值或者不到目标值 //最后相减的值取绝对值后，总是小于步数的 //Math.abs(dir)||speed if(Math.abs(target-obj.offsetLeft)&lt;Math.abs(dir))&#123; clearInterval(obj.timer); //根据目标值板正 obj.style.left =target+'px'; &#125; &#125;, 20);&#125; 缓动动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function buffer(obj, json, fn) &#123; // 1. 清除定时器 clearInterval(obj.timer); var begin = 0, end = 0; // 2. 设置定时器 obj.timer = setInterval(function () &#123; // 2.0 旗帜, 决定动画是否结束 let flag = true; // 2.1 遍历 for(let k in json)&#123; // 2.2.-1 求出起始值 和 结束值 if(k === 'opacity')&#123; // 透明度 begin = parseInt( parseFloat(getCssAttr(obj, k)) * 100); end = parseInt(parseFloat(json[k]) * 100); &#125;else if(k === 'scrollTop')&#123; // 滚动到头部 begin = obj.scrollTop; end = parseInt(json[k]); &#125;else &#123; // 正常情况 begin = parseInt(getCssAttr(obj, k)); end = parseInt(json[k]); &#125; // 2.2.0 求出步长 //步长公式 let step = (end - begin) * 0.2; step = step &gt;=0 ? Math.ceil(step) : Math.floor(step); // 2.2.1 计算起始位置 if(k === 'opacity')&#123; obj.style.opacity = (begin + step) / 100; obj.style.filter = 'alpha(opacity=' + (begin + end)+')'; // 针对IE &#125;else if(k === 'scrollTop')&#123; obj.scrollTop = begin + step; &#125;else if(k === 'zIndex')&#123; obj.style[k] = json[k]; &#125;else &#123; obj.style[k] = begin + step + 'px'; &#125; // 2.2.2 判断 if(begin !== end)&#123; flag = false; &#125; &#125; // 3.0 结束动画 if(flag)&#123; clearInterval(obj.timer); // 开启动画组中的下一组动画 if(fn)&#123; // 判断有没有这个函数 fn(); &#125; &#125; &#125;, 60);&#125; js获取CSS利用 [] 访问属性 元素.style[“属性”];1234567891011121314//这种语法的好处就是可以动态的传递参数作为属性//只能获取行类标签 var h = 'height'; box.style[h] = 300 + 'px';//获取外部css或页内的cssfunction getStyleAttr(obj, attr) &#123; if(obj.currentStyle)&#123; // IE 和 opera return obj.currentStyle[attr]; &#125;else &#123; //window.getComputedStyle("元素", "伪类") （ 注意：两个选项是必须的，没有伪类 用 null 替代 ） //也可以点选，但是为了传递参数作为属性 return window.getComputedStyle(obj, null)[attr]; &#125;&#125; 定时器 在定时器事件前，先设置接收定时器的变量指向null 在定时器事件里，先要清除定时器再设置定时器，先清除是防止定时器累加轮播第一种这种不适合多图1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162function slider (sliderid,olStyleClassName,imgWidth,speed,second) &#123; //高级排他 //lastIndex 选中的小圆点样式 currentIndex 小圆点索引 picIndex 图片索引 let lastIndex=0,currentIndex=0,picIndex=0; // 1. 获取需要的标签 let ul=$(sliderid).children[0]; let ol=$(sliderid).children[1]; let list=ul.children; let olList= ol.children; // 2.克隆最后一个li标签 ul.appendChild(list[0].cloneNode(true)); // 3.动态创建小圆点 for(let i= 0;i&lt;list.length-1;i++)&#123; let li =document.createElement("li"); ol.appendChild(li); &#125; //4.第一个小圆点选中 olList[0].className=olStyleClassName; //5.监听每个li的进入事件 for(let i= 0;i&lt;olList.length;i++)&#123; //5.1 每一个li绑定自己的事件 olList[i].onmouseover=function () &#123; //先清除之前的选中状态，在把当前选中的索引给lastIndex lastIndex=currentIndex; olList[lastIndex].className=""; this.className=olStyleClassName; lastIndex=i; //5.2图片动起来 constant(ul,-(i * imgWidth),speed); currentIndex=picIndex=i; &#125;; &#125; //6.定时器 let timer; timer = setInterval(autoPlay, second); // 7. 清除和设置定时器 $(sliderid).onmouseover = function () &#123; clearInterval(timer); &#125;; $(sliderid).onmouseout = function () &#123; timer = setInterval(autoPlay, second); &#125;; function autoPlay()&#123; picIndex++; currentIndex++; //如果图片到了最后一张 if (picIndex &gt; list.length - 1) &#123; ul.style.left = 0; //从第二张图片开始 picIndex = 1; &#125; constant(ul, -(picIndex * imgWidth), speed); //小原点的选中 if (currentIndex &gt; olList.length - 1) &#123; currentIndex = 0; &#125; for (let i=0;i&lt;olList.length;i++)&#123; olList[i].className=""; &#125; olList[currentIndex].className=olStyleClassName; &#125;&#125; 第二种两个图片宽度的位置，第一个位置显示（当前），第二位置隐藏 第三种改变透明度，循环一遍让所有的opacity动画为0，然后当前为opacity动画为1，索引++、12345678910111213141516171819function opacityAutoPlay(ulid,speed) &#123; // 1. 获取所有的li标签 var lis = $(ulid).getElementsByTagName("li"); var index = 0; // 2. 开始定时器 setInterval(function () &#123; // 2.1 改变透明度 for(let i=0; i&lt;lis.length; i++)&#123; let singerLi = lis[i]; buffer(singerLi, &#123;opacity: 0&#125;, null); &#125; buffer(lis[index], &#123;opacity: 1&#125;, null); // 2.2 索引++ index++; if(index === lis.length)&#123; index = 0; &#125; &#125;, speed);&#125; 瀑布流 父盒子居中 Math.floor(屏幕宽度/子盒子宽度)=cols 子盒子的宽度*cols=父盒子的宽度 margin:0 auto; 子盒子定位第一行不变，其他子盒子接在第一行最矮的盒子的后面（反复） 拿到所有盒子的高度。把第一行的盒子的高度放在一个数组里面（i&lt;cols,heightArr[]) 在剩下的盒子里面(i&gt;=cols),找出第一行最矮的盒子的高度（Math.min(…heightArr)||Math.min.apply(this.height)）2.1 找出最矮盒子的索引(遍历heightArr[],找出和第二步盒子高度一样的i返回)2.2 剩下盒子定位（left=第2.1步的索引*子盒子宽度，top=最矮的盒子高度）2.3 更新最矮盒子的高度 （heightArr[最矮盒子的高度]+=当前盒子的高度） 滚动加载图片 监听窗口的滚动，滚动到你需要的位置加载 js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 window.onload = function () &#123; // 1. 实现瀑布流布局 waterFull("main", "box"); // 2. 动态加载图片 window.onscroll = function () &#123; if(checkWillLoadImage())&#123; // 2.1 造数据 var dataArr = [ &#123;"src": "img04.jpg"&#125;, &#123;"src": "img06.jpg"&#125;, &#123;"src": "img08.jpg"&#125;, &#123;"src": "img09.jpg"&#125;, &#123;"src": "img10.jpg"&#125;, &#123;"src": "img12.jpg"&#125;, &#123;"src": "img14.jpg"&#125;, &#123;"src": "img16.jpg"&#125;, &#123;"src": "img18.jpg"&#125; ]; // 2.2 创建元素 for(var i=0; i&lt;dataArr.length; i++)&#123; var newBox = document.createElement("div"); newBox.className = "box"; $("main").appendChild(newBox); var newPic = document.createElement("div"); newPic.className = "pic"; newBox.appendChild(newPic); var newImg = document.createElement("img"); newImg.src = "images/" + dataArr[i].src; newPic.appendChild(newImg); &#125; // 2.3 重新布局 waterFull("main", "box"); &#125; &#125;&#125;;/** * 实现瀑布流布局 */function waterFull(parent, child) &#123; // 1. 父盒子居中 // 1.1 获取所有的盒子 var allBox = $(parent).getElementsByClassName(child); // 1.2 获取子盒子的宽度 var boxWidth = allBox[0].offsetWidth; // 1.3 获取屏幕的宽度 var screenW = document.documentElement.clientWidth; // 1.4 求出列数 var cols = parseInt(screenW / boxWidth); // 1.5 父盒子居中 $(parent).style.width = cols * boxWidth + 'px'; $(parent).style.margin = "0 // 2. 子盒子的定位 // 2.1 定义高度数组 var heightArr = [], boxHeight = 0, minBoxHeight = 0, minBoxIndex = 0; // 2.2 遍历子盒子 for (var i = 0; i &lt; allBox.length; i++) &#123; // 2.2.1 求出每一个子盒子的高度 boxHeight = allBox[i].offsetHeight; // 2.2.2 取出第一行盒子的高度放入高度数组 if (i &lt; cols) &#123; // 第一行 heightArr.push(boxHeight); &#125; else &#123; // 剩余行 // 1. 取出最矮的盒子高度 // minBoxHeight = _.min(heightArr); minBoxHeight=Math.min(...heightArr); // 2. 求出最矮盒子对应的索引 minBoxIndex = getMinBoxIndex(heightArr, minBoxHeight); // 3. 子盒子定位 allBox[i].style.position = "absolute"; allBox[i].style.left = minBoxIndex * boxWidth + 'px'; allBox[i].style.top = minBoxHeight + 'px'; // 4. 更新数组中的高度 heightArr[minBoxIndex] += boxHeight; &#125; &#125; console.log(heightArr, minBoxHeight, minBoxIndex);&#125;/** * 获取数组中最矮盒子高度的索引 * @param arr * @param val * @returns &#123;number&#125; */function getMinBoxIndex(arr, val) &#123; for(var i=0; i&lt;arr.length; i++)&#123; if(arr[i] === val)&#123; return i; &#125; &#125;&#125;/** * 判断是否具备加载图片的条件 */function checkWillLoadImage() &#123; // 1. 获取最后一个盒子 var allBox = document.getElementsByClassName("box"); var lastBox = allBox[allBox.length - 1]; // 2. 求出最后一个盒子自身高度的一半 + offsetTop var lastBoxDis = lastBox.offsetHeight * 0.5 + lastBox.offsetTop; // 3. 求出屏幕的高度 var screenW = document.body.clientHeight || document.documentElement.clientHeight; // 4. 求出页面偏离浏览器的高度 var scrollTop = scroll().top; return lastBoxDis &lt;= screenW + scrollTop;&#125; jq123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//当页面加载完毕$(window).on('load',function () &#123;//1.实现瀑布流布局waterFall();//2.滚动加载$(window).on('scroll',function () &#123;//判断是否加载if (checkWillLoad())&#123;////创造假数据var data = &#123;'dataImg':[&#123;'img':'23.jpg'&#125;,&#123;'img':'24.jpg'&#125;,&#123;'img':'25.jpg'&#125;,&#123;'img':'26.jpg'&#125;,&#123;'img':'27.jpg'&#125;,&#123;'img':'28.jpg'&#125;]&#125;;//遍历创建盒子$.each(data.dataImg,function (index,value)&#123;//创建一个div标签 设置它的类为'box' 添加到'main'里面去var newBox = $('&lt;div&gt;').addClass('box').appendTo($('#main')); var newPic = $('&lt;div&gt;').addClass('pic').appendTo($(newBox)); //创建img 取出遍历的对象value的img属性对应的值 $('&lt;img&gt;').attr('src','images/'+$(value).attr('img')).appendTo($(newPic)); &#125;) //1.实现瀑布流布局 waterFall(); &#125; &#125;); &#125;); //实现瀑布流布局 function waterFall () &#123; //拿到所有的盒子 var allBox = $('#main &gt; .box'); //取出其中一个盒子的宽度 var boxWidth = $(allBox).eq(0).outerWidth(); //取出屏幕的高度 var screenWidth = $(window).width(); //求出列数 //取整函数取整 var cols = Math.floor( screenWidth/boxWidth); //父标签居中 $('#main').css(&#123; 'width':cols * boxWidth + 'px', 'margin':'0 auto' &#125;); //对子盒子定位 var heightArr = []; //遍历 $.each(allBox,function (index,value) &#123; //取出单独盒子的高度 var boxHeight = $(value).outerHeight(); //判断是否第一行 if(index &lt; cols) &#123; heightArr[index] = boxHeight; &#125; else //剩余的盒子要瀑布流布局 &#123; //求出最矮的盒子高度 var minBoxHeight = Math.min.apply(null,heightArr); //取出最矮高度对应的索引 封装了js的这个方法 var minBoxIndex = $.inArray(minBoxHeight,heightArr); //定位 $(value).css(&#123; 'position':'absolute', 'top':minBoxHeight + 'px', 'left':minBoxIndex * boxWidth + 'px' &#125;); //更新数组中最矮的高度 heightArr[minBoxIndex] += boxHeight; &#125; &#125;) &#125; //判断是否符合加载条件 function checkWillLoad() &#123; //直接取出最后一个盒子 var lastBox = $('#main &gt; div').last(); //取出最后一个盒子高度的一半 + 头部偏离的位置 var lastBoxDis = $(lastBox).outerHeight() + $(lastBox).offset().top; //求出浏览器的高度 var clientHeight = $(window).height(); //求出页面偏离浏览器高度 var scrollTopHeight = $(window).scrollTop(); //比较返回 return lastBoxDis &lt;= clientHeight + scrollTopHeight; &#125; margin:0 auto 块级元素 给定要居中的块级元素的宽度。 所有元素也可以通过对父元素设置text-align：center；的方式来实现居中。而对于块元素来说，对要居中的元素自身进行设置text-align:center也能实现居中 margin:0 auto;可以使盒子居中，text-align:center;可以使文本居中，节流onresize举列子窗口大小一变化就执行，太过灵敏，所以需要阻止1234567891011121314151617//使用定时器var timer = null;window.onresize = function () &#123; clearTimeout(timer); // 节流 timer = setTimeout(function () &#123; waterFull('main', 'box'); &#125;, 200);&#125;//封装之后的function throttle(fn, delay) &#123; var timer = null; return function () &#123; clearTimeout(timer); timer = setTimeout(fn, delay); &#125;&#125; apply/call这个面试中常考到，现在只做初步了解(https://www.cnblogs.com/gaowx/p/4837687.html ) 改变函数的this指向 apply可以改变传递给函数参数的形式Date123456789101112131415161718192021222324function newDate()&#123; //声明日期对象，里面可以设置参数表示其他时间 let date =new Date(); //获取时间里面的年 date.getFullYear() //月0-11 date.getMonth()+1 //日1-31 date.getDate() //获取星期0-6 data.Day //设置某一天 date.setDate（day） //时0-23 date.getHours() //分0-59 date.getMinutes() //秒0-59 date.getSeconds() //获取毫秒 date.getMilliSeconds() //时间戳 date.getTime()&#125; ms转化时间 cookie封装封装成插件，引入该文件后，$.addCookie(key,value,day,path,domain)来引用1234567891011121314151617181920212223242526272829303132333435363738394041;(function ($,window) &#123; $.extend(&#123; addCookie: function addCookie(key,value,day,path,domain)&#123; //1.处理默认保存的路径 var index=window.location.pathname.lastIndexOf('/'); var currentPath=window.location.pathname.slice(0,index) path=path||currentPath //2.处理默认domain domain=domain||document.domain //3.处理默认的过期时间 if(!day)&#123; document.cookie=key+"="+value+";path="+path+";domain="+domain+';' &#125; else&#123; var date =new Date(); date.setDate(date.getDate()+day) document.cookie=key+"="+value+";expires="+date.toGMTString()+";path="+path+";domain="+domain+';' &#125; &#125;, getCookie: function getCookie(key)&#123; var res=document.cookie.split(';') for(var i=0;i&lt;res.length;i++)&#123; //把key和value切割 var temp=res[i].split('=') //前后可能有空格，把空格删除 if(temp[0].trim()===key)&#123; return temp[1] &#125; &#125; &#125;, delCookie: function delCookie(key, path) &#123; //默认情况下只能删除默认路径中保存的cookie，如果要删除指定路径保存的cookie，要把路径值传出去 //设置过期时间为-1 addCookie(key, getCookie(key), -1, path) &#125; &#125;);&#125;)(jQuery,window); 动态添加的元素绑定事件 delegate 123$(&apos;ul&apos;).delegate(&apos;li&apos;,&apos;click&apos;,function()&#123;//操作的还是li&#125;) onclick事件在动态添加数据的时候，就给元素绑定onclick事件 on（）常用 12345//把动态添加的元素写在on里面，如果调用的函数是外部定义好的，则在调用的时候不加（）//不然会跳过点击事件直接执行函数$(&quot;父元素或祖辈元素&quot;).on(&quot;click&quot;,&quot;动态添加的元素&quot;,function()&#123;$(this).css(&quot;border&quot;,&quot;5px solid #000&quot;);&#125; 其他清除默认样式http://yui.yahooapis.com/3.18.1/build/cssreset/cssreset-min.css 下拉框1234567891011121314151617181920//拿到select对象：var myselect=document.getElementById("select");//拿到选中项的索引var index=myselect.selectedIndex ; // selectedIndex代表的是你所选中项的index//拿到选中项options的value：myselect.options[index].value;//拿到选中项options的text：myselect.options[index].text;//拿到选中项的其他值，比如这里的url： myselect.options[index].getAttribute('url');//jqueryvar options=$(“#select option:selected”); //获取选中的项alert(options.val()); //拿到选中项的值alert(options.text()); //拿到选中项的文本alert(options.attr('url')); //拿到选中项的url值//设置//设置value为pxx的项选中$(".selector").val("pxx")//设置text为pxx的项选中$(".selector").find("option[text='pxx']").attr("selected",true) H5 datalistdatalist 只是列表赋值取值还是通过input.样式等都在input上操作https://www.zhangxinxu.com/wordpress/2013/03/html5-datalist-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8-%E5%8F%AF%E8%A1%8C%E6%80%A7/ 邮箱的自动补全HTML代码：123456789邮箱：&lt;input type=&quot;email&quot; id=&quot;email&quot; list=&quot;emailList&quot; name=&quot;off_autocomplete&quot; /&gt;&lt;datalist id=&quot;emailList&quot;&gt;//其中*为占位符，当文本框输入内容的时候，*替换成邮箱地址的前半部分，于是，动态邮件地址提示的效果就实现了 &lt;option value=&quot;*@qq.com&quot;&gt; &lt;option value=&quot;*@163.com&quot;&gt; &lt;option value=&quot;*@gmail.com&quot;&gt; &lt;option value=&quot;*@yahoo.com.cn&quot;&gt; &lt;option value=&quot;*@126.com&quot;&gt;&lt;/datalist&gt; JS代码：12345678910111213141516171819202122232425262728var eleList = document.getElementById("emailList") , eleMail = document.getElementById("email") , htmlListInit = '', arrEmailList = [];if (eleMail &amp;&amp; eleList &amp;&amp; (htmlListInit = eleList.innerHTML) !== '') &#123; // 得到类似["qq.com", "163.com", "gmail.com", ...]的数据 arrEmailList = [].slice.call(eleList.getElementsByTagName("option")).map(function(option) &#123; return option.value.replace("*@", ""); &#125;); eleMail.fnListReplace = function() &#123; var arrValue = this.value.trim().split("@"); // 修复FireFox浏览器下无限input问题 // 如果值不完全匹配某option值，执行动态替换 if (arrValue.length !== 2 || arrEmailList.indexOf(arrValue[1]) === -1) &#123; eleList.innerHTML = htmlListInit.replace(/\*/g, arrValue[0]); &#125; return this; &#125;; // 绑定输入事件侦听 eleMail.addEventListener("input", function() &#123; this.fnListReplace.call(this); &#125;, false); // 载入即匹配 eleMail.fnListReplace.call(eleMail).focus();&#125; else &#123; eleList = document.createElement("datalist"); eleList.innerHTML = '&lt;p class=sorry&gt;抱歉，当前浏览器不支持HTML5 datalist.&lt;/p&gt;'; eleMail.parentNode.appendChild(eleList);&#125; jquery.editable-select控件引入jquery.editable-select.cssjquery.editable-select.js调用方法123456789101112$('#editable-select').editableSelect(&#123; bg_iframe: true, //是否加iframe case_sensitive: false, items_then_scroll: 10 ,//设置下拉选项的数目 isFilter:false/true, //是否根据条件过滤下拉选项 onCreate:, //当输入时触发 onShow：, //当下拉时触发 onHide：, //当下拉框隐藏时触发 onSelect：, //当下拉框中的选项被选中时触发 effects:default/slide/fade， //动画效果 duration： //动画效果的时间&#125;);]]></content>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
</search>
