<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[note-二分法]]></title>
    <url>%2F2021%2F01%2F04%2Fnote-%E4%BA%8C%E5%88%86%E6%B3%95%2F</url>
    <content type="text"><![CDATA[二分搜索的简单框架如果是有序数组，可以考虑使用二分法 重心在while里用&lt;=还是&lt;,mid是+1还是-1，主要是清除搜索区间 mid需要采用防止溢出的写法，(left+right)/2中如果left与right太大，会导致整型溢出，而left+(right-left)/2不会溢出且结果一样。 public int searchInsert(int[] nums, int target) { int left = 0;int right = nums.length - 1; while(left&lt;=right){ int mid = left + (right - left)/2; //防溢出的写法 if(nums[mid] == target)return mid; else if(nums[mid]&lt;target) left = mid+1 ; //闭区间 else if(nums[mid]&gt;target) right = mid-1; }//退出来说明没找到 return -1; } //找左侧边界 public int searchInsert(int[] nums, int target) { int left = 0;int right = nums.length - 1; while(left&lt;=right){ int mid = left + (right - left)/2; if(nums[mid] == target)right = mid-1; //找到不返回，往左侧收缩 else if(nums[mid]&lt;target) left = mid+1; else if(nums[mid]&gt;target) right = mid-1; } //检查left越界情况 if(left&gt;=nums.length||nums[left]!=target)return -1; return left; } //找右边界 public int searchInsert(int[] nums, int target) { int left = 0;int right = nums.length - 1; while(left&lt;=right){ int mid = left + (right - left)/2; if(nums[mid] == target)left = mid+1; //找到不返回，往右侧收缩 else if(nums[mid]&lt;target) left = mid+1; else if(nums[mid]&gt;target) right = mid-1; } //检查left越界情况 if(right&lt;0||nums[right]!=target)return -1; return right; } 为什么要单独处理越界问题？注意target比所有元素小以及比所有元素大的情况， 35.搜索插入位置 704.二分查找 题目给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5输出: 2示例 2: 输入: [1,3,5,6], 2输出: 1示例 3: 输入: [1,3,5,6], 7输出: 4示例 4: 输入: [1,3,5,6], 0输出: 0 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/search-insert-position著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 代码 class Solution { public int searchInsert(int[] nums, int target) { int left = 0;int right = nums.length - 1; // mid = 0; while(left&lt;=right){ int mid = left + (right - left)/2; //防溢出的写法 if(nums[mid] == target)return mid; else if(nums[mid]&lt;target) left = mid+1; else if(nums[mid]&gt;target) right = mid-1; }//退出来说明没找到 return right+1; } } 问题1：为什么while循环的条件中是&lt;=,而不是&lt;?初始化时right =nums.length - 1,right指向的是最后一个元素，相当于搜索的区间是[left,right]。当right=nums.length时，是越界的相当于区间是[left,right)。这道题采用的是前者。什么时候停止搜索？1.找到了。2.循环终止了。循环什么时候终止？当搜索区间为空的时候就可以停止了。while(left&lt;=right)的终止条件相当于[right+..,right]，这个时候搜索区间为空了。而while(left&lt; right)的终止条件是[right,right]这个时候搜索空间并不是空了，如[2,2]说明索引2的元素被漏掉了。 问题2：为什么left = mid+1和right=mid-1?这个操作的主要目的就是控制搜索区间，就本题的搜索区间是[left,right]，那么当检查到当前的mid不是目标数字时，应该去搜索[left,mid-1]或者[mid+1,right],mid本身已经被搜索过了。 问题3：算法的不足？如果当目标元素在数组中重复时，想获取左侧边界或者右侧边界的索引时，此算法就不行了。 34.在排序数组中查找元素的第一个和最后一个题目给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 进阶： 你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？ 示例 1： 输入：nums = [5,7,7,8,8,10], target = 8输出：[3,4]示例 2： 输入：nums = [5,7,7,8,8,10], target = 6输出：[-1,-1]示例 3： 输入：nums = [], target = 0输出：[-1,-1] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路套入框架，分两次查找 public int[] searchRange(int[] nums, int target) { //分两次查找 //找作左边界 int first,last;int[] ans = new int [2]; int left = 0;int right = nums.length - 1; while(left&lt;=right){ int mid = left + (right - left)/2; if(nums[mid]&lt;target) ans[0] = left = mid+1; else right = mid-1; } //检查left越界情况 if(left&gt;=nums.length||nums[left]!=target)ans[0] = -1; //找右边界 left = 0; right = nums.length - 1; while(left&lt;=right){ int mid = left + (right - left)/2; if(nums[mid]&lt;=target) left = mid+1; else right = mid-1; } //检查right越界情况 if(right&lt;0||nums[right]!=target)ans[1] = -1; else ans[1] = right; return ans; }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[234.回文链表]]></title>
    <url>%2F2021%2F01%2F03%2F234.%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目请判断一个链表是否为回文链表。 示例 1: 输入: 1-&gt;2输出: false示例 2: 输入: 1-&gt;2-&gt;2-&gt;1输出: true进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/palindrome-linked-list著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路1把原始链表反转存入一条新的链表，然后比较这两个链表是否相同，这里会用到额外的空间。 思路21.先利用快慢指针找到中间节点的位置，模仿回文串形成以中间位置为对称的两段。2.反转后面一端，使得可以通过next获取到链表元素。例外一个类似的思路：边走边反转 代码 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public boolean isPalindrome(ListNode head) { ListNode fast = head,slow=head; while(fast!=null &amp;&amp; fast.next !=null){ slow = slow.next; fast = fast.next.next; }//奇数情况下slow还需要再走一步。 if(fast!=null) slow = slow.next; //开始反转链表,fast指向反转后的链表头 fast = reverse(slow); while(fast !=null){ if(head.val != fast.val)return false; head = head.next; fast = fast.next; } return true; } ListNode reverse(ListNode head){ ListNode pre=null ,cur = head; while(cur!=null){ ListNode next = cur.next; cur.next = pre; pre = cur; cur = next; } return pre; } }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[25.K个一组翻转链表]]></title>
    <url>%2F2020%2F12%2F30%2F25.K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-nodes-in-k-group著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路1.先翻转head开头的k个节点2.将k+1个元素作为head递归调用reverseKGroup函数 根据这个思路需要找到第k个节点。 套上递归三部曲1.递归参数及返回值参数为头节点以及需要翻转的节点k，返回值为翻转好了的头节点。 public ListNode reverseKGroup(ListNode head, int k){} 2.递归终止条件需要翻转k个节点，那么不足k个节点就会终止递归，这里表示不足的方法很巧妙，可以学习。把k个节点为一组分组，递归的时候我们仅仅考虑当前k个节点，那么就需要记录第k+1的节点，作为下一次递归的头节点。 翻转k个节点，那么就需要从有开始找到k个节点，如果找到了进行翻转，如果没找到说明不足k个节点 ListNode a = head; ListNode b = head; for(int i =0;i&lt;k;i++){ //说明不足k个节点 if(b==null) return head; b = b.next; //b指向的是第k+1个元素,用于防止断链 } 3.本层递归需要做什么本层递归需要翻转k个节点，由上述操作可以转化为翻转[a,b)区间内的链表。 public ListNode reverseKGroup(ListNode a, ListNode b) { ListNode pre , nxt; pre = null; while(a!=b){ nxt =a.next; a.next = pre; pre = a; a =nxt; } return pre; }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常用类]]></title>
    <url>%2F2020%2F12%2F29%2FJava%E5%B8%B8%E7%94%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[字符串相关的类String1.Serializable表示字符串是支持序列化的2.comparable接口，表示String可以比较大小3.String类是一个final类，用双引号引起来表示，String对象的字符内容是存储在一个字符数组value[]中，值在创建之后不能更改。 public final class String implements java.io.Serializable,Comparable&lt;String&gt;,CharSequence { //常量数组 private final char value[]; private int hash; } 不可变性 方法区：字符串常量池(String.. .) + 类信息(方法) + 静态变量… 不可以在原内存区域上进行修改，final型的value[] 字面量赋值 String str=”abc” 说明1：先去缓冲池中找有没有abc对象，没有新建并入池，有的话直接使用。说明2：修改String类型变量，是新建了一个value[]数组把新的地址赋值给该变量。 public void test(){ //根据说明1，s1、s2指向同一个地址 String s1 = &quot;abc&quot;; String s2 = &quot;abc&quot;; //根据说明1，说明2，去缓冲池中找hello，没有，新建并赋值一个新地址 s1 = &quot;hello&quot;; System.out.println(s1); //hello System.out.println(s2); //abc } String的实例化方法String str1 = “hello” 与 String str2 = new String(“hello”)的区别？ new在堆空间中开辟了一个空间，把该空间的地址值返回给str2，该空间的内容值为hello在常量池中的地址。 //通过字面量定义:此时的str1和str2的数据hello声明在方法区中的字符串常量池中 String str1 =&quot;hello&quot;; String str2 =&quot;hello&quot;; //通过new + 构造器方法：此时str3和str4保存的地址值，是数据在堆空间中开辟空间对应的地址值 String str3 = new String(&quot;hello&quot;); String str4 = new String(&quot;hello&quot;); System.out.println(str1 == str2);//true System.out.println(str1 == str3);//false System.out.println(str1 == str4);//false System.out.println(str3 == str4);//false //本质上this.value = new char[0] String s1 = new String(); //this.value = original.value; String s2 = new String(String original); //this.value = Array.copyOf(value,value.length) String s3 = new String(char [] a); String s4 = new String(char [] a,int startIndex,int count); String不同拼接操作的对比 常量与常量的拼接结果在常量池，且常量池中不会存在相同内容的常量。 只要其中有一个是变量，就相当于new，结果在堆空间中 如果拼接的结果调用intern()方法,返回值就在常量池中。 String s1 = &quot;javaEE&quot;; String s2 = &quot;hadoop&quot;; //s3与s4是字面量从常量池中去找 String s3 = &quot;javaEEhadoop&quot;; String s4 = &quot;javaEE&quot; +&quot;hadoop&quot;; //字面量连接 //有变量名参与，相当于new，在堆空间去创建 String s5 = s1 + &quot;hadoop&quot;; String s6 = &quot;javaEE&quot; + s2; String s7 = s5.intern(); //返回值得到的s7在常量池中 System.out.println(s3 == s4);//true System.out.println(s3 == s5);//false System.out.println(s3 == s6);//false System.out.println(s5 == s6);//false System.out.println(s3 == s7);//true 面试题面试题1:String s = new String(“abc”);方式创建对象，在内存中创建了几个对象？两个，一个是堆空间中new结构，另一个是char[]对应的常量池中的数据”abc” 面试题2 public class StringTest { String str = new String(&quot;good&quot;); //char在堆中 char [] ch = {&#39;t&#39;,&#39;e&#39;,&#39;s&#39;,&#39;t&#39;}; public void change(String str,char ch[]){ str = &quot;test ok&quot;; ch[0] = &#39;b&#39;; } public static void main(String[] args) { StringTest ex = new StringTest(); ex.change(ex.str,ex.ch); System.out.println(ex.str);//good System.out.println(ex.ch);//best } } 补充： 堆Heap:一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放入堆内存中，保存所有引用类型的真实信息。 规范上是把永久存储区化入堆逻辑，事实上是没有在堆中的。 JDK1.6 字符串常量池放方法区(方法区具体实现：永久代)JDK1.7 字符串常量池放堆里JDK1.8 字符串常量池放方法区(方法区具体实现：元空间) Young Generation Space 新生区 Tenure Generation Space 养老区 permanent Space 永久存储区 (可以看成方法区) String常用方法int length():返回字符串的长度,return value.length;char charAt(int index):返回某索引处的字符,return value[index]boolean isEmpty():判断是否是空字符串,return value.length == 0String toLowerCase():使用默认语言环境，将String中所有的字符转换成小写，返回转换的结果，原字符串不变String toUpperCase():使用默认语言环境，将String中所有的字符转换成小写，返回转换的结果，原字符串不变String trim():返回字符串的副本，忽略前导空白和尾部空白boolean equals(Object obj):比较字符串的内容是否相同boolean equalsIgnoreCase(String anotherString):与equals方法类似，忽略大小写String concat(String str):将指定字符串连接到此字符串的结尾，等价用+，此方法不常用int compareTo(String anotherString):比较两个字符串的大小，从左往右一个一个比，根据Asc码相减。String subString(int beginIndex):返回一个新的字符串，从begin开始截取,截取符在数字的左边。String subString(int beginIndex,int endIndex):返回一个新的字符串，从begin开始、end结束,截取符在数字的左边。boolean endWith(String suffix):测试此字符串是否以指定的后缀结束boolean startsWith(String prefix):测试此字符串是否以指定的前缀开始boolean startWith(String prefix,int toffset):测试此字符串从指定索引开始的字符串是否以指定的前缀开始boolean contains(CharSequence s):当前仅当此字符串包含指定的char值序列时，返回trueint indexOf(String str):返回指定字符串在此字符串中第一次出现处的索引，没找到返回-1int indexOf(String str,int fromIndex):返回指定字符串在此字符串中从指定位置开始第一次出现处的索引，没找到返回-1int lastIndexOf(String str):返回指定字符串从后往前找第一次出现的索引位置，没找到返回-1int lastIndexOf(String str,int fromIndex):返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始从后往前查找，没找到返回-1 替换String replace(char oldChar,char newChar):返回一个新的字符串，通过用newChar替换旧的字符，所有都替换String repalce(CharSequence targer,CharSequence replacement):使用指定的字面值替换目标字符串String replaceAll(String regex,String replacement):替换正则表达式匹配到的东西String replaceFirst(String regex,String replacement)：替换其中一个 匹配boolean matches(Sting regex):告知此字符串是否匹配给定的正则 切片String[] split(String regex):根据给定的正则表达式的匹配拆分此字符String[] split(String regex,int limit):根据给定的正则表达式的匹配拆分此字符,最多不超过limit个 包装类Wrapper只有子父类关系才可以强转 包装类(封装类):针对八种基本数据类型定义相应的引用类型 基本数据类型、包装类与String类间的转换 基本数据类型与包装类 JDK5.0新特性：的自动装箱与自动拆箱 int num = 10 Integer num1 = new Integer(num) int num0 = num1.intValue method(num1); //自动装箱 int num2 = 10 Integer in1 = num2 //自动拆箱 int num3 = in1 //method public void method(Object obj) 基本数据类型、包装类 -&gt; String 方法1：连接运算方法2：调用String重载的valueOf(xxx) //方法1：连接运算 int num = 10; String str = num + &quot;&quot;; //方法2：调用Strinf重载的valueOf(xxx) float f = 12.3f String str2 = String.valueof(f) String -&gt; 基本数据类型、包装类 调用包装类的parseXxx(String str) String str1 = &quot;123&quot;; int num = Integer.paserInt(str1) String与char[]之间的转换String -&gt; char[]str.toCharArray() 返回一个char类型的数组char[] -&gt; String:调用String的构造器new String(arr) 返回一个String 习题 三目运算符要求:前后的数据类型统一,所以整型会自动类型提升到浮点型。 //习题1 Object o1 = true ? new Integer(1) : new Double(2.0) System.out.println(o1) //1.0 //习题2 public void test(){ Integer i = new Integer(1); Integer j = new Integer(1); System.out.println(i == j); //false //Integer内部定义了IntegerCache结构,自动装箱的时候从Integer cache数组(-128~127)中找,不需要重新new了，所以找到的是同一个地址 Integer m = 1; Integer n = 1; System.out.println(m == n); //true Integer x = 128; Integer y = 128 ; System.out.println(x == y); //false }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[206.旋转链表]]></title>
    <url>%2F2020%2F12%2F28%2F206.%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 限制：0 &lt;= 节点个数 &lt;= 5000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 反转的核心就是 当前的结点.next = pre , 所以需要一个指针指向前一个结点，为了防止断链(后一个结点找不到),还需要一个指针指向当前结点的后一个结点。 代码 迭代写法： class Solution { public ListNode reverseList(ListNode head) { ListNode pre =null; while(head!=null){ ListNode temp = head.next; head.next = pre; pre = head; head = temp; } return pre; } } 递归写法： 先处理后递归，顺序是从左到右。如果要从右往左处理，可以先递归后处理。 class Solution { ListNode pre =null; public ListNode reverseList(ListNode head) { return reverseList(null,head); } public ListNode reverseList(ListNode pre , ListNode head){ //终止条件 if(head==null) return pre; //本层递归逻辑 ListNode temp = head.next; head.next = pre; return reverseList(head,temp); } } //另外的一种写法 class Solution { ListNode pre =null; public ListNode reverseList(ListNode head) { if(head == null) return pre; ListNode temp = head.next; head.next = pre; pre = head; return reverseList(temp); } } 反转链表2题目反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 说明:1 ≤ m ≤ n ≤ 链表长度。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-linked-list-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 迭代思路 一个节点p指向第m-1个节点，一个节点q指向第m个节点，后面需要反转的节点依次往p与q之间插入。 插入选择的是头插法，每一个插入到最前面。 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode reverseBetween(ListNode head, int m, int n) { ListNode dummyHead = new ListNode(0); dummyHead.next = head; ListNode g = dummyHead; //指向m-1个元素 ListNode p = dummyHead.next; //指向第m个元素 int step = 0; while (step++ &lt; m - 1) { g = g.next; p = p.next; } for (int i = 0; i &lt; n - m; i++) { ListNode removed = p.next; //需要移动的元素 p.next = p.next.next; //采用的头插法 removed.next = g.next; g.next = removed; } return dummyHead.next; } } 递归思路 从后往前反转，终止条件是n==1，本次要做的是使当前节点反转。 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { //不需要反转的第一个节点 ListNode successor = null; //先定位到需要反转的节点位置 == 反转前n个节点 public ListNode reverseBetween(ListNode head, int m, int n) { if(m ==1){// m就表示要反转的结点 // 翻转head之后的n个节点;，head永远指向头节点 return reverseBetween(head,n); } //从头开始寻找第m个节点。 //大规模化为小规模 head.next = reverseBetween(head.next, m-1, n-1); return head; } //反转前n个节点 ListNode reverseBetween(ListNode head, int n){ if(n == 1){//找到了最后一个需要反转的 //successor为第一个不需要反转的 //为了防止断链,要记录下来 successor = head.next; return head; } //p为反转的最后一个元素 //反转好的元素返回的头节点 ListNode p = reverseBetween(head.next, n-1); head.next.next = head; head.next = successor; return p; //新的头节点 } }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[203.移除链表元素]]></title>
    <url>%2F2020%2F12%2F28%2F203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[题目删除链表中等于给定值 val 的所有节点。 示例: 输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6输出: 1-&gt;2-&gt;3-&gt;4-&gt;5 思路 移除首元结点和移除其他节点的操作是不一样的，因为首元结点没有前驱节点。我们在首元结点之前设置一个头节点，这样可以同一操作。 代码 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode removeElements(ListNode head, int val) { ListNode p = new ListNode(0); p.next = head; ListNode q = p; while(q.next != null){ if(q.next.val == val){ q.next = q.next.next; }else{ q= q.next; } } return p.next; } }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[297.二叉树的序列化与反序列化]]></title>
    <url>%2F2020%2F12%2F25%2F297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[题目 序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。 请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 前序遍历 反序列：如何使用由前序遍历生成的列表构造二叉树，结合前序遍历，列表的第一个元素就是节点元素。前序遍历序列化，再前序遍历反序列化。 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ public class Codec { // Encodes a tree to a single string. public String serialize(TreeNode root) { StringBuilder sb = new StringBuilder(); serialize(root,sb); return sb.toString(); } void serialize(TreeNode root,StringBuilder sb){ if(root == null){ sb.append(&quot;null,&quot;); return; } sb.append(root.val+&quot;,&quot;); serialize(root.left,sb); serialize(root.right,sb); } // Decodes your encoded data to tree. public TreeNode deserialize(String data) { //先将字符串转化成列表，问题就转换成如何根据列表构造二叉树 LinkedList&lt;String&gt; nodes = new LinkedList&lt;&gt;(); for(String s:data.split(&quot;,&quot;)){ nodes.addLast(s); } return deserialize(nodes); } //通过辅助函数构造二叉树 TreeNode deserialize(LinkedList&lt;String&gt; nodes){ if(nodes.isEmpty()) return null; String first = nodes.removeFirst(); if(first.equals(&quot;null&quot;))return null; TreeNode root = new TreeNode(Integer.parseInt(first)); root.left = deserialize(nodes); root.right = deserialize(nodes); return root; } } 后序遍历前序遍历反序列化做了哪些事？找到root节点的值，然后递归计算左右节点。那么我们按照这个思路，后序遍历得到的左右中的顺序，那么只需要取最后一个得到root节点，然后递归右左节点就行了。 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ public class Codec { // Encodes a tree to a single string. public String serialize(TreeNode root) { StringBuilder sb = new StringBuilder(); serialize(root,sb); return sb.toString(); } void serialize(TreeNode root,StringBuilder sb){ if(root == null){ sb.append(&quot;null,&quot;); return; }//放前面防止报空指针异常的错误 serialize(root.left,sb); serialize(root.right,sb); sb.append(root.val+&quot;,&quot;); } // Decodes your encoded data to tree. public TreeNode deserialize(String data) { //先将字符串转化成列表，问题就转换成如何根据列表构造二叉树 LinkedList&lt;String&gt; nodes = new LinkedList&lt;&gt;(); for(String s:data.split(&quot;,&quot;)){ nodes.addLast(s); } return deserialize(nodes); } //通过辅助函数构造二叉树 TreeNode deserialize(LinkedList&lt;String&gt; nodes){ if(nodes.isEmpty()) return null; String first = nodes.removeLast(); if(first.equals(&quot;null&quot;))return null; TreeNode root = new TreeNode(Integer.parseInt(first)); root.right = deserialize(nodes); root.left = deserialize(nodes); return root; } } 中序遍历 中序遍历无法实现反序列化方法，因为没有办法找到root节点。 层次遍历 序列化时，套入模板 if(root == null) reutrn; Queue&lt;TreeNode&gt;q = new LinkedList&lt;&gt;() q.offer(root); while(!q.isEmpty()){ TreeNode cur = q.poll; //层次遍历的操作 if(cur.left!= null){ q.offer(cur.left); } if(cur.right != null){ q.offer(cur.right); } } 反序列化时，同样先将字符串转换成列表，然后再找根节点，列表顺序由层序遍历得到，那么还原根节点的时候也可以采用层次遍历还原。 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ public class Codec { // Encodes a tree to a single string. public String serialize(TreeNode root) { if(root == null) return &quot;&quot;; StringBuilder sb = new StringBuilder(); Queue&lt;TreeNode&gt;q = new LinkedList&lt;&gt;(); q.offer(root); while(!q.isEmpty()){ TreeNode cur = q.poll(); //层次遍历的操作 if(cur == null) { sb.append(&quot;null,&quot;); continue; } sb.append(cur.val+&quot;,&quot;); q.offer(cur.left); q.offer(cur.right); } return sb.toString(); } // Decodes your encoded data to tree. public TreeNode deserialize(String data) { if(data.isEmpty())return null; String[] nodes = data.split(&quot;,&quot;); //第一个元素是根节点。 TreeNode root = new TreeNode(Integer.parseInt(nodes[0])); Queue&lt;TreeNode&gt;q = new LinkedList&lt;&gt;(); q.offer(root); //循环获取到nodes数组中的每一个元素 for(int i = 1;i&lt;nodes.length;){ //队列中的就是父节点 TreeNode cur = q.poll(); //层序遍历是父节点取出后，左右孩子节点分别进入，那么此时先取出来的就是左孩子节点 String left = nodes[i++]; if(!left.equals(&quot;null&quot;)){ cur.left = new TreeNode(Integer.parseInt(left)); q.offer(cur.left); //放入是一个节点 }else{ cur.left = null; } String right = nodes[i++]; if(!right.equals(&quot;null&quot;)){ cur.right = new TreeNode(Integer.parseInt(right)); q.offer(cur.right); //放入是一个节点 }else{ cur.right = null; } } return root; } }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的总结]]></title>
    <url>%2F2020%2F12%2F23%2Fnote-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[递归三要素与回溯递归 1.确定递归函数的参数和返回值2.确定终止条件3.确定单层递归逻辑 回溯 总是成对出现的，回溯还隐藏在递归传值的形参中，因为形参有自己的作用域。后序遍历也隐藏着天然的回溯，后序遍历是从底往上，前序遍历是从上往下 递归的返回值关于递归函数的返回值问题，一般需要遍历整棵树是不需要返回值的，如果要搜索其中一条符合条件的路径，是需要及时返回的。 但是在236题中，发现如果需要对递归的返回值进行逻辑处理，其实也相当于遍历了整棵树并返回了值。 搜索一条边的写法 if (递归函数(root-&gt;left)) return ; if (递归函数(root-&gt;right)) return ; 搜索整棵树的写法 left = 递归函数(root-&gt;left); right = 递归函数(root-&gt;right); left与right的逻辑处理; 技巧1.求众数结合有一个技巧可以较少遍历的次数，适当的清空结果集。2.若仅与前一个值有关，就可以使用pre记录3.类似数组构造二叉树的题目，每次分隔尽量不定义新数组，通过下标索引直接在原数组上操作。4.灵活运用遍历，二叉搜索树中序遍历产生的数组是从小到大，那么二叉搜索树逆中序遍历产生的数组是从大到小 分类一般：1.涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。2.求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。单纯求深度就用前序。3.求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[236.二叉树的最近公共祖先]]></title>
    <url>%2F2020%2F12%2F23%2F236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%2F</url>
    <content type="text"><![CDATA[题目给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 示例 1: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。示例 2: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 首先遍历应该是从下往上的，所以选择后序遍历 套上递归三部曲 1.返回值的类型以及参数 参数为要找的节点的值，这个值是不变的。 public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { } 2.递归终止条件 终止条件要么是找到了节点，要么是遇见了空节点 //说明找到了节点 if(root == q || root == p || root == null ){ //找到了 return root; } 3.确定单层逻辑 值得注意的是 本题函数有返回值，是因为回溯的过程需要递归函数的返回值做判断，但本题我们依然要遍历树的所有节点。 递归函数有返回值就是要遍历某一条边，但有返回值也要看如何处理返回值！ 搜索一条边的写法 if (递归函数(root-&gt;left)) return ; if (递归函数(root-&gt;right)) return ; 搜索整棵树的写法 left = 递归函数(root-&gt;left); right = 递归函数(root-&gt;right); left与right的逻辑处理; 在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯） 返回值不为空说明是找到了，如何判断一个节点是节点q和节点p的公共祖先节点?如果一个节点的左子树里有p或q，或者一个节点的右子树中有p或q,那么就找到了。说明我们在后序遍历中，是需要利用left和right做逻辑处理的，不能立即返回，要等left与right逻辑处理完之后才能返回。 //左子树 TreeNode left = lowestCommonAncestor(root.left,p,q); //右子树 TreeNode right = lowestCommonAncestor(root.right,p,q); //情况1都不为空 if(left !=null &amp;&amp; right != null) return root; //都为空 if(left == null &amp;&amp; right == null) return null; //说明其中一个为空 return left == null ?right:left; 为什么left为空，right不为空，目标节点通过right返回呢？反之亦然 代码 public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { //终止条件 if(root == null || root == p || root == q)return root; //如何表示找到了公共节点？左右子树的返回值不全为空 //后序遍历，并且需要使用递归返回值做逻辑运算，所以还是需要遍历整棵树 TreeNode left = lowestCommonAncestor(root.left,p,q); TreeNode right = lowestCommonAncestor(root.right,p,q); //后序处理 if(left == null &amp;&amp; right == null){ return null; } if(left != null &amp;&amp; right !=null){ return root; } return left == null?right:left; } 总结 1.求最小公共祖先，需要从底向上遍历，那么二叉树，只能通过后序遍历（即：回溯）实现从低向上的遍历方式。2.在回溯的过程中，必然要遍历整颗二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。3.公共祖先的判断条件是左右子树中有目标节点]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[222.完全二叉树的节点个数]]></title>
    <url>%2F2020%2F12%2F23%2F222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目 给出一个完全二叉树，求出该树的节点个数。 说明： 完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。 示例: 输入: 1 / \ 2 3 / \ /4 5 6 输出: 6 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/count-complete-tree-nodes著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 之前做过一次，发现用的暴力解法，没有体现完全二叉树的性质，时间复杂度为O(N) public int countNodes(TreeNode root) { if(root == null) return 0; return countNodes(root.left) + countNodes(root.right) + 1; } } 根据满二叉树的节点总数和树的高度的关系 节点总数 = 2^h-1，可以得出 public int countNodes(TreeNode root) { int h = 0; while(root !=null){ root = root.left; h++; } return (int)Math.pow(2,h) - 1; } 其实完全二叉树，可以看成普通二叉树与满二叉树的结合体。 public int countNodes(TreeNode root) { TreeNode l = root ,r = root; int hl =0,hr=0 ; int h = 0; while(l !=null){ l = l.left; hl++; } while(r !=null){ r = r.left; hr++; } if(hl == hr){ return (int)Math.pow(2,h) - 1; } return countNodes(root.left) + countNodes(root.right) + 1; } } 这个算法的时间复杂是O(logNlogN)，while需要logN的时间，最后的递归并不是O(N)的时间，因为两个递归中最终只有一个会真的递归下去，另外一个一定会出发hl==hr]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[501.二叉搜索树中的众数]]></title>
    <url>%2F2020%2F12%2F23%2F501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目 给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。 假定 BST 有如下定义： 结点左子树中所含结点的值小于等于当前结点的值结点右子树中所含结点的值大于等于当前结点的值左子树和右子树都是二叉搜索树例如：给定 BST [1,null,2,2], 1 \ 2 / 2返回[2]. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-mode-in-binary-search-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 首先是一个二叉搜索树，那么根据二叉搜索树的特点，可以得知中序遍历是单独非增的，那么套上中序遍历的模板。 //根据中序遍历单调不减的特点，相同的元素个数应该会出现在左右两边 TreeNode pre = null; //记录前一个结点 int count = 1; //统计评论 int maxCount = 1 ; //最大频率 public void inorder(TreeNode root){ if(root == null) return ; inorder(root.left); //处理节点 inorder(root.right); } 先处理频率,累计当前数出现的频率，如果当前和pre不相等则重置 if(pre != null &amp;&amp; root.val == pre.val){ count ++ ; }else{ //如果不相等,重置 count = 1 ; } 因为需要返回的是最大频率的，这里有个技巧就是当count == maxCount 时先把该数放进去，该数不一定是最大频率的，然后当 count&gt;maxCount 时，更新maxCount，并清空数组，重新放进去 if(pre != null &amp;&amp; root.val == pre.val){ count ++ ; }else{ //如果不相等,重置 count = 1 ; } if(count == maxCount){ answer.add(root.val); //放入数组中 }else if(count &gt; maxCount){ //说明不是出现次数最多数，清空数组，更新maxCount answer.clear(); answer.add(root.val); maxCount = count; } //更新当前值 pre = root; 代码 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { //根据中序遍历单调不减的特点，相同的元素个数应该会出现在左右两边 TreeNode pre = null; //记录前一个结点 int count = 1; //统计评论 int maxCount = 1 ; //最大频率 List&lt;Integer&gt; answer = new ArrayList&lt;&gt;();//答案数组 public int[] findMode(TreeNode root) { inorder(root); //JAVA数组的一些特点 int[] mode = new int[answer.size()]; for (int i = 0; i &lt; answer.size(); ++i) { mode[i] = answer.get(i); } return mode; } public void inorder(TreeNode root){ if(root == null) return ; inorder(root.left); //处理节点 if(pre != null &amp;&amp; root.val == pre.val){ count ++ ; }else{ //如果不相等,重置 count = 1 ; } if(count == maxCount){ answer.add(root.val); //放入数组中 }else if(count &gt; maxCount){ //说明不是出现次数最多数，清空数组，更新maxCount answer.clear(); answer.add(root.val); maxCount = count; } //更新当前值 pre = root; inorder(root.right); } }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea使用笔记]]></title>
    <url>%2F2020%2F12%2F22%2Fidea%2F</url>
    <content type="text"><![CDATA[Moduleproject 工程下可以新建 module ,每个module下都有一个src目录。 顶级 项目project –&gt; 多个模板module(基本根据功能划分) 删除module 方法1.右键remove module方法2.右键open module settings -&gt; 点减号 并没有删掉，模块变成普通的文件夹，普通的文件目录邮件delete就可以直接删除了。 快捷键复制ctrl + D 复制该行并输出在该行下一行 换行ctrl + shift + enter 换到上一行shift + enter 换到下一行 快捷开发alt+shift+S 选中代码块包裹，try-catch等等alt+shift+delete 删除代码包裹块alt + enter 错误解决办法ctrl + p 光标停在new类的括号中，显示可选形参alt + ins 快速生成代码，构造器等 模板位置1：Editor - General - Postfix completion此位置不可以修改 位置2: Editor - Live Templates - other/output此位置可以自己修改与添加 按Tab键切换光标位置 sout x.sout + Tab = System.out.println(x); soutp + Tab = System.out.println(“打印当前方法的形参”); main main + Tab public static void main(String[] args){ $END$} fori fori + Tabfor (int i = 0; i &lt; ; i++) {} 100.for + enterfor (int i = 0; i &lt; 100; i++) {}]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[98.验证二叉搜索树]]></title>
    <url>%2F2020%2F12%2F22%2F98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。示例 1: 输入: 2 / \ 1 3输出: true 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/validate-binary-search-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 陷阱1.不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了 我们应该比较的是 左子树所有节点小于中间节点，右子树所有节点而与中间节点 陷阱2.样例中最小节点 可能是int的最小值，如果这样使用最小的int来比较也是不行的。 此时可以初始化比较元素为long的最小值，long的最小值小于int的最小值 代码 中序遍历树，检查是否是升序排列。 1.确定递归函数，返回值以及参数 这道题递归是可以有返回值的，因为如果找到一个不符合条件的节点就可以立即返回，不需要遍历整颗二叉树 long pre = Long.MIN_VALUE; // 因为后台测试数据中有int最小值 bool isValidBST(TreeNode* root) 2.递归终止条件 if (root == NULL) return true; 3.单层逻辑 中序遍历，当前节点的值是不是小于前一个节点的值 //有返回值，如果不符合就立刻返回 if(!(isValidBST(root.left)))return false; //比较如果不符合立即返回 if(root.val&lt;= pre) return false; //更新pre值 pre = root.val; //访问右子树 return isValidBST(root.right); 整体代码 class Solution { long pre = Long.MIN_VALUE; public boolean isValidBST(TreeNode root) { if (root == null) { return true; } if (!isValidBST(root.left)) { return false; } if (root.val &lt;= pre) { return false; } pre = root.val; return isValidBST(root.right); } } 思考 那如果样例中根节点的val可能是long的最小值，又要怎么办呢？ 解决办法：避免初始化最小值，取到最左面节点的数值来比较。 class Solution { TreeNode pre = null; public boolean isValidBST(TreeNode root) { if (root == null) { return true; } if (!isValidBST(root.left)) { return false; } if (pre!=null &amp;&amp; root.val &lt;= pre.val) { return false; } pre = root; return isValidBST(root.right); } }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程]]></title>
    <url>%2F2020%2F12%2F21%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[基本概念程序：为完成特定任务，用某种语言编写的一组指令的集合，即一段静态(没有加载到内存空间中)的代码、静态对象。 进程：是程序的一次执行过程或者正在运行的一个程序。是一个动态的过程，有自己的生命周期。进程作为资源分配单位，系统会在运行时为每个进程分配不同的内存区域。 每个进程有自己的方法区和堆程序是静态的，进程是动态的 线程(thread)：一个程序内部的一条执行路径。一个进程 = 多个线程，线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器，线程切换的开销小。一个进程中的多个线程共享方法区和堆 -&gt; 同一个堆中分配对象，可以访问相同的变量和对象，这就使得线程间通信更简便、高效，但多个线程操作共享的系统资源可能会带来安全的隐患。 并行：多个CPU同时执行多个任务。多个人同时做不同的事。并发：一个CPU”同时”执行多个任务。多个人做同一件事。 一个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc()垃圾回收线程、异常处理线程。当然如果发生异常，会影响主线程。 线程的创建和使用继承Thread类Java语言的JVM允许程序运行多个线程，通过java.lang.Thread类来体现 Thread类的特性1.每个线程都是通过某个特定Thread对象的run()方法来操作的，经常把run()方法的主体称为线程体。2.通过该Thread对象的start()方法来启动这个线程，而非直接调用run() 使用 1.创建一个继承于Thread类的子类2.重写Thread的run(),将此线程执行的操作声明在run()中3.创建Thread类的子类的对象4.通过此对象调用start(),start的作用 ①启动当前线程 ②调用当前线程的run() 问题1：不能直接子类对象调用run方法启动线程如果子类对象直接调用run方法，相当于调用了普通的方法，并没有启动新线程。问题2：在启动一个线程，同样的操作再调用一次 newThread.start(); 是错误的。因为线程start只能启动一次。重新创建一个子类对象。 共享数据1.可以成员变量设置static2.可以模仿Runnable，设置构造器，构造器中的指向同一个地址来实现数据共享。 //1.创建一个继承于Thread类的子类 public class NewThread extends Thread{ //2.重写Thread的run() public void run(){ //将此线程执行的操作声明在run()中 this.yield(); //this指的是这个类的实例对象， } } //如main方法里 //3.创建Thread类的子类的对象 NewThread newThread = new NewThread(); //4.通过此对象调用start() newThread.start(); //1.启动当前线程 2.调用当前线程的run() //newThread是主线程帮忙造的，start调用之后分线程开始执行。 可以使用匿名子类 new Thread(){ @override public void run(){} }.start(); Thread类的方法void start():①启动当前线程 ②调用当前线程的run()run():线程在被调用时执行的操作String getName():返回线程的名称void setName(String name):设置该线程名称设置线程的名字还可以在子类中设置构造器继承父类构造器。static Thread currentThread():返回执行当前代码的线程Thread。在Thread子类中就是this，通常用于主线程和Runnable实现类isAlive():判断线程是否还存活。 yield():释放当前cpu的执行权，之后再公平竞争join(): 占用cpu。在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b执行完以后，线程a才结束阻塞状态变成就绪状态，等待获取cpu的使用权static sleep(long millitime):单位是ms,让当前线程睡眠指定的millitime毫秒,不会释放当前占有的锁，导致线程进入TIMED-WATING状态。 线程通讯：wait()/notify()/notifyAll()这三个方法定义在Object类中的。 //1.创建一个继承于Thread类的子类 public class NewThread extends Thread{ //2.重写Thread的run() public void run(){ //将此线程执行的操作声明在run()中 this.yield(); //this指的是这个类的实例对象， //Thread.currentThread().yield()也可以 //这里只能try-catch 因为run方法的父类并没有throws，子类异常&lt;=父类异常 try{ sleep(1000); }catch(InterruptedException e){ e.printStackTrace; } } } 实现Runnable接口因为类的单继承性，如果某个子类已经继承了一个类，此时可以通过实现Runnable接口创建线程。 1.创建一个实现Runnable接口的类2.实现类去实现Runnable中的抽象方法:run()3.创建实现类的对象4.将此对象作为参数传递到Threa类的构造器中，创建Thread类的对象5.通过Thread类的对象调用statr方法 //1.创建一个实现Runnable接口的类 class Mthread implements Runnable{ //2.实现类去实现Runnable中的抽象方法:run() @Override public void run(){ System.out.println(Thread.currentThread().getName()) } } //如main方法里你m //3.创建实现类的对象 MThread mThread = new MThread(); //4.将此对象作为参数传递到Threa类的构造器中，创建Thread类的对象 Thread t1 = new Thread(mThread); //5.通过Thread类的对象调用statr方法 t1.start(); //在启动一个线程，同样的操作 Thread t2 = new Thread(mThread); t2.start(); start()①启动当前线程 ②调用当前线程的run(),调用的是当前线程的run，跟Mthread类有什么关系呢？ 当前线程的run间接的调用Runnable类型 mThread里的run()。 //target Thread类中 private Runnable target; //构造器 public Thread(Runnable target){} public void run(){ if(target != null) target.run(); } 比较实现Runnable接口与继承Thread类两种方式 开发时，优先选择实现Runnable接口的方式原因：1.实现的方式可以多实现，没有类单继承性的局限性2.实现的方式更适合来处理多个线程有共享数据的情况 联系：Thread类本身也实现了Runnable接口，都需要重写run()方法，都是通过调用Thread类中的start()方法开启线程。 实现Callable接口 –JDK5.0新增与Runnable相比，Callable功能更强大1.重写call方法，可以有返回值，支持泛型的返回值2.call方法可以抛出异常3.需要借助FutureTask类，比如获取返回结果。 FutureTast同时实现了Runnable、Future接口，既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。 //1.创建一个实现Callable的实现类 class MyThread implements Callable{ //2.实现call方法，将此线程需要执行的操作声明在call中 @Overrid public Object call() throws Exception{} } //main //3.创建Callable接口实现类的对象 MyThread myThread = new MyThread(); //4.作为参数传递到FutureTask构造器中，创建futureTask对象 FutureTsk futureTask =new FutureTask(myThread); //5.将futureTask对象作为参数传递到Thread类的构造器中，动线程 new Thread(futureTask).start(); //get()返回值为FutureTask构造器参数Callable实现类重写的call()的返回值 Object sum = futureTask.get(); 使用线程池 –JDK5.0新增、常用背景：经常创建和销魂、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中，可以必反频繁创建销魂，实现重复利用。好处：1.提高了响应速度2.降低资源消耗3.便于线程管理 corePoolSize:核心池的大小 maximumPoolSize:最大线程数 keepAliveTime:线程没有任务时最多保持多长时间后会终止。 import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class ThreadPool { public static void main(String[] args) { // 1.调用Executors的newFixedThreadPool(),返回指定线程数量的ExecutorService ExecutorService为接口 ExecutorService pool = Executors.newFixedThreadPool(10); //设置线程池的属性,接口的实现类 ThreadPoolExecutor pool1 = (ThreadPoolExecutor) pool; //pool1.xxxx // 2.将Runnable实现类的对象作为形参传递给ExecutorService的submit()方法中，开启线程 //execute适用于Runnable，submit适用于Callable // 并执行相关的run() pool.execute(new MyThread()); pool.execute(new MyThread()); pool.execute(new MyThread()); // 3.结束线程的使用 pool.shutdown(); } } 线程的调度抢占式：高优先级的线程抢占CPU Java的调度方法同优先级线程组成先进先出队列，使用时间片策略。对高优先级，使用优先调度的抢占式策略。 线程的优先级等级MAX_PRIORITY ：10MIN_PRIORITY : 1NORM_PRIORITY: 5 默认优先级 getPriority()：返回线程优先级setPriority(int newPriority)：改变线程的优先级 说明：1.线程创建时继承父线程的优先级2.优先级低的线程只是获取CPU时间片的优先级被降低，但不会永久分配不到CPU时间片，JAVA的线程调度在保障效率的前提下尽可能公平 线程的生命周期1.两个概念：状态、相应的方法2.关注：状态a -&gt; 状态b :哪些方法执行了(回调方法);某个方法主动调用：状态a -&gt; 状态b JDK中用Thread.State类定义了线程的几种状态 新建NEW：当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态。就绪RUNNABLE：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已经具备了运行的条件，只是没有分配到CPU资源。运行RUNNING：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run()方法定义了线程的操作和功能。阻塞BLOCKED：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出CPU并临时终止自己的执行，进入阻塞状态死亡DEAD：线程完成了它的全部工作或线程被提前强制性地终止或出现异常导致结束 线程的同步 ⭐线程的安全：多个线程对数据的共享当某个线程正在进行某个操作，还没有操作完成，其他线程也进来操作。在Java中，我们通过同步机制，来解决线程的安全问题。 synchronized同步代码块synchronized(同步监视器){ //需要被同步的代码 //操作共享数据的代码} 说明：共享数据指多个线程共同操作的变量。操作共享数据的代码为需要被同步的代码，注意包含代码的范围。可以理解成一个线程拿了锁，执行需要同步的代码，执行完毕后解锁 同步监视器（锁）任何一个类的对象，都可以充当锁。要求：多个线程必须要共用同一个锁 结论1.可以考虑使用当前对象this，继承Thread方法要小心this是否是同一个锁。2.还可以传Window.class，说明类也是一个对象。Window.class是Class类的实例，Class clazz = Window.class，其中Window.class是唯一的，因为类只加载一次。**也就是说当前的类是Class实例。 同步方式：1.解决了线程的安全问题2.操作同步代码时，只能有一个线程参与，其他线程等待，相当于是一个单线程过程，效率低。 class Window1 implements Runnable{ private int ticket = 100; //Object obj = new Object(); @Override public void run() { while (true){ //synchronized(obj){ synchronized(this){ if(ticket&gt;0){ try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() +&quot;:卖票&quot; + ticket); ticket--; } else{ break; } } } } } public class WindowTest1 { public static void main(String[] args) { Window1 w = new Window1(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); } } //继承Thread类的安全问题 package ranan; /** * 继承Thread类 * 创建三个窗口卖票，总票数为100张 * 存在线程的安全问题 * @author ranan * @create 2020-12-23 16:57 */ class Window extends Thread{ private static int ticket = 100; //要公用同一个锁 //static Object obj = new Object(); @Override public void run() { while (true){ //synchronized (obj){ synchronized(Window.class){ //Window.class是Class类的实例 //Class clazz = Window.class; //是唯一的，因为类只加载一次。 if(ticket&gt;0){ try { Thread.sleep((100)); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(getName() +&quot;:卖票&quot; + ticket); ticket--; } else{ break; } } } } } public class WindowTest { public static void main(String[] args) { Window t1 = new Window(); Window t2 = new Window(); Window t3 = new Window(); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); } } 同步方法如果操作共享数据的代码完整的声明在一个方法中，可以将这个方法声明同步的。 1.解决实现Runnable接口的线程安全问题，在方法前面添加synchronized关键字，此时的同步监视器是this。2.解决Thread继承类的线程安全问题，对于Thread继承类来说，注意该方法要写成静态的，这样该方法只会加载一份，此时的同步监视器是当前的类。 总结1.同步方法仍然涉及到同步监视器，只是不需要我们显式的声明2.非静态的同步方法，同步监视器是this。静态的同步方法，同步监视器是当前的类。 方式二：Lock锁 JDK5.0新增为了避免程序出现异常而无法正确释放锁，在使用ReentrantLock时必须在finally语句块中执行锁的释放。 注意要同一个锁上锁解锁 //无参默认fair=false，有参数一般为true表示公平先进先出 //1.新建ReentrantLock对象 ReentrantLock lock = new ReentrantLock(); try{ //2.调用锁定方法lock(),上锁 lock.lock(); }finally{ //3.调用解锁方法:unlock(),解锁 lock.unlock(); } synchronized与lock/reentrantLock的比较 synchronized: 在执行完相应的同步代码以后，自动的释放同步监视器reentrantLock:1.Lock显式获取锁和释放锁2.lock可以知道有没有成功获取锁 推荐优先使用顺序Lock -&gt; 同步代码块 -&gt; 同步方法 线程的死锁问题有多个线程同时被阻塞时，它们之间若相互等待对方释放锁资源，就会出现死锁。说明：1.出现死锁后，不会出现异常，不会出现提示，只是所有的线程都从处于阻塞状态，无法继续。2.我们使用同步时，要避免出现死锁。解决办法：为锁操作添加超时时间，在线程持有锁超时后自动释放该锁。 练习题1银行有一个账户，有两个储户分别向同一个账户存3000元，每次存1000存3次，每次存完打印余额分析：1.是否是多线程？是，两个储户线程，创建线程2.是否有共享数据？有，账户3.是否有线程安全问题？有4.如何解决线程安全问题？同步机制，有三种方式。 代码 线程的通信wait()方法Object类的方法调用wait方法的线程会进入WAITING状态，只有等到其他线程的通知或者中断才会返回。调用wait方法之后会释放对象的锁，所以常用于同步方法或同步代码块中 sleep方法Thread类的方法static sleep(long millitime):单位是ms,让当前线程睡眠指定的millitime毫秒,不会释放当前占有的锁，导致线程进入TIMED-WATING状态。 notify()方法/notifyAll()方法Object类的方法，用于唤醒在此对象监视器上等待的一个线程，如果所有线程都在此对象上等待，则会选择随机唤醒其中一个线程。notifyAll()方法唤醒所有。 说明：1.wait()、notify()、notifyAll()必须使用在同步方法或同步代码块中。2.上述三个方法的调用者必须是同步代码块或同步方法中的同步监视器。3.这三个方法是定义在object类中的方法。 sleep()和wait()的异同1.相同点：都可以使当前线程进入阻塞状态2.不同点声明的位置：Thread类中声明sleep，Object类中声明wait调用的范围：wait必须在同步代码块和同步方法中调用是否释放同步监视器：sleep方法不会释放当前占有的锁，而wait会释放当前占有的锁。线程状态：sleep会导致线程进入TIMED-WATING状态，wait会导致线程进入WATING状态 练习题生产者消费问题 多线程如何共享数据1.将Runnable对象作为一个类的内部类，将共享数据作为这个类的成员变量。2.将数据抽象成一个类，并将对这个数据的操作封装在类的方法中。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java异常]]></title>
    <url>%2F2020%2F12%2F14%2FJava%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[异常概述error：Java虚拟机无法解决的严重问题。如JVM系统内部错误、资源耗尽等严重情况，一般不编写针对性的代码进行处理。exception：其他因编码错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。如空指针访问、数组角标越界。 异常exception分为编译时异常和运行时异常 Java源程序 –javac.exe–&gt; 字节码文件 –java.exe–&gt; 在内存中加载、运行类编译时异常：执行javac.exe文件名时，可能出现的异常。运行时异常：执行java.exe文件名时，可能出现的异常. 异常处理机制抛：程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象，并将此对象抛出，其他的代码将不会执行。 抓：异常的处理方式，有try-catch-finally与throws (系统三单) 方法重写的规则之一：子类重写的方法抛出的异常类型 &lt;= 父类该方法的异常类型。多态的时候处理了父类的异常，使用子类的该方法时抛出的异常比父类的小所以也可以处理。 开发中如何选择使用哪种方法？1.如果父类被重写的方法没有throws处理异常，则子类重写的方法也不能使用throws2.递进关系的方法调用中，各方法分别采用throws，整体集中try-catch 异常处理机制一: try-catch-finallytry{ //可能出现异常的代码 }catch(异常类型1 变量名1){ //String getMessage() 获取异常信息 //printStackTrace() 打印堆栈信息 e.getMessage(); e.printStackTrace(); //处理异常的方式1 }catch(异常类型2 变量名2){ //处理异常的方式2 }finally{ //try-catch执行完后执行 //一定会执行的代码 } 1.finally可选，一定会执行即使try-catch里面有异常或者return。2.只会匹配一个catch，类似if-ifesle3.若catch中的异常类型满足子父类关系，则子类要声明在父类的上面，否则报错。4.在try结构中声明的变量，在出了try结构之后，就不能被调用。5.像数据库连接、输入输出流、网络编程Socket等资源，JVM不能自动的回收，需要手动进行释放。此时的资源释放就需要声明在finally中。 体会1:使用try-catch-finally处理编译时异常，使程序在编译时不会再报错，但是运行时仍可能报错，相当于将一个编译时可能出现的异常延迟到运行时出现。体会2：开发中，由于运行时异常比较常见，一般不处理运行时异常。 异常处理机制二：throws + 异常类型class ExceptionTest{ //写在方法声明处，指明此方法执行时，可能会抛出的异常类型。 public void method() throws 异常类型{ //并没有捕获异常，只是将异常往上抛 //真正的处理是try-catch } } 体会:throws的方法只是将异常抛给了方法的调用者，并没有真正将异常处理掉。 用户自定义异常手动抛出异常关于异常对象的产生： ①系统自动生成的异常对象 ②手动的生成一个异常对象，并抛出throw (i) //运行时异常可以不用处理 throw new RuntiomeException(&quot;有些有message参数&quot;) //需要处理因为包含了编译时异常，可选throws或者try-catch-finally throw new Exception(&quot;xx&quot;) 自定义异常类 //1.继承现有的异常结构RuntimeException、Exception public class MyException extends RuntimeException{ //2.提供全局常量:serialVersionUID，唯一标识类 static final long serialVersionUID = -70343551545L; //3.提供重载的构造器 public MyException(){ } public MyException(String msg){ super(msg); } } throw与throws的区别throw是生成一个异常对象，抛出一个异常类的对象。throws是处理异常，声明在方法的声明处。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[257.二叉树的所有路径]]></title>
    <url>%2F2020%2F12%2F14%2F257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[递归 + 回溯 题目给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明: 叶子节点是指没有子节点的节点。 示例: 输入: 1 / \2 3 \ 5 输出: [“1-&gt;2-&gt;5”, “1-&gt;3”] 解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-tree-paths著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 从根节点到叶子的路径，所以需要前序遍历，这样才方便让父节点指向孩子节点，找到对应的路径。这里涉及到了回溯，因为记录路径之后，需要回溯来退回到上一个节点再进入下一个路径 套入递归三部曲1.递归函数的参数以及返回值要传入根节点，记录每一条路径的path和存放结果集的result //参数为当前的节点cur、当前的路径path、结果集res public void traversal(TreeNode cur,String path,List&lt;String&gt;res){} 2.递归的终止条件找到叶子节点，就可以结束递归把path放进结果集中了,递归结束后就需要进行回溯。回溯和递归是一一对应的，有一个递归就要有一个回溯 if(cur.left == null &amp;&amp; right == null){ //把path加入到结果集中 res.add(path); return; } 3.本层递归需要做的事情因为是前序遍历，所以需要先记录先当前的路径path+=cur.val。然后进行递归与回溯，因为参数path的数据类型是String类型，在JAVA中修改String类型变量，是新建了一个char[]数组把新的地址赋值给该变量。所以每次的局部变量之间是不会互相干扰的(可以简单的理解为是传值),这里是隐含了回溯，相当于每次递归结束返回上一次递归，path值又变成了上一次递归的值，所以相当于每次都进行了一次对应的回溯。 if(cur.left != null) traversal(cur.left,path+&quot;-&gt;&quot;,res); //左 if(cur.right != null) traversal(cur.right,path+&quot;-&gt;&quot;,res); //右 代码 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public List&lt;String&gt; binaryTreePaths(TreeNode root) { List &lt;String&gt; res = new ArrayList&lt;&gt;(); if(root == null) return res; traversal(root,&quot;&quot;,res); return res; } //参数为当前的节点cur、当前的路径path、结果集res public void traversal(TreeNode cur,String path,List&lt;String&gt;res){ //找到叶子节点，就可以结束递归把path放进结果集中了,并结束递归 path += cur.val; if(cur.left == null &amp;&amp; cur.right == null){ res.add(path); return; } if(cur.left != null) traversal(cur.left,path+&quot;-&gt;&quot;,res); //左 if(cur.right != null) traversal(cur.right,path+&quot;-&gt;&quot;,res); //右 } }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[111.二叉树的最小深度]]></title>
    <url>%2F2020%2F12%2F09%2F111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目 给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。说明: 叶子节点是指没有子节点的节点。 递归法思路1.确定递归函数的参数和返回值 public int minDepth(TreeNode root) {} 2.确定终止条件 结点为空的时候 if(root == null) return 0; 3.确定单层递归的逻辑(从局部考虑) 选择左子树和右子树的高度中较小的一个+1这个是错误的写法，比如只有右子树的结点会是左子树的高度+1 = 0+1 =1 depth = Math.min(minDepth(root.left),minDepth(root.right))+1; 需要分情况讨论如果左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度。右子树为空，左子树不为空，最小深度是 1 + 左子树的深度。最后如果左右子树都不为空，返回左右子树深度最小值 + 1 。 if(root.left == null){ return minDepth(root.right) + 1; }else if(root.right ==null){ return minDepth(root.left) + 1; }else{ return Math.min(minDepth(root.left),minDepth(root.right))+1; } 代码 class Solution { public int minDepth(TreeNode root) { if(root == null) return 0; if(root.left == null){ return minDepth(root.right) + 1; }else if(root.right ==null){ return minDepth(root.left) + 1; }else{ return Math.min(minDepth(root.left),minDepth(root.right))+1; } } } 迭代法考虑层序遍历，从根结点开始，这层没有左右孩子为空的结点，则深度+1，如果发现有左右孩子为空的结点，说明这个结点为叶子结点，且第一个出现的叶子结点到根结点的距离就是最小深度。 套上层次遍历需要分层的模板 class Solution { public int minDepth(TreeNode root) { if(root == null) return 0; if(root.right == null &amp;&amp; root.left == null) return 1; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.add(root); int depth = 0 ; while(!queue.isEmpty()){ int size = queue.size(); for(int i = 0 ; i&lt;size ; i++){ root = queue.poll(); if(root.right == null &amp;&amp; root.left == null) return depth+1; if(root.right != null) queue.add(root.right); if(root.left != null) queue.add(root.left); } depth++; } //防止编译错误，随便返回 return depth; } }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[226.翻转二叉树]]></title>
    <url>%2F2020%2F12%2F03%2F226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目 翻转一棵二叉树。 示例： 输入： 4 / \ 2 7 / \ / \ 1 3 6 9 输出： 4 / \ 7 2 / \ / \ 9 6 3 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/invert-binary-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 翻转是把每一个结点的左右孩子交换，所以可以选择先遍历再交换。 遍历的顺序我选择的是前序遍历，这样操作结点的顺序可以和遍历的顺序统一起来 题解 递归法 1.确定递归函数的参数和返回值 参数是指向当前结点的指针，返回值不需要，但是题目中给出的要返回TreeNode类型的root节点的指针，可以使用题目给的函数。 public TreeNode invertTree(TreeNode root) {} 2.确定递归的终止条件 当前结点为空时，递归结束。 if(root == null) return null; 3.确定单层递归逻辑 选择的是前序遍历，那么应该先交换左右结点，在左子树递归，右子树递归 swap(root.left, root.right); invertTree(root.left); invertTree(root.right); 代码 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode invertTree(TreeNode root) { //swap(root.left,root.right); 交换左右结点 if(root == null) return null; TreeNode p = root.left; root.left = root.right; root.right = p; invertTree(root.left); invertTree(root.right); return root; } } 迭代法 引入前序遍历迭代法的模板 Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); //对当前结点的操作 //此题是交换结点 TreeNode p = node.left; node.left = node.right; node.right = p ; //模板，前序遍历右子树先进栈，左子树后进栈 if (node.right != null) stack.push(node.right); if (node.left != null) stack.push(node.left); } //最终代码 class Solution { public TreeNode invertTree(TreeNode root) { if(root == null) return null; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); TreeNode p = node.left; node.left = node.right; node.right = p ; if (node.right != null) stack.push(node.right); if (node.left != null) stack.push(node.left); } return root; } }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[513.找树左下角的值]]></title>
    <url>%2F2020%2F11%2F16%2F513.%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目 给定一个二叉树，在树的最后一行找到最左边的值。 示例 1: 输入: 2 / \ 1 3 输出: 1 示例 2: 输入: 1 / \ 2 3 / / \ 4 5 6 / 7 输出: 7 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-bottom-left-tree-value著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 本题应该输出的是最后一层的第一个数。首先想到的是套上BFS的模板 代码 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int findBottomLeftValue(TreeNode root) { Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); TreeNode currentNode = root; queue.add(currentNode); int ans = root.val; while(!queue.isEmpty()){ int size = queue.size(); //分层 for(int i =0; i&lt; size;i++){ currentNode=queue.poll(); //队列的先进先出的特点，那么每次循环开始的第一个元素就是最左边的 if(i == 0) ans = currentNode.val; if(currentNode.left!=null)queue.add(currentNode.left); if(currentNode.right!=null)queue.add(currentNode.right); } } return ans; } } 其他解法 不用进行分层，可以少一层循环。入队的时候，从右往左，右边先入，那么最后出队的就是最左边的结点， class Solution { public int findBottomLeftValue(TreeNode root) { Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty()){ root = queue.poll(); if (root.right != null) queue.offer(root.right); if (root.left != null) queue.offer(root.left); } return root.val; } }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[102.二叉树的层次遍历]]></title>
    <url>%2F2020%2F11%2F16%2F102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[题目 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 示例： 二叉树：[3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 返回其层次遍历结果： [ [3], [9,20], [15,7] ] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 可以使用BFS遍历，怎么给 BFS 遍历的结果分层呢？可以在每一层遍历开始前，先记录队列中的结点数量n（也就是这一层的结点数量），这样就达到了分层的效果。 // 二叉树的层序遍历 void bfs(TreeNode root) { Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) { int n = queue.size(); for (int i = 0; i &lt; n; i++) { // 变量 i 无实际意义，只是为了循环 n 次 TreeNode node = queue.poll(); if (node.left != null) { queue.add(node.left); } if (node.right != null) { queue.add(node.right); } } } } 代码 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { if(root == null) return new ArrayList&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); //借助队列 Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); TreeNode currentNode = root; queue.add(currentNode); while(!queue.isEmpty()){ List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); int size = queue.size(); //可以在每一层遍历开始前，先记录队列中的结点数量n，达到分层的效果 for(int i =0; i&lt; size;i++){ currentNode=queue.poll(); list.add(currentNode.val); if(currentNode.left!=null){ queue.add(currentNode.left); } if(currentNode.right!=null){ queue.add(currentNode.right); } } res.add(list); } return res; } }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[100.相同的树]]></title>
    <url>%2F2020%2F11%2F16%2F100.%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目 给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1: 输入: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3] 输出: true 示例 2: 输入: 1 1 / \ 2 2 [1,2], [1,null,2] 输出: false 示例 3: 输入: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2] 输出: false 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/same-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 1.确定递归函数的参数和返回值类型判断两棵树是不是相等，那么需要两个指针分别指向两棵树比较的位置，返回值类型为布尔类型。 public boolean isSameTree(TreeNode p, TreeNode q) 2.终止条件当两个比较结点的数字不同就可以返回了，要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。 为空的情况:2.1其中一个为空,另外一个不为空 return false2.1两个都为空 return true if(p == null &amp;&amp; q != null) return false; else if(p != null &amp;&amp; q == null) return true; else if(p == null &amp;&amp; q == null) return false; else if(p.val != q.val) return false; else{ //数值相同的情况 } 3.本层递归应该做什么从局部看成3个结点，返回值类型为布尔类型，那么检查了根节点的情况，需要分别检查左边结点与右边结点 isSameTree(p.left,q.left); isSameTree(p.right,q.right); 代码 class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { if(p == null &amp;&amp; q != null) return false; else if(p != null &amp;&amp; q == null) return false; else if(p == null &amp;&amp; q == null) return true; else if(p.val != q.val) return false; else{ return isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right); } } }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[101.对称二叉树]]></title>
    <url>%2F2020%2F11%2F16%2F101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \ 2 2 / \ / \3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \ 2 2 \ \ 3 3 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/symmetric-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 1.确定递归函数的参数和返回值类型判断是不是镜像对称，那么就需要两个指针一个指向左子树，一个指向右子树。返回值类型为布尔类型、 boolean compare(TreeNode left, TreeNode right) 2.终止条件当两个结点(指的是镜像位置的两个结点)的数字不同就可以返回了，要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。 结点为空的情况有：2.1一个为空，一个不为空，return false2.2两个都为空，return true 然后在进行比较数值是否相同 if(left == null &amp;&amp; right !=null)return false; else if(left != null &amp;&amp; right ==null)return false; else if(left == NULL &amp;&amp; right == NULL) return true; else if (left.val != right.val) return false; //剩下的else就是数值相同的情况 3.确定单层递归的逻辑 单层递归处理的是两个结点都不为空，且值相等的情况。从局部看成3个结点，返回值类型为布尔类型，那么检查了根节点的情况，需要检查左边和后边的镜像对称位置。 从以下示例看，也就是左子树的左节点3的位置与右子树的右节点3的位置，类似的还有4的位置 /* 1 / \ 2 2 / \ / \ 3 4 4 3 */ //代码如下 boolean outside = compare(left.left, right.right); //结点值为3的位置 boolean inside = compare(left.right, right.left); 代码 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public boolean isSymmetric(TreeNode root) { if(root == null) return true; return compare(root.left,root.right); } public boolean compare(TreeNode left, TreeNode right){ if(left == null &amp;&amp; right !=null)return false; else if(left != null &amp;&amp; right ==null)return false; else if(left == null &amp;&amp; right == null) return true; else if (left.val != right.val) return false; else{ boolean outside = compare(left.left, right.right); boolean inside = compare(left.right, right.left); return outside &amp;&amp; inside; } } }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[112.路径总和]]></title>
    <url>%2F2020%2F11%2F16%2F112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例: 给定如下二叉树，以及目标和 sum = 22， 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 1.确定递归函数的参数和返回类型 参数应该是指向当前结点的指针与根节点到父节点的路径和。 问题:递归函数什么时候需要返回值？什么时候不需要返回值？如果需要搜索整颗二叉树，那么递归函数就不要返回值，如果要搜索其中一条符合条件的路径，递归函数就需要返回值，因为遇到符合条件的路径了就要及时返回。 这道题的返回值是布尔类型，找到就可以返回true了，没有搜索整颗二叉树。 public boolean hasPathSum(TreeNode root, int sum) {} 2.终止条件是什么？ 转换思想:计数器如何统计这条路径的和？一般是通过累加然后判断是否等于目标和，那么代码比较麻烦，可以用递减，让计数器count初始为目标和，然后每次减去遍历路径节点上的数值。如果最后count == 0，同时到了叶子节点的话，说明找到了目标。和。如果遍历到了叶子节点，count不为0，就是没找到。 递归终止条件的代码 if (cur.left == null &amp;&amp; cur.right == null &amp;&amp; count == 0) return true; // 遇到叶子节点，并且计数为0 if (cur.left == null &amp;&amp; cur.right == null) return false; // 遇到叶子节点而没有找到合适的边，直接返回 3.本级递归应该做什么终止条件是判断是否到达叶子节点，所以节点为空就不要进入递归了。递归函数是有返回值的，如果递归函数返回true，说明找到了合适的路径，应该立刻返回。 if(root.left != null){ if(dfs(root.left,sum-root.left.val)) return true; } if(root.right != null){ if(dfs(root.right,sum-root.right.val))return true;//这种传值的参数隐含着回溯的思想 } return false; 代码 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public boolean hasPathSum(TreeNode root, int sum) { if(root == null) return false; return dfs(root,sum-root.val); } public boolean dfs(TreeNode root, int sum){ if (root.left == null &amp;&amp; root.right == null &amp;&amp; sum == 0) return true; // 遇到叶子节点，并且计数为0 if (root.left == null &amp;&amp; root.right == null) return false; if(root.left != null){ //hasPathSum函数有返回值，如果返回值为true说明找到了路径 if(dfs(root.left,sum-root.left.val)) return true; } if(root.right != null){ if(dfs(root.right,sum-root.right.val))return true; } return false; } } 化简写法假定从根节点到当前节点的值之和为val，可以将大问题转换成一个小问题，是否存在从当前节点的子节点到叶子的路径，满足其路径和为sun-val class Solution { public boolean hasPathSum(TreeNode root, int sum) { if (root == null) { return false; } if (root.left == null &amp;&amp; root.right == null) { //注意这里 return sum == root.val; } return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val); } }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[note-树]]></title>
    <url>%2F2020%2F11%2F15%2Fnote-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树是树结构的一种，两个叉就是说每个节点最多只有两个子节点，我们习惯称之为左节点和右节点 对数据结构的操作无非就是遍历加访问，遍历就是找，访问就是改。 二叉树的概念二叉树的种类 满二叉树：只有度为0的结点和度为2的结点，并且度为0的结点在同一层上完全二叉树：若二叉树的深度为k，除第k层外，其他各层的结点数都达到了最大个数，第k层所有的结点都连续集中在最左边 优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子结点的顺序关系 平衡二叉树：左子树和右子树的深度之差(平衡因子)的绝对值不超过1，且它的左子树和右子树都是一颗平衡二叉树。 二叉搜索树：二叉搜索树是一个有序树，左子树上所有结点的值小于根结点的值；右子树上所有结点的值大于根结点的值 高度与深度 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数二叉树节点的高度: 从该节点到叶子节点的最长简单路径边的条数 因为求深度可以从上往下去查，所以需要前序遍历(中左右)，而高度只能从下往上去查，所以只能后序遍历(左右中) 二叉树的遍历前序遍历可以理解成从上往下，后序遍历可以理解成从下往上 二叉树回溯的过程就是从低到上,且后序遍历就是天然的回溯过程，最先处理的一定是叶子节点 二叉树算法框架二叉树算法的总路线:明确一个节点要做的事情，然后剩下的事抛给框架。 void traverse(TreeNode root) { // root 需要做什么？在这做。 // 其他的不用 root 操心，抛给框架 traverse(root.left); traverse(root.right); } 比如100.判断两棵二叉树是否完全相同 boolean isSameTree(TreeNode root1, TreeNode root2) { // 都为空的话，显然相同 if (root1 == null &amp;&amp; root2 == null) return true; // 一个为空，一个非空，显然不同,如果都为空为执行上面的判断提前返回不会到这一步。 if (root1 == null || root2 == null) return false; // 两个都非空，但 val 不一样也不行 if (root1.val != root2.val) return false; // root1 和 root2 该比的都比完了 return isSameTree(root1.left, root2.left) &amp;&amp; isSameTree(root1.right, root2.right); } 144.二叉树的前序遍历 94.二叉树的中序遍历 145.二叉树的后序遍历 前序遍历先访问当前结点 -&gt; 遍历左子树 -&gt; 遍历右子树 递归写法 class Solution { public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); dfs(root,res); return res; } public void dfs(TreeNode root,List&lt;Integer&gt; res){ if(root == null)return; res.add(root.val); dfs(root.left,res); dfs(root.right,res); } } 迭代法递归的底层实现就是栈，因为每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈。根据栈先进后出的特点，前序遍历的顺序是中左右,所以右孩子比左孩子先入栈。 class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;&gt; (); if (root == null) return res; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); res.add(node.val); if (node.right != null) stack.push(node.right); if (node.left != null) stack.push(node.left); } return res; } } 中序遍历先遍历左子树 -&gt; 访问当前结点 -&gt; 遍历右子树 递归写法 public void dfs(TreeNode root,List&lt;Integer&gt; res){ if(root == null)return; dfs(root.left,res); res.add(root.val); dfs(root.right,res); } 迭代写法在前序遍历的迭代过程中，其实我们有两个操作1.处理:将元素放进res数组2.访问:遍历结点前序遍历先访问的元素是中间结点，先处理的元素也是中间结点，访问和处理的顺序是一致。 但是中序遍历先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点，访问和处理的顺序是不一致的。 那么在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。 public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;&gt; (); if (root == null) return res; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; while (cur != null || !stack.isEmpty()) { //一路向左 if(cur != null){ stack.push(cur); cur = cur.left; }else{ //当前的cur指向null，开始出栈 TreeNode node = stack.pop(); cur = node; //指向出栈的元素,例如最左边 res.add(node.val); cur = cur.right; } } return res; } 后序遍历遍历左子树 -&gt; 遍历右子树 -&gt; 访问当前结点 递归写法 public void dfs(TreeNode root,List&lt;Integer&gt; res){ if(root == null)return; dfs(root.left,res); dfs(root.right,res); res.add(root.val); } 迭代写法 先序遍历是中左右，后序遍历是左右中 中左右 -&gt; 调整代码左右顺序 -&gt; 中右左 -&gt; 反转结果数组(利用链表从头插入) -&gt; 左右中 class Solution { public List&lt;Integer&gt; postorderTraversal(TreeNode root) { LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt; (); if (root == null) return res; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); res.addFirst(node.val); if (node.left != null) stack.push(node.left); if (node.right != null) stack.push(node.right); } return res; } } 前中后序统一的迭代写法 前序和后序遍历的迭代写法是有关联的，但是中序遍历中使用了栈来保存处理结点的顺序，借助指针来控制访问顺序。 中序遍历借助指针的是原因是：访问和处理的顺序不一致统一写法的就是都放入栈中，把要处理的结点坐上标记。 标记法：要处理的结点放入栈之后，紧接着放入一个空指针做标记。 以中序遍历为例： 1.栈的特性入栈和出栈顺序相反，想要输出顺序”左中右”，入栈顺序必须按照”右中左”。2.入栈的处理：可以把整颗树简化为3个节点一组的多个子树。即(父节点，左孩子，右孩子)这3个节点组成的子树。每次循环处理的实际就是将这样的3个节点按照规则顺序(右中左)进行入栈。所以才有了代码中看到的：每次都是先将栈顶元素去除，然后对以栈顶元素做为父节点的3个节点子树按规则顺序（右中左）入栈。3.NULL节点的加入和出栈规则的规定：保证了当左孩子作为栈顶元素时，不会立即出栈，而是会将当前的左孩子(即栈顶元素)作为下次遍历的父节点接着按照规则顺序入栈。直到当前的左孩子做为父节点再无孩子时(无孩子时，入栈规则就成了(父节点,NULL节点))，遇到NULL节点了，才进行出栈。这样就保证了左孩子先出栈啦 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;&gt; (); if (root == null) return res; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; stack.push(root); while (!stack.isEmpty()) { //获取栈顶元素,使用了标记法，所以需要通过空指针区别是否是需要处理的结点 TreeNode node = stack.pop(); if(node!=null){//不为空就开始添加结点，为空就开始处理结点 //按右中左结点添加到栈中 if(node.right !=null) stack.push(node.right); stack.push(node); stack.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记,处理的顺序 if (node.left != null) stack.push(node.left); // 添加左节点（空节点不入栈） } else{//需要处理的结点 node = stack.pop(); //重新获取栈顶元素 res.add(node.val); //处理该元素，本题是放入结果之中 } } return res; } } //先序遍历，入栈顺序变成右左中 if(node.right !=null) stack.push(node.right); if(node.left != null) stack.push(node.left); // 添加左节点（空节点不入栈） stack.push(node); stack.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记,处理的顺序 //同理可以得出后序遍历入栈的顺序 层次遍历 102.二叉树的层次遍历 107.二叉树的层次遍历2 199.二叉树的右视图 429.N叉树的层序遍历 513.找树左下角的值 515.在每个树行中找最大值 559.N叉树的最大深度 637.二叉树的层平均值 111.二叉树的最小深度 层序遍历一个二叉树，就是从左到右一层一层的去遍历二叉树。 这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。 模板 层次遍历的步骤:1.对于不为空的结点，先把该结点加入到队列中2.从队中拿出结点，如果该结点的孩子结点不为空，就分别把孩子结点加入队列中3.重复上述操作直到队列为空 public class Solution{ class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } } public static void LaywerTraversal(TreeNode root){ if(root==null) return; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); TreeNode currentNode = root; queue.add(currentNode); while(!queue.isEmpty()){ currentNode=queue.poll(); System.out.println(currentNode.val); if(currentNode.left!=null){ queue.add(currentNode.left); } if(currentNode.right!=null){ queue.add(currentNode.right); } } } } 层序遍历要求我们区分每一层，也就是返回一个二维数组。而 BFS 的遍历结果是一个一维数组，无法区分每一层。可以在每一层遍历开始前，先记录队列中的结点数量n（也就是这一层的结点数量），这样就达到了分层的效果。 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { if(root == null) return new LinkedList&lt;&gt;(); LinkedList&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); //借助队列 Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); TreeNode currentNode = root; queue.add(currentNode); while(!queue.isEmpty()){ List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); int size = queue.size(); //可以在每一层遍历开始前，先记录队列中的结点数量n，达到分层的效果 for(int i =0; i&lt; size;i++){ currentNode=queue.poll(); list.add(currentNode.val); if(currentNode.left!=null){ queue.add(currentNode.left); } if(currentNode.right!=null){ queue.add(currentNode.right); } } res.add(list); } return res; } } 二叉搜索树二叉搜索树是一个有序树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉搜索树 所以二叉搜索树递归遍历和迭代遍历和普通二叉树都不一样。 特点：1.在中序遍历下，输出的二叉搜索树结点的数值是有序序列。可以利用这个来判断是否是二叉搜索树2.二叉搜索树中不能有重复的元素。3.最左边的就是最小的4.遇到在二叉搜索树上求最值、差值之类的，就把它想成在一个有序数组上求最值，求差值，这样就简单多了。 针对BST的遍历框架 void BST(TreeNode root,int target){ if(root.val == target){ //找到目标进行访问操作 } if(root.val &lt; target){ BST(root.right,target); } if(root.val &gt; target){ BST(root.left,target); } } 总结1.如果当前节点会对下面的子节点有整体影响，可以通过辅助函数增长参数列表，借助参数传递信息。2.一定要利用二叉搜索树中序遍历的特点，数组从小到大，反过来逆中序遍历，数组就是从大到小]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[129.求根到叶子节点数字之和]]></title>
    <url>%2F2020%2F11%2F15%2F129.%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目 给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。 例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。 计算从根到叶子节点生成的所有数字之和。 说明: 叶子节点是指没有子节点的节点。 示例 1: 输入: [1,2,3] 1 / \ 2 3 输出: 25 解释: 从根到叶子节点路径 1-&gt;2 代表数字 12. 从根到叶子节点路径 1-&gt;3 代表数字 13. 因此，数字总和 = 12 + 13 = 25. 输入: [4,9,0,5,1] 4 / \ 9 0 / \ 5 1 输出: 1026 解释: 从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495. 从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491. 从根到叶子节点路径 4-&gt;0 代表数字 40. 因此，数字总和 = 495 + 491 + 40 = 1026. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sum-root-to-leaf-numbers著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 根据二叉树的特点,往往都可以利用递归解决。 可以从两个示例中看出一点规律，从上往下看，每个节点都对应一个数字 = 其父节点对应的数字乘以10再加上该节点的值（这里假设根节点的父节点对应的数字是0）比如示例2的9这个结点，代表的就是 4*10+9 = 49;当到结点5时，它是一个叶子结点，490+5 = 495,这时候可以与总数开始相加了。所以遍历时，不仅需要当前指向的结点值，还需要父节点代表的值。 这个就可以使用DFS,因为是数字的累加，所以递归遍历的时候不需要返回值，直接把sum累加就行。 代码 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { int sum = 0; public int sumNumbers(TreeNode root) { childNumbers(root,0); return sum; } public void childNumbers(TreeNode root,int parentNumbers){ if(root == null){ return; } //当前结点代表的值 int k = root.val + parentNumbers*10; if(root.left == null &amp;&amp; root.right == null){ //说明到叶子结点了 sum += k; return; } childNumbers(root.left,k); childNumbers(root.right,k); } }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[328.奇偶链表]]></title>
    <url>%2F2020%2F11%2F13%2F328.%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。 请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。 示例 1: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL示例 2: 输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL说明: 应当保持奇数节点和偶数节点的相对顺序。链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/odd-even-linked-list著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 链表的题最好画图分析 1.奇数结点在前，偶数结点在后2.用两个指针，一个指向奇数结点，一个指向偶数结点3.奇数指针要停在最后一个奇数结点，因为需要和偶数结点拼接4.分别处理时断链了，但是发现可以借助奇偶指针，找到下一个位置 代码 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode oddEvenList(ListNode head) { if(head == null || head.next== null){ return head; } ListNode even = head.next , odd = head; ListNode evenHead = even; //奇数指针需要留在最后一个基数结点 while(even != null &amp;&amp; even.next != null){ //奇数 odd.next = even.next; odd = odd.next; //偶数 even.next = odd.next; even =even.next; } odd.next = evenHead; return head; } }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[922.按奇偶排序数组2]]></title>
    <url>%2F2020%2F11%2F12%2F922.%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%842%2F</url>
    <content type="text"><![CDATA[题目 给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。 对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。 你可以返回任何满足上述条件的数组作为答案。 示例： 输入：[4,2,5,7] 输出：[4,5,2,7] 解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sort-array-by-parity-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 利用一个新的数组，用even记录偶数下标，odd记录奇数下标，循环目标数组依次把原数组的元素按要求放到新数组之中。 代码 public int[] sortArrayByParityII(int[] A) { int length = A.length; int [] B = new int [length]; int even = 0 , odd = 1; //记录偶数和基数开始的位置 for(int i=0 ; i&lt;length ;i++){ if(A[i] %2 == 0){ //说明是偶数 B[even] = A[i]; even += 2; } else{ B[odd] = A[i]; odd += 2 ; } } return B; } 其他解法 1.循环2.找到偶数位置上不符合条件的元素3.一定会有个奇数位置上不符合条件的元素与其匹配，找到这个元素4.进入下一次循环 双指针法 public int[] sortArrayByParityII(int[] A) { int length = A.length; int even = 0, odd = 1; while(even&lt;length){ //出错的A[even] if(A[even] % 2 !=0 ){ //寻找与其匹配的奇数 while(A[odd]%2 !=0){ odd = odd + 2; } //找到了交换 int temp = A[even]; A[even] = A[odd]; A[odd] = temp ; } even = even + 2; } return A; }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day11-142.环形链表2]]></title>
    <url>%2F2020%2F11%2F11%2F142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82%2F</url>
    <content type="text"><![CDATA[题目 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。 示例： 示例1 输入：head = [3,2,0,-4], pos = 1 输出：返回索引为 1 的链表节点 解释：链表中有一个环，其尾部连接到第二个节点。 示例2 输入：head = [1,2], pos = 0 输出：返回索引为 0 的链表节点 解释：链表中有一个环，其尾部连接到第一个节点。 示例3 输入：head = [1], pos = -1 输出：返回 null 解释：链表中没有环。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/linked-list-cycle-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 哈希法 遍历整个链表，如果当前的结点不在哈希表中则添加之后继续遍历，如果在哈希表中,那么当前的结点就是环的入口结点。 时间复杂度：O(N)空间复杂度：O(N) 新建一个哈希表 快慢指针法 思路见链表笔记 代码 public ListNode detectCycle(ListNode head) { ListNode fast = head,slow = head; //排除空链和只有一个结点 while (fast != null &amp;&amp; fast.next != null) { fast = fast.next.next; slow = slow.next; //先判断有没有环，在某个位置会相遇 if(slow == fast){ while (head != slow) { //两相遇指针，一个从头结点开始， head = head.next; slow = slow.next; } return slow; } } return null; }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[160.相交链表]]></title>
    <url>%2F2020%2F11%2F10%2F160.%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表： 题目 在节点 c1 开始相交。 注意：如果两个链表没有交点，返回 null.在返回结果后，两个链表仍须保持原有的结构。可假定整个链表结构中没有循环。程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/intersection-of-two-linked-lists著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 相交的问题，想到了快慢指针，有两个指针，指向A链表的pA,指向B链表的pB。 通过走过的总路程一样的办法，假设A自己独有的部分为a，B独有的部分为b，AB共有的部分为c。那么a+c +b = b+c +a。 若相交，在C处相交若不相交，a + b = b+ a, C点为null 代码 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if(headA == null||headB == null){ return null; } ListNode pA = headA,pB = headB; while(pA != pB){ pA = pA == null? headB : pA.next; pB = pB == null? headA : pB.next; } return pA; } }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[109.有序链表转换二叉搜索树]]></title>
    <url>%2F2020%2F11%2F10%2F109.%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例: 给定的有序链表： [-10, -3, 0, 5, 9], 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 找中间结点作为根结点，中间结点的左边链表又使中间结点为根节点，依次递归。左边链表变成一颗平衡二叉树后，作为根结点的左子树。右边链表同样的处理作为根结点的右子树。 找中间结点需要用到快慢指针，把链表转换成平衡二叉树时考虑用递归。 找中间结点的方法 //获取到中间结点 ListNode centerNode(ListNode head){ ListNode slow = head,fast = head; while(fast!=null &amp;&amp; fast.next != null){ //快指针走两步 fast = fast.next.next; //慢指针走一步 slow = slow.next; } return slow; } 代码 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode sortedListToBST(ListNode head) { if (head == null) return null; //开始的时候尾结点没有任何影响 return dfs(head,null); } //链表变成平衡二叉树 TreeNode dfs(ListNode head,ListNode tail){ if (head == tail) return null; ListNode mid = centerNode(head,tail); TreeNode cur = new TreeNode(mid.val); cur.left = dfs(head,mid); cur.right = dfs(mid.next,tail); return cur; } //获取到中间结点 ListNode centerNode(ListNode head,ListNode tail){ ListNode slow = head,fast = head; while(fast!= tail &amp;&amp; fast.next != tail){ //快指针走两步 fast = fast.next.next; //慢指针走一步 slow = slow.next; } return slow; } } centerNode和dfs的形参列表一样，里面的代码也互相不干扰，也可以合并成一个函数。]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[61.旋转链表]]></title>
    <url>%2F2020%2F11%2F08%2F61.%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目 定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2 输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL 解释: 向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL 向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL 输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4 输出: 2-&gt;0-&gt;1-&gt;NULL 解释: 向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL 向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL 向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL 向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/rotate-list著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 先连成一个循环链表，需要找到尾结点的位置，然后再根据k找断链的位置 代码 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode rotateRight(ListNode head, int k) { //用于记录链表的长度 int length = 0 ; //辅助的指针 ListNode p = head; //head不能是个空链表 if(head == null){ return head; } //找到了最后一个结点, while(p.next != null){ length++; p = p.next; } //此时的head指向了最后一个结点，长度加上最后一个结点的 length++; //开始断链 k%length, k = length - k % length -1 ; //成环 p.next = head; //寻找断链的结点 while(k-- &gt; 0){ head = head.next; } //p为返回的头指针 p = head.next; //断链 head.next = null; return p; } }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[110.平衡二叉树]]></title>
    <url>%2F2020%2F11%2F08%2F110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目 给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1 思路 1.终止条件(基线条件)是什么? 树为空的时候 2.应该返回什么？ 它是一个平衡二叉树需要满足三个条件：它的左子树是平衡二叉树，它的右子树是平衡二叉树，它的左右子树的高度差不大于1。换句话说：如果它的左子树或右子树不是平衡二叉树，或者它的左右子树高度差大于1，那么它就不是平衡二叉树。 这里我们返回的信息应该是既包含子树的深度的int类型的值，又包含子树是否是平衡二叉树的boolean类型的值。 可以定义一个单独的ReturnNode类 ``` class ReturnNode{ boolean isB; int depth; //构造方法 public ReturnNode(int depth,boolean isB){ this.isB = isB; this.depth = depth; } } ``` 3.本级递归应该做什么？递归的目的是什么？ 目前树有三个节点：root，left，right。我们首先判断left子树和right子树是否是平衡二叉树，如果不是则直接返回false。再判断两树高度差是否不大于1，如果大于1也直接返回false。否则说明以root为节点的子树是平衡二叉树，那么就返回true和它的高度。 代码 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { class ReturnNode{ boolean isB; int depth; //构造方法 public ReturnNode(int depth,boolean isB){ this.isB = isB; this.depth = depth; } } //主函数 public boolean isBalanced(TreeNode root) { return isBST(root).isB; } public ReturnNode isBST(TreeNode root){ if(root == null){ return new ReturnNode(0, true); } ReturnNode left = isBST(root.left); ReturnNode right = isBST(root.right); if(left.isB == false || right.isB == false){ return new ReturnNode(0, false); } if(Math.abs(left.depth - right.depth) &gt; 1){ return new ReturnNode(0, false); } return new ReturnNode(Math.max(left.depth,right.depth)+1,true); } }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[104.求二叉树的最大深度]]></title>
    <url>%2F2020%2F11%2F07%2F104.%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]， 3 / \ 9 20 / \ 15 7返回它的最大深度 3 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 1.终止条件(基线条件)是什么? 什么时候递归结束，树为空的时候，此时树的深度为0,返回0，递归就结束了。 2.应该返回什么？ 题目求的是树的最大深度，我们需要从每一级得到的信息应该是这一级对应的树的最大深度，返回值应该是的最大深度。 3.本级递归应该做什么？递归的目的是什么？ 首先，还是强调要走出之前的思维误区，递归后我们眼里的树一定是这个样子的，看下图。本级递归就三个节点：root、root.left、root.right，其中根据第二步，root.left和root.right分别记录的是root的左右子树的最大深度。那么本级递归应该做什么就很明确了，自然就是在root的左右子树中选择较大的一个，再加上1就是以root为根的子树的最大深度了，然后再返回这个深度即可。 代码 class Solution { public int maxDepth(TreeNode root) { int max = 0; if(root == null){ return 0; } int leftDepth = maxDepth(root.left); int rightDepth = maxDepth(root.right); max = Math.max(leftDepth,rightDepth) + 1; return max; } }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[note-递归]]></title>
    <url>%2F2020%2F11%2F07%2Fnote-%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[递归是一个很好理解的概念,但是每次自己写的时候老是写不出来,无意中发现了这篇文章,这里记录下阅读笔记。 递归是一个反复调用自身的过程，说明它每一级的功能都是一样的，只需要关注一级递归的解决过程。 如图所示，只需要关注一级的A就行了。需要将一个大规模问题划分成一个个小规模问题。 需要知道的三个点 1.整个递归的终止条件(基线条件):递归应该在什么时候结束？2.找返回值:应该给上一级返回什么信息?3.本级递归应该做什么:在这一级递归中，应该完成什么任务? 另外版本的三个问题 1.确定递归函数的参数和返回值：确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数，并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。2.确定终止条件：写完了递归算法,运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出3.定单层递归的逻辑：确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。 104.求二叉树的最大深度1.终止条件(基线条件)是什么? 什么时候递归结束，树为空的时候，此时树的深度为0,返回0，递归就结束了。 2.应该返回什么？ 题目求的是树的最大深度，我们需要从每一级得到的信息应该是这一级对应的树的最大深度，返回值应该是的最大深度。 3.本级递归应该做什么？递归的目的是什么？ 首先，还是强调要走出之前的思维误区，递归后我们眼里的树一定是这个样子的，看下图。本级递归就三个节点：root、root.left、root.right，其中根据第二步，root.left和root.right分别记录的是root的左右子树的最大深度。那么本级递归应该做什么就很明确了，自然就是在root的左右子树中选择较大的一个，再加上1就是以root为根的子树的最大深度了，然后再返回这个深度即可。 代码 跟着这个作者的思路写了一下代码,快要感动哭了,第一次写递归写的如此的清晰容易。 class Solution { public int maxDepth(TreeNode root) { int max = 0; if(root == null){ return 0; } int leftDepth = maxDepth(root.left); int rightDepth = maxDepth(root.right); max = Math.max(leftDepth,rightDepth) + 1; return max; } } 24.两两交换链表中的结点思路 1.终止条件(基线条件)是什么? 什么时候递归结束，没有可以交换的结点就结束递归，也就是只剩下一个结点或者没有结点的时候。 2.应该返回什么？ 本题的目的是两两交换结点，那么本级递归应该向上一级返回交换好的链表，这里返回指向交换好链表的指针。 3.本级递归应该做什么？递归的目的是什么？ 因为返回值是交换好的链表，所以结合第二步，只考虑本级递归，这个链表在我们眼中其实就三个结点：head、head.next、已处理好的链表部分。 因为前一级递归返回过来的是已经处理好的链表部分，也就是图中的第三个部分，在交换图中的前两个结点时，交换后需要连接上第三个部分，所以这里需要看见的是三个结点。 代码 class Solution { public ListNode swapPairs(ListNode head) { if(head == null || head.next == null){ return head; } //下面的任务便是交换这3个节点中的前两个节点 ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } } 110.平衡二叉树给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1 思路 1.终止条件(基线条件)是什么? 树为空的时候 2.应该返回什么？ 它是一个平衡二叉树需要满足三个条件：它的左子树是平衡二叉树，它的右子树是平衡二叉树，它的左右子树的高度差不大于1。换句话说：如果它的左子树或右子树不是平衡二叉树，或者它的左右子树高度差大于1，那么它就不是平衡二叉树。 这里我们返回的信息应该是既包含子树的深度的int类型的值，又包含子树是否是平衡二叉树的boolean类型的值。 可以定义一个单独的ReturnNode类 ``` class ReturnNode{ boolean isB; int depth; //构造方法 public ReturnNode(int depth,boolean isB){ this.isB = isB; this.depth = depth; } } ``` 3.本级递归应该做什么？递归的目的是什么？ 目前树有三个节点：root，left，right。我们首先判断left子树和right子树是否是平衡二叉树，如果不是则直接返回false。再判断两树高度差是否不大于1，如果大于1也直接返回false。否则说明以root为节点的子树是平衡二叉树，那么就返回true和它的高度。 代码 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { class ReturnNode{ boolean isB; int depth; //构造方法 public ReturnNode(int depth,boolean isB){ this.isB = isB; this.depth = depth; } } //主函数 public boolean isBalanced(TreeNode root) { return isBST(root).isB; } public ReturnNode isBST(TreeNode root){ if(root == null){ return new ReturnNode(0, true); } ReturnNode left = isBST(root.left); ReturnNode right = isBST(root.right); if(left.isB == false || right.isB == false){ return new ReturnNode(0, false); } if(Math.abs(left.depth - right.depth) &gt; 1){ return new ReturnNode(0, false); } return new ReturnNode(Math.max(left.depth,right.depth)+1,true); } }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[note-链表]]></title>
    <url>%2F2020%2F11%2F07%2Fnote-%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表的结构单链表:结点有一个指针域的链表双链表:结点有两个指针域的链表，双向链表的本质就是空间换时间，因此如果题目对时间有要求，可以考虑使用双向链表，循环链表:首尾相接的链表，当我们需要在遍历到尾部之后重新开始遍历的时候，可以考虑使用循环链表。 头指针:执行链表中第一个结点的指针。首元结点:链表中存储第一个数据元素va1的结点。头结点:链表首元结点之前的一个结点,往往不存储元素，作为附加结点。 头结点 1.如何表示空表? 无头结点,头指针为空时表示空表 head == null有头结点,当头结点的指针域为空时表示空表 head.next == null 2.头结点的好处? 便于首元结点的处理 首元节点的地址保存在头结点的指针域中，所以链表的第一个位置上的操作和其他位置一致，不需要进行特殊处理。便于空表和非空表的统一处理 3.头结点的数据域内装什么？ 可以为空，也可以存放线性表的长度等附加信息。但此结点在统计表长时不算入。 链表的基本操作链表节点的定义 public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } 判断链表是否为空 boolean ListEmpty(ListNode head){ return head.next == null } 单链表的销毁 从头指针开始，依次释放所有的结点，包括了头结点。 while(L){ //需要辅助结点p，p指向要销毁的结点 P = L; L = L.next ; //Java中有垃圾回收机制,p = null delete p ; } 清空链表 链表仍存在，但链表中无元素，成为空链表，头指针和头结点仍然在。 //P从首元结点开始 p = L.next; while(p){ //q指向要清除的结点的下一个结点 q = p.next; delete p ; p = q; } 结点的取值 //p指针用于寻找，从首元结点开始，count表示计数,i表示要找的第几个元素 p = L.next; count = 1; while(p &amp;&amp; count &lt; i){ P = p.next; count ++ ; } 结点的插入 这里往往需要先遍历找到结点 结点的删除 只需要将需要删除的节点的前驱指针的 next 指针修正为其下下个节点即可，注意考虑边界条件。 伪代码： 待删除位置的前驱节点.next = 待删除位置的前驱节点.next.next 链表的遍历链表是一种兼具递归和迭代性质的数据结构，树结构是链表的衍生，所以链表也有前序遍历和后序遍历。 void traverse(ListNode head){ //前序遍历 traverse(head.next); //后序遍历 } 性能分析 类型 插入/删除(时间复杂度) 查询(时间复杂度) 使用场景 数组 O(n) o(1) 数据量固定、频繁查询、较少增删 链表 O(1) O(n) 数据量不固定，频繁增删、较少查询 相交或环形链表1.判断某条链表是否存在环。2.获取某条链表环的大小。3.获取某两条链表的相交节点。 相交链表双指针法 找到两个单链表相交的起始节点。 如图所示 这种题目的重点就是 A单独的部分 + AB共有的部分 + B单独的部分 = B单独的部分 + AB共有的部分 + A单独的部分 这样一定在交点处相遇。即使没有交点，去掉AB共有的部分，等式也是成立的。 哈希法 1.有 A, B 这两条链表, 先遍历其中一个，比如 A 链表, 并将 A 中的所有节点存入哈希表。2.遍历 B 链表,检查节点是否在哈希表中, 第一个存在的就是相交节点 环形链表判断是否有环思路可以使用快慢指针法， 分别定义 fast 和 slow指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。 问题：为什么一定在环中相遇？在非环的位置，fast一定走的比slow快，所以fast一定会先进入环，然后在环中循环。slow是一步一步走的，那么在环中一定会相遇。 求环的起点哈希法 遍历整个链表，如果当前的结点不在哈希表中则添加之后继续遍历，如果在哈希表中,那么当前的结点就是环的入口结点。 时间复杂度：O(N)空间复杂度：O(N) 新建一个哈希表 快慢指针法]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[24.两两交换链表中的节点]]></title>
    <url>%2F2020%2F11%2F07%2F24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例: 输入：head = [1,2,3,4] 输出：[2,1,4,3] 输入：head = [] 输出：[] 输入：head = [1] 输出：[1] 提示：链表中节点的数目在范围 [0, 100] 内0 &lt;= Node.val &lt;= 100 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/swap-nodes-in-pairs著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 “将相邻的链表节点两两交换”，我们可以把链表两两分成若干组，在组内互换节点后再组合起来。 1.终止条件(基线条件)是什么? 什么时候递归结束，没有可以交换的结点就结束递归，也就是只剩下一个结点或者没有结点的时候。 2.应该返回什么？ 本题的目的是两两交换结点，那么本级递归应该向上一级返回交换好的链表，这里返回指向交换好链表的指针。 3.本级递归应该做什么？递归的目的是什么？ 因为返回值是交换好的链表，所以结合第二步，只考虑本级递归，这个链表在我们眼中其实就三个结点：head、head.next、已处理好的链表部分。 因为前一级递归返回过来的是已经处理好的链表部分，也就是图中的第三个部分，在交换图中的前两个结点时，交换后需要连接上第三个部分，所以这里需要看见的是三个结点。 代码 class Solution { public ListNode swapPairs(ListNode head) { if(head == null || head.next == null){ return head; } //下面的任务便是交换这3个节点中的前两个节点 ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; } }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象-类的成员]]></title>
    <url>%2F2020%2F11%2F06%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%2F</url>
    <content type="text"><![CDATA[Java类及类的成员:属性、方法、构造器;代码块、内部类面向对象的三大特征:封装性、继承性、多态性其他关键字:this、super、static、final、abstract、package、import、interface 类的成员 属性 方法 构造器 代码块 内部类 属性语法格式 修饰符 数据类型 属性名 = 初始化值; 修饰符：1.权限修饰符 private、缺省、protected、public2.其他修饰符 static、final 变量的分类 成员变量:在方法体外，类体内声明的变量 实例变量 不以static修饰 类变量 以static修饰 局部变量:在方法体内部声明的变量 形参 方法、构造器中定义的变量 方法局部变量 在方法内定义 代码块局部变量 在代码块内定义 问题1:成员变量与局部变量的区别 类型 位置 权限修饰符 默认初始化值 内存加载位置 成员变量 类的{}里 可以使用权限修饰符 根据其类型有默认初始化值 堆空间或静态域中 局部变量 方法内、方法形参、构造器内、构造器形参、代码块内 不可以使用权限修饰符,可以用final 没有默认初始化值,在调用局部变量前要显示赋值 栈空间 方法语法格式 修饰符 返回值类型 方法名 (形参列表){ 方法体程序代码; return 返回值;} 说明:1.返回类型为void时，不必使用return语句。如果使用，仅用来结束方法2.判断是否是同一个方法需要判断两个条件，方法名是否相同、形参列表是否相同。 方法的重载(overload) 同一个类中,允许存在同名方法,只要他们的参数个数或者参数类型不同。-&gt; 两同一不同:同一个类、相同方法名，参数列表不同 通过对象调用方法时，如何确定某一个指定的方法?方法名 -&gt; 参数列表(参数的个数,数据类型及顺序) Java的重载是可以包括父类和子类的,子类可以重载父类的同名不同参数的方法 方法的重写(override/overwrite) 子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作。 重写的规定： 方法声明：权限修饰符 返回值类型 方法名(形参列表) throws 异常的类型{ //方法体 } 1.子类重写继承的方法：要求方法名、形参列表要相同2.子类重写的方法权限修饰符 &gt; = 父类被重写方法权限修饰符 –&gt; 子类不能重写父类中声明为private权限的方法3.异常类型也是包含关系 子类 &lt;= 父类4.返回值类型:基本数据类型同，引用数据类型同或子类 父类void,子类void 父类返回A类型,子类A类或A类的子类 父类基本数据类型,子类相同的基本数据类型5.重写的是非static -&gt; static方法是属于类的 可变个数的形参 格式:数据类型 … 变量名 String …strs = String[] strs 使用:1.当调用可变个数形参的方法时，可以传参0,1,2…2.会与本类中方法名相同,形参不同的方法之间构成重载3.此写法类似JS的三点运算符,所有参数会被封装成一个数组4.可变个数形参在方法的形参中，必须声明在末尾5.注意如果子父类的形参分别是…strs与[]strs也会重写6.优先会调用参数列表个数确定的方法 方法参数的值传递机制-值传递基本数据类型:数据值引用数据类型:地址值(含变量的数据类型 –&gt; 用于赋值的检查) main()方法JAVA虚拟机需要调用类的main()方法，所以该方法的访问权限必须是publicJAVA虚拟机在执行main()方法时不必创建对象，所以该方法必须是静态的 main()方法的使用说明1.main()方法作为程序的入口2.main()方法是一个静态方法，通过类调用3.main()方法可以让我们与控制台交互(Scanner) java 运行文件名 传入的参数也就是main方法接收的参数 (运行时cmd传参) -&gt; java 类名 “Tom” “ranan” public static void main(String args []){ } 构造器(constructor)任何一个类都有构造器constructor,构造器与类同名 构造器的特征 1.与类名相同2.不声明返回值类型3.没有return语句，不被static、final、synchronized、abstract、native修饰 构造器的作用1.创建对象:new + 构造器2.初始化对象的信息 语法格式修饰符 类名(参数列表){ 初始化语句;} 构造器的说明1.如果没有显式的定义类的构造器,系统默认提供一个空参的构造器，空参的构造器修饰符与类的修饰符一样2.显示定义了构造器之后,系统就不提供默认的空参构造器3.一个类中定义的多个构造器,彼此构成重载4.父类的构造器不可被子类继承5.一个类中至少有一个构造器 //创建类的对象: new + 构造器 Person p = new Person() class Person{ //属性... //构造器 public Person(){ } //方法... } JavaBeanJavaBean是Java语言写成的可重用组件JavaBean其实就是指符合如下标准的Java类:①类是公共的②有一个无参的公共的构造器③有属性,且有对应的get、set方法 代码块1.代码块用来初始化类、对象，不用调用即可执行。2.代码块如果有修饰符，那么只能是static修饰符，所以代码块分为静态代码块static{}与非静态代码块{} 静态代码块随着类的加载而执行，初始化类的信息，只执行一次。 非静态代码块随着对象的创建而执行，可以在创建对象时，对对象的属性等进行初始化，每次创建对象的时候都会执行一次，且先于构造器执行。 非静态代码块是在堆中的,每new一次开辟一个新空间执行一次非静态代码块。 执行顺序 执行顺序：由父及子，静态先行 知识点1:因为继承，子类加载前要加载父类的所有信息知识点2:代码块执行先于构造器 存疑:非静态代码块的执行随着构造器的执行而执行??? class Father { static { System.out.println(&quot;1&quot;); } { System.out.println(&quot;2&quot;); } public Father() { System.out.println(&quot;3&quot;); } } public class Son extends Father { static { System.out.println(&quot;4&quot;); } { System.out.println(&quot;5&quot;); } public Son() { System.out.println(&quot;6&quot;); } public static void main(String[] args) { // 由父及子 静态先行 System.out.println(&quot;7&quot;); new Son(); } } /* main方法也是静态方法，需要类去调 此例中是通过Son.main调用，先需要加载Son 因为继承，子类加载前要加载父类的所有信息 son -&gt; father-&gt;Object 跟着继承链往上找，Object加载完毕，加载father，静态代码块执行，父类加载完毕son类加载，静态代码块执行，然后才是Son.main的调用输出7，然后执行new Son() 1.输出1 2.输出4 3.输出7 执行new Son() 找子类的构造器，先执行super()继承父类的构造器，父类的构造器继承Object的构造器，Object的构造器执行完毕后，由于代码块先于构造器，所以父类的非静态代码块执行，再执行父类的构造器，此时子类继承父类完毕，执行自己的非静态代码块，再执行构造器初始化对象。 4.输出2 5.输出3 6.输出5 7.输出6 */ 属性的赋值顺序1.默认初始化2.显示初始化/在代码块中赋值3.构造器中初始化 内部类允许一个类的定义位在另一个类的内部，前者称为内部类，后者称为外部类。内部类一般用在定义它的类或语句块之内，在外部引用它时必须给出完整的名称，内部类的名字不能与包含它的外部类类名相同。 内部类的分类成员内部类(作为类的成员,可以用static修饰)局部内部类(方法内、代码块内、构造器内) 成员内部类成员内部类: 1.作为外部类的成员 1.1调用外部类的结构 外部类名.this.xxx 1.2可以被static、private修饰-&gt; 外部类不可以 2.作为一个类: 2.1可以定义属性、方法、构造器等 2.2可以被final修饰，表示此类不能被继承 2.3可以被abstract修饰，表示此类不能被实例化 2.4编译以后生成OuterClass$InnerClass.class字节码文件（也适用于局部内部类）- 外部类$内部类名.class 注意：1.非static的成员内部类中的成员不能声明为static，只有在外部类或static的成员内部类中才可声明static成员。2.外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式 1.如何实例化成员内部类的对象 静态成员内部类: 外部类名.内部类名 对象名 = new 外部类名.内部类名(); 非静态成员内部类: new一个外部类的实例，外部类名.内部类名 对象名 = 外部类实例.new 内部类名() 2.如何在成员内部类中区分调用外部类的结构 外部类名.this.xxx 局部内部类1.如何声明局部内部类 class 外部类{ 方法1(){ class 局部内部类{//方法2} } { class 局部内部类() } } 在局部内部类的方法2中，如果调用方法1中的局部变量，要求此局部变量声明为final(从内部类与类生成两个字节码文件角度思考) 2.局部内部类的特点2.1内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但 是前面冠以外部类的类名和$符号，以及数字编号。2.2只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方 都不能使用该类。2.3局部内部类可以使用外部类的成员，包括私有的。2.4局部内部类可以使用外部方法的局部变量，但是必须是final的。由局部内部类和局部变量的声明周期不同所致。2.5局部内部类和局部变量地位类似，不能使用public,protected,缺省,private2.6局部内部类不能使用static修饰，因此也不能包含静态成员 匿名内部类格式 new 父类构造器(实参列表) | 实现接口(){ //匿名内部类的类体部分} 匿名内部类不能定义任何静态成员、方法和类，只能创建匿名内部类的一个实例。匿名内部类必须继承父类或实现接口。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象-三大特征]]></title>
    <url>%2F2020%2F11%2F06%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%2F</url>
    <content type="text"><![CDATA[面向对象的特点封装与隐藏为什么需要封装性？设计程序追求”高内聚，低耦合”高内聚:类的内部数据操作细节自己完成，不允许外部干涉低耦合:仅对外暴露少量的方法用于使用 隐藏对象内部的复杂性，只对外公开简单的接口，便于外界调用，从而提高系统的可扩展性、可维护性。 封装性的体现 1.将类的属性私(xx)有化(private),提供公共的(public)方法来获取(getxx)和设置(setxx)该私有属性2.不对外暴露的私有方法3.单例模式(将构造器私有化) 封装性的体现，需要权限修饰符来配合封装性:Java提供了4种权限修饰符来修饰类及类的内部结构，体现其在被调用时的可见性大小 权限修饰符1.权限从小到大 private &lt; 缺省 &lt; protected &lt; public2.4种权限可以用来修饰类的内部结构:属性、方法、构造器、内部类3.对于class的权限修饰只可以用public和default(缺省) 修饰符 类内部 同一个包 不同包的子类 同一个工程 private Yes - - - (缺省) Yes Yes - - protected Yes Yes Yes - public Yes Yes Yes Yes 不同包下的普通类(非子类)不能调用声明为private、缺省、protected权限的属性 继承性public class Student extend Person{ //与Person重复的就不用写的 } 继承性的好处1.减少了代码的冗余，提高了代码的复用性2.便于功能的扩展3.为多态性的使用提供前提 子类继承父类后，子类中就获取了父类中声明的所有的属性和方法。特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私的结构。只因为封装性的影响，使得子类不能直接调用父类的结构而已。 Object类Java.lang.Object类是所有类(除Object类本身)的祖先类1.Object类只声明了一个空参的构造器2.数组也作为 Object类的子类出现，可以调用 Object类中声明的方法 Java.lang.Object类中定义的一些方法:public boolean equals(Object obj) 对象比较public int hashCode() 获取Hash码public String toString() 对象打印时调用 equals(Object obj)方法 只适用于引用数据类型，比较的是地址值Object类中equals()定义的方法和==作用是相同的 public boolean equals(Object obj){ return (this == obj) } 说明1.String、Date、File、包装类等都重写了Object类中的equals()方法，比较的两个对象的实体类容是否相同2.通常情况下，自定义的类如果使用equals()方法，也会比较对象的实体类容是否相同，所以可以重写equals()方法 //手写版本, class Customer{ public boolean equals(Object obj){ //利用了多态性，形参是object，实参其实大多数时候是object的子类 if(this == obj){ return true } if(obj instanceof Customer){ //父类没办法看见子类独有的方法 //确定该Object子类也是Customer的实例 //Customer是父类,转换了后父类可以调用子类的特有方法用于比较 Customer cust = (Customer)obj //比较两个对象的每个属性是否相同 .... } //自动生成的版本 @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Person other = (Person) obj; if (age != other.age) return false; if (name == null) { if (other.name != null) return false; } else if (!name.equals(other.name)) return false; return true; 特殊：String类型在常量池,重新定义一个变量时，若在常量池中发现有内容一样的字符串，会直接把该字符串的地址赋值给该变量。new String()方法创建的字符串除外 toString()方法 1.当我们打印一个引用对象时,实际上就是调用当前对象的toString(),输出地址2.Object类中toString()的定义: public String toString(){ return getClass().getName() + &quot;@&quot; + Integer.toHexString((hashCode)); } 3.String、Date、File、包装类等都重写了Object类中的toString()方法，返回”实体内容”信息 特例： String s = &quot;abc&quot;; s = null ; System.out.println(s) //null System.out.println(s.toString) //出现空指针异常 多态性对象的多态性:父类的引用指向子类的对象编译时和运行时类型不一致，产生了多态 多态性的使用前提1.类的继承关系2.方法的重写 多态的使用(虚拟方法调用) 1.当调用子父类同名同参数的方法时,在编译期,只能调用父类中声明的方法,但在运行期,我们实际执行的是子类重新父类的方法2.对象的多态性只适用与方法,不适用于属性 —&gt; 属性不会被重写,若同名则在内存中会出现两个。使用的时候声明的是什么类型使用的就是什么类型的属性。(属性编译和运行都看左边) 虚拟方法调用方法编译时看左边,运行时看右边,编译的时候以为调用的是父类的方法,实际调用的是子类的方法。 不能调用子类所特有的方法，编译时，该实例是父类的。 多态是运行时行为,父类动态调用属于子类的方法，在编译时是无法确定调用的是哪一个子类的方法，所以是运行时行为。(动态绑定) class Animal{ protected void eat(){ ... } } class Cat extends Animal{ protected void eat(){ ... } } class Dog extends Animal{ protected void eat(){ .. } } public class Test{ public static Animal get(int key){ switch(key){ case 0: return new Cat(); case 1： return new Dog(); } } public static void main(String[] args){ int key = new Random().nextInt(2); Animal animal = get(key); animal.eat(); } } 向下转型向上转型:多态 前提:存在子父类关系目的:使用子类的特定方法 有了多态性以后，内存中实际上是加载了子类的属性和方法，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。(编译器看不见) // 调用子类特有属性和方法 //p的地址值指向new出来的空间，编译时实例是属于person类的，编译器只看的Person的属性和方法 Person p = new Man() Person p1 = new Woman() //把p的地址赋值给m1，由于m1是Man类型，所以看得见Man特有的属性和方法 Man m1 = (Man)p Object o = new Man() //o可以转到Man的父类,最低可转换到Man 使用强转时，可能出现ClassCaseException的异常。可以先用instanceof关键字判断一下再向下转型。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java关键字]]></title>
    <url>%2F2020%2F11%2F06%2FJava%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[权限修饰符:private 缺省 protected public -&gt; 封装性修饰符:static \ final \ abstact \ native 权限修饰符1.权限从小到大 private、缺省、protected、public2.4种权限可以用来修饰类的属性、方法、构造器、内部类3.对于class的权限修饰只可以用public和default(缺省);public类可以在任意地方被访问,default类只可以被同一个包内部的类访问 修饰符 类内部 同一个包 不同包的子类 同一个工程 private Yes - - - (缺省) Yes Yes - - protected Yes Yes Yes - public Yes Yes Yes Yes 不同包下的普通类(非子类)不能调用声明为private、缺省、protected权限的属性 return1.使用在方法体中，用于结束方法与返回数据2.return关键字后面不可以声明执行语句3.在异常处理中try-catch-finally的结构中，如果try/catch的结构中写了return，但是finally中的结构仍会执行 thisthis指向当前实例,可以理解为当前对象。 this可以调用:属性、方法、构造器 在类的方法中,我们可以使用’this.属性’或’this.方法’的方式,调用当前对象属性或方法,通常会省略’this.’，但如果方法的形参和类的属性同名时,必须显示用”this.变量”来表明是属性。 this还可以用来调用构造器,在构造器中通过使用”this(形参列表)”来调用其他不同的构造器，最多只能有一个。”this(形参列表)”必须声明在当前构造器的首行 public Person(){ //... } public Person(String name){ this(); //调用空参,通过传不同类型的参数调用其他不同的构造器 } supersuper理解为父类的 super可以调用属性、方法、构造器 this与super都是解决子类父类成员重名时，用谁的问题 super的使用1.子类重写父类的方法后,想使用父类的原方法可以使用super2.super(形参列表)的形式调用父类中的构造器,必须声明在子类构造器的首行3.构造器首行没有显示声明this(形参列表)或super(形参列表),默认调用的super() 子类对象的实例化过程从结果上来看(继承性): 子类继承父类以后,就获取了父类中声明的属性或方法 创建子类的对象,在堆空间中,就会加载所有父类中声明的属性从过程上来看: 通过子类的构造器创建子类对象时，最先会直接或间接调用其父类的构造器(super在第一行)，直到调用到java.lang.Object类中空参的构造器为止,在调用自己的构造器。 明确:虽然创建子类对象时,调用了父类的构造器但没有new,所以只创建了一个new子类出来的对象。 package1.为了更好的实现项目中类的管理提供包的概念2.使用package声明类或接口所属的包，声明在源文件的首行3.包属于标识符，遵循标识符的命名规则、规范(都小写)4.每’.’一次，就代表一层文件目录 补充:同一个包下，不能命名同名的接口、类;不同的包下，可以命名同名的接口、类 MVC设计模式MVC将整个程序分成视图模式层(view)、控制器层(controller)、数据模型层(model)三层 模型层 model 主要处理数据数据对象封装 model.bean/domain数据库操作类 model.dao数据库 model.db 视图层 view 显示数据相关工具栏 view.utils自定义view view.ui 控制层 controller 处理业务逻辑应用界面相关 controller.activity存放fragment controller.fragment显示列表的适配器 controller.adapter服务相关 controller.service抽取的基类 controller.base import1.导入指定包下的类、接口(导入所有用通配符)2.声明在包声明和类声明之间3.使用是的本包或者java.lang包(包含一些Java语言的核心类)下的，则可以省略import结构，用其他包的内容都要引用4.在源文件中使用了不同包下的同名类，至少一个类以全类名的方式使用(包名.类 …)5.如果’xxx.‘方式表明可以调用xxx包下的所有结构(仅一层)，但是如果使用的是xxx的子包仍然需要显示调用 –&gt; 只要跨包就要import6.import static 导入指定类或接口中的静态结构 -&gt; import 落脚点是类或接口，import static 落脚点是类中的静态结构 static引入：编写一个类(无static)时，实际在描述其对象的属性和行为，而并没有产生实质上的对象，只有通过new关键字才会分配内存空间给对象，其方法才可以被外部调用。有时候希望无论是否产生了对象或无论产生了多少对象的情况下，某些特定的数据在内存空间里只有一份，所有对象共享。 说明:1.static主要用来修饰类的内部结构:属性、方法、代码块、内部类2.static修饰属性 -&gt; 静态变量/类变量 属性按是否使用static修饰分为 静态属性 VS 非静态属性(实例变量) 类的多个对象共享同一个静态变量 静态变量随类的加载而加载早于对象的创建，由于类只加载一次(缓存在方法区)所以静态变量在内存中只会存在一份存在方法区的静态域中 (方法区:类的加载信息、静态域、常量池)3.使用static修饰方法 -&gt; 静态方法 (从生命周期思考) 静态方法随类的加载而加载,此时还没有对象，所以静态方法中不能使用this和super。 静态方法中只能调用静态方法或静态属性 ，非静态方法中，既可以调用非静态的也可以调用静态的 总结 静态方法/类变量 非静态方法/实例变量 类 yes no 对象 yes yes instanceof语法: a instanceof A 判断对象a是否是类A的实例(间接的也行)返回值：是返回true,不是返回false说明：1.要求a所属的类与类A必须是父子类关系，否则编译会出错。 finalfinal可以用来修饰的结构:类、方法、变量 1.final用来修饰类 此类不能被其他类继承，比如：String类、System类、StringBuffer类…2.final修饰方法 此方法不可以被重写3.final修饰变量 final修饰属性，可以赋值的位置:显示初始化，代码块中初始化、构造器中初始化 final修饰局部变量，修饰形参时仅能使用不能修改 如果希望每个对象final修饰的属性值不一样，可以在构造器中赋值static可以与final同时使用,称为全局常量。 abstract抽象类有时候将父类设计得非常抽象，以至于它没有具体的实例仅用于继承，这样的类叫做抽象类。 abstract可以用来修饰类、方法 1.abstract修饰类:抽象类 不可以被实例化 抽象类中一定要有构造器，便于子类实例化时调用2.abstract修饰方法:抽象方法 方法没有方法体,只有方法声明(大括号也没有)，不可以被调用 包含抽象方法的类一定是抽象类，因为抽象方法不可以被调用，如果类不是抽象类，被实例化之后就可以被对象调用。 若子类重写了父类中的所有抽象方法后，可以实例化;否则子类必须也是抽象方法。 抽象类使用说明:1.abstract不能用来修饰私有方法，因为私有方法不能被重写；也不能用来修饰静态方法，静态方法在静态域中只有一份，可以说修改，但不能说是重写(覆盖);也不能用来修饰跟着final的方法、final的类。 创建抽象类的匿名子类对象 //Person是一个抽象类 //创建一个匿名子类的对象p //父类的引用指向了子类，多态性 Person p = new Person(){ //Person的子类，需要对抽象方法进行重写 //这个子类没有名字 } 接口interfaceJava不支持多重继承，接口可以实现多重继承。 接口的使用：1.Java中接口与类是并列的结构2.定义接口 -&gt; 定义接口中的成员 JDK7及以前，只能 全局常量:public static final 抽象方法:public abstract JDK8还可以定义 静态方法：public static,只能接口来调用 默认方法: public default 类优先原则 如果实现类继承父类和实现的接口中声明了同名同参数的默认方法，那么子类在没有重写此方法的情况下，默认调用的是父类的该方法。 3.接口中不能定义构造器，意味着接口不可以实例化4.Java开发中,接口通过让类去实现(implements)的方式来使用 如果实现类覆盖(实现)了接口中的所有抽象方法，则此实现类就可以实例化 如果实现了没有覆盖覆盖(实现)接口所有的抽象方法，则此实现类为抽象类(加上abstract) JDK8 默认方法，可以通过接口名.super.方法名调用 5.Java类可以实现多个接口 –&gt; 弥补Java单继承性的局限性格式:class AA extends BB implements CC,DD 如果继承的接口中有同名同参的默认方法，实现类需要重写该方法，不然会报错 6.接口与接口之间可以多继承7.接口的具体使用，体现了多态性(形参为接口，实参为实现类)8.接口实际上可以看作一种规范 接口的主要用途就是被实现类实现 -&gt; 面向接口编程 interface Flyable{ //全局常量 public static final MAX_SPEED = 7000; //也可以省略不写 int MIN_SPEED = 1; //抽象方法 public abstrat void fly(); //也可以省略 void stop(); } class Plane implements Flyable{ } 创建接口匿名实现类的对象 //USB是接口 //匿名实现类{} //USB接口的引用指向了实现类的对象 //实现类的实例p USB phone = new USB(){ //实现类关于接口的抽象方法重写 } 接口的应用:代理模式(proxy) 利用一个类(代理类)去控制另外一个类(被代理类)，不暴露被代理类的方法，通过代理类方法的调用从而间接调用被代理类的方法。 /* * 接口的应用：代理模式 * */ public class NetWorkTest { public static void main(String[] args) { Server server = new Server(); ProxyServer proxyServer = new ProxyServer(server); proxyServer.browse(); } } interface NetWork{ public void browse(); } //被代理类 class Server implements NetWork{ @Override public void browse() { System.out.println(&quot;真实的服务器访问网络&quot;); } } //代理类 class ProxyServer implements NetWork{ private NetWork work; public ProxyServer(NetWork work){ this.work = work; } public void check(){ System.out.println(&quot;联网之前的检查工作&quot;); } @Override public void browse() { check(); work.browse(); } } 整理1.this/super:调用属性、方法、构造器2.static修饰类的内部结构:属性、方法、代码块、内部类3.final可以用来修饰的结构:类、方法、变量4.abstract可以用来修饰:类、方法 仅用于继承，不能用来实例化]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[note-前缀和]]></title>
    <url>%2F2020%2F11%2F05%2Fnote-%E5%89%8D%E7%BC%80%E5%92%8C%2F</url>
    <content type="text"><![CDATA[综述适用场景：题目要求连续的限制好处:优化时间复杂度 引入前缀和的思路是对于一个给定的数组 nums，我们额外开辟一个前缀和数组进行预处理。 有N个正整数的数组A，要求一个新数组B，数组B的第i个元素是原数组A第0到第i个数的和。如[1,2,3,4,5,6]的前缀和pre = [0,1,3,6,10,15,21],也就是pre[i+1] = pre[i] + nums[i]。 pre[i]就是nums[0..i-1]的和。 int n = nums.length; // 前缀和数组 int[] pre = new int[n + 1]; pre[0] = 0; for (int i = 0; i &lt; n; i++) pre[i + 1] = pre[i] + nums[i]; 连续子数组总个数 求数组的连续子数组总个数 这里连续指的是数组的索引连续，比如[1,3,4]的连续子数组有[1],[3],[4],[1,3],[3,4],[1,3,4]，总个数为6 思路:总的连续子数组个数等于=以索引为 0 结尾的子数组个数 + 以索引为 1 结尾的子数组个数 + … + 以索引为 n - 1 结尾的子数组个数. 以索引0结尾的子数组个数:[1] 1个以索引1结尾的子数组个数:[3],[1,3] 2个以索引2结尾的子数组个数:[4],[3,4],[1,3,4] 3个以索引i结尾的子数组个数:[i],[i,i-1],[i,i-1,i-2..] i+1个 所以这道题可以直接用等差数列求和公式 (1 + n) * n / 2，其中n数组长度。 还可以利用前缀和的思路，索引为2结尾的子数组个数 = 索引为1结尾的子数组个数 + 1,边遍历边求和。 int countSubArray(int [] nums){ int count,pre; for(int i =0;i&lt;nums.length;i++){ pre += 1; //当前索引结尾的个数 = 前一个索引结尾的+1 count += pre;//总的 } return count; } 560.和为K的子数组题目给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例： 输入:nums = [1,1,1], k = 2 输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 说明 : 数组的长度为 [1, 20,000]。数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/subarray-sum-equals-k著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路题目求的是xxx的连续的子数组个数,题目要求连续的限制可以考虑用前缀和。如何快速得到某个子数组的和？可以利用之前说的 pre[i]就是nums[0..i-1]的和,那么 nums[i,j] = pre[j+1] - pre[i] 代码 class Solution { public int subarraySum(int[] nums, int k) { //构造前缀和 int length = nums.length; int pre [] = new int [length + 1]; int count = 0 ; for(int i=0;i&lt;length;i++){ //前缀和数组 pre[i+1] = pre[i] + nums [i]; } // 记录符合条件的个数 int ans = 0; // 穷举所有子数组 for (int j = 1; j &lt;= length; j++) for (int i = 0; i &lt; j; i++){ //子数组的和nums[i,j] = pre[j+1] - pre[i] == K ? // i&lt;j j&lt;=length if (pre[j] - pre[i] == k) ans++; } return ans; } } 优化 前缀和 + hash表 利用前缀和快速的得到了某个子数组的和，但是穷举了所有子数组所以效率很低。 为了方便，重新定义一下:定义pre[i] = [0..i]里所有的和,pre[i] = pre[i-1] + num[i] ,这样考虑就需要注意当i = 0时，i-1 =-1的边界问题 那么[j..i]这个子数组的和为k ==转化为==&gt; pre[i] - pre[j-1] == K,为了减少遍历的层数，做移项处理符合条件的下标j需要满足 pre[j-1] == pre[i] - K pre[j-1]是[0..j-1]子数组的和，会先于pre[i]被算出 ==转化为==&gt; pre[i] - k的结果在前面的记录(假设有个存储结构)有无出现，如果出现说明当前情况符合条件，计数器+1 这里采用hash表，因为可能不断的有新pre[i]-K与pre[j-1]相等，所以还需要记录与pre[j-1]相等的个数，所以以和为键，出现次数为对应的值。这里的j是随机的,因为可能数组的下标是[j-1…i]、[j-2…i],不妨设我们求的是[j+1…i]的子数组和为k。那么从左到右更新map时，保证了mp[pre[i]−k] 里记录的pre[j]的下标范围是0≤j≤i。 由于pre[i]的计算只与前一项的答案有关，之前的答案都写进hash表中了。因此我们可以不用建立pre数组，直接用pre变量来记录pre[i-1]的答案 public class Solution { public int subarraySum(int[] nums, int k) { int count = 0, pre = 0; // map：前缀和 -&gt; 该前缀和出现的次数 HashMap &lt; Integer, Integer &gt; mp = new HashMap &lt; &gt; (); //基本的 mp.put(0, 1); for (int i = 0; i &lt; nums.length; i++) { //当前的和 = 上一个和 + 当前数组 pre += nums[i]; //如果前面有这个前缀和，则直接更新答案 if (mp.containsKey(pre - k)) { count += mp.get(pre - k); } //当前pre如果在表中有，就不用在放在表中直接表中的value+1，比如：value = 2 说明前面有2个前缀和都可以使得 pre = 一个值，那么下一次pre-k与之前的键有两个位置都可以满足条件 count+2 //没有就0+1 mp.put(pre, mp.getOrDefault(pre, 0) + 1); } return count; } }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[note-深度优先算法]]></title>
    <url>%2F2020%2F11%2F04%2Fnote-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[图的遍历 从已给的连通图中某一顶点出发，沿边访问图中所有顶点，每个顶点仅被访问一次。遍历实质:找每个顶点的邻接点的过程。 如何避免重复访问?解决思路:设置辅助数组visited[n],用来标记每个被访问过的顶点。 初始状态visited[i]为0。 顶点i被访问,改visited[i]为1，防止多次被访问。 深度优先搜索DFS 利用栈，一条路走到底全部入栈，没有路走则出栈重新找路，直到所有的顶点都被访问。 void DFS(AMGraph G, int V){ //图G为邻接矩阵类型,V是开始的顶点 visited[v] = true ; for(w=0;w&lt;G.vexnum;w++){ //依次检查邻接矩阵v所在行 if((G.arcs[v][w]!=0)&amp;&amp;(!visited[w])) DFS(G,w); //w是v的邻接点，如果w未访问，则递归调用DFS //递归结束返回上一层,就是在实现回退的操作 } }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[394.字符串解码]]></title>
    <url>%2F2020%2F11%2F04%2F394.%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[题目 leetcode394.字符串解码 给定一个经过编码的字符串，返回它解码后的字符串。编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复k次。注意k保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 示例 ： 输入：s = &quot;3[a]2[bc]&quot; 输出：&quot;aaabcbc&quot; 输入：s = &quot;3[a2[c]]&quot; 输出：&quot;accaccacc&quot; 输入：s = &quot;2[abc]3[cd]ef&quot; 输出：&quot;abcabccdcdcdef&quot; 输入：s = &quot;abc3[cd]xyz&quot; 输出：&quot;abccdcdcdxyz&quot; 思路 看见方括号，首先想到用栈。 题目给定的条件有四种可能出现的字符1.字母 -&gt; 直接拼接str2.数字 -&gt; 拼接到数字字符串3.[ -&gt; 当前的str与当前的num入栈,清空str与num4.] -&gt; {str,num}出栈,当前的str是需要重复的字符串，{}里的str是[前的字符串 示例: xy3[a2[c]] | str | num |stack x | &quot;x&quot; |&quot;&quot; | [] y | &quot;xy&quot;|&quot;&quot; | [] 3 | &quot;xy&quot;|&quot;3&quot;| [] [ | &quot;&quot;| &quot;&quot;| [{str:&quot;xy&quot;,num:&quot;3&quot;}] a | &quot;a&quot; | &quot;&quot;| [{str:&quot;xy&quot;,num:&quot;3&quot;}] 2 | &quot;a&quot; | &quot;2&quot;| [{str:&quot;xy&quot;,num:&quot;3&quot;}] [ | &quot;&quot; | &quot;&quot;| [{str:&quot;xy&quot;,num:&quot;3&quot;},{str:&quot;a&quot;,num:&quot;2&quot;}] c | &quot;c&quot;|&quot; &quot; |[{str:&quot;xy&quot;,num:&quot;3&quot;},{str:&quot;a&quot;,num:&quot;2&quot;}] ] | &quot;a&quot; + &quot;cc&quot;|&quot;&quot; |[{str:&quot;xy&quot;,num:&quot;3&quot;}] ] | &quot;xy&quot; + &quot;accaccacc&quot;|&quot;&quot; |[] 代码 /** * @param {string} s * @return {string} */ var decodeString = function(s) { let num = &#39;&#39;,str=&#39;&#39;; let stack = [] ; for(let char of s){ if(!isNaN(char)){ num += char; }else if(char == &quot;[&quot;){ stack.push({str,num}); str =&quot;&quot;; num =&quot;&quot;; }else if(char ==&quot;]&quot;){ let date = stack.pop(); str = date.str + str.repeat(date.num); }else{ str += char; } } return str; }; 其他解法 这道题是一个不断的解码之后拼接的问题，把答的字符串分解成一个个小的字符串进行解码。 比如:”3[a2[c]d]2[b]xy”,可以拆分成”3[a2[c]d]”,”2[b]”,”xy”。”[]” 里可能嵌套 “[]” ,所以需要递归的只有拆分后有”[]”的部分。 这时套入递归的三个问题 1.终止条件(基线条件)是什么? 什么时候递归结束,”]”结束递归 2.应该返回什么？ 题目对字符串进行解码，返回的应该是解好码的字符串，”3[a2[c]d]” 这种情况可以看出这种递归其实是从内到外的,不仅要返回解码好的”cc”,还应该返回”d”的下标,也就是”]”的下一个位置给上一级递归继续进行,直到最外层的”]”解析完毕。 3.本级递归应该做什么？递归的目的是什么？ 首先本层应该要对字符串进行解码，其次是要与已经解好码的字符串进行拼接。结合2按要求进行返回。 const type = { isAlpha: s =&gt; /[a-z]/i.test(s), isDigit: s =&gt; /[0-9]/.test(s), isOpenParen: s =&gt; s === &#39;[&#39;, isCloseParen: s =&gt; s === &#39;]&#39;, }; /** * @param {string} s * @return {string} */ var decodeString = function (s, i = 0) { // 从 i 开始遍历字符串 let decoded = &#39;&#39;; // 解密字符串 let cnt = &#39;&#39;; // 累计次数 while (i &lt; s.length) { if (type.isAlpha(s[i])) { decoded += s[i]; i++; } else if (type.isDigit(s[i])) { cnt += s[i]; i++; } else if (type.isOpenParen(s[i])) { //从内层的递归中获取解码好的字符串与下一次从哪里开始的坐标 const [pattern, nextIndex] = decodeString(s, i + 1); decoded += pattern.repeat(Number(cnt)); cnt = &#39;&#39;; i = nextIndex; continue; } else if (type.isCloseParen(s[i])) { return [decoded, i + 1]; } } return decoded; }; 参考]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[note-滑动窗口法]]></title>
    <url>%2F2020%2F11%2F04%2Fnote-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B3%95%2F</url>
    <content type="text"><![CDATA[综述使用场景：解决连续问题，如”连续子串xxx”,”连续子数组xxx”。优点：把嵌套的for循坏转换为单个for循坏，优化时间复杂度。 由于区间连续，因此当区间发生变化时，可以通过旧有的计算结果对搜索空间进行剪枝，这样便减少了重复计算，降低了时间复杂度。 假设有数组[a,b,c,d,e],一个大小为2的滑动窗口在其滑动，滑动窗口也可以说是在合法区间内滑动，动态的拥有一些数据。 [a,b] [b,c] [c,d] [d,e] 滑动窗口的分类 固定窗口大小 窗口大小不固定，求解最大的满足条件的窗口 窗口大小不固定，求解最小的满足条件的窗口 固定窗口大小 对于固定窗口，我们只需要固定初始化左右指针left和right之间的距离。 1.left初始化为0。2.初始化right，使 窗口大小 = right - left + 1。3.同时移动left和right，固定住窗口的大小。4.判断窗口内的连续元素是否满足题目限定的条件。 4.1 如果满足，再判断是否需要更新最优解，如果需要则更新最优解。 4.2 如果不满足，则继续。 可变窗口大小 对于可变窗口，同样固定初始化左右指针left和right,分别表示窗口的左右顶点。 1.left和right都初始化为0。2.right指针移动一步3.判断窗口内的连续元素是否满足题目限定的条件 3.1 如果满足，再判断是否需要更新最优解，如果需要则更新最优解。并尝试通过移动 left 指针缩小窗口大小。循环执行 3.1 3.2 如果不满足，则继续。 也就是说right指针先右移，直到窗口满足条件，然后移动left指针，缩小范围。 题目参考文章]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[941.有效的山脉数组]]></title>
    <url>%2F2020%2F11%2F03%2F941.%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目 leetcode941 给定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。 让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组： A.length &gt;= 3在 0 &lt; i &lt; A.length - 1 条件下，存在 i 使得：A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i]A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1] 思路 1.先找到最大值记录下坐标i。2.一个变量记录元素与最大值的差3.i的左边，当前元素与最大值的差与变量比较，应该越来越大4.i的右边，当前元素与最大值的差与变量比较，应该越来越小 代码 class Solution { public boolean validMountainArray(int[] A) { int length = A.length; int pre = -10000; int next = 10000; if(length == 0){ return false; } //找到最大值 int cur = A[0],index = 0; for(int i = 1 ; i&lt;length ; i++){ if(A[i] &lt;= cur ){ break; } cur = A[i]; index = i ; } //如果最大值在第一个元素和最后一个返回false if(index == 0 || index == length-1){ return false; } //循坏比较 for(int i = 0; i&lt;length;i++){ if(i&lt;index){ //说明在最大值的左边 if(A[i] - cur &lt;= pre){ return false ; } pre = A[i] - cur ; } if(i&gt;index){ //说明在最大值右边 if(A[i] == cur || A[i] - cur &gt;= next){ return false; } next = A[i] - cur ; } } return true; } } 优化 第二天起来看，感觉写的太复杂了。要多花时间在思考上面，而不是写代码QAQ转换了下思维，可以从开头往右找峰值，找到峰值返回；然后从后面往左找峰值，找到峰值返回，再比较峰值数的索引是不是一样就行了。这样想想好像比之前的思路更简洁一点，至少代码是简洁了好多。 class Solution { public boolean validMountainArray(int[] A) { int length = A.length; if(length &lt; 3){ return false; } //左右两个指针 int left = 0,right = length-1; //从左往又找最大值 while(left &lt; length-1 &amp;&amp; A[left] &lt; A[left+1]){ left++; } //从右往左找 while(right &gt; 0 &amp;&amp; A[right] &lt; A[right-1]){ right--; } if(left == 0 || right == length-1 ||left != right){ return false; } return true; } }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day3-1381.设计一个支持增量操作的栈]]></title>
    <url>%2F2020%2F11%2F03%2F1381.%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81%E5%A2%9E%E9%87%8F%E6%93%8D%E4%BD%9C%E7%9A%84%E6%A0%88%2F</url>
    <content type="text"><![CDATA[题目 leetcode1384.设计一个支持增量操作的栈 实现自定义栈类 CustomStack ： CustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。void push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。int pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1。void inc(int k, int val)：栈底的 k 个元素的值都增加val。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。 示例 输入： [&quot;CustomStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;increment&quot;,&quot;increment&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;] [[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]] 输出： [null,null,null,2,null,null,null,null,null,103,202,201,-1] 解释： CustomStack customStack = new CustomStack(3); // 栈是空的 [] customStack.push(1); // 栈变为 [1] customStack.push(2); // 栈变为 [1, 2] customStack.pop(); // 返回 2 --&gt; 返回栈顶值 2，栈变为 [1] customStack.push(2); // 栈变为 [1, 2] customStack.push(3); // 栈变为 [1, 2, 3] customStack.push(4); // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4 customStack.increment(5, 100); // 栈变为 [101, 102, 103] customStack.increment(2, 100); // 栈变为 [201, 202, 103] customStack.pop(); // 返回 103 --&gt; 返回栈顶值 103，栈变为 [201, 202] customStack.pop(); // 返回 202 --&gt; 返回栈顶值 202，栈变为 [201] customStack.pop(); // 返回 201 --&gt; 返回栈顶值 201，栈变为 [] customStack.pop(); // 返回 -1 --&gt; 栈为空，返回 -1 代码 class CustomStack { private int length; //记录当前元素，默认为0 private int arr []; public CustomStack(int maxSize) { this.arr = new int [maxSize]; } public void push(int x) { if(length == arr.length){ //说明栈满了 return; } arr[length++] = x; } public int pop() { if(length == 0){ return -1; } return arr[--length]; } public void increment(int k, int val) { int min = Math.min(k, length); for(int i = 0; i &lt; min; i++) arr[i] += val; } }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2020%2F11%2F03%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式是在实践中总结和理论化之后的代码结构、编程风格、以及解决问题的思考方式。 单例设计模式目的：只存在一个对象 某个类只能存在一个对象实例，且该类只提供一个取得其对象的方法。要让类在虚拟机中只能产生一个对象，首先将类的构造器的访问权限设置为private，这样就不能用new在类外产生类的对象了，但可以在内部产生该类的对象。因为在类的外部无法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以只指向类内部产生的该类对象的变量也必须定义成静态的。 好处 坏处 饿汉式 对象加载时间过长 线程安全的 懒汉式 延迟对象的创建 //饿汉式 Class Bank(){ private Bank(){} //内部创建类的对象 private static Bank() instance = new Bank() //提供公共的方法，返回类的实例 public static Bank getInstance(){ return instance; } } //懒汉式 Class Order(){ //私有化构造器 private Order(){} //声明当前类对象，没有初始化 private static Order instance = null; //在方法中造对象，效率稍差 // public synchronized static Order getInstance(){ // If(instance == null){ //Instance = new Order() //} //return instance //} //双重检查，效率稍高 if(instance == null){ synchronized(Bank.class){ If(instance == null){ Instance = new Order() } } return instance } } 应用场景 网站的计数器，一般单例模式实现，否则难以同步。应用程序的日志应用，一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。数据库连接池的设计，因为数据库连接是一种数据库资源。Application单例的典型应用。 模板方法设计模式多态的应用:模板方法设计模式(TemplateMethod) 抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造、但子类总体上会保留抽象类的行为方式。 解决的问题:当功能内部一部分实现是确定的，一部分实现是不确定的，这时可以把不确定的部分暴露出去，让子类去实现。整体步骤很固定、通用的在父类中写好。其他易变部分可以抽象出来，供不同子类实现，这就是一种模板模式。 示例: abstract class Template{ //计算某段代码执行所需要花费的时间 public void spendTime(){ long start = System.currentTimeMillis(); this.code();//不确定的部分、易变的部分 long end = System.currentTimeMillis(); System.out.println(&quot;花费的时间为：&quot; + (end - start)); } public abstract void code(); } 工厂模式实现了创建者与调用者的分离，将创建对象的具体过程屏蔽起来，提高灵活性。设计模式与面向对象设计原则都是为了使开发项目更加容易扩展和维护，解决方式就是分工 无工厂模式 public class Client{ public static void main(String[] args){ //创建 Car a = new Aud(); Car b = new BYD(); //调用 a.run() b.run() } } 简单工厂//工厂类 xxxFactory class CarFactory{ //方式一 public static Car getCar(String type){ if(&quot;奥迪&quot;.equals(type)){ return new Audi(); }else if(&quot;比亚迪&quot;.equals(type)){ return new BYD(); }else{ return null; } } //方式二 public static Car getAudi(){ return new Audi(); } public static Car getByd(){ return new BYD(); } } //调用 public class Client{ public static void main(String[] args){ //创建 Car a = CarFactory.getCar(&quot;奥迪&quot;); Car b = CarFactory.getCar(&quot;比亚迪&quot;); //调用 a.run() b.run() } } 缺点：对于新增产品，需要修改代码，违反了开闭原则(对扩展开放，对修改封闭) 工厂方法模式//工厂接口 interface Factory{ //抽象方法，获取car Car getCar(); } //两个工厂类，获取的什么车 class AudiFactory implements Factory{ public Audi getCar(){ return new Audi(); } } class BydFactory implements Factory{ public BYD getCar(){ return new BYD; } } //调用 public class Client{ public static void main(String[] args){ //创建 获取工厂 Car a = new AudiFactory.getCar(); Car b = new AudiFactory.getCar(); //调用 a.run() b.run() } } 总结:简单工厂模式与工厂方法模式其实没有真正的避免代码的改动。在简单工厂模式中，新产品的加入要修改工厂橘色的判断语句；在工厂方法中，要么将判断逻辑留在抽象工厂角色中，要么在客服程序中将具体工厂角色写死(上述例子)。而且产品对象创建条件的改变必然会引起工厂角色的改变，面对这种情况，Java的反射机制与配置文件的巧妙结合突破了限制 –这在Spring中完美体现。 抽象工厂模式抽象工厂模式和工厂方法模式的区别在于需要创建对象的复杂程度上，而且抽象工厂模式是三个里面最为抽象、最具一般性的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[821.字符的最短距离]]></title>
    <url>%2F2020%2F11%2F02%2F821.%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[题目 leetcode821.字符的最短距离 给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。 示例 1:输入: S = “loveleetcode”, C = ‘e’输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] 说明:字符串 S 的长度范围为 [1, 10000]。C 是一个单字符，且保证是字符串 S 里的字符。S 和 C 中的所有字母均为小写字母。 思路 初始化一个数组distanceArr，赋最大值。 找到S中与C相等的字符。 先往左边扫，直到扫到第一个或者distanceArr[left] &lt; distance。 再往右边扫，直到扫到下一个C或者最后一个数组元素。 说明： 往右扫时扫到下一个C就停止而不用比是不是最短距离的原因是：以下一个C为基准往左扫的时候会比较距离。 数组元素默认值为0，0已经是最小距离了，为方便比较赋最大值 。 代码 import java.util.Arrays; class Solution { public int[] shortestToChar(String S, char C) { int length = S.length(); int distanceArr [] = new int [length]; //刚开始数组的距离不能全部为0,因为这样就是最小的距离的没办法比较之后更改 Arrays.fill(distanceArr,Integer.MAX_VALUE); for(int i = 0 ; i &lt; length ; i++){ //S中找到C if(C == S.charAt(i)){ //记录左指令与右指针，并且距离distance int left = i,right = i + 1,distance = 0 ; //往左边扫,扫到最开始或者遇见数组中距离比distance小的结束 while(left &gt;= 0 &amp;&amp; distanceArr[left] &gt; distance){ distanceArr[left--] = distance++ ; } //跳出循环之后，应该更新distance distance = 1 ; //往右边扫,扫到下一个C或者最后一个数组元素 while(right &lt; length &amp;&amp; C != S.charAt(right) ) { distanceArr[right++] = distance ++; } } } return distanceArr; } } 反思可以先对可能情况进行分类帮助分析： 1.只有左边有C字符： sdafC… 2.左右两边都有C字符：…CdsfsC… 3.只有右边有C字符：…Cdsff 其他解法 class Solution { public int[] shortestToChar(String S, char C) { int length = S.length(); int distanceArr [] = new int [length]; int pre = - 10000; //刚开始没有e距离就无限大,因为后面的-pre //先从左往右遍历 for(int i = 0 ; i &lt; length ; i++){ //每一个元素计算与pre的距离，遇见C把C的当前位置更新为pre //looexxevx v离第二个e的距离小于第一个e所以更新e的位置为pre if(C == S.charAt(i)){ pre = i; } distanceArr[i] = i - pre; } //从右往前遍历 pre = 10000; for(int i =length-1 ; i&gt;=0 ;i--){ if(C == S.charAt(i)){ pre = i; } distanceArr[i] = Math.min(distanceArr[i], pre - i); } return distanceArr; } }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[66.加一]]></title>
    <url>%2F2020%2F11%2F01%2F66.%E5%8A%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[题目 leetcode66.加一 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1:输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。示例 2:输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 提示：不要将数组转化为数字做加法再转回来。 思路 从最后一个数组元素开始往前遍历，不是9直接+1返回数组，是9变为0进入下一次循环，不断的重复直到某一个数组元素不是9或者找到了第一个元素。特殊情况数组元素全为9的时候，例子:[9,9] -&gt; [1,0,0] 代码 class Solution { public int[] plusOne(int[] digits) { for(int i = digits.length-1 ; i &gt;= 0 ; i--) //从后往前遍历 { if(digits[i] != 9){ digits[i]++ ; return digits; } digits [i] = 0 ; } //如果退出循环说明是特殊情况，且目前的数组元素全是0。 //因为JAVA数组长度一确定就不能修改，所以用返回一个新数组 //数组中为int型元素默认值为0，所以只需要修改第一个元素为1 int newArr [] = new int [digits.length + 1]; newArr[0] = 1; return newArr; } }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python总结]]></title>
    <url>%2F2020%2F10%2F22%2Fpython%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1.两个数组合成一个数组 List extend()方法 extend()函数用于在列表的后面追加新列表的值，用新列表扩展原来的列表。 list.extend(元素列表),没有返回值 +操作符 c1 = [&quot;Red&quot;,&quot;Green&quot;,&quot;Blue&quot;] c2 = [&quot;Orange&quot;,&quot;Yellow&quot;,&quot;Indigo&quot;] c3 = c1 + c2 # c3 = [&quot;Red&quot;,&quot;Green&quot;,&quot;Blue&quot;,&quot;Orange&quot;,&quot;Yellow&quot;,&quot;Indigo&quot;]]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux学习笔记]]></title>
    <url>%2F2020%2F10%2F19%2Flinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[在Linux内核基础上进行开发包装,Linux的主要发行版:Ubuntu(乌班图)、RedHat(红帽)、CentOS… 虚拟机连接的三种模式 双击进去,crtl+alt退出 虚拟机网络连接的三种模式: 张三:192.168.14.100(windows)李四:192.168.14.110 桥接模式:1.大家都在同一个网段,相互可以通讯2.因为ip地址有限,可能造成ip冲突 centos虚拟机张三:192.168.14.xxx,与李四在同一个网段相互可以通信 Nat网络地址转换模式:1.虚拟机不占用其他的ip,不会ip冲突2.内网的其他人不能和虚拟机通讯 王五:192.168.14.130(windows)转换的新地址:192.168.20.33centos虚拟机:192.168.20.xxx王五可以通过转化成14网段与李四通讯,但李四找不到王五 主机模式:单独的一台电脑 startx 启动图形化界面 Linux的目录结构Linux的文件系统是采用树状目录结构，只有一个根目录，在Linux世界里，一切皆文件。 bin 是Binary的缩写,这个目录存放着最经常使用的命令sbin s是Super User的意思,这里存放的是系统管理员使用的系统管理程序home 存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的root 该目录为系统管理员，也称作超级权限者的用户主目录etc 所有的系统管理所需要的配置文件和子目录user 这个目录很重要，用户的很多应用程序和文件都放在这个目录下，类似windows下的program files目录boot 存放的启动Linux使用的一些核心文件，包括一些连接文件以及镜像文件proc/srv/sys 这些目录最好不要修改media linux系统会自动识别一些设备,例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下mut 系统提供该目录是为了让用户临时挂载别的文件系统的，可以将外部的存储挂载在mut上，然后进入该目录就可以查看里面的内容了usr/local 给主机额外安装软件所安装的目录，一般是通过编译源码方式安装的程序var 这个目录存放着在不断扩充的东西，习惯将经常被修改的目录放在这个目录下，包括各种日志文件 Linux常用操作远程登陆Linux为什么需要远程登陆Linux1.Linux服务器是开发小组共享的2.正式上线的项目是运行在公网的3.因此程序员需要远程登陆到centos进行项目管理或者开发 XShell远程登陆Linux的软件(登陆后基本是命令行操作) XShell,前提是Linux启动了SSHD服务，该服务会监听22号端口 1.首先需要知道需要连接的Linux的IP地址2.在Xshell中新建会话 协议:SSH,端口号:22,主机:需要连接的Linux的IP地址3.输入Linux的用户名和密码注意：如果在Xshell中输入reboot重启的是Linux SecureCRT用于远程登陆Linux的软件,在大数据开发中使用较多 解决乱码问题: 会话选项 - 外观 - 编码UTF-8 Xftp远程上传文件到Linux与从Linux中下载文件的软件 XFtp 1.操作步骤和上述一样,协议是SFTP端口号是222.解决乱码问题：设置中使用UTF-8编码 Vi与Vim编辑器Vi文本编辑器，Vim是Vi的增强版本 vi和vim三种常见模式 正常模式： 可以使用快捷键 -&gt; 以vim打开一个档案直接进入一般模式插入模式/编辑模式: 程序员可以输入内容 -&gt; 按i进入编辑模式命令行模式： 可以输入相关命令完成读取、存盘、替换、离开vim等 -&gt; 按： 开机、重启和用户登陆注销关机&amp;重启命令 shutdowm shutdown -h now:表示立即关机 shutdown -h 1:表示一分钟后关机 shutdown -r now:立即重启halt 效果等价与关机reboot 重启系统sync 将内存的数据同步到磁盘 用户登陆和注销1.登陆时尽量少用root账号登陆，因为系统管理员是最大的权限，避免操作失误。可以利用普通用户登陆，登陆后再用su-用户名命令来切换成系统管理员身份2.在提示符下输入logout可注销用户(退出) 使用细节：1.logout注销指令在图形运行级别无效，在运行级别3下有效 用户管理用户家目录的概念/home/目录下有各个用户对应的家目录，当用户登陆时，会自动进入到自己的家目录，如/home/ranan 添加用户一个用户至少属于一个用户组基本语法: useradd [选项] 用户名 使用细节:1.如果在添加用户的时候没有指定分到哪个用户组，则会默认创建一个同名用户组2.可以通过useradd -d 指定目录(不能是已经存在的目录) 新的用户名给新创建的用户指定家目录,如 useradd -d /home/ranan ran。没有指定的话就默认创建同名家目录。3.useradd -g 用户组名 用户名 指定用户在哪个组 指定/修改密码 基本语法:passwd 用户名 删除用户使用root权限基本语法:userdel [选项] 用户名 userdel ranan :保留家目录,删除用户userdel -r ranan :删除家目录与用户 使用细节:实际开发中会保留家目录 查询用户信息基本语法:id 用户名返回值:用户id号,所在组的id,所在组的名称 切换用户在操作Linux中,如果当前用户的权限不够，可以通过su -指令切换到高权限用户 基本语法: su - 切换用户名细节说明:1.从权限高的用户切换到权限低的用户，不需要输入密码2.当需要返回到原来用户时，使用exit指令 查看当前用户/登录用户基本语法:whoami 用户组新增组语法: groupadd 组名 删除组语法: groupdel 组名 修改用户的组语法：usermod -g 用户组 用户名 用户和组的相关文件 /etc/passwd文件 - 用户(user)配置文件 记录用户的各种信息 每行的含义：用户名:口令(密码):用户标识符(id):组标识号:家目录:shell /etc/group文件 - 组配置文件 记录组的各种信息 每行含义:组名:口令:组标识符:组内用户列表 /etc/shadow文件 - 口令配置文件 记录密码和登陆信息是加密文件 每行含义:登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志 实用指令指令运行级别常用运行级别是3和5,系统的运行级别配置文件/etc/inittab0:关机1:单用户(找回丢失密码)2:多用户无网络服务3:多用户有网络服务4:保留5:图形界面6:重启 命令:init [希望进入的级别号0123456] 切换到指定运行级别的指令 如何找回丢失的root密码？思路:进入单用户模式,root不需要密码就可以登陆，然后修改root密码实现:开机-&gt;在引导时输入回车键 -&gt; 看见第一个界面输入e -&gt; 新界面选择第二行输入e -&gt;输入1回车 =&gt; 再次输入b进入单用户模式 -&gt; 使用passwd指令来修改root密码前提:不可以远程，仅仅在装Linux系统的电脑可以操作 帮助指令语法: man [命令或配置文件]功能描述:获得帮助信息语法: help 查看的指令(功能描述:获得shell内置命令的帮助信息) 文件目录类pwd指令语法:pwd功能:显示当前工作目录的绝对路径 ls指令语法:ls [选项] [目录或是文件]常用选项:-a 显示当前目录所有的文件和目录,包含隐藏文件 l 以列表的方式显示信息 h 符合人查看习惯的显示 cd切换指令语法:cd [参数]功能描述:切换到指定目录常用参数:绝对路径和相对路径cd ~ 或者cd 回到自己的家目录cd .. 回到当前目录的上一级目录 mkdir指定 midir指令用于创建目录基本语法 mkdir [选项] 要创建的目录常用选项 -p: 创建多级目录实例:mkdir /home/dog 创建的一级目录 rmdir指令基本语法:rmdir [选项] 删除的空目录使用细节: rmdir 删除的是空目录，如果目录下有内容时无法删除rm -rf 删除非空的目录 rm 指令rm 指令删除文件或目录基本语法： rm [选项] 要删除的文件或目录常用选项 r 递归删除整个文件夹 f 强制删除不提示rm -rf 删除目录 mv 指令mv 移动文件与目录或者重命名基本语法:mv oldNameFile newNameFile 重命名 当前的目录的old移动到当前目录时发现已经有了，所以就重命名mv 源地址 目的 移动文件实例:mv aaa.txt /root/ 当前目录的aaa移动到root目录下 touch指令touch指令创建空文件基本语法: touch 文件名称(可以时多个文件，用空格分隔) cp指令cp指令拷贝文件到指定目录基本语法: cp [选项] source(源文件) dest(目的)常用选项-r 递归复制整个文件夹例子:将/home/test整个目录拷贝到/home/xxx目录 cp -r test/ xxx/强制覆盖不提示的方法\cp cat指令cat查看文件内容基本语法: cat [选项] 要查看的文件常用选项: -n 显示行号使用细节:cat只能浏览文件，而不能修改文件，为了浏览方便，一般会带上管道指令 | more ,代表分页显示(空格跳到下一页)实例: cat -n /root/aaa.txt | more more 指令是一个基于vi编辑器的文本过滤器，以全屏幕的方式按页显示文本文件的内容基本语法: more 要查看的文件使用细节:enter 一行行看，空格 翻页，ctrl+b 上一页less 指令用来分屏查看文件内容,它的功能与more类似，但比more指令更强大，支持各种显示终端,less指定在显示文件内容时，并不是一次将整个文件加载之后才显示，二十根据显示需要加载内容，对于显示大型文件具有较高的效率语法:less 要查看的文件 &gt; 指令和&gt;&gt;指令 输出重定向(会覆盖)和 &gt;&gt; 追加指令 基本语法: ls -l &gt;文件 ：ls -l显示的内容覆盖写入文件中 Is -l &gt;&gt; 文件ls -l显示的内容追加到文件后面 Cat 文件1 &gt; 文件2 将文件1的内容覆盖到文件2 echo “内容” &gt;&gt; 文件 echo指令echo输入内容到控制台基本语法： echo [选项] [输出内容]实例:输出当前环境变量 echo $PATH head指令head用于显示文件的开头部分内容，默认情况下该指令显示文件前10行内容基本语法:head 文件Head -n 数字 文件 数字代表查看的行数，-n代表指示查看行数命令 tail指令tail用于输出文件中尾部的内容，默认输出后10行基本语法:tail 文件 查看文件后10行内容tail -n 数字 文件 查看文件的后数字行内容tail -f 文件 实时追踪该文档的所有更新(经常使用) ln 指令软链接(符号链接)，类似windows的快捷方式，主要存放了所链接文件的路径基本语法:ln -s [原文件或目录] [软链接名]给原文件创建一个软链接细节说明:1.删除软链接时不用带最后的/，仅仅删除软链接本身2.切换到软链接之后，用pwd查看目录时，看到的是软链接所在的目录(类比桌面快捷键) history指令查看已经执行过的历史命令，也可以执行历史指令基本语法:history [数字]使用细节:默认显示所有指令，可选中的数字代表显示最近的几条，使用!数字执行历史指令 时间日期类date指令-显示/修改当前日期 基本语法:data 显示当前时间data “+%Y %d” 显示当前年份，双引号里的加号可以看成字符串拼接%Y年%m月%d日%H时%M分%S秒data -s 字符串时间 设置系统当前日期 cal指令-查看日历cal [选项]使用细节:1.不加选项，本月日历2.选项可填年份，显示整年的日历 搜索查找类find指令-查询find指令将从指令目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端基本语法:find [搜索范围] [选项]应用实例:1.按文件名，根据名称查找/home目录下的hello.txt - find /home -name hello.txt2.按拥有者，查找/opt目录下用户名称为nobody的文件 - find /home -user nobody3.查找整个linux系统下大于20m的文件 +大于 -小于 - find / -size +20M locate指令locate指令可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名及路径的locate数据库实现快速定位给定的文件。Locate指令无需遍历整个文件系统，查询速度较快。基本语法:locate 搜索文件 - 返回文件的路径使用细节:由于locate指令基于数据库进行查询，所以第一次运行前，必须使用updatedb指令创建locate数据库grep指令与管道符号 |grep过滤查找，查找文件中是否存在某个关键词，管道符|表示将前一个命令的处理结果输出传递给后面的指令执行基本语法:grep [选项] 查找内容 源文件-n 显示匹配以及行号-i 忽略字母大小写应用实例:请在hello.txt文件中，查找yes所在行，并显示行号 cat hello.txt | grep -n yes 压缩和解压gzip/gunzip指令-压缩/解压文件基本语法:gzip 文件 - 只能将文件压缩为*.gz文件，原文件删除只剩下压缩后的文件Gunzip 文件.gz - 解压缩文件命令 zip/unzip指令zip用于压缩文件，unzip用于解压，在项目打包发布中有用基本语法:zip [选项] XX.zip 将要压缩的内容unzip [选项] 解压到的路径 XXX.zip常用选项：zip r 递归压缩，即压缩目录unzip d&lt;目录&gt; 指定解压后文件的存放目录实例:将mypackage.zip解压到/opt/tem/路径下 - unzip - d /opt/tmp/ mypackage.zip tar指令tar指令是打包指令，最后打包后的文件是.tar.gz的文件基本语法:tar [选项] XXX.tar.gz 打包的内容常用选项:-c 产生.tar打包文件-v 显示详细信息-f 指定压缩后的文件名-z 打包同时压缩-x 解压实例:压缩多个文件，将/home/a1.txt 和/home/a2.txt 压缩成 a.tar.gz - tar -zcvf a.tar.gz /home/a1.txt /home/a2.txt将myhome.tar.gz 解压到/opt目录下 - tar -zxvf myhome.tar.gz -C /opt/ (注意解压到的目录必须存在)将myhome.tar.gz 解压到当前目录下 - tar -zxvf myhome.tar.gz 组管理和权限管理组管理在linux中每个文件都有所有者、所在组、其他组的概念 文件/目录 所有者 查看文件的所有者指令:ls -ahl 修改文件的所有者指令:chown 用户名 文件名 文件/目录 所在组 组的创建指令:groupadd 组名 默认情况下，当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组 查看文件/目录所在组指令:ls -ahl 修改文件所在组指令:chgrp 组名 文件名 改变用户所在组usermod -g 组名 用户名usermod -d 目录名 用户名 改变该用户登陆的初始目录 权限(文件和目录)管理例子：ls -l 显示：文件类型 文件所有者权限(3个位置) 文件所在组的用户的权限 文件其他组的用户权限,1 文件的所有者 所属组 数字 文件最后的修改时间 文件名 文件类型: - 普通文件 d:目录 l:软链接 c:字符设备 b:块文件(硬盘等) 1:如果是文件，文件表示硬链接，如果是目录表示该目录的子目录个数 数字:代表文件大小，如果是目录则是4096 rwx权限:文件 r 可读、查看 w 可以修改但是不可删除，删除的前提是对该文件所在的目录有写权限 x 可以被执行目录 r代表可读,可以读取，ls查看目录内容 w代表可写，可以修改，目录的创建/删除、重命名 x代表可执行，可以进入该目录 还可以用数字表示r=4,w=2,x=1 修改权限基本说明:通过chmod指令，可以修改文件或者目录的权限。 第一种 + - = 变更权限u:所有者 g:所有组 o:其他人 a:所有人(u、g、o的综合) chmod u=rwx,g=rx,o=x 文件/目录名chmod o+w 文件/目录名 给其他人增加写权限chmod a-w 文件/目录名 给所有人减去写权限 第二种 通过数字变更权限 规则:r=4 w=2 x= 1 rwx=4+2+1=7 chmod u=rwx,g=rx,o=x 文件/目录名 = chmod 751 文件/目录名 修改文件所有者基本说明:chown newowner file 改变文件的所有者chown newowner:newgroup file 改变文件的所有者和所有组-R 如果是目录 则使其下所有子文件或目录递归生效 案例:1.将/home/kkk目录下所有的文件和目录的所有者都修改成tom -&gt; chown -R tom /home/kkk/ 修改文件所在组基本介绍:chgrp newgroup file 改变文件的所有组 案例:1.将/home/kkk目录下所有的文件和目录的所在组都修改成 xxx -&gt; chgrp -R xxx kkk/ 定时任务调度任务调度，指系统在某个时间执行特定的命令或程序 crontabcrontab机制 定时的调度我们的脚本或者代码 基本语法:crontab [选项]service crond restart 重启任务调度 常用选项:-e 编辑crontab定时任务-l 列出当前的crontab任务-r 删除当前用户所有的crontab任务 案例:如果只是简单的任务，直接在crontab中加入任务即可;复杂的任务，需要写脚本(shell编程) 设置任务调度文件:/etc/crontab设置个人任务调度。执行crontab -e命令接着输入任务到调度文件如:*/1**ls -l /etc &gt;&gt; /tem/to.txt意思说每小时的每分钟执行ls -l /etc/ &gt; /tmp/to.txt命令 —直接写1.crontab -e2./1 * ls -l /etc &gt;&gt; /tem/to.txt (注意空格)3.当保存退出后就程序4.在每一分钟都会自动的调用 ls -l /etc &gt;&gt; /tem/to.txt —通过脚本写1.先编写一个文件 /home/mytask.sh (写指令) ls -l /etc &gt;&gt; /tem/to.txt2.给mytask.sh 可执行权限 -&gt; chmod 744 mytask.sh3.crontab -e4./1 * /home/mytask.sh 说明:第一个后面 - 分钟 - 0-59第二个后面 - 小时 - 0-23第三个后面 - 天 - 0-31第四个后面 - 月 - 0-12第五个*后面 - 星期 - 0-7(0和7代表星期天) 代表任何时间,代表不连续的时间-代表连续的时间范围 /n代表每个多久执行依次 磁盘分区、挂载Linux分区的原理示意图: 查看系统的分区和挂载情况:-f 指格式化是可选项，如果想看分区大小则不添加这个选项。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-matplotlib]]></title>
    <url>%2F2020%2F10%2F16%2Fpython-matplotlib%2F</url>
    <content type="text"><![CDATA[完成机器学习pla算法和pocket算法作业的时候,想要把数据可视化出来,发现需要用到matplotlib,此篇博客记录matplotlib的学习笔记。 matplotlib专门用于开发2D(3D)图表,mat-matrix矩阵、plot画图、lib-library库 matplotlibmatplotlib的三层结构1.容器层 1.1画板层Canvas 一般不会接触 1.2画布层Figure:plt.figure() 一个画布上可以创建多个绘图区 1.3绘图区/坐标系axes:plt.subplots x、y轴张成的区域 2.辅助显示层:图表的一些标注,辅助图表的显示 3.图像层:画不同的图表 matplotlib.pyplot的函数(类似与matlab的画图函数)作用于当前图形(figure)的当前坐标系(axes) 简单的案例: # 创建画布 plt.figure(figsize=(长,宽),dpi=) # figsize:设置画布大小 # dpi：图形的清晰度 # 返回fig对象 # 绘制图像 x = [1,2,3,4,5] plt.plot(x,[5,4,3,2,1]) # 对此调用就可以画多个图标 plt.xticks(x[::5]) # 准备x的刻度说明 # 保存图片 plt.savefig(&quot;test.png&quot;) # 显示图像 plt.show() 注意1.plt.show()会释放figure资源,如果在显示图片之后保存图片将只能保存空图片2.显示中文需要下载字体 2.1安装字体 2.2删除matplotlib缓存文件 2.3配置文件解决的教程 辅助显示层编辑坐标轴plt.xticks(x,kwargs)x:要显示的刻度值,后面参数可以传显示的值plt.yticks(y,kwargs)y:要显示的刻度值 from matplotlib import pyplot as plt import random x = range(10) y = [random.uniform(15,18) for i in x] x_ticks_label = [&quot;11点{}分&quot;.format(i) for i in x] plt.figure() plt.plot(x,y) # x的刻度说明 plt.xticks(x[::3],x_ticks_label[::3]) plt.show() # 展现图片 网格显示plt.grid(True,linestyle=”–”,alpha=0.5)参数1:是否显示网格参数2:线条风格参数3:透明度 添加描述信息plt.xlabel(“描述信息”)plt.ylabel(“描述信息”)plt.title(“”) 图像层 多次调用就可以画多个图表 图例不仅需要在图像层修改还需要在辅助层修改plt.legend(loc=”low right”),可以空参 绘图区 figure axes = matplotlib.subplots(nrows=1,ncols=1,**fig_kw)创建一个带有多个axes(坐标系/绘图区)的图,返回一个图对象和绘图区 figure, axes = plt.subplots(nrows=1,ncols=1,**fig_kw) # 返回两个实例对象 # axes[0].方法的形式来画图,具体的可以看文档 对比散点图scatter:用两组数据构成多个坐标点，考察坐标点的分布，判断两变量之间是否存在某种关联趋势plt.scatter(x,y) 柱状图bar:统计/对比plt.bar(x,y,width,align=”center”,**kwargs)对比形式的柱状图:1.调用两次bar2.两个bar的x要岔开,否则画出来的柱状图会覆盖 直方图histogram:分布状态 饼图:分类数据的占比情况 numpynumpy中在数值计算,多用于多维数组上执行数值运算 数组numpy.array() Python中的list容器，可以当成数组使用，但由于里面的元素可以是任何对象，因此列表中保存的是对象的指针，保存一个简单的列表[1,2,3]，需要三个指针和三个整数对象，结构不高效Python中提供的array模块，只支持一维数组，不支持多维数组(矩阵) numpy.array(arr)参数:数值返回值:ndarray类型,也就是numpy里面的数组类型 numpy.arange()参数表示范围,根据范围返回一个可迭代的数组类型 numpy.arange(10) = np.array(range(10)) # [0,1,2,3,4,6,7,8,9] a = numpy.arange(4,10,2) # [4,6,8] 从4开始到10结束,步长为2 type(a) # 返回a的数据类型 a.dtype # 数组中数据的类型 a.shape # 返回一个元组(几个值就是几维的)，输出矩阵的形状 数组计算np.r_[]/np._c[] np.r_：是按列连接两个矩阵，就是把两矩阵上下相加，要求列数相等 np.c_：是按行连接两个矩阵，就是把两矩阵左右相加，要求行数相等 import numpy as np a = np.array([1, 2, 3]) b = np.array([4, 5, 6]) c = np.c_[a,b] print(np.r_[a,b]) print(c) print(np.c_[c,a]) # 结果： [1 2 3 4 5 6] [[1 4] [2 5] [3 6]] [[1 4 1] [2 5 2] [3 6 3]] numpy.vstack(tup) 垂直按照行顺序把每个数组给堆叠起来,返回一个新的数组 参数:元组、列表或者numpy数组返回值:numpy的数组 a=[[1],[2],[3]] b=[[1],[2],[3]] c=[[1],[2],[3]] d=[[1],[2],[3]] print(np.vstack((a,b,c,d))) # 输出： [[1] [2] [3] [1] [2] [3] [1] [2] [3] [1] [2] [3]] a=[1,2,3] b=[4,5,6] print(np.vstack((a,b))) # 输出： [[1 2 3] [4 5 6]] 切片# 返回值是一个数组 X = np.array ([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9], [10, 11], [12, 13], [14, 15], [16, 17], [18, 19]]) # X[:,0]就是取所有行的第0个数据 print(X[:, 0]) #输出：[ 0 2 4 6 8 10 12 14 16 18] #X[1,:]第一维中下标为1的元素的所有值 print(X[1,:]) #输出：[2 3] Y = np.array([[0,1,2],[3,4,5],[6,7,8],[9,10,11],[12,13,14],[15,16,17],[18,19,20]]) #Y[:, m:n]，即取所有数据的第m到n-1列数据，含左不含右 print (Y[:,1:3]) &#39;&#39;&#39; 输出： [[ 1 2] [ 4 5] [ 7 8] [10 11] [13 14] [16 17] [19 20]] numpy.random.normal()numpy.random.normal(loc=0,scale=1e-2,size=shape) 生成正态分布 参数：1.loc(float)：正态分布的均值，对应着这个分布的中心。loc=0说明这一个以Y轴为对称轴的正态分布，2.scale(float)：正态分布的标准差，对应分布的宽度，scale越大，正态分布的曲线越矮胖，scale越小，曲线越高瘦。3.size(int 或者整数元组):输出的形状,默认为None。如(10,2) -&gt; 输出一个10行2列的元组 返回值:元组数据 标准正太分布（μ=0, σ=1）:np.random.normal(loc=0, scale=1, size)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象]]></title>
    <url>%2F2020%2F10%2F11%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[getClass方法 实例.getClass()方法,返回实例的直接父类 JUnitJava中的JUnit单元测试1.使用JUnittest目录(src同级)用于存放测试类，在此目录上右击鼠标并将此目录标记为Test Resources Root选择要进行测试的类文件，在类文件中按下组合键CTRL+SHIFT+T弹出创建测试类的窗口或者右键goto -&gt; test2.自动创建的Java类，进行单元测试 此类是public 此类提供公共的无参构造器(默认的不需要去写)3.此类中声明单元测试方法 此方法的权限是public,没有形参与返回值4.此单元测试方法的上面需要声明注释@Test,并导入import org.junit.Test]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10.9数组练习]]></title>
    <url>%2F2020%2F10%2F09%2F10-9%E6%95%B0%E7%BB%84%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[杨辉三角题目使用二维数组打印一个杨辉三角形(二维数组的内容输出是一个杨辉三角)杨辉三角形:11 11 2 11 3 3 11 4 6 4 1 思路1.第一个有1个元素,第n行有n个元素2.第一行的第一个元素和最后一个元素都是13.从第三行开始，对于非第一个元素和最后一个元素的元素的元素 arr[i][j] = arr[i-1][j-1] + arr[i-1][j] 代码 public class YangHuiTriangle { public static void main(String[] args) { //1.声明并初始化二维数组 int yangHui[][] = new int[10][]; //2.给数组的元素赋值 for (int i=0;i&lt;yangHui.length;i++){ //第n行有n个元素 yangHui[i] = new int [i+1]; //首位数组赋值 yangHui[i][0] = yangHui[i][i] = 1; //非首位元素赋值 for (int j=1;j &lt; yangHui[i].length-1;j++){ yangHui[i][j] = yangHui[i-1][j-1] + yangHui[i-1][j]; } } //3.输出二维数组 for(int i=0;i&lt;yangHui.length;i++){ for(int j=0;j&lt;yangHui[i].length;j++){ System.out.print(yangHui[i][j] + &quot; &quot;); } System.out.println(); } } } 常见算法1.创建一个长度为6的int型数组，要求数组元素的值都在1-30之间，且是随机赋值。同时要求元素的值各不相同。思路：赋值之后与数组前面的元素比较，相同则重新赋值 public class Test { public static void main(String[] args) { int arr [] = new int[6]; for (int i=0;i&lt;arr.length;i++){ arr[i] = (int)(Math.random()*30)+1; //与该元素前面的元素进行比较 for (int j =0;j&lt;i;j++){ if (arr[i]==arr[j]){ //说明相同了 i--; break; } } } //输出 for (int i = 0;i &lt; arr.length;i++){ System.out.println(arr[i]); } } } 数组的复制/反转/查找数组的复制(区别于数组变量的赋值) int[] array1,array2; array1 = new int[]{1,2,3,4,5}; array2 = new int[array1.length]; for(int i=0;i&lt;array2.length;i++){ array2[i] = array1[i]; } 数组的反转 for(int i=0,j=arr.length-1;i&lt;j;i++,j++){ String temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } 数组元素的排序算法内部排序：所有操作都在内存中完成外部排序：借助外部存储器由多次内部排序组成 交换排序:冒泡排序、快速排序 冒泡排序冒泡排序思想:依次比较相邻元素的排序码，发现逆序则交换，使排序码较大的元素往后移 因为排序的过程中，各元素不断接近自己的位置，所以如果一趟比较下来没有进行过交换说明有序，因此需要在排序过程中设置一个标志swap判断元素是否进行过交换，从而较少不必要的比较 1.最多进行length-1趟2.每趟是的比较次数arr.length-1-i3.比较的是相邻的两个元素4.结束条件:某一趟没有交换元素 //时间复杂度O(n^2) public class BubbleSort { public static void main(String [] args){ int[] arr = new int[]{0,1,2,3,4}; boolean swap = false; //冒泡排序,最多进行arr.length-1趟 for(int i=0;i&lt;arr.length-1;i++){ for (int j = 0; j&lt;arr.length-1-i;j++){ //比较次数arr.length-1-i if (arr[j] &gt; arr[j+1]){ //每趟都是相邻元素比较 int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; swap = true; } } //某趟没有交换元素说明有序可以直接退出 if (!swap){ break; } } } } 快速排序内排序中速度最快的排序方法，冒泡排序的升级版，时间复杂度O(nlog(n)) 基本思想(大规模化小规模使用同样的办法-递归)：1.任取一个元素(如:第一个)为中心pivot2.所有比它小的元素放前,比它大的放后,形成左右两个子表3.对各子表重新选择中心元素并依此规律调整4.直到每个子表的元素只剩下一个 //时间复杂度O(nlogn) public class QuickSort { //实现快排的代码 public static void subSort(int[] data,int start,int end){ //当开始位置小于结束位置时，可以开始排序 if(start &lt;end){ int pivot = data[start]; //记录需要进行排序的下标 int low = start,high = end; while (low &lt; high){ //从右往左找，找到一个比基准数小的数 while (low&lt;high &amp;&amp; pivot&lt;=data[high]){ high--; } //找到比基数小的,填左边坑 data[low] = data[high]; //从做往右找，找到一个比基准数大的数 while (low &lt; high &amp;&amp; pivot &gt;= data[low]) { low++; } //填右边坑 data[high] = data[low]; }//low = high跳出循环 //基准数找到正确的位置 data[low] = pivot; //处理所有比基准数小的数字 subSort(data,start,low); //处理所有比基准数大的数字 subSort(data,low+1,end); } } }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java总结(学习中)]]></title>
    <url>%2F2020%2F10%2F09%2FJava%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[辨析1.break和continue的相同点与不同点 使用场景 作用 break switch-case和循环 结束当前循环 continue 循环 结束本次循环 2.面向过程(procedure oriented programming)与面向对象(object oriented programming)例子:人把大象装进冰箱 面向过程:强调的是功能行为,考虑怎么做①把冰箱门打开②抬起大象，塞进冰箱③把冰箱门关闭 面向对象:强调具备了功能的对象,考虑谁来做面向对象的三个点:封装（encapsulation），继承（Inheritance），多态（polymorphism）实体：人、冰箱、冰箱人{ 打开(冰箱){ 冰箱.打开(); } 抬起(大象){ 大象.进入(冰箱); } 关闭(冰箱){ 冰箱.关闭(); }}冰箱{ 打开(){} 关闭(){}}大象{ 进入(冰箱){}} 3.成员变量与局部变量的区别 类型 位置 权限修饰符 默认初始化值 内存加载位置 成员变量 类的{}里 可以使用权限修饰符 根据其类型有默认初始化值 非static的 堆空间 局部变量 方法内、方法形参、构造器内、构造器形参、代码块内 不可以使用权限修饰符 没有默认初始化值,在调用局部变量前要显示赋值 栈空间 补充： 有默认初始化值-&gt; 数组元素、属性 4.区分方法的重载和重写① 重载：同类下同方法名不同形参列表的方法之间，构造器可以重载 重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作。构造器不能重载 ② 可以介绍一下重载和重写的具体规则 重载:两同一不同 -&gt; 同一个类、相同方法名，参数列表不同 重写:继承,同名同参数 ③ 重载：不表现为多态性 重写:表现为多态性 -&gt; 从编译和运行的角度看,编译器是知道同名不同参数列表的方法是不同得的方法,所以重载在编译时知道调用地址，所以是静态绑定的。而重写只有等方法调用的时候才知道具体的调用，所以是动态绑定的。 如何定位到一个方法: 1.先看方法名 2.对比参数列表 5.equals()与==的区别== : 运算符,基本数据类型比较数值(不一定数据类型一样),引用数据类型比较两个对象的地址值。 -&gt; == 符号使用时，左右两边的变量一致(可以通过某种方法统一)equals(): 方法,只使用于引用数据类型,没重写equals()比较的是地址，重写的比较的是实体内容 int i =10 double d = 10.0 //存在自动类型提升 //以 + 为例子，但是在其他运算符中也会存在自动类型提升 i == d //true， 6.sleep()和wait()的异同1.相同点：都可以使当前线程进入阻塞状态2.不同点声明的位置：Thread类中声明sleep，Object类中声明wait调用的范围：wait必须在同步代码块和同步方法中调用是否释放同步监视器：sleep方法不会释放当前占有的锁，而wait会释放当前占有的锁。 6.String类型值的两种不同赋值待解决1.面向对象的编程思想？ == 对于引用类型来讲，比较的是两个引用数据类型变量的地址值是否相同 2.new3.Java类什么时候加载，什么时候初始化。p331回看 理解1.万事万物皆对象？①在Java语言中，我们将功能、结构等封装到类中，通过类的实例化，来调用具体的结构②在与前端后端交互时，前后端的结构在Java层交互时，都体现为类、对象 2.println参数为char数组时的重载char[] arr = new char[]{&#39;a&#39;,&#39;b&#39;,&#39;c&#39;}; System.out.println(arr); //输出abc 而不是地址值]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础(学习中)]]></title>
    <url>%2F2020%2F09%2F25%2FJava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[第一章 Java概述java特点1.面向对象:类与对象两个基本概念，封装、继承与多态三大特点2.健壮性：吸收了c/c++语言的优点，去掉了其影响程序健壮性的部分3.跨平台:不同版本的JVM(java虚拟器) java两种核心机制1.Java虚拟机 Java Virtal Machines2.垃圾回收机制 Garbage Collection Java程序还是会出现内存泄露和内存溢出问题 JDK、JRE JDK(Java Development Kit) Java开发工具包：是提供给Java开发人员使用，其中包含了java的开发工具与JRE –&gt; JDK = JRE + 开发工具集(javac.exe,java.exe,javadoc.exe) JRE(Java Runtime Environment) Java运行环境:包括java虚拟机和hava程序所需的核心类库等，如果想要运行一个开发好的Java程序，只需要JRE即可 –&gt; JRE = JVM + Java SE标准类库 JDK的开发工具完成Java程序，JRE运行 java -javac 文件名.java 编译-&gt; .class文件（字节码文件） -java 字节码文件名 运行-&gt; 结果 注释 单行注释//多行注释/**/文档注释/** */,注释内容可以被JDK提供的工具javadoc所解析(javadoc -d 生成的文件夹名字 -author -version 文件名)，生成一套以网页文件形式体现的说明文档 注意 1.在一个java源文件中可以有多个类，但只能给与文件名一样的类添加public2.每一行执行语句都以;结束3.程序的入口是main()方法，格式是固定的 public static void main(String[] args){ System.out.println(&quot;输出语句换行&quot;); System.out.print(&quot;输出语句不换行&quot;); } 4.编译之后会生成一个或多个字节码文件，字节码文件的文件名与java源文件中的类名相同 第二章 基本语法Java命名规范(建议)包名：所有小写xxxyyy类名、接口名：驼峰命名法(第一个单词首字母大写)XxxYyy变量名、方法名：第一个单词首字母小写，其余单词首字母大写xxxYyy常量名：所有字母都大写，多单词用下划线连接xxx_yyy 变量1.Java中每个变量必须先声明并初始化后使用2.变量的作用域:其定义所在的一对{}内3.变量是程序中最基本的存储单元。包含变量类型、变量名和存储的值 –&gt; 数据类型 变量名 = 变量值 数据类型按数据类型分类: 1.string是class类型2.定义long型变量，必须以”l”或”L”结尾3.定义float型变量，变量要以”f”或”F”结尾4.char型初始化要有值,单引号括住 按声明的位置不同: 成员变量,在方法体外,类体内声明的变量 实例变量,不以static修饰 类变量,以static修饰 局部变量,在方法体内部声明的变量 基本数据类型之间的运算规则前提:这里讨论7种基本数据类型变量间的运算，不包含布尔类型。 1.自动类型提升 byte/short/char -&gt; int -&gt; long -&gt; float-&gt;double 当byte/short/char三种类型(同类型也是)做运算时,结果至少用int接收 java在做运算时，如果操作数均在int范围内，那么一律在int的空间内运算2.强制类型转换 - 自动类型提升的逆运算(强制转换的类型)xx 特殊情况情况1: long l = 12315465111 会把12315465111当作int型(此时会编译失败因为超出int的范围),类型提升到long型情况2: 浮点型默认的是double,所以float型后面一定需要添加f/F String1.String属于引用数据类型,双引号括住2.String可以与其他类型做连接运算 运算符只有单目运算符、三元运算符、赋值运算符是从右向左运算的 %：取余运算结果的符号与被模数的符号相同++/–/+=/-=/..：不会改变变量本身的数据类型=:支持连续赋值,类型相同可以赋值(或者变量提升),赋值时会先检查类型是否相同 int n =10 n += (n++) + (++n) // n = n + (n++) + (++n) // n = 10 + 10 + 12 逻辑运算符(操作数是布尔类型)-常用短路与/短路或 位运算符 - 最高效方式的计算 2*8? 2&lt;&lt;3 或 8&lt;&lt;1 交换两个变量的值1.使用临时变量2.m = (m^n)^n 有局限性:适用于数值类型 m = 原来n的值 三元运算符：(条件表达式)?表达式1：表达式2 流程控制Scanner类1.导包: import java.util.Scanner2.Scanner实例化Scanner scan = new Scanner(System.in)3.调用Scanner类的相关方法(next()/nextXxx())，来获取指定类型的变量 //使用scanner从键盘获取int型数据 import java.util.Scanner; class ScannerTest{ public static void main(String[] args){ Scanner scan = new Scanner(System.in); String num = scan.next(); } } 随机数Math.random() [0.0,1.0)公式:[a,b] –&gt; Math.random()*(b-a+1) + a switch根据switch表达式中的值，依次匹配case中的常量，有break才退出,没有会向下执行。switch结构中的表达式只能是byte、short、char、int、枚举类型、String类型 注意:在case中不要定义重复的变量，switch下的变量作用域是同一个 switch(表达式){ //合并 case 常量1: case 常量2: 语句; default: 语句; } 循坏循环结构的4个要素:①初始化条件②循环条件③循环体④迭代条件 for(①;②;③){ ④ } //for循环和while循环可以相互转化 ① while(②){ ③; ④; } 技巧：循环嵌套时，外层控制行数，内层控制列数 break和continue/return break: swich-case/循环结构 - 默认结束当前循环continue: 循环结构 - 默认结束当次循环 如果要结束外层的for，可以通过标签实现 label:for(..){ for(..){ .... break label; //结束指定标识的一层循环结构 } } return:并非专门用于结束循环的,当一个方法执行到一个return语句时,这个方法将被结束。 数组数组长度一旦确定就不能修改数组是一种特殊的类，因为它也继承了Object 一维数组的使用1.声明和初始化,初始化时要指定长度2.数组的长度,属性length3.数组元素的默认初始化值 -&gt; 整型(byte、short、int、long)0,浮点型(float、double)0.0，char型(ACSII=0),布尔型false(0),引用数据类型null。 //静态初始化 //int ids[] = 这种写法也可以 int[] ids = new int[]{1001,1002,1003} int arr[] = {1234,5}; //类型推断 //动态初始化,分配了5个空间 String[] names = new String[5]; 一维数组的内存解析虚拟机栈(stack):局部变量。堆(heap):new出来的结构,对象(非static的成员变量)、数组方法区：常量池(String…) + 类信息(方法) + 静态变量… 当局部变量没用之后，会依次出栈，堆里的空间会在一个不确定的时间被回收。 二维数组的使用 //静态初始化,可以省略new int[][] int[][] arr = new int[][]{{123},{4,5}}; int arr[][] = {{123},{4,5}}; //类型推断 //动态初始化[[0,0],[0,0],[0,0]] String[][] arr2 = new String[3][2] //动态初始化 String[][] arr2 = new String[3][] Arrays工具类java.util.Arrays类为操作数组的工具类 Arrays.equals(arr1,arr2) 判断两个数组是否相等,返回布尔值Arrays.toString(arr) 输出数组信息,返回StringArrays.fill(arr,val) 将val填充到arr数组中,返回voidArrays.sort(arr) 数组排序,返回voidArrays.binarySearch(arr,key) 二分查找key,arr需要有序,返回数组下标int,没找到返回负数]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9.14数组-主要元素]]></title>
    <url>%2F2020%2F09%2F14%2F9-14%E4%B8%BB%E8%A6%81%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[题目: 数组中占比超过一半的元素称之为主要元素。给定一个整数数组，找到它的主要元素。若没有，返回-1 示例: 输入：[1,2,5,9,5,9,5,5,5] 输出：5 输入：[3,2] 输出：-1 思路 首先需要知道数组的长度，其次是查询一个元素出现的次数比较是否超过数组长度的一半，若超过则输出该元素，如果没有超过，查询下一个元素。 实现过程 var majorityElement = function(nums) { let flag = 1 let number = nums.length/2 if(nums.length == 1){ return nums[0] } for(let i = 0;i&lt;nums.length;i++){ //获取到当前比较的元素 let current = nums [i] //如果当前元素是第一次出现则查询次数，如果不是第一次出现，则执行下一次循环 if(nums.indexOf(current) != i){ //不是第一次出现,则执行下一次循环 continue } for(let j = i+1;j&lt;nums.length;j++){ //获取到该元素的后续元素 if(current == nums [j]){ flag ++ } if(flag &gt; number){ console.log(flag) //如果次数已经超过了一半则直接返回该元素 return current } } } return -1 }; 其他方法 评论中提及最多的是使用Map容器，Map容器是一组key不重复的键值对的结构。 var majorityElement = function (nums) { //初始化一个max的作用是当前数组的元素仅一个时比较 let len = nums.length / 2, m = new Map(), max = 0 for (let num of nums) { //设置key为num，如果该key已经存在，当前值+1 m.set(num, m.has(num) ? m.get(num) + 1 : 1) //比较当前元素出现的次数与之前出现元素的最大次数 max = Math.max(max, m.get(num)) if (max &gt; len) { return num } } return -1 };]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9.13数组-转置矩阵]]></title>
    <url>%2F2020%2F09%2F13%2F9-13%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[题目:给定一个矩阵A,返回A的转置矩阵。矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。 示例： 输入：[[1,2,3],[4,5,6],[7,8,9]] 输出：[[1,4,7],[2,5,8],[3,6,9]] 输入：[[1,2,3],[4,5,6]] 输出：[[1,4],[2,5],[3,6]] 思路: 通过观察矩阵,发现当i(行数)=j(列数)时数字处于对角位置,不需要置换(也可以置换统一处理,置换后不影响);当i ≠ j 时,i与j需要发生置换。 实现过程 let transpose = function (A) { let newArray = new Array(A.length) for (let i = 0; i &lt; A.length; i++) { //得到每一行元素 for (let j = 0; j &lt; A[i].length; j++) { //得到每一个元素 newArray[j][i] = A[i][j] } } return newArray }; let test = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] console.log(transpose(test)); 问题1:报错:Cannot set property ‘0’ of undefined原因:需要先初始化数组,再进行赋值。 修改版本: var transpose = function(A) { let newArray = [] //根据A[0]的长度，为新数组创建一系列内部空数组 for (let i =0; i &lt; A[0].length; i++) { newArray[i] = [] } console.log(&#39;newArray&#39;,newArray); for(let i=0;i&lt;A.length;i++){ //得到每一行元素 for(let j=0;j&lt;A[i].length;j++){ //得到每一个元素 newArray[j][i] = A[i][j] } } return newArray }; 反思优化 看了别人的代码，发现可以在以下方面进行优化。初始化新数组的时候，如果使用arr[i][j] = A[j][i],可以少进行一次循环。这里可以多思考一下，现在才开始感觉思维并不是很开阔。 var transpose = function (A) { var rows = A.length var cols = A[0].length var arr = [] for (var i = 0; i &lt; cols; i++) { arr[i] = [] for (var j = 0; j &lt; rows; j++) { arr[i][j] = A[j][i] } } return arr } 还看见了一个更精简的。Array.from把v的伪数组(字符串也可)转换为真数组,第一个参数为有length属性的伪数组，第二个参数作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。暂时可以理解但自己想不出来。 var transpose = function(A) { return Array.from({length:A[0].length},(v,i)=&gt;A.map(v=&gt;v[i])) };]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义拷贝]]></title>
    <url>%2F2020%2F08%2F31%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B7%B1%E5%BA%A6%E5%85%8B%E9%9A%86%2F</url>
    <content type="text"><![CDATA[补充：循环引用 const obj1 = { a:1, b:[&#39;e&#39;,&#39;f&#39;], c:{h:{i:2}}, d:function(){} } //循环引用 obj1.b.push(obj1.c) obj1.c.j = obj1.b 大众版本问题1：函数属性会丢失(JSON存不了函数)问题2：循环引用会出错(死循环) function deepClone(target){ return JSON.parse(JSON.stringify(target)) } 面试基础版解决问题1：函数属性不会丢失仍然存在问题:循环引用会出错 function deepClone(target) { //数组/对象 if (target instanceof Array || (target !==null &amp;&amp; typeof target ===&quot;object&quot;)) { const cloneTarget = target instanceof Array ? [] : {} for (const key in target) { if (target.hasOwnProperty(key)) { cloneTarget[key] = deepClone(target[key]) } } return cloneTarget }else { return target } } 面试加强版本解决问题1：函数属性不会丢失解决问题2：循环引用解决思路: 目标：同一个对象/数组只能被克隆一次 创建克隆对象前：如果克隆对象已经存在，直接返回 创建克隆对象后：保存克隆对象 缓存容器：Map key:target value:cloneTarget 问题：为什么选择Map容器不使用对象？因为对象的键是字符串,使用Map容器保存的键是数组/对象，值是克隆之后的数组/字符串 function deepClone(target,map = new Map()) { //数组/对象 if (target instanceof Array || (target !==null &amp;&amp; typeof target ===&quot;object&quot;)) { //先判断是否已经产生了克隆对象 let cloneTarget = map.get(target) if (cloneTarget) { //如果产生了就直接返回克隆对象，不要对同一个对象多次克隆 return cloneTarget } //创建克隆容器 cloneTarget = target instanceof Array ? [] : {} //一产生克隆对象就存进去key:原容器、value为克隆产生的容器 map.set(target,cloneTarget) for (const key in target) { if (target.hasOwnProperty(key)) { //map缓存要继续用下去，不传就相当于又重新产生了一个map对象 cloneTarget[key] = deepClone(target[key],map) } } return cloneTarget }else { return target } } 面试加强版本2耗时：for..in &gt;&gt;&gt; for | forEach |while优化数组遍历性能：数组用for..in循环耗时太多 export function deepClone(target,map = new Map()) { //数组/对象 if (target instanceof Array || (target !==null &amp;&amp; typeof target ===&quot;object&quot;)) { //先判断是否已经产生了克隆对象 let cloneTarget = map.get(target) if (cloneTarget) { //如果产生了就直接返回克隆对象 return cloneTarget } //创建克隆容器 if (target instanceof Array) { cloneTarget = [] map.set(target,cloneTarget) //向数组添加元素 target.forEach((item,index)=&gt;{ cloneTarget[index] = deepClone(target[key],map) }) }else{ cloneTarget = {} map.set(target,cloneTarget) //向对象添加属性 for (const key in target) { if (target.hasOwnProperty(key)) { cloneTarget[key] = deepClone(target[key],map) } } } return cloneTarget }else { return target } }]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-文件]]></title>
    <url>%2F2020%2F08%2F30%2Fpython-%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[基础open()函数 通过open函数来打开一个文件参数： file 打开文件的名字(路径),如果在同一目录下直接使用文件名即可 encoding：文本文件的编码默认None，utf-8中文编码encoding = ‘utf-8’ mode:默认是读取文件,’r’只读;’w’可写,覆盖性的写;’a’追加内容;”+”为操作符增加功能’r+’可读可写、文件不存在报错…;x用来新建文件、文件存在则报错。读取模式写在r/w/a后面，默认是r读取文本文件，b读取二进制文件返回值： 代表当前打开文件的对象,可以看作是一个文件的标识符 read()方法文件标识符.read()用来获取文件中的内容，将内容全部保存为一个字符串返回。 如果读取的文件太大的话，会一次性将文件的内容加载到内存中，容易导致内存泄露，所以对于较大的文件，不要直接调用read() read()第一个参数size，读取文本文件时，size是以字符为单位的，读取二进制文件时，size用来指定用读取的字符数量，默认-1 如果多次调用read()会继续上一次读的内容继续往下读，如果已经读取到了文件的最后，则会返回’’空串 readline()方法/readlines()方法文件标识符.readline()用来读取一行内容文件标识符.readlines()该方法用于一行一行读取内容，会一次性将读取的内容封装到一个列表中返回for t in file_obj采用迭代也可以一行一行读 write()方法如果操作的是一个文本文件的话，则write()需要传递一个字符串作为参数，返回值是写入字符的个数文件标识符.write(string),一个文件多次调用write则会接着往后写 with as语句 文件标识符.close()用来关闭文件 with … as 语句,可以自动关闭文件with open(file_name) as file_obj: pass # 在with语句中可以直接使用file_obj做文件的标识符 # 这个文件只能在with中使用，一旦with结束则文件会自动close tell()/seek()方法文件标识符.tell()用来查看当前读取的位置文件标识符.seek()用来修改当前读取的位置，第一参数是要切换到的位置，第二个参数是计算位置方式0从头计算、1从当前位置开始计算、2从最后位置开始计算]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组声明式方法]]></title>
    <url>%2F2020%2F08%2F24%2F%E6%95%B0%E7%BB%84%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%B3%BB%E5%88%97%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[有两种编程方式:命令式和声明式 ·命令式编程：命令“机器”如何去做事情(how)，这样不管你想要的是什么(what)，它都会按照你的命令实现。·声明式编程：告诉“机器”你想要的是什么(what)，让机器想出如何去做(how)。 声明式内部的实现都已经封装好，只要按照要求传参数就可以。 map(callback):按照原始元素依次处理元素,返回新数组 callback2个参数，当前元素item、当前元素的下标indexreduce(callback,[initValie]):累计器,返回累计结果 callback4个参数,上一次调用回调返回的值(第一次为初始值)、item当前被处理的元素、index当前元素的索引filter(callback):过滤器,在数组中筛选出符合条件的元素，返回新素组 callback3个参数.当前元素、当前元素索引、当前元素所在的数组find(callback):找到数组中第一个满足条件返回true的元素 callback2个参数，当前元素、当前元素索引findIndex(callback):找到第一个满足条件返回true的元素下标 callback2个参数，当前元素、当前元素索引every(callback):数组进行检查，有一个元素不满足要求，整个表达式返回false，其余元素不检查 callback3个参数.当前元素、当前元素索引、当前元素所在的数组some(callbcak):对整个数组进行检查，如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。反之返回false。 callback3个参数.当前元素、当前元素索引、当前元素所在的数组 //产生一个每个元素都比原来大10的新数组 const arr = [1,3,6,9,15,19,16] console.log(arr.map((item,index)=&gt;item+10)); //得到所有奇数的和 console.log(arr.reduce((preTotal,item,index)=&gt;{ return preTotal + (item%2 ===1?item:0) },0)); //得到值大于8且下标是偶数的元素组成的数组 console.log(arr.filter((item,index)=&gt;index%2 ===0&amp;&amp;item&gt;8)); //找出一个值大于8且下标是偶数位的元素 console.log(arr.find((item,index)=&gt;index%2 ===0&amp;&amp;item&gt;8)); //找出一个值大于8且下标是偶数的元素的下标 console.log(arr.findIndex((item,index)=&gt;index%2 ===0&amp;&amp;item&gt;8)); //判断下标为偶数的元素是否都是奇数 console.log(arr.every((item,index)=&gt; index%2===1 || (index%2===0&amp;&amp;item%2 ===1))); //判断是否有下标为偶数的元素为奇数 console.log(arr.some((item,index)=&gt; index%2===1 || (index%2===0&amp;&amp;item%2 ===1))); 自定义 //map() Array.prototype.map = function (callback) { let arr = [] //遍历当前数组的每个元素，调用callback得到结果数据添加arr for (let index = 0; index &lt; this.length;index++) { let element = this[index] const result = callback(element,index) arr.push(result) } return arr } //reduce() Array.prototype.reduce = function (callback,initValue) { //结果为初始值 let total = initValue //遍历当前数组的每个元素，调用callback得到累加的结果数据 for (let index = 0; index &lt; this.length;index++) { let element = this[index] total = callback(total,element,index) } //返回结果 return total } //filter() Array.prototype.filter = function (callback) { let arr = [] //遍历当前数组的每个元素，得到布尔值 for (let index = 0; index &lt; this.length;index++) { let element = this[index] if(callback(element,index)){ arr.push(element) } } return arr } //find() Array.prototype.find = function (callback) { //遍历当前数组的每个元素，得到布尔值,为true返回当前的元素 for (let index = 0; index &lt; this.length;index++) { let element = this[index] if(callback(element,index)){ return element } } return undefined } //findIndex() Array.prototype.findIndex = function (callback) { //遍历当前数组的每个元素，得到布尔值,为true返回当前的元素下标 for (let index = 0; index &lt; this.length;index++) { let element = this[index] if(callback(element,index)){ return index } } return -1 } //every() Array.prototype.every = function (callback) { //遍历当前数组的每个元素，调用callback得到一个布尔值，一旦是false返回false for (let index = 0; index &lt; this.length;index++) { let element = this[index] const result = callback(element,index) if(!result){ return false } } return true } //some() Array.prototype.some = function (callback) { //遍历当前数组的每个元素，调用callback得到一个布尔值，一但是true，返回true for (let index = 0; index &lt; this.length;index++) { let element = this[index] const result = callback(element,index) if(result){ return true } } return false }]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call-apply-bind]]></title>
    <url>%2F2020%2F08%2F22%2Fcall-apply-bind%2F</url>
    <content type="text"><![CDATA[函数对象的call方法与apply方法 函数对象：函数像对象一样去使用,函数.xx。 共同点：1.这两个方法都是函数对象的方法，需要通过函数对象来调用2.当对函数调用 call()和apply()时，都会执行该函数3.call()和apply()的第一个参数为对象，执行call()与apply的函数对象里的this指向第一个参数 不同点：call()方法方法可以将实参在第一个参数对象之后依次传递apply()方法需要将实参封装到一个数组中统一传递 bind()、call()、apple()的区别 都能指定函数中的this Array.prototype.call()/Array.prototype.apply()是立即调用函数，Array.prototype.bind()是将函数返回 Array.prototype.call(obj)/Array.prototype.bind()从第二个参数开始依次传，Array.prototype.apply(obj)第二个参数是数组，传入的数据放入数组中 let obj ={name:&quot;ranan&quot;} function f(data,data2) { console.log(this); console.log(data + data2); return data+data2 } f.call(obj,33,22) //{name:&quot;ranan&quot;} 55 f.apply(obj,[33,22])//{name:&quot;ranan&quot;} 55 //所以apply通常用于将数组转化为函数的参数 let bar=f.bind(obj) //bind不调用函数 bar(33,22)//{name:&quot;ranan&quot;} 55 //上面也可以写成 f.bind(obj)(33,22)//{name:&quot;ranan&quot;} 55 Function.prototype.bind(obj) 作用:将函数内的this绑定为obj，并将函数返回(并不调用) 返回原函数的拷贝，我们称这个拷贝的函数为绑定函数。 将函数中的this固定为调用bind方法时的第一个参数， 绑定this之后，无论有哪个对象调用绑定函数，绑定函数中的this依旧之前绑定的第一个参数 如果绑定函数作为构造函数，已经捆绑的this会被忽略掉，this依然指向实例对象 function Person(name){ this.name = name; } var bindPerson = Person.bind({name:&quot;绑定函数&quot;}) new bindPerson(&quot;张三&quot;) // Person {name: &quot;张三&quot;} 通常用于指定回调函数的this，因为apply与call会立即调用 使用场景 保持上下文的方法 var o={ f: function () { var self=this; var fff=function() { console.log(this.value); // bind(this) 中 this 指向的是o，这里也可直接写成 bind(o) }.bind(this); fff(); }, value: &quot;Hello World!&quot; }; o.f(); // Hello World！ 总结 call() 立即调用函数 从第二个参数开始依次传 将函数内的this绑定为obj undefined/null this指向window bind() 将函数返回 从第二个参数开始依次传,指定返回函数的参数 将函数内的this绑定为obj undefined/null this指向window apply() 立即调用函数 第二个参数是数组，传入的数据放入数组中 将函数内的this绑定为obj undefined/null this指向window 应用call()/bind():根据伪数组生成真数据bind():vue中的事件回调函数内部 自定义 Function.prototype.call = function (obj,...args) { //参数被封装成数组 //处理obj是undefined与null的情况 if (obj === undefined || obj === null) { obj = window } //给obj添加一个方法tempFn,this指的是fn函数对象 obj.tempFn = this //fn里的this指向obj const result = obj.tempFn(...args) //调用后，删除obj上的该方法 delete obj.tempFn return result } Function.prototype.apply = function (obj,args) { //处理obj是undefined与null的情况 if (obj === undefined || obj === null) { obj = window } //给obj添加一个方法tempFn,this指的是fn函数对象 obj.tempFn = this //fn里的this指向obj const result = obj.tempFn(...args) //调用后，删除obj上的该方法 delete obj.tempFn return result } Function.prototype.bind = function (obj,...args) { //返回新函数 return (...args2) =&gt; { //调用原来函数，指定this为obj，参数列表由args和atgs2依次组成 return this.call(obj,...args,...args2) } }]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数节流和防抖]]></title>
    <url>%2F2020%2F08%2F22%2F%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96%2F</url>
    <content type="text"><![CDATA[事件频繁触发可能造成的问题？ 1.一些浏览器事件:window.onresize、window.mousemove等，触发的频率非常高，会造成浏览器性能问题2.如果向后台发送请求，频繁触发(搜索)，对服务器造成不必要的压力 如何限制事件处理函数频繁调用?1.函数节流2.函数防抖 函数节流(throttle) 理解: 在函数需要频繁触发时，函数执行依次后，只有大于设定的执行周期后才会执行第二次，适合多次事件按时间做平均分配触发场景： 窗口调整resize 页面滚动scroll DOM元素的拖拽功能实现mousemove 抢购疯狂点击click 函数防抖(debounce)理解： 在函数需要频繁触发时，在规定时间内，只让最后一次生效，前面的当作抖动不生效场景: 输入框实时搜索联想keyup、input 自定义 //用来返回节流函数的工具函数 function throttle(callback,delay){ let pre = 0 return function(event){ //Dom事件回调的函数里this是发生事件的标签 //节流函数/真正的事件回调函数 const current = Date.now() //当前时间 //事件触发后，节流函数也会被返回，只是满足一定的条件再调用 if (current - pre &gt; delay) { //只有离上一次调用callback的时间差大于delay //callback()是window调用的，所以callback函数里的this是window callback.call(this,event) //记录此次调用的时间 pre = current } } } //用来返回防抖函数的工具函数 function debounce(callback,delay){ //事件发生指定时间后才调用处理事件的回调函数 return function (event) { //如果上次事件还没有真正处理，又重复触发就取消它 if(callback.hasOwnProperty(&quot;timeoutId&quot;)){ clearTimeout(callback.timeoutId) } callback.timeoutId = setTimeout(() =&gt; { callback.call(this,event) //标记事件已经正在处理 delete callback.timeoutId }, delay); } }]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-class]]></title>
    <url>%2F2020%2F08%2F20%2Fpython-%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[类是type类型的对象，定义类实际上就是定义了一个type类型的对象。类和对象都是对现实生活中的事物或程序中内容的抽象 方法的每次被调用时，默认传递一个参数(调用方法的实例对象本身，类似this)，所以方法中至少要定义一个形参 使用类创建实例对象的流程1.创建一个变量mc2.在内存中创建一个新对象(type=Person)3.调用init方法4.将新对象的id赋值给变量ranan 类的定义 1.属性和方法的查找流程：先找自身对象 -&gt; 再找类对象2.类中定义的属性和方法都是公共的，任何该类实例都可以访问。但是方法中不能直接访问类中的属性 所以一般情况下，属性保存到实例对象中，方法保存到类对象中。 类的init方法类中有一些特殊方法,以__开头，__结尾。特殊方法不需要自己调用。 类的init方法类似与构造器,调用类创建对象时，类后边的所有参数都会依次传递到init()中 实例方法实例方法:以self为第一个参数的方法实例调用时，会自动将当前调用对象作为self传入当通过类调用时，不会自动传递self，必须手动传入 类方法在类内部使用@classmethod 来修饰的方法属于类方法类方法的第一个参数是cls(class),也会被自动传入，cls就是当前的类对象类方法可以通过类去调用，也可以通过实例调用，没有区别 静态方法在类中使用 @staticmethod来修饰的方法属于静态方法，静态方法不需要任何默认参数。静态方法可以通过类和实例去调用，静态方法基本是一个和当前类无关的方法，只是一个保存到当前类中的函数，一般都是一些工具方法。 # class 类名([父类]): # 没父类括号也可以省略 # 代码块 class Person: def __init__(self,name): self.name = name def hello(self): print(&quot;你好!&quot;) @classmethod def test(cls): print(&quot;这是类方法&quot;) # mc为类Myclass的实例 # 调用Person等于调用init ranan = Person(&#39;biubiu&#39;) # 默认传递一个参数 ranan.hello() 类属性:属于类实例属性:只能通过实例对象来访问和修改，属于实例类方法:第一个参数cls实例方法:第一个参数self静态方法:不默认传参 封装为了增加数据的安全性，引入了封装的概念，封装是面向对象的三大特性之一。 封装指的是隐藏对象中一些不希望被外部访问到的属性或方法。 封装的优点:1.隐藏了属性名，使调用者无法随意的修改对象中的属性2.增加了getter和setter方法，很好的控制了属性是否只读3.使用setter方法设置属性，可以增加数据的验证，确保数据的值是正确的4.使用getter方法获取属性，使用setter方法设置属性，可以在读取属性和修改属性的同时做一些其他的处理 如何隐藏一个对象的属性名? - 将对象的属性名，修改为一个外部不知道的名字 如何获取/修改对象中的属性？ - 提供getter和setter方法使外部可以访问到属性 - getter获取对象中的指定属性(get_属性名 ) class Dog: &#39;&#39;&#39; 表示狗的类 &#39;&#39;&#39; def __init__(self,name): self.hidden_name = name def get_name(self): return self.hidden_name def set_name(self,name): self.hidden_name = name 隐藏属性 上述的方法其实通过hidden_name还是可以访问到，如果想彻底隐藏，可以为对象的属性使用双下划线开头__xxx，是对象的隐藏属性(私有属性)，隐藏属性只能在类内访问，类外不能访问。 其实隐藏属性只不过是Python自动为属性改了名字，实际上是将名字修改成_类名_属性名。所以一般不用这种方式。 一般我们会将一些私有属性以—开头结合封装假装是私有属性。 property装饰器 property装饰器用来将一个get方法，转换为对象的属性，让我们像调用属性一样使用get方法使用property装饰的方法名必须和属性名一样,setter方法的装饰器:@属性名.setter(属性名不算上下划线，因为下划线仅仅表示这是一个私有属性) class Dog: &#39;&#39;&#39; 表示狗的类 &#39;&#39;&#39; def __init__(self,name): self._name = name # def get_name(self): # return self.hidden_name @property def name(self): return _self.ame @name.setter def name(self,name): self._name = name print(p.name) p.name = &#39;xxx&#39; 继承继承是面向对象的三大特性之一，子类可以直接继承父类中的所有的属性和方法。继承之后子类的实例也是父类的实例。class 类名(父类): –如果创建类时,省略了父类，则默认父类为object super()如果子类有自己init，希望可以直接调用父类的init来初始化父类中定义的属性super()可以用来获取当前类的父类，super()返回对象调用父类方法时，不需要传递self class Animal: def __init__(self,name): pass class Dog(Animal): def __init__(self,name,age): super().__init__(name) self._age = age 多重继承 在开发中没有特殊情况，应该避免使用多重继承，因为多重继承会让代码过于复杂 __bases__这个属性可以用来获取当前类的所有父类,返回一个元组。 在python中，一个类可以同时有多个父类,如果多个父类中有同名方法，则会先在第一个父类中寻找、然后找第二个…… class Dog(Animal1,Animal2): pass 多态多态是面向对象的三大特征之一，多态从字面上理解是多种形态，比如狗(狼狗，藏獒….都是狗的形态),一个对象可以使用不同的形态去呈现。 # 对于say_hello()这个函数来说，只要对象中含有name属性，就可以作为参数传递 # 这个函数并不会考虑对象的类型，只要有name属性即可 def say_hello(obj) print(&quot;你好%s&quot;%obj.name) # say_hello2违反了多态，因为要求对象是A的实例 # 违反了多态的函数，只适用一种类型的对象，函数的适应性 def say_hello2(obj2) if isinstance(obj,A): print(&quot;你好%s&quot;%obj.name) 鸭子类型：如果一个东西，走路像鸭子，叫声像鸭子，那么它就是鸭子？？ 特殊方法特殊方法一般不需要手动调用，在一些特殊情况下自动调用 __new__在创建对象时调用__ninit__(self,[....])初始化对象时调用__del__(self)对象删除前调用 当我们打印一个对象时，实际上打印的是对象中的特殊方法__str__(self)的返回值，这个方法将对象转换成字符串的时候调用__repr__(self)在当前对象使用repr()函数时调用，它的作用是指定对象在交互模式中输出的效果 class Person: # __gt__会在对象做大于比较的时候调用，该方法的返回值将会作为比较的结果 self&gt;ohter,self是比较左边的，other是比较右边的 def __gt__(self,other): return self.age &gt; other.age p1 = Person() # print(p1) 实际上等于 print(str(p1)),调用了对象内部的__str__(self) 特殊方法 print(p1) print(repr(p1))]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[debug调试]]></title>
    <url>%2F2020%2F08%2F20%2Fdebug%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[调试的目的1.查找bug:不断缩小可疑代码的范围2.查看程序的运行流程，用于熟悉接手项目的代码 如何开启调试模式1.运行前添加debugger语句,常用于打包后才运行的项目2.浏览器打断点，程序运行前或者过程中，常用于运行源码js 调试操作 resume:恢复程序的执行，可能程序执行完或者进入下一个断点处step over:单步跳转，尝试执行完当前语句(如果内部有断点，自动跳入内部断点处)，进入下一条语句step into:跳入，进入当前调试函数内部，停在函数第一条语句前step out:跳出，一次性执行完当前函数后面所有语句并出去deactivate breakpoints: 使所有断点暂时失效 call stack: 调用栈，显示程序函数调用的过程scope:作用域链，当前执行环境对应的作用域中包含的变量数据 注意点:1.如果想看回调函数内部的一步步实现，给异步函数内部打断点，因为回调函数放入队列中执行。]]></content>
      <categories>
        <category>前端</category>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue2.0源码分析]]></title>
    <url>%2F2020%2F08%2F19%2Fvue2.0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[数据代理实现更新显示 data对象的所有属性的操作由vm对象来代理操作好处:通过vm对象就可以方便的操作data中的数据实现：1.通过Object.defineProperty(vm,key,{})给vm添加data对象的key2.所有添加的属性都设置get/set方法3.读/改vm对象时,通过get/set返回/修改data中对应的属性值 const vm = new Vue({ data:{ name:&#39;tom&#39; } }) console.log(vm.name,vm._data.name) //tom 代理读 vm.name = &#39;jack&#39; //代理写 console.log(vm._data.name) //jack 模板解析实现初始化显示 基本流程:使用DocumentFragment，一次页面更新批量处理DOM 1.将el元素中的所有子节点保存到一个fragment容器2.编译fragment中所有层次子节点 - 对表达式文本节点进行解析 - 对元素节点的指令属性进行解析 3.将编译好的fragment插入到el中 插值语法 1.根据正则对象得到匹配出的表达式字符串:子匹配/RegExp.$12.从data中取出表达式对应的属性值3.将属性值设置为文本节点的textNode.textContent &lt;p&gt; {{name}} &lt;/p&gt; 事件指令指令（Directives）带有前缀 v- elementNode.addEventListener(“eventName”,callback.bind(vm)) 1.从指令中取出事件名2.根据指令的值从methods中得到对应的事件处理函数对象3.给当前节点绑定指定事件名和回调函数的DOM事件监听4.解析完之后在节点中移除指令属性 // button.addEventListener(&quot;click&quot;,this.test.bind(vm)) //test里面的this指向vm &lt;button v-on:click=&quot;test&quot;&gt;&lt;/button&gt; 一般指令1.得到指令名和指令值2.从data中根据表达式得到对应的值3.根据指令名确定需要操作元素节点的属性 v-text -&gt; elementNode.textContent = value v-html -&gt; elementNode.innerHTML = value v-class -&gt; elementNode.className += value4.将得到的表达式的值设置到对应的属性上5.移除元素的指令属性 数据绑定数据绑定 数据绑定:一旦更新了data中的某个属性数据，所有界面上直接使用或间接使用了此属性的节点都会更新 数据劫持 数据绑定是实现的效果，数据劫持是实现数据绑定的一种技术 数据劫持是vue中用来实现数据绑定的一种技术。基本思想:通过defineProperty()来监视data中所有的属性(任意层次)数据的变化，一旦变化就去更新界面。 发布者-订阅者模式 发布者:observer对象，对data中所有层次属性进行监视，包含监视data数据的setter方法。发生变化更新data中的数据，并通知dep。 订阅器(中间者):dep对象，个数与data中的属性一一对应，每个属性的setter都引用了对应的dep对象用于通知dep数据发生了改变，并且每个dep对象与watcher建立了n:n关系。dep接收到发布者通知后通知对应的watcher订阅者。 订阅者:watcher对象，包含更新对应节点的回调函数。个数与模板表达式(插值/一般指令)一一对应。更新对应的节点。 watcher -&gt; dep 用于判断当前watcher与dep关系是否已经建立dep -&gt; watcher 用于通知watcher对象更新对应的节点。 黑色初始化，红色数据发生变化 双向数据绑定双向数据绑定是建立在单向数据绑定(model-&gt;view)的基础上 实现流程:1.解析v-model指令时，给当前元素添加input监听2.当input的value发生改变时，将最新值保存到表达式在data中对应的属性上-&gt;触发数据绑定 什么是单向数据绑定？什么是双向数据绑定? 双向数据绑定:model改变view自动更新，view改变model自动更新。单向数据绑定:model -&gt; view 单向绑定：插值形式，v-bind也是单向绑定双向绑定：表单的v-model，用户对View层的更改会直接同步到Model层]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mutations常量中括号]]></title>
    <url>%2F2020%2F08%2F19%2Fmutations%E5%B8%B8%E9%87%8F%E4%B8%AD%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[学习vuex一直有一个疑问，为什么mutations里面方法名要加上大括号? 通过看文档以及查资料发现了原因 为什么使用常量代替?使用常量代替mutation事件类型可以让工具发挥作用，且把常量放在单独的文件中可以让让你的代码合作者对整个app包含的mutation一目了然 为什么使用中括号原来这里使用的是ES6的写法，一下子没转过弯 首先mutations.js对象,在ES6中的对象的扩展中讲到了方法的简写。如下列代码所示，由于对象的属性名就算没有添加引号也会自动的加上引号变成字符串，some_mutation会被解析成’some_mutation’,但如果我们使用的是变量SOME_MUTATION，那么需要对属性名添加中括号。 //-------------ES5的写法 const SOME_MUTATION = &#39;some_mutation&#39; let mutations = {} mutations[SOME_MUTATION] = function (state) {// mutate state} //方法,对象的属性名会自动被解析成字符串 const mutations = { //方法名，会自动被解析成字符串&#39;some_mutation&#39; some_mutation:function(){ } //如果方法名是变量 [SOME_MUTATION]some_mutation:function(){ } } //方法的简写 const mutations = { [SOME_MUTATION](){ } }]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex学习笔记]]></title>
    <url>%2F2020%2F08%2F18%2Fvuex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[流程图 基本使用//store/index.js /* vuex最核心的管理对象模块 */ import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; Vue.use(Vuex) //这部分可以单独写成一个文件，然后通过import引入 const state = {} const mutations = { FN(state){ //state状态更新 } } const actions = { fn({commit,state}){ commit(&quot;FN&quot;) } } //依赖state里面的属性，计算生成的属性写在getters里面 const getters = { xxx(state){ //计算 } } //建立统一数据容器，唯一的容器 let store = new Vuex.Store({ state, mutations, actions, getters }) stat:状态对象 mutations: 操作state,直接更新state的多个方法对象 只操作state,若组件中只需要修改state无异步无逻辑操作，可以直接操作mutations actions commit–&gt; 操作mutations 间接更新state的多个方法对象 异步操作、逻辑代码处理、发送请求 getters:包含多个基于state的getter计算属性的对象 mutations-type:包含n个mutations的type名称常量 store 对象中的属性1.state 包含所有state数据的对象2.getters 包含所有getter计算属性的对象3.dispatch(actionName,data) 触发action调用4.commit(mutationName,data) 触发mutation调用 store(容器)注册到实例上，main.js里面，所有的组件都会有一个属性$store import store from &#39;&#39; new Vue({ store, }) //----------组件对象中 //在组件中使用 {{$store.state.XXX}} //在js中使用 this.$store.xxx 使用map函数简化store使用map函数，参数是数组，返回值为对象。使用的前提是计算属性/方法名等要和store里面的名字一致。 import {mapState,mapGetters,mapMutations,mapActions} from &quot;vuex&quot; //常用mapState，mapGetters computer:{ count(){ return this.$store.state.count } //使用map函数 ...mapState([&#39;count&#39;]) //返回值{count(){return this.$store.state[&#39;count&#39;]}},...解构出来 ...mapGetters([&#39;evenOrOdd&#39;])//返回值{evenOrOdd(){return this.$store.getters[&#39;evenOrOdd&#39;]}},...解构出来 } methods:{ increment(){ this.$store.commit(&#39;INCREMENT&#39;) } //使用map函数写法 ...mapMutations({increment:&#39;INCREMENT&#39;}) } 拆分文件store/index.js vuex最核心的管理对象store import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; import state ..... //引入state,getters等文件 export default new Vuex.Store({ state, mutations, actions, getters }) //此文件在项目根目录index.js里面进入store,并在Vue中注册store，让所以组件都能通过$store看到store对象 store/state.js store/mutations-types 包含n个mutation函数名的常量模块 export const REQ_SUCCESS = &#39;req_success&#39; store/mutations.js 一个包含n个用于直接更新状态数据的方法的对象模块 import {REQ_SUCCESS} from &#39;./mutation-types&#39; export default{ //直接使用REQ_SUCCESS被解析成&#39;REQ_SUCCESS&#39; [REQ_SUCCESS](state,y){ state.xxx = true state.yyy = y //y是从action里接收的数据 } } store/actions.js 一个包含n个用于间接更新状态数据的方法的对象模块，可以包含异步和逻辑处理代码 import {REQ_SUCCESS} from &#39;./mutation-types&#39; export default{ //搜索的异步action，包含了异步代码的action async search({commit},params){ //params用于异步ajax请求获取数据的参数 //如果成功了，提交请求成功的mutation //这种写法传递的数据y本身 commit(REQ_SUCCESS,y) //还可以通过对象的形式来传递 commit(REQ_SUCCESS,{y}) //这种写法mutations里应该改成 [REQ_SUCCESS](state,{y}) } } store/getters.js 一个包含n个基于state的getter计算属性方法的对象模块，]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS常用操作总结]]></title>
    <url>%2F2020%2F08%2F13%2Fjs%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[判断对象是否是数组/对象的元素/属性(常用于对象) in 格式： 变量 in 对象/数组当是数组时，变量指的是索引(不常用)当是对象时，变量指的是对象的属性名 (对象)Object.prototype.hasOwnProperty(value) 格式:object.hasOwnProperty(value)该方法只能判断对象自身属性是否存在，对于继承属性会返回false (常用于数组和字符串) Array.prototype.includes(value) 格式:array/string.includes(value) 返回值为布尔值。以前判断用indexOf返回的是数字。 (常用于数组和字符串) Array.prototype.indexOf(value)/lastIndexOf(value) 返回value在数组中出现的第一个下标和最后一下下标，没有出现则返回-1应用场景：两个方法结合判断下标是否相等，可以用来判断数组中唯一出现的值 如何判断数据类型typeof返回的数据类型:String,Number,Boolean,Undefined,Object(Array,null也是),Function，不能准确的确定数据的类型。 Object.prototype.toString.call() Object.prototype.toString.call(target)可以区分各种类型，但它无法区分自定义对象类型，自定义类型可以采用instanceof区分。 那么为什么Object.prototype.toString.call(target)可以区分？ toString方法返回反映这个对象的字符串（除了null和undefined之外） console.log({name:&quot;张三&quot;}.toString());//[object Object] console.log([1,2].toString());//1,2 console.log(typeof [1,2].toString())//String obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？ 因为toString为Object的原型方法，而Array,function等类型作为Object的实例重写了toString方法，调用toString方法时，优先调用的是重写之后的toString方法，所以要使用Object原型上的toString才可以反映对象的具体类型。 遍历对象的遍历性能 for..in/keys+forEach 耗时差不多 for..in 循环的是key for (const key in object) { if (object.hasOwnProperty(key)) { const element = object[key]; } } Object.keys(obj) + forEach Object.keys(obj).forEach(key =&gt;{ const element = object[key]; }) 数组遍历性能for..in / for /forEach/while耗时：for..in &gt;&gt;&gt; for | forEach |while 将伪数组转化成真数组使用场景:所有dom元素获取的标签都是伪数组,当需要对伪数组进行遍历的时候就需要转化成真数组。 伪数组:最基本的要求就是具有length属性的对象,length属性的值为数字下标的个数,对象的属性名必须为数值型或字符串型的数字。 obj={ &quot;0&quot;:&quot;zhang&quot;, &quot;1&quot;:18, length:2 Array.from(lis) 此方法是ES6的语法 返回一个真数组，第一个参数为伪数组,还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 扩展运算符 ES6的语法 let newArr= [...obj] [].slice.call(lis) 此方法是ES5的语法 [].slice.call(obj) = Array.protype.slice.call(obj) [].slice() slice会通过索引位置获取新的数组，该方法不会修改原数组，只是返回一个新的子数组。没传参数相当于返回一个浅拷贝。该方法内部是通过for循环和length结合实现的，可以改变为伪数组调用call会把this的指向改为传进去的obj，call()会立即调用slice函数此方法会让obj/伪数组拥有slice()方法且立即调用该方法 数组去重方法一:利用forEach和indexOf，会有隐式遍历。方法二:利用forEach和对象容器,只需要一重遍历，效率更高。方法三，ES6语法，Set容器的元素唯一与三点运算符。 /* 方法一，利用forEach和indexOf */ export function unique1(array) { let arr = [] array.forEach(item =&gt; { if (arr.indexOf(item) === -1) { //indexOf隐式遍历 arr.push(item) } }); return arr } /* 方法二，利用forEach和对象容器 只需要一重遍历，效率更高 */ export function unique2(array) { let arr = [] let contain = {} //属性名是item，属性值是true，主要判断的属性名 array.forEach(item =&gt; { if (!contain.hasOwnProperty(item)) { arr.push(item) contain[item] = true //arr与contain容器数据保持一致 } }); return arr } /* 方法三，ES6语法，Set容器的元素唯一与三点运算符 */ export function unique3(array) { return [...new Set(array)] }]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router学习笔记]]></title>
    <url>%2F2020%2F08%2F12%2Fvue-router%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Vue Router 是 Vue.js官方的路由管理器 import Vue from &#39;vue&#39; impor VueRouter from &#39;vue-router&#39; //使用Vue插件 Vue.use(VueRouter) //创建路由器的构建函数 new VueRouter({ //应用中所有路由 routes:[ ] }), //路由配置 routes:[ { path:&quot;&quot;, component: }, ] //注册路由器 import.... //引入路由 new Vue({ router //所有组件都能通过$router属性看到router对象,所有组件都有一个代表当前路由的$route数据 }) //使用 //用来生成路由链接 &lt;router-link to=&quot;&quot;&gt;&lt;/router-link&gt; //用来显示当前路由组件界面 &lt;router-view&gt;&lt;/router-view&gt; 路由配置通过$route可以获取到当前的路由数据。 routes:[ { path:&quot;/home&quot;, component: redirect: //重定向路由 children:[//注册子路由 path:&quot;/home/news&quot; component: children:[ { //动态路由 path:&quot;/home/news/detail/:id&quot; }, { //进入/home后自动显示当前的子路由 path:&quot;&quot;, redirect:&quot;/home/news&quot; } ] ] } path加/和不加/有什么区别 /xx就是根路径。下面代码去到children是/#/child而不是/#/fa/child。而不以斜杠开头的，都会被当成普通的字符串拼到当前路径的后面。 path: &quot;/fa&quot; children: { path: &quot;/child&quot; } 路径参数1.query参数，跟在路径?后面2.params参数 动态路由及监视 路由组件对象是在第一次请求对应路径时才创建，从一个路由组件离开、路由组件死亡，再进入需要重新创建。当在同一个路由路径上做切换(只是改了参数),当前路由组件对象被直接复用,也就是说组件的生命周期钩子不会再被调用。 解决办法:1.监视$route watch:{ &#39;$route&#39;(to,from){ //当请求参数发生改变时，内部指定了新的$route属性，所以一般监视就可以了 } } 2.路由导航 编程式路由导航 声明式:router-link编程式:$router.push()/replace() push往栈中放元素，repalce是替换栈顶元素。 命名路由 path:&quot;/home&quot;, component: redirect: //重定向路由 name:&quot;home&quot; 通过name关键字对该路由进行命名，在router-link中的路径可以直接使用命名路由:to:&quot;{name:home,params:{id}}&quot;来使用,第一个表示跳转之后的路由，第二个表示传递该路由的参数，这种写法也可以使用在编程式路由导航之中。 props 可以将路由参数映射成props在路径配置中设置props之后，会自动把接收的parmas参数以标签属性传入路由组件 // 之前通过$route来获取参数 ID：{{$route.params.id}} //将路由参数映射成props props:[&quot;id&quot;] routes:[ // 在路径中设置props之后，会自动把接收的parmas参数以标签属性传入路由组件 //布尔写法 {path:&#39;/user/:id&#39;,props:true} //函数写法,可以获取query参数 { path:&#39;/user/:id&#39;, //函数返回的对象中的所有属性都会以标签属性传入组件中 props:(route) =&gt; ({ id:route.params.id, name:route.query.name }) } ] router-link router-link-active 表示当前被选中的link的类名 router-link与a标签的区别a点击之后，会发送普通的HTTP请求,刷新页面。路由链接点击后不会发送请求，不会刷新页面会局部更新组件。 HTML5 history模式const router = new VueRouter({ mode:&quot;history&quot;, //应用中所有路由 routes:[...] }) history模式与history模式 hash模式 路径:http://localhost:8000/#/home 发送请求的路径:http://localhost:8080 响应:返回index页面 -&gt; path(/home)被解析为前台路由路径 hash模式无论在什么路径下请求的都是根路径，#之后的路径发请求的时候不会携带。 history模式 路径:http://localhost:8000/home 发送请求的路径:http://localhost:8000/home 响应: 404错误 希望: 如果没有对应的资源，返回index页面 -&gt; path(/home)被解析为前台路由路径 解决办法:添加配置 devServer:true, output:publicPath:”/“ //webpack.config.js module.exports = { //开发服务器配置 devServer:{ //更详细的可以看文档 //fallback：planB的意思 histortApiFallback:true } //可能还需要配置出口的publicPath:&quot;/&quot;，引入打包文件的路径左侧以/开头 } 缓存路由组件keep-alive路由组件对象在访问对应路径的时候创建，默认情况下，切换到其他路由对象会死亡释放，再切换回来是重新创建的组件对象 &lt;keep-alive&gt;能在组件切换的过程中将状态保留在内存中，防止重复渲染DOM。 设置了keepAlive缓存的组件： 第一次进入：beforeRouterEnter -&gt;created-&gt;…-&gt;activated-&gt;…-&gt;deactivated 后续进入时：beforeRouterEnter -&gt;activated-&gt;deactivated activated和deactivated仅在keepAlive缓存的组件里被激活只有第一次进入该组件时，才会走created钩子，而需要缓存的组件中activated是每次都会走的钩子函数。 属性1.include: 字符串或正则表达式。只有匹配的组件会被缓存。2.exclude: 字符串或正则表达式。任何匹配的组件都不会被缓存。 // 需要对组件对象进行name命名 &lt;keepAlive exclude=&quot;组件的name名&quot;&gt; &lt;/keepAlive&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件通信]]></title>
    <url>%2F2020%2F08%2F06%2Fvue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[一个组件接收属性数据不是用来直接修改，只是用来读取显示的，所以子组件最好不要直接修改父组件的值，通常通过set来设置。 父子组件传值父传子父组件传值 通过动态绑定数据传值 &lt;Person :age =&quot;age&quot; /&gt; 子组件接收语法:props:[]/{} //更详细的查看文档 props:{ //简单的检测类型 height:Number, //检测类型+其他验证 age:{ typr:Number, default:0, required:true } } slot父组件 -&gt; 子组件 带数据的标签结构 插槽相当于占位,本身不显示。传给插槽的是静态页面,相关的数据等解析是在父组件解析好了再传给子组件的,所以需要的数据和方法都定义在父组件。 //子组件 &lt;slot name=&quot;slotName&quot;&gt;如果父组件没传默认显示的内容&lt;/slot&gt; //父组件在子组件的标签体内传值 &lt;Son&gt; &lt;h1 slot=&quot;slotName&quot;&gt; 如果子组件有多个插槽，可以指定传给哪个插槽 &lt;/h1&gt; &lt;/Son&gt; 子传父1.如果子组件要更新父组件的数据，调用父组件的更新函数来更新父组件的数据。 自定义vue事件 this.$emit(“myEvent”,value) 表示子组件向父组件分发myEvent事件 父组件监听(以-命名)myEvent事件后，触发doSomething回调函数调用 //@ 绑定事件监听 &lt;my-component @my-event=&quot;doSomething&quot;&gt;&lt;/my-component&gt; 2.this.$emit(update: prop, “newPropVulue”) 使子组件向父组件传达：更新属性，并抛出新的属性值。 从上述代码中可以看出首先更新的值要是从父组件中接收的，也就是props里面的值。其次父组件该值需要写成 &lt;ProjectPagination :filter-data=&quot;filterData&quot; @update:filter-data=&quot;filterData=$event&quot;&gt;&lt;/ProjectPagination&gt; 更简单的写法是.sync修饰符 &lt;ProjectPagination :filter-data=&quot;filterData&quot; :filter-data.sync=&quot;filterData&quot;&gt;&lt;/ProjectPagination&gt; 注意:这里有一个Vue.sync修饰符与$emit(update:xxx)写法的坑 使用.sync修饰符 //有效 this.$emit(&quot;update:filterData&quot;, this.data.slice(0, val)); //无效 this.$emit(&quot;update:filter-Data&quot;, this.data.slice(0, val)); 不使用.sync修饰符 //无效 this.$emit(&quot;update:filterData&quot;, this.data.slice(0, val)); //有效 this.$emit(&quot;update:filter-Data&quot;, this.data.slice(0, val)); 兄弟组件传值所有组件对象的原型对象都是不同的vm,所有的vm都是Vue的实例、都有一个共同的原型对象。 又根据这个特点，利用原型链实现子孙组件通信与兄弟组件通信 用来分发事件以及绑定事件监听的全局对象被称为全局事件总线(Global Event Bus) //在vue原型上创建一个全局事件总线对象，所有的组件都可以看见这个事件总线 Vue.prototype.$globalEventBus = new Vue() //可以优化，不用再创建一个vue实例 new Vue({ beforeCreate(){ Vue.prototype.$globalEventBus = this } }) //一个组件分发事件 this.$globalEventBus.$emit(&quot;分发事件名&quot;,value) //一个组件进行事件监听 this.$globalEventBus.$on(&quot;监听的事件名&quot;,function触发的回调函数)]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础]]></title>
    <url>%2F2020%2F07%2F31%2Fpython-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[基础Python是解释型语言，用途有Web应用、爬虫程序、科学计算、自动化运维、大数据、云计算、人工智能等。 补充:解释型语言:不会在执行前对代码进行编译，而是在执行的同时一边执行一边编译。 Python开发环境搭建开发环境搭建就是安装Python的解释器安装解释器的同时会安装python开发工具IDLE，在IDLE中可以通过TAB键来查看代码的提示。交互模式写一行执行一行，并不适用于我们日常的开发。 基本语言1.Python中严格区分大小写2.Python中的每一行就是一条语句，每条语句以换行结束3.Pyhton中每一行语句不要太长4.一条语句可以分多行编写，以\结尾5.Python是缩进严格的语言6.注释符#，习惯上注释符后跟一个空格 字面量和变量字面量表示的意思就是它的字面的值，在程序中可以直接使用，比如:1,2,’hello’变量可以用来保存字面量 Python中使用变量，不需要声明，直接变量赋值，但不能使用没有赋值的变量。Python是一个动态类型的语言，可以为变量赋任意类型的值。 数据类型数值Python数值分成了整数、浮点数、复数。在python中所有的整数都是int类型，如果数字的长度过大，可以使用下划线作为分隔符，比如123456可以写成123_456 其他进制的整数二进制0b 八进制0o 十六进制0x 在python中所有小数都是float类型，对浮点数进行运算时，可能得到一个不精确的结果。 字符串 大部分同JS类似。1.用三重引号来表示JS中的模板字符串。2.字符串不能和其他类型进行加法运算3.在创建字符串时，可以在字符串中指定占位符,%s在字符串中表示任意字符4.格式化字符串，可以通过在字符串引号外面添加f来创建一个格式化字符串,在格式化字符串中可以直接嵌入变量,该变量必须已经赋值。 # 表示用孙悟空替换%s b = &#39;Hello %s&#39;%&#39;孙悟空&#39; b = &#39;Hello %s 你好%s&#39;%(&#39;tom&#39;,&#39;孙悟空&#39;) # 还可以限制位数，不够就补空格 b = &#39;Hello %2s&#39;%&#39;孙悟空&#39; # 表示限制在3-5之间 b = &#39;Hello %3.5s&#39;%&#39;孙悟空&#39; # %f 浮点数占位符,会四舍五入 # %d 整数占位符，不会四舍五入 b = &#39;Hello %.5f&#39;%123.123 # 打印 print(&quot;a=&quot;,a) print(&quot;a=%s&quot;%a) print(f&#39;a={a}&#39;) # 格式化字符串 c = f&#39;hello{a}&#39; 字符串的复制 字符串和数字相乘，则解释器会将字符串重复指定的次数并返回。 a=&#39;abc&#39; a= a*2 print(a) abcabc 布尔值和空值 True表真，False表假，注意开头大写，布尔值实际上也属于整型，True相当于1，False相当于0。 None空值专门表示不存在 类型检查type type()用来检查值的类型，返回值为其类型 对象object 一切皆对象,上面的数据类型都是对象，程序运行当中，所有的数据都是存储到内存中然后再运行，对象是内存中专门用来存储指定数据的一块区域，对象实际上就是一个存储数据的容器。 每个对象都要保存三种数据 id 标识 通过id()来查看对象的id，在CPython中,id就是对象的内存地址，id一旦创建就不能改变。 type 类型 用来表示对象所属的类型，如int str float bool等，通过type()查看类型，Python是一门强类型语言，类型创建后不可以改变。 value 值 值就是对象中存储的数据，可变对象的值可以改变，不可变对象的值不可以改变。 在python中，对象并没有直接存储到变量中，变量更像是给对象起的别名，变量中存储的是对象的id(地址)。 变量中保存的对象id，只有在为变量重新赋值才会改变。 类型转换将一个类型的对象转换为其他对象，并不是改变对象本身的类型，而是根据当前对象的值创建一个新对象int() 浮点数直接取整，整数字符串直接转整数，其他类型字符串报错，None也会报错。float() float和int基本一致str()/bool() 表空的都会转化成False 运算符(操作符)算术运算符 两个不同类型不能进行加法字符串和数字相乘，会对字符串指定重复次数/除法运算结果总会返回一个浮点类型//整除，只保留计算后的整数位。对浮点数运算时，结果也是浮点数即使是整除运算。 关系运算符 关系运算符用来比较两个值之间的关系，总会返回一个布尔值 可以对两个字符串进行大于/小于的运算，当对字符串进行逐位比较时，比较的是字符串的Unicode编码，比出大小后直接返回后面的字符串将不会进行比较了。 ==与!=比较的是对象的值is比较两个对象是否是同一个对象，比较的是IDis not 比较两个对象是否不是同一个对象，比较的是ID 逻辑运算符可以连着用,表示关系成立，以中间的数为基准比较 # 相当于 1&lt;2 and 2&lt;3 和中间数进行比较 Python独有 1&lt;2&lt;3 逻辑运算符 not 逻辑非 对非布尔值，非运算符会将其转换为布尔值，再取反and 逻辑与 Python中的逻辑与和JS一样，也是短路的与，对非布尔值会先转化为布尔值运算，最终返回原值or 逻辑或 短路的或 # 与运算找false 2 1 and 2 # 或运算找true 1 1 or 2 条件运算符(三元运算符) 语法: 语句1 if 条件表达式 else 语句2 条件运算符在执行时，先对条件表达式进行求值判断，执行相应语句并返回执行结果。 流程控制语句条件判断语句(if) 语法: if 条件表达式 : 语句 Python是通过缩进表达代码块的,Python代码中使用的缩进方式必须统一，要么全缩进要么全空格 依次判断找到表达式结果为True的，执行代码块，然后语句结束。所以if-elif中只有一个代码块被执行。 if True： # Tab缩进 或者 4个空格 # end=&quot;&quot; 可以控制打印之后不换行 print(123,end=&quot;&quot;) # else: # else的代码块 elif 条件表达式 : # 代码块 input函数 input()函数用来获取用户的输入，调用后程序会立即暂停，等待用户输入，点击回车程序才会继续向下执行。 输入的内容会作为返回值返回，返回值为字符串参数为字符串，作为提示文字显示 循环语句while 条件表达式: 代码块else: 代码块，仅跳出循环后执行一次 break与continue break 可以用来立即退出循环语句,后面与循环一套的elsecontinue 可以退出本次循环，本次循环continue后面的语句将不会被执行，执行下一次循环，不会影响循环一套的else pass 用于在判断或循环语句中占位 序列列表列表(list)是Python中的一个对象，列表中可以保存多个有序的数据列表存储的数据，称为元素列表的索引可以是负数，如果是负数从后向前获取元素 切片 切片指从现有列表中，获取一个子列表，索引传个值，起始位置包括，结束位置不包括。或者可以理解为从索引的左边切下。语法: 列表[起始:结束] 列表[起始:结束:步长]步长表示每次获取元素的间隔，默认值是1，不能是0但是可以是负数，负数则会从列表的后面像前面取切片操作不会影响原来的列表，会返回一个新的列表起始位置和结束位置的索引可以省略不写 通过切片来修改列表，进行赋值时，只能使用序列中元素的个数没有要求。当设置了步长时，序列中元素的个数必须和切片中元素的个数一致。 # 列表的创建 my_list = [1,2,3] # 列表的使用，通过索引使用 my_list[0:0] = [9] //[9 1 2 3] # 删除元素 del list[0] # 通过len()函数获取列表的长度,列表的最大索引+1 len(my_list) 列表的方法 都是直接修改原列表 插入：s.append(value) 序列的最后添加value，不可以使用直接赋值的办法是因为索引超过最大值了会保存s.insert(i,value) 想列表的指定位置插入一个元素，参数1要插入的位置，参数2插入的元素s.extend(list) 使用新的序列来扩展当前序列，会将当前序列中的元素添加到当前列表中，相当于+ = 删除: s.clear() 清空序列s.pop() 根据索引删除并返回指定元素s.remove() 删除指定值的一个元素s.reverse() 序列反转s.sort() 用来对列表中的元素进行排序，默认升序排列，如果需要降序，则需要传递一个reverse = True作为参数 range()函数 range() 可以生成一个自然数序列,可以创建一个指定执行次数的for循环。 该函数需要三个参数1.起始位置，可以省略，默认是12.结束位置3.步长，可以省略，默认是1 range(5) # 生成一个序列[0,1,2,3,4] for i in range(30): print(i) 列表的常用操作/序列通用操作 + 两个列表拼接为一个列表* 可以将列表重复指定的次数in 用来检查指定元素是否存在列表中，语法：元素 in 列表 ，返回布尔值not in 用来检查指定元素是否不在列表中 函数:len(list) 获取列表中的元素个数min(list) 获取列表中的最小值max(list) 获取列表中的最大值 两个方法:方法和函数基本是一致的，只不过方法必须通过对象.方法()的形式调用s.index() 获取指定元素在列表中的位置,如果列表中没有会报错，仅返回第一次出现的索引。第一次参数表示查找的元素，第二个参数表示查找的起始位置，第三个参数表示查找的结束位置s.count() 统计指定元素在列表中出现的次数 序列(sequence)序列是Python中最基本的一种数据结构，数据结构指计算机中数据存储的方式 序列用于保存一组有序的数据，所有的数据在序列当中都有一个唯一的位置(索引) 序列的分类 可变序列:序列中的元素可以改变 列表(list) 不可变序列:序列中的元素不可以改变 字符串(str) 元组(tuple) 可以通过list()函数将其他的序列转换为list 所有的序列都可以进行解包。 遍历序列 for-in循环将序列中的所有元素取出来,每执行一次会将序列中的一个元素赋值给变量，变量指的是键值,这里是和JS不同的地方 for 变量 in 序列: 代码块 元组tuple把元组当成是一个不可变的列表，一般当我们希望数据不改变时，就是用元组，其余情况都使用列表。 创建元组，使用小括号()，当元组不是空元组时，可以省略括号,至少有一个逗号(可以看成元组的信号) 元组的特殊用法类似JS的解构赋值，在对一个元组进行解包时，变量的数量必须和元组中的元素的数量一致，也可以在变量前面添加*,这样变量将会获取元组中所有的剩余元素，变量为一个列表 my_tuple = 10,20,30,40 # 元组的解构赋值（解构） a,b,c,d = my_tuple # c=[30,40] a,b,*c = my_tuple 字典 dict字典属于一种新的数据结构，称为映射。字典的作用和列表类似，都是用来存储对象的容器。 列表存储数据的性能很好，但是查询数据的性能很差 在字典中每一个元素都有一个唯一的名字(键名)，通过这个唯一的名字就可以快速的查找到指定的元素(键值) 字典的键是任意的不可变对象，一般为字符串，不可以重复，如果重复，后面的会替换前面的；值可以是任意对象。 # 创建字典,类似JSON格式 d = {&#39;age&#39;:18} d[&#39;age&#39;] 字典的操作函数:dict() 来创建字典,这种方式 创建的字典，key都是字符串 也可以将一个包含双值(仅两个值如’ab’)子序列的序列转换为字典。len() 获取字典中键值对的个数in 检查字典中是否包含指定的键not in 检查字典中是否不包含指定的键 方法:d.get(key[,default]) 根据键来获取字典中的值，如果键不存在，会返回None;通过[]来获取值时，如果键不存在，会抛出异常。d.setdefault(key[,default]) 可以用来向字典中添加key-value，如果key存在，则返回key的值不会对字典做任何操作，如果key不存在，则向字典中添加这个key，并设置valued.updata(other d) 将其他字典中的key-value添加到当前字典中d.popitem() 随机删除字典中的一个键值对，一般都会删除最后一个键值对并以元组形式返回，删除空字典时报错d.pop(key[,default]) 根据key删除字典中的key-value，返回值是删除的value。删除不存在的key会报错，如果指定了默认值就不会报错并直接返回默认值d.clear() 用来清空字典copy()d.copy() 该方法用于对字典进行浅复制 复制以后的对象和原对象是独立的，修改一个不会另外一个，浅复制仅是简单的复制对象内部的值，如果值是一个可变对象，这个可变对象不会被复制(会影响原来的值) d = dict(name=&#39;孙悟空&#39;,age=18) # {&quot;name&quot;:&quot;孙悟空&quot;，&quot;age&quot;:18} d = dict([(name,&#39;孙悟空&#39;),(age,18)]) # 获取字典中的值,注意引号,有引号为字符串，没有引号为变量， d[&#39;name&#39;] = &quot;value&quot; # key存在修改，不存在添加 # 删除字典中的key-value，key不存在报错 del d[&#39;name&#39;] 字典的遍历d.keys()该方法会返回字典的所有key的序列d.values()该方法会返回字典的所有value的序列d.items(k,v)该方法会返回字典中所有项的序列[(k,v),(k,v)] 集合set集合和列表非常相似，类似JS的Set 不同点 - 集合中只能存储不可变对象 - 集合中存储的对象是无序 - 集合中不能出现重复的元素 集合的创建使用{}或使用set(),创造空集合只能使用set(),使用{}默认是创建的字典。 set可以将序列和字典(的键)转换为集合，利用这点可以去重， in 检查集合中的元素len()来获取集合中元素的数量 s.add() 向集合中添加元素s.update() 将一个集合/元组/字典(key)中的元素添加到当前集合中s.pop() 随机删除集合中的元素并返回s.remove(value) 删除集合中的指定元素s.clear()清空集合s.copy() 对集合进行浅复制 集合的运算 # 在对集合做运算时，不会影响原来的集合，而是将运算结果返回 # 创建两个集合 s = {1,2,3,5,9} s2 = {4,6,7,8,9} # &amp; 交集运算 result = s &amp; s2 # | 并集运算 result = s | s2 # - 差集 result = s - s2 # ^ 异或集(除去交集的剩余部分，只在一个集合中出现的元素) result = s ^ s2 # &lt;= 检查一个集合是否是另外一个集合的子集 # &lt; 检查一个集合是否是另外一个集合的真子集 函数 function函数也是一个对象def 函数名([形参1=默认值,形参2]): 代码块 位置参数:将对应位置的参数复制给对应位置的形参关键字参数:通过参数名直接传递参数，可以不按照形参定义的顺序去传递混合使用关键字和位置参数时，必须将位置参数写到前面 函数在调用时，解析器不会检查实参的类型，实参可以传递任意类型的对象 当传的参数是可变参数时，不想形参影响实参，传参可以通过x.copy()或x[:]传副本，这样形参和实参之间互不影响 不定长参数 在定义函数时，可以在形参前边加上*,这个形参将会获取到所有的实参，它会将所有的实参保存到一个元组,带*的参数后的所有的参数，必须以关键字参数的形式传递必须按形参顺序。 # 如果*后没跟变量，可以使用这种写法要求调用函数时必须使用关键字参数的形式传值 def fn(*,a,b,c): 代码块 # * 形参只能接收位置参数，而不能接收关键字参数 def fn(*a): 代码块 # **形参可以接收其他的关键字参数，将这些参数统一保存到字典中，字典的key就是参数的名字，字典value就是参数的值 # **只能有一个且写在参数的最后 def fn(**a): 代码块 参数的解包通过一个星号，对序列进行参数的解包。通过两个星号，对字典进行参数的解包 def fn(a,b,c): 代码块 # 传递实参时，也可以在序列类型的参数前添加星号，这样会依次将序列中的元素作为参数传递。 # 序列中元素的个数必须和形参的个数一致 t = (10,20,30) fn(*t) d = {&#39;a&#39;:100,&#39;b&#39;:200,&#39;c&#39;:300} # 通过**来对字典进行解包操作,相当于关键字参数，所以key要和参数名一致 fn(**d) help() help()是python的内置函数，通过help(函数对象)函数可以查询python中的函数的用法 文档字符串(doc str)在定义函数时，可以在函数内部第一行用&#39;&#39;&#39;文档字符串&#39;&#39;&#39;编写文档字符串，文档字符串就是函数的说明，可以通过help()函数来查看函数的说明。 作用域 作用域分两种 全局作用域:在程序执行时创建，在程序执行结束时销毁 函数作用域:在函数调用时创建，在调用结束时销毁，每调用一次就会产生一个新的函数作用域 如果希望在函数内部修改全局变量，可以通过global关键字来声明变量，表示这个变量不是函数内部的而是全局的。 命名空间命名空间指的是变量存储的位置，每一个变量都需要存储到指定的命名空间中。每一个作用域都会有一个它对应的命名空间，命名空间实际上就是一个字典，是一个专门用来储存变量的字典。 locals() 用来获取当前作用域的命名空间，返回当前作用域的命名空间globals() 用来获取全局命名空间 递归 基线条件,问题可以被分解为的最小问题，当满足基线条件时，递归就不在执行了递归条件，将问题继续分解的条件 函数式编程 在Python中，函数是一等对象一等对象一般特点：1.对象是在运行时创建的2.能赋值给变量或作为数据结构中的元素3.能作为参数传递4.能作为返回值返回 高阶函数至少符合以下两个特点的一个:1.接收一个或多个函数作为参数2.将函数作为返回值返回 filer()函数可迭代结构中过滤出符合条件的元素，保存到新的序列中参数:1.函数，根据函数来过过滤课迭代结构(需要返回bool值)2.需要过滤的可迭代结构返回值：过滤后的新可迭代的结构 这个的函数可以传匿名函数,也可以将匿名函数赋值给一个变量，这里的返回值直接返回不需要使用return 语法:lambda 参数列表 : 返回值 map()函数 map()函数可以对可迭代对象中的所有元素做指定的操作，然后将其添加到一个新的对象中返回。语法:map(函数,可迭代对象) sort()方法/sorted()函数 sort()方法用来对列表中的元素进行排序，会影响原列表。该方法是直接比较列表中元素的大小。 在sort()可以接收一个关键字参数key，key需要一个函数作为参数，当设置了函数作为 参数，每次都会以列表中的一个元素作为参数来调用函数，并且使用函数的返回值来比较元素的大小。如:l.sort(key=len)利用列表元素的长度排序。key = int 每个元素转换成int类型排序key = string 每个元素转换成string类型排序 这种用法只在比较的时候转换，不影响原来列表的类型 sorted()可以对任意的序列进行排序,不会影响原来的序列，返回一个新的对象。第一个参数为序列，第二个参数为key 闭包 将函数作为返回值返回 产生闭包的条件1.函数嵌套2.内部函数引用了外部函数的数据 装饰器 开闭原则，程序的设计要求开发对程序的扩展，要关闭对程序的修改 在希望不修改原函数的情况下，对函数进行扩展 只需要在现在的函数，创建一个新的函数，把原来的函数在新的函数中运行。这种方式要求每扩展一个函数就要手动创建一个新函数，为了避免麻烦，我们创建一个函数，让这个函数可以自动帮助我们生产函数 def begin_end(old_function): &#39;&#39;&#39; 用来对其他函数进行扩展，使其他函数可以在执行前打印开始执行，执行后打印执行结束 参数：要扩展的函数对象 &#39;&#39;&#39; # 打包 def new_function(*args,**kwargs): print(&quot;开始执行&quot;) # 解包 old_function(*args,**kwargs) print(&quot;执行结束&quot;) return new_function 像begin_end()这种函数就被称为装饰器，在开发中使用装饰器扩展函数的功能。在定义函数时，可以通过@装饰器来指定装饰器，可以同时为一个函数指定多个装饰器，函数将会被由内到外的装饰 # 在函数前面@装饰器，表示下面的函数被该装饰器装饰 @begin_end @装饰器2 def say_hello(): 代码块 # 执行的结果是被装饰器装饰后的结果 say_hello() 可变对象 列表、字典 变量中保存的对象id，只有在为变量重新赋值才会改变。可变对象指的是对象的值可变列表中的对象改变，该改变的是值，并没有重新给列表赋值 # 改对象 a[0] = 10 # 改变量 a = [1,2,3] 对象Object对象由三部分组成1.对象的标识，不可变(id)2.对象的类型，不可变(type)3.对象的值(value) 面向对象 面向对象的语言就是语言中的所有操作都是通过对象来进行的 类classclass isinstance()/issubclass()函数 isinstance(mc,MyClass) 用来检查mc(第一个参数)是否是MyClass(第二个参数)的实例，返回布尔值issubclass()用来检查第一个参数是否是第二个参数的子类 垃圾回收程序运行过程中产生的垃圾会影响到程序运行的运行性能，所以这些垃圾必须被及时清理。在Python中有自动的垃圾回收机制，它会自动将这些没有被引用的对象删除，所以不用手动处理垃圾回收程序结束之后，对象也会被自动回收 模块在Python中一个py文件就是一个模块，模块名要符合标识符的规范。语法: import 模块名 – 模块名为python文件的名字可以引用同一个模块多次，但是模块的实例只会创建一次。在每一个模块内部都有一个name属性，通过这个属性可以获取到模块的名字,name属性值为main的模块是主模块，一个程序中只会有一个主模块，主模块就是直接通过python执行的模块 模块中添加了_的变量，通过import *引入是看不见该变量的 # 给模块起别名 import test_module as test print (test.__name__) # 输出test_module print (__name__) # 输出__main__ # 访问模块中的变量:模块名.属性/方法() # 引入模块中的部分内容 # 语法 from 模块名 import 变量,变量 from m import Person,test # 引入模块中所有内容，一般不会使用 from m import * # 也可以为引入的变量使用别名 # 语法: from 模块名 import 变量名 as 别名 # 测试代码，当前文件为主模块的时候才需要执行 if __name__ == &#39;__main__&#39;: # 测试代码 time模块 time()可以用来获取当前的时间，返回的单位是秒 from time import * begin = time() pprint模块 pprint 模式给我们提供了一个方法pprint()该方法可以用来对打印的数据做简单的格式化。 包package包也是一个模块，当我们模块中代码过多时，或者一个模块需要被分解为多个模块时，就需要使用包 普通的模块就是一个py文件，而包是一个文件夹。包中必须要一个__init__.py,在这个中可以包含有包的主要的内容 # 这个包里有很多模块，这里引入a.py ,b.py form package_test import a,b __pycache__是模块的缓存文件，py代码在执行前，需要被解析器先转换为机器码，然后再执行，python会在编译一次以后，将转化后的机器码保存到缓存文件中 python标准库sys模块，可以获取到python解析器的信息os模块让我可以对操作系统进行访问 # 引入sys模块 import sys # 获取执行代码时，命令行中包含的参数(指令后面紧跟的) # 该属性是一个列表，列表保存了当前命令的所有参数 sys.argv # 当前程序中引入的所有模块，modules是一个字典，key为模块名，value是模块对象 sys.modules # 该属性是一个保存了模块的搜索路径的列表，有点类似环境变量path sys.path # 表示当前python运行的平台 sys.platform # 用来退出程序 sys.exit(&quot;提示语句&quot;) # 通过这个属性可以获取到系统的环境变量 os.environ os.environ[&#39;path&#39;] # 可以执行操作系统的命令 os.system(&quot;命令名&quot;) # os.listdir(path=&quot;.&quot;)获取当前目录的目录结构,返回一个列表，列表中的每一个元素都是文件夹/文件名 r = os.listdir() # os.getcwd()获取当前所在的目录 r = os.getcwd 异常Python是希望在出现异常时,我们可以编写代码来对异常进行处理，避免因为异常导致整个程序的终止。 try-except语句，try必须、except和finally至少有一个。 try: 代码块，可能出现错误的语句 except: 代码块，出现错误以后的处理方式 else: 代码块，没出错时要执行的语句 finally: 代码块，该代码块总会执行 异常的传播 函数中出现异常时，如果函数中对异常进行了处理，异常将不会传播；如果函数中没有对异常进行处理，异常会传播到函数的调用处。在异常传播时，实际上就是把异常对象抛给了调用处，如NameError类的对象专门用来处理变量错误的异常。 异常对象 如果except后不跟任何内容(默认Exception)，此时会捕获到所有的异常;如果except后跟着一个异常的类型，那么此时只会捕获该类型的异常一个try后可能跟n个except,类似elif,可以跟n个但只执行一个exceptException是所有异常类的父类，效果等于except后不跟任何内容可以在异常类后面跟着一个as xx,此时xx就是异常对象 try: print(c) print(10/0) except NameError as err: print(&quot;出现NameError异常&quot;) except ZeroDivisionError: print(&quot;出现ZeroDivisionError异常&quot;) finally: print(&quot;无论是否出现异常，该子句都会执行&quot;) 抛出异常 可以使用raise语句来抛出异常，raise语句后需要跟一个异常类或者异常类的实例。也可以自定义异常类，主要创建一个类继承Exception就可 class MyError(Exception): pass def add(a,b): # 如果a和b中有负数，就向调用出抛出异常 if a&lt;0 or b&lt;0 # 抛出异常类 raise Exception # 抛出异常类的实例 raise MyError(&quot;两个参数中不能有负数&quot;) r = a + b return r]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue基础]]></title>
    <url>%2F2020%2F07%2F31%2Fvue%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[创建vue实例 //————html &lt;div id=&quot;app&quot;&gt; &lt;a href = &quot;msg&quot;&gt;&lt;/a&gt; &lt;button v-on:click=&quot;test&quot;&gt;test&lt;/button&gt; &lt;/div&gt; //——————js const vm =new Vue({ //配置对象:属性名是一些特定的名称 el:&quot;#app&quot; , //值是选择器 element 用来查找根元素 该根元素所覆盖的htlm+js为模板页面 data:{ //包含多个可变数据的对象,为模板页面提供数据 msg:&quot;xxx&quot; }, //data还可以是函数，一定要有返回值 //data(){return{}} methods:{ //包含n个事件回调函数 test(event){ event.target.innerHTML } } }) vm会自动拥有data中所有属性，页面中可以直接访问使用不用使用this数据代理:由vm对象来代理对data中所有属性的操作 问题1：js以什么形式存在 指令:vue自定义标签属性 例子:v-model 插值:动态显示数据，可以写表达式 知识点1:强制数据绑定v-bind: 为某个标签属性绑定动态data时，要在属性前面添加: 知识点2:绑定事件监听v-on: 简写@事件名=”回调函数” 也可以写成@事件名=”回调函数(参数)” methods里面常常放回调函数 Object.definePropertiy 该方法的存储器属性(setter,getter)可以实现简单的数据双向绑定 const p = { firstName:&quot;A&quot;, lastName:&quot;B&quot; //还可以在这直接写get/set //get fullName(){} } Object.defineProperty(p,&quot;fullName&quot;,{ //当读取属性值时自动调用(回调)，函数返回值作为属性值 get(){ //this是对象p return this.firstName +&#39;-&#39;+ this.lastName }, //当设置属性时自动调取,监视属性值的变化 set(value){ const names = value.split(&quot;-&quot;) this.firstName = names[0] this.lastName = name[1] } }) console.log(p.fullName); computed 计算属性，通过已有数据(依赖数据)计算动态产生一个要显示的结果数据，相当于使用了属性的get方法。执行的时机： 1.初始显示第一次执行，得到初始值显示 2.依赖数据发生改变就会再次调用。 注意：所有vue控制的回调函数的this都是vm或者组件对象。 computed：{ //计算属性的套路 filterPersons(){ //1.得到依赖的数据 const {searchName,persons} = this //2.进行计算处理，产生结果数据并返回 const newPersons = persons.filter(p =&gt; p.name.includes(searchName)) return newPersons } } 问题2:如果页面中需要fullName多次渲染，是否computed里的fullName函数会执行多次？ 答：不会执行多次，计算属性会先去缓存取，取不到在执行一次getter计算，计算的结果放入缓存。 问题3:用什么结构来缓存计算属性？用对象来缓存计算属性，对象的属性名永远是字符串。 getter和setter属性的set方法称为setter、属性的get方法称为getter,如果要自己设置get与set，那么该计算属性后面接对象。 computed：{ fulllName:{ get(){ return this.firstName +&#39;-&#39;+ this.lastName } set(value){ const names = value.split(&quot;-&quot;) this.firstName = names[0] this.lastName = name[1] } } } 总结1.只用getter，计算属性就是一个函数2.使用getter/setter，计算属性是一个包含geeter的setter的对象 watch监视 当监视的属性变化时自动调用，初始显示的时候不调用。 //用于监视vm的哪个属性的变化 watch:{ firstName(newValue,oldValue)=&gt;{ //当firstName发生改变时自动调用 }, //一般监视 todos(){} } 假设监视的todos是一个数组，数组内部发生变化，但todos数组在内存中存的是地址，地址并没有改变，这种监视叫做一般监视。如果想要监视todos以及todos里面的数据变化，可以使用深度监视。 深度监视: watch:{ todos:{ deep:true, //深度监视 handler(value){ //监视的回调函数，value最新的todos值 } } } class动态绑定/style动态绑定 动态绑定的class会和静态绑定的class合并。 //值为字符串 &lt;p :class=&quot;classA&quot;&gt; //动态绑定多个class &lt;p :class=&quot;{classA:true,classB:false}&quot;&gt; //hasA，hasB是data里面的变量，通常操作hasA，hasB变量的改变改变样式 &lt;p :class=&quot;{classA:hasA,classB:hsaB}&quot;&gt; //style的值为对象 &lt;p :style = &quot;{color:myColor,fontSize:mySize+&#39;px&#39;}&quot;&gt; 使用场景:值为字符串 –&gt; 类名不确定时使用值为对象 –&gt; 类名确定，不确定是否有该类的样式 重点:HTML不区分大小写，所以HTML之中用连接线写法，而Js之中用驼峰写法 条件渲染 v-if/v-else的标签二选一， v-show是通过改变标签的样式实现显示与隐藏的 v-for遍历 &lt;li v-for = &quot;(p,index) in persons&quot; :key=&quot;p.id&quot;&gt;&lt;/li&gt; data:{ persons:[] }, methods:{ updataP(index,newP){ //这种方法不会更新页面 //this.persons[index] = newP //这种方法可以更新页面 this.persons[index].name = newP.age this.persons.splice(index,1,newp) } } 问题4：vue的数据绑定如何实现1.vue会监视data中所有层次的属性2.对象中的属性数据通过添加set方法来实现监视3.数组中的元素也实现了监视data的数据,重写数组一系列更新元素的方法。首先调用原生对应的方法对元素进行处理，再更新界面。 重写的数组方法:push()、pop()、shift()、unshift()、splice()、sort()、reverse() 在定义数据时，可以考虑根据状态赋值，如数组排序，比如有不排序，升序，降序三种状态，可以考虑用一个数字来表示该状态 0-不排序、1-升序、2-降序 如果两个不同的事件回调函数里面操作大部分相同，也可以尝试参数用true/false来表示不同的事件 事件处理 1.绑定监听 当函数需要操作事件对象时，可以显示的传$event &lt;button @click=&quot;test(&#39;x&#39;,$event)&quot;&gt;&lt;/buuton&gt; 2.事件修饰符 阻止(prevent)事件的默认行为 / 停止(stop)事件冒泡 / once 只触发一次 &lt;button @click.prevent=&quot;test(&#39;x&#39;)&quot;&gt;&lt;/buuton&gt; 3.按键修饰符 @keyup.enter 表示回车按键起来时执行 还可以自定义按键修饰符 Vue.config.keyCodes.f1 = 112 //@key.f1=&quot;&quot;使用 声明周期钩子(回调)函数钩子函数都是自己定义 beforeCreate() 在这两个回调之间，vue会实现数据代理，后面可以通过vm读取data中的数据。 created() beforeMount() 在显示前执行一次 这期间，会把之前模块中解析的内容批量替换el里的内容 mounted() 在第一次显示之后执行1次,同一个组件对象只执行一次。 这里的更新指的是页面更新,通常通过数据改变触发页面更新，也就是一下两个回调都发生在数据改变后，只不过一个页面还没有更新，一个页面更新完毕 beforeUpdate() 读老页面updated() 读新页面 beforeDestroy() 销毁前执行1次 常用的声明周期方法created()/mounted() 常用于异步请求,发送ajax请求，启动定时器等异步任务beforeDestory() 做收尾工作，清除定时器等 过渡和动画 transition标签，需要有过渡和动画的标签部分需要包裹在transition标签内。 在x-enter-active里面写transition/animation样式，定义进入动画的过渡在x-leave-active里面写transition/animation样式，定义离开动画的过渡 &lt;transition name:&quot;自定义过渡的动画名称如:fade&quot;&gt; ... &lt;transition&gt; 过滤器 功能:对要显示的数据进行特定格式化后再显示，没有改变原有数据。语法: Vue.filter(filterName,function(value被处理的数据,formatStr传过来的值{return 显示的数}) 在html使用 {{xxx | filterName(formatStr)}} 常用内置指令指令的作用是操作标签 v-if:如果为true，当前标签才会输出到页面v-show:通过控制display样式来控制显示/隐藏v-for:遍历数组/对象v-on:绑定事件监听，简写@v-model:双向数据绑定ref:为某个元素/组件注册一个唯一标识，vue对象通过$refs属性访问这个元素/组件对象v-html:更新元素的innerHTML，会解析标签v-text:更新元素的textContent 自定义标签 1.注册全局指定 Vue.directive(&quot;指令名称如:xxx&quot;,function(el,binding){ //el:指令属性所在的标签元素对象 //binding:包含指令相关信息数据的对象，如指令名，指令值等 }) 2.定义局部指令指令在vue实例上的局部指令 new Vue({ directives:{ //&quot;xxx&quot;:function() ES6中省略fuction和冒号 &quot;xxx&quot;(el,binding){} } }) 插件每个插件对象都必须有一个install方法，该方法通过Vue.use(插件名)调用。所以声明使用Vue插件，Vue.use(插件名)内部调用插件的install方法来安装插件。 单文件组件 组件中的data必须用函数返回对象的形式,因为每个组件标签都会产生一个实例，如果直接会对象形式，每个组件就共享了data中的数据，而使用函数返回对象的形式，每个组件通过调用data函数使用独立的数据。 保证对一个组件的多个实例对象的data对象不是共有的，而是各自的data对象。 每个组件只能有一个根标签,一个组件对象就是一个小的vm，组件内回调函数的this是指向组件对象，模板中获取数据读取组件对象的对应属性值。 单文件vue组件，后缀名为vue &lt;template&gt;&lt;/template&gt; &lt;script&gt; //1.引入组件 import export default{ //声明接收属性，该属性在组件标签中传值 //接收的所有标签属性都会成功组件对象的属性 props:[]/{}, data(){ return{ } }, methods:{}, watch:{}, //2.注册组件 components:{ //组件名 }, filters:{}, directive{}, } &lt;/script&gt; &lt;style scoped&gt;&lt;/style&gt; 引入组件时的问题:什么时候加./什么时候不加？ 不加时直接用模块名引入的是第三方库，默认从node_modules里面找，如果是自己定义的组件不是第三方引用的则需要添加 组件化编码的基本流程1.拆分界面，抽取组件2.编写静态组件3.编写动态组件，初始化数据、动态显示初始化界面、实现与用户交互功能 设置数据 -&gt; 类型，名称，位置如果是哪些组件用则交给共有的父组件。数据的更新-&gt; data数据定义在哪个组件，更新数据的行为就定义在哪个组件，如果子组件要更新父组件的数据，调用父组件的更新函数来更新父组件的数据。一个组件接收属性数据不是用来直接修改，只是用来读取显示的。 问题：组件对象和vm之间的关系 所有组件对象的原型对象都是不同的vm,所有的vm都是Vue的实例、都有一个共同的原型对象。 组件传值 脚手架脚手架的使用 目前常用的是2.0版本和3.0版本 //3.0 npm install -g @vue/cli vue create project_name npm run server //2.0 npm insstall -g @vue/cli-init vue init webpack project_name npm run dev v2与v3创建的项目区别 V2 V3 配置文件 配置直接可见,可直接修改 隐藏配置文件,扩展修改配置通过创建vue.config.js文件 main.js components:…template:..使用template要用带编译器的vue版本 render:h =&gt; h(app)默认使用的运行时的vue版本,打包文件更小 补充： 1.render //&lt;App&gt;&lt;/App&gt; 创建App的组件对象返回，最终会被渲染到el指定的页面、 import App ... render:createElment =&gt; createElenment(App) 2.vue.config.js module.exports ={ configureWebpacl:{ //内部写webpack原生配置 } //只能写vue封装的配置 }]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奇奇怪怪的坑们]]></title>
    <url>%2F2020%2F07%2F30%2F%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E5%9D%91%E4%BB%AC%2F</url>
    <content type="text"><![CDATA[7.30 hexo拒绝访问今天发现博客无法访问，报错是ERR_CONNECTION_REFUSED。开始慢慢寻找原因。 先重新上传了本地库，发现可以上传成功并且hexo s启动后本地可以访问。然后用手机流量可以访问博客。那么问题就到了PC端。ping了网址发现是127.0.0.1,检查了浏览器没开代理。通过朋友的帮助，在hosts文件中，添加185.199.111.153 biubiuins.github.io，让DNS在解析该域名时解析成前面的ip。]]></content>
      <categories>
        <category>questions</category>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Promise]]></title>
    <url>%2F2020%2F07%2F28%2Fpromise%2F</url>
    <content type="text"><![CDATA[Promise预备知识1.函数对象与实例对象函数对象：将函数作为对象使用实例对象：new函数产生的对象 括号左边是函数，点左边是对象 function Fn(){ //Fn函数 } const fn = new Fn() //这里的Fn是构造函数，fn是实例对象（new返回的，简称对象） Fn.prototype //Fn本身是个函数，但是使用了XX.XXX(使用了.)，把该函数作为对象来使用，所以这里的Fn是函数对象 2.两种类型的回调函数/*-----------同步回调函数--------------*/ const arr = [1,3,5] arr.forEach(item =&gt;{ //遍历回调，同步回调函数，一上来就执行，不会放入队列 console.log(item) }) //forEach是一个函数，回调函数也是一个函数。说明该回调函数是同步回调函数，等完全执行完毕之后才执行最后一个打印语句 console.log(&quot;forEach()执行完毕之后&quot;) //输出 //1，3，5 forEach()执行完毕之后 /*-----------异步回调函数--------------*/ setTimeout(()=&gt;{//异步回调函数，会放入队列中将来执行 console.log(&quot;timeout callback()&quot;) },0) console.log(&quot;setTimeout()之后&quot;) //输出 //setTimeout()之后 timeout callback() 同步回调 理解：立即执行，完全执行完了才结束，不会放入回调队列中例子：数组遍历相关的回调函数 /promise的excutor函数 异步回调 理解：不会立即执行，会放入回调队列中来执行例子：定时器回调 /ajax回调 /promise的成功与失败的回调 3.error处理错误类型 Error:所有错误的父类型子类型(常见的)：ReferenceError: 引入错误，引用的变量不存在TypeError: 数据类型不正确的错误RangeError：数据值不在其所允许的范围内。SyntaxError：语法错误 错误处理 若没有捕获error，后续的代码是不会执行的捕获错误:try{}catch(error){}抛出错误:throw new Error(message) //抛出错误，自己定义错误 function something(){ if(Date.now()%2 ===1){ console.log(&quot;当前时间为奇数,可以执行任务&quot;) }else{ // throw new Error(里面为传出的message) 固定格式 throw new Error(&#39;当前时间为偶数，无法执行任务&#39;) } try{ something() } catch(error){ //error下面两个属性message与stack console.log(error.message)//错误相关信息 console.log(error.stack)//函数调用栈记录信息 } } Promise的理解和使用Promise是JS中进行异步编程的新的解决方案（旧的是纯回调的方式）从语法来说：Promise是一个构造函数从功能上说：Promise对象用来封装一个异步操作并可以获取其结果 Promise的状态 pending变为resolved（成功） pending变为rejected (失败) 说明：只有这两种变化，且一个Promise对象只能改变一次。无论是成功还是失败，都会有一个结果数据。成功的结果数据一般称为value，失败的结果数据一般称为reason //1.创建一个新的promise对象,里面传一个回调函数 const p = new Promise((resolve,reject)=&gt;{ //执行器函数excutor 同步回调 //2.执行异步操作,promise常用于封装异步函数。 setTimeout(()=&gt;{ const time = Date.now() //如果当前时间是偶数代表成功，否则代表失败 if(time%2 ==0){ //3.1 如果成功了，调用resolve(value) resolve(&quot;成功的数据,time=&quot;+time) }else{ //3.2 如果失败了，调用reject（reason） reject(&quot;成功的数据,time=&quot;+time) } },1000); }) p.then( value =&gt;{ //接收得到成功的value数据 onResolved console.log(&quot;成功的回调&quot;,value) }, reason =&gt; { //接收得到失败的reason数据 onRejected console.log(&quot;失败的回调&quot;,reason) } ) //输出 成功的回调 成功的数据,time=XXXX 优势 指定回调函数的方式更加灵活。旧的，必须在启动异步任务前指定回调函数;promise：启动异步任务 =&gt; 返回peomise对象 =&gt; 给promise对象绑定回调函数(甚至可以在异步执行之后才指定他的回调函数) 支持链式调用，可以解决回调地狱问题（回调函数嵌套调用，不便于阅读/不便于异常）。 几个关键问题 1.如何改变promise的状态？（1）resolve(value):如果当前是pending就会变为resolved（2）reject（reason）：如果当前是pending就会变为rejected（3）抛出异常(throw)：如果当前是pending就会变成rejected throw new Error(&quot;出错了&quot;) reason值是你抛出的东西 2.一个promise指定多个成功/失败的回调函数，都会调用吗？ 当promise改变为对应状态时都会调用 3.改变promise状态和指定回调函数谁先执行。 /*---------先指定回调函数后改状态------------*/ new Promise((resolve,reject)=&gt;{ setTimeout(()&gt;{ resolve(1)//后改变的状态，同时指定数据，异步执行回调函数 },1000); }).then(//先指定回调函数，保存当前指定的回调函数 value=&gt;{},reason=&gt;{} ) /*---------先改状态后指定回调函数------------*/ new Promise((resolve,reject)=&gt;{ //同步回调 resolve(1)//先改变的状态，同时指定数据 ); }).then(//异步回调 value=&gt;{},reason=&gt;{}//后指定回调函数，异步执行回调函数 ) 4.promise.then()返回的新的promise的结果状态由什么决定 then方法返回的结构也是promise，返回的promise的状态由then执行的回调函数结果决定。 回调函数中return的值是非promise类型的数据，则返回的promise的状态为成功，value为return值。若return的值是新promise，由返回的promise状态决定。 5.promise异常传透和中止 当使用promise的then链式调用时，可以在最后指定失败的回调，因为没有处理异常相当于 reason =&gt; {throw reason}，会一层一层往下寻找异常处理直到找到。 当使用promise的then链式调用时，若想中断promise链，可以return new Promise(()=&gt;{})返回一个处于pending的promise。 自定义promise链接：https://github.com/biubiuins/promise-/tree/master promise方法Promise.resolve()/reject() Promise.resolve()：该方法返回一个新的成功的promise，值为参数Promise.reject():该方法返回一个新的失败的promise，值为参数。 Promise.race() 返回一个新的promise，第一个完成的promise的结果就是最终返回的promise结果。 Promise.allSettled() 该方法接收promise数组，返回promise对象，该对象的状态永远为成功，该对象的值为一个数组，数组的元素为参数中每一个promise的当前值与当前状态。 Promise.all(iterable) 包含n个promise的数组(可迭代对象)，返回一个新的promise，所有promise都成功返回的新的promise状态才成功。成功则返回一个数组，里面包含参数中promise成功的返回值，顺序与参数顺序一致。失败则返回失败的原因。 async与await本质:Generator语法糖，async取代Generator函数的星号*.await取代的是yield ES7的async/await进一步的优化Promise的写法，async函数始终返回一个Promise，await可以实现一个”等待”的功能，async/await被称为异步编程的终极解决方案，即用同步的形式书写异步代码，并且能够更优雅的实现异步代码顺序执行。 1.async 函数async是’异步’的简写，用于申明这个函数是异步的。函数的返回值为Promise对象，promise对象的结果由async函数执行的返回值决定。 2.await 表达式await相当于then的语法糖。当await后面的表达式为promise，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，得到的结果就是promise成功的value。如果右侧表达不是promise，得到的结果就是它本身。 注意：1.await必须放在async函数里面2.await只能得到成功的结果，失败的结果需用try-catch3.try catch只能捕获同步代码，不能捕获异步代码，在async函数内，使用await可以捕获异步代码，这里实际上是异步代码变成了同步代码。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise链式调用顺序]]></title>
    <url>%2F2020%2F07%2F28%2Fpromise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[第一题 setTimeout(()=&gt;{ console.log(1); },0) Promise.resolve().then(()=&gt;{ console.log(2); }) Promise.resolve().then(()=&gt;{ console.log(3); }) console.log(4); /* 输出：4 2 3 1 */ 第二题 setTimeout(() =&gt; { console.log(1); }, 0) //Promise为构造函数 new Promise(resolve =&gt; { console.log(2); //同步执行 resolve()//成功 }).then(() =&gt; { //成功的回调 console.log(3); }).then(() =&gt; {//此处的then等上一个执行完之后再放入微队列执行 console.log(4); }) console.log(5);//同步执行 /* 输出:2 5 3 4 1 */ 注意：链式的then要等前一个then执行完毕才知道状态，才可以进入微队列执行。 第三题 //定义了一个返回promise的函数 const first = () =&gt; (new Promise((resolve, reject) =&gt; { console.log(1); //同步执行1 //返回promise的函数 let p = new Promise((resolve, reject) =&gt; { console.log(2); //同步执行2 //放入宏队列1 setTimeout(() =&gt; { console.log(3); resolve(4) //最后执行宏队列时状态已经修改，不再是等待，所以该行代码不执行 }, 0) resolve(5) //立刻执行，p的状态立刻成功 }) resolve(6) //first的状态变成成功 //成功的回调放入微队列1 p.then((arg) =&gt; { console.log(arg); }) })) //成功的回调放入为微队列2 first().then((arg)=&gt;{ console.log(arg); }) console.log(7);//同步执行3 /*输出 1 2 7 5 6 3 开始：输出 1 2 7 宏[3] 微[5 6] 输出微队列：5 6 输出宏队列：3 */ 第四题 //加入宏队列1 setTimeout(()=&gt;{ console.log(0); },0) new Promise((resolve,reject) =&gt;{ console.log(1); //同步执行1 resolve() //成功的回调加入微队列1 }).then(()=&gt;{ console.log(2); new Promise((resolve, reject) =&gt; { console.log(3); resolve() //成功的回调加入微队列3 }).then(()=&gt;{ console.log(4); //成功的回调加入微队列5 }).then(()=&gt;{ console.log(5); }) //成功的回调加入微队列4 }).then(()=&gt;{ console.log(6); }) new Promise((resolve, reject) =&gt; { console.log(7); // 同步执行2 resolve() //成功的回调加入微队列2 }).then(()=&gt;{ console.log(8); }) /* 输出：1 7 2 3 8 4 6 5 0 状态1：同步执行输出1 7 宏[0] 微[2 8] 状态2,执行微任务1（整个then）：输出2 3 宏[0] 微[8 4 6] 状态3,执行微任务2：输出 8 宏[0] 微[4 6] 状态4,执行微任务3：输出4 宏[0] 微[6 5] .... */ 这道题我错在6和5的顺序上面，不太懂为什么6在5前面。阅读了一篇文章之后才明白，下面是对知识点进行摘录+总结。 知识点1 当执行 then 方法时，如果前面的 promise 已经是 resolved 状态，则直接将回调放入微队列中。 then方法是同步执行的，但是then中的回调是异步执行的。 在同步执行then方法时，会进行判断： 如果前面的 promise 已经是 resolved 状态，则会立即将回调推入微队列 如果前面的 promise 是 pending 状态则会将回调存储在 promise 的内部(不会被执行，也不会被放入微队列中)，一直等到 promise 被 resolve 才将回调推入微队列 知识点2 resolve的作用除了将当前的 promise 由 pending 变为 resolved，还会遍历之前通过 then 给这个 promise 注册的所有回调，将它们依次放入微队列中，很多人以为是由 then 方法来触发它保存回调，而事实上是由 promise 的 resolve 来触发的，then 方法只负责注册回调。 对于 then 方法返回的 promise 它是没有 resolve 函数的，取而代之只要 then 中回调的代码执行完毕并获得同步返回值，这个 then 返回的 promise 就算被 resolve new Promise((resolve,reject) =&gt;{ console.log(1); resolve() //第一个then }.then(()=&gt;{ ... //第二个then }).then(()=&gt;{ ... }) 首先Promise是实例化，同步执行函数，打印1，执行resolve函数，将 promise 变为 resolved，但由于此时 then 方法还未执行。由知识点2：resolve会触发保存它的回调。then是同步的，所以会依次保存第一个then和第二个then [主]外部第一个 then，外部第二个 then [微] 空 然后执行第一then,由于前面的promise已经被resolve了，所以将第一then的回调放入微队列。 [主]外部第二个 then [微]外部第一个 then的回调 但是这个回调还没有执行，所以第一then返回的promise 仍为 pending 状态，所以同步执行第二个then。由于前面的 promise 是 pending 状态，所以外2then 的回调也不会被推入微任务队列也不会执行 [主]空 [微]外一 then的回调 现在主线程空了，执行微任务，也就外一 then的回调，首先打印出2，随后实例化内部promise，打印3，执行resolve函数,遍历then保存。 new Promise((resolve,reject) =&gt;{ .... //外1 }.then(()=&gt;{ console.log(2); new Promise((resolve, reject) =&gt;{ console.log(3); resolve() }.then(()=&gt;{ //内部第一个then console.log(4); }).then(()=&gt;{ //内部第二个then console.log(5); }) } //外2 .then(()=&gt;{ ..... }) [主]内1 then 内2的then [微]空 然后执行内1的then，由于前面的 promise 已被 resolve，所以将回调放入微任务队列中。 [主]内2的then [微]内1then的回调 然后执行内2的then，因为内部第一个then的回调还未执行所以状态为pending，所以内2then 的回调和外2then 的回调一样，不注册不执行。 [主]空 [微]内1then的回调 外1的回调全部执行完毕，这里尤其注意:内2then的回调没执行，但是内2then是执行了的，相当于回调执行完毕。外1then 返回的 promise 的状态由 pending 变为 resolved，同时遍历之前通过 then 给这个 promise 注册的所有回调，将它们的回调放入微任务队列中。 [主]空 [微]内1then的回调 外2then 的回调 主线程执行完毕，取出内1then的回调执行 [主]内1then的回调 [微]外2then 的回调 打印4，内1then返回的promise状态由 pending 变为 resolved，同时遍历之前通过 then 给这个 promise 注册的所有回调，将它们的回调放入微任务队列中。 [主] 空 [微]外2then 的回调 内2的回调]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js异步:宏队列与微队列]]></title>
    <url>%2F2020%2F07%2F28%2F%E5%AE%8F%E9%98%9F%E5%88%97%E4%B8%8E%E5%BE%AE%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[异步执行的函数(回调函数)放入队列中执行。队列分为宏队列与微队列。 宏队列：用来保存执行的宏任务（回调），比如：dom事件回调，ajax回调，定时器回调微队列：用来保存执行的微任务（回调），比如：promise回调，mutation回调 1.JS为单线程引擎，必须先执行所有的初始化同步任务代码。2.每次取出第一个宏任务执行前，都要将所有的微任务执行完毕。 注:取到栈里执行，若有嵌套的情况如下列代码，执行第一个setTimeout回调时，把里面的微任务放入微队列，执行第二宏任务前，先将所有的微任务执行完毕。 setTimeout(()=&gt;{ //会立即放入宏队列 console.log(&quot;timeout callback1()&quot;); Promise.resolve(3).then( value =&gt;{ //会立即放入微队列 console.log(&quot;Promise onResolved3()&quot;,value); } ) },0) setTimeout(()=&gt;{ //会立即放入宏队列 console.log(&quot;timeout callback2()&quot;); },0) Promise.resolve(1).then( value =&gt;{ //会立即放入微队列 console.log(&quot;Promise onResolved1()&quot;,value); } ) Promise.resolve(2).then( value =&gt;{ //会立即放入微队列 console.log(&quot;Promise onResolved2()&quot;,value); } ) /* 输出:Promise onResplved(),1 Promise onResplved(),2 timeout callback1() Promise onResolved3() timeout callback2() ) */]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组的方法]]></title>
    <url>%2F2020%2F07%2F27%2F%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[数组的方法slice()与splice()语法:array.slice(start,end)第一个参数截取开始的位置索引，包含第二个参数为结束的位置索引，不包含 不修改原数组 返回截取的新数组 语法:array.splice(start,length,increase1,increase2..)删除数组中的指定元素，并为数组添加新元素第一个参数是开始的索引第二个参数是删除的数量第三个参数及以后是新添加的元素，添加的位置在开始索引之前。 修改原数组 返回值为删除的元素，有添加的元素返回值是整个数组 concat()语法:array.concat(array2,array3..)concat()可以连接两个或多个数组 如果是值直接放进去，如果是数组，取出值来再放进 不修改原数组 返回值为新数组 join()语法:arrayy.join(连接符)join()将数组转换为一个字符串，默认逗号 不修改原数组 返回值为转换的字符串 reverse()语法:array.reverse()反转数组 修改元素组 sort()语法:array.sort()对数组中的元素进行排序,默认按照Unicode编码进行排序，默认升序 修改原数组 指定排序的规则,浏览器将会分别使用数组中的元素作为实参去调用回调函数，回调函数需要定义两个形参。浏览器根据回调函数的返回值来决定元素的顺序，返回值大于0则元素a、b交换位置,其余不变语法:array.sort(function(a,b){ //a一定在b前面,比如升序 return a&gt;b?1: 0 //return a-b 更简单}) 数组的扩展Array.from(v) 把伪数组(字符串也可)转换为真数组类数组(伪数组)最基本的要求就是具有length属性的对象,该类数组对象的属性名必须为数值型或字符串型的数字。 let arrayLike = { 0: &#39;tom&#39;, 1: &#39;65&#39;, 2: &#39;男&#39;, 3: [&#39;jane&#39;,&#39;john&#39;,&#39;Mary&#39;], &#39;length&#39;: 4 } let arr = Array.from(arrayLike) console.log(arr) // [&#39;tom&#39;,&#39;65&#39;,&#39;男&#39;,[&#39;jane&#39;,&#39;john&#39;,&#39;Mary&#39;]] Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。如下： let arr = [1,2,2,2,3,4,5] let set = new Set(arr) console.log(Array.from(set, item =&gt; item + 1)) // [2,3,4,5,6] Array.of(v1,v2,v3) 将v1，v2..等元素转换成数组 find() 找到第一个满足条件返回true的元素 let arr = [2,4,6] console.log(arr.find((value, index) =&gt; value &gt; 4)); //输出6 findIndex() 找到第一个满足条件返回true的元素下标 let arr = [2,4,6] console.log(arr.findIndex((value, index) =&gt; value &gt; 4)); //输出2 Array.prototype.includes(value) 字符串与数组都有includes方法，判断数组中是否包含指定的value，返回值为布尔值。以前判断用indexOf返回的是数字。 Array.prototype.indexOf(value)/lastIndexOf(value) 返回value在数组中出现的第一个下标和最后一下下标，没有出现则返回-1 应用场景：两个方法结合判断下标是否相等，可以用来判断数组中唯一出现的值 Array.prototype.flat()/flatMap() Array.prototype.flat()将多维数组转化为低维数组,从外层括号开始删，默认一次删一个，比如从三维到一维，需要删2个则flat()传参2 const arr = [1,2,3,4,[5,6,[7,8]]] console.log(arr.flat())//输出[1,2,3,4,5,6,[7,8]] Array.prototype.flatMap()类似map()。先执行map在执行flat，也就是先返回数组再降低维度。 数组的遍历Array.prototype.forEach()语法: array.forEach(function(currentValue, index, array){})调用数组的每个元素，并将元素传递给回调函数。第一个参数，当前遍历的元素。第二个参数，当前遍历的元素索引第三个元素，当前遍历的数组 特点 不返回新数组 不能中断 对空数组不执行回调 Array.prototype.map()语法: array.map(function(currentValue,index,arr), thisValue) 按照原始数组元素顺序依次处理元素，结果放在一个新数组里返回。 /*------从接口得到数据------*/ const users=res.items.map(item =&gt; ({ url: item.html_url, img: item.avatar_url, name: item.login, }) ); 特点 返回新数组，不改变原始数组。 for-of / for-infor-of不仅仅可以遍历数组，具有iterator接口的，都可以使用for-of进行遍历 for (var value of arr) { console.log(value); // 1,2,3 } 与for-in的区别：1.for-in 获取的是键名，数组的键名是索引，for-of获取的是键值2.for-in 会遍历对象的整个原型链,性能非常差不推荐使用。 Array.prototype.filter()语法：array.filter(function(currentValue,index,arr), thisValue) 创建一个新的数组，指定数组中符合条件的元素放入新数组。 返回一个新数组，按照约定条件筛选数组元素时比较常用 /*-----去重问题----*/ var arr = [1, 2, 2, 3, 4, 5, 5, 6, 7, 7,8,8,0,8,6,3,4,56,2]; var arr2 = arr.filter((x, index,self)=&gt;self.indexOf(x)===index) console.log(arr2); //[1, 2, 3, 4, 5, 6, 7, 8, 0, 56] every()/some()ever语法: array.every(function(currentValue,index,arr), thisValue) 对整个数组进行检查，如有一个元素不满足，整个表达式返回false，且其余元素不检查。否则返回true。 不会改变原数组 语法:array.some(function(currentValue,index,arr),thisValue) 对整个数组进行检查，如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。反之返回false。 不会改变原数组 这两个方法在实际开发中，大有可用之处。比如在判定用户是否勾选了不可操作的数据，或者是否勾选了一条可以操作的数据可以使用这两个方法遍历循环数组。 reduce()/reduceRight()语法:arr.reduce(callback,[initialValue]) callback （执行数组中每个值的函数，包含四个参数） previousValue 必选。上一次调用回调返回的值，或者是提供的初始值（initialValue） currentValue 必选。数组中当前被处理的元素 index 可选。当前元素在数组中的索引。 arr 可选。当前元素所属的数组对象。 initialValue （作为第一次调用 callback 的第一个参数。） 将数组元素做“叠加”处理，返回一个值。 reduce方向从左向右，reduceRight方向从右向左 var arr = [1, 2, 3, 4]; var sum = arr.reduce(function(prev, cur, index, arr) { console.log(prev, cur, index); return prev + cur; }) console.log(arr, sum); /*-----打印结果---*/ 1 2 1 3 3 2 6 4 3 [1, 2, 3, 4] 10 index是从1开始的，第一次的prev的值是数组的第一个值。数组长度是4，但是reduce函数循环3次。 var arr = [1, 2, 3, 4]; var sum = arr.reduce(function(prev, cur, index, arr) { console.log(prev, cur, index); return prev + cur; }，0) //注意这里设置了初始值 console.log(arr, sum); /*----打印结果----*/ 0 1 0 1 2 1 3 3 2 6 4 3 [1, 2, 3, 4] 10 这个例子index是从0开始的，第一次的prev的值是我们设置的初始值0，数组长度是4，reduce函数循环4次。 如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始 对空数组来说，不设置初始值会报错，设置了初始值不会报错，所以一般来说我们提供初始值通常更安全。 使用场景也很多，具体可以看 参考文档]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串的方法]]></title>
    <url>%2F2020%2F07%2F27%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[字符串的属性在底层字符串是以字符数组的形式保存的[“h”,”e”] charAt()语法：string.charAt()根据索引获取指定的字符，返回值为获取的字符 concat()语法:string.concat(str1，str2….)连接一个或多个字符串，返回值为新的字符串 indexof()语法:string.indexof(“x”,start)在string中寻找x的位置，找到返回索引，没找到返回-1第一个参数为查找的字符第二个参数为开始查找的位置indexof()是从前往后找lastindexof()是从后往前找 slice()/substring()语法:string.slice(start,end)第一个参数截取开始的位置索引，包含第二个参数为结束的位置索引，不包含 如果为-1值的是从后往前的第一个 不修改原字符串 返回截取的字符串 语法:string.substring(start,end) 与slice类似区别： substring不可以传递负值，传了默认为0 如果第二个参数小于第一个参数，会自动调整参数的位置 toUpperCase()/toLowerCase()语法：string.toUpperCase() 字符串转换成大写 不修改原字符串 返回转化的大写字符串 split()语法：string.split(“,”)/string.split(/[0-9]/)join()的功能相反,可以将一个字符串拆分为一个数组参数为拆分规则,如例子的根据字符串里的逗号拆分数组,参数可以是正则表达式 默认全拆不修改原字符串，返回值为数组 let str=&quot;1a2b3c4d5e6f&quot; let result = str.split(/[0-9]/) //输出[a,b,c,d,e,f] search()语法:string.search(搜索的内容)搜索字符串中是否含有指定内容,返回第一次(g失效)出现的索引或者-1参数是指定内容可以是正则表达式 match()语法:string.match(条件)根据正则表达式，从一个字符串中将符合条件的内容提取出来,返回值是数组 默认返回符合条件的第一个内容要找所有内容，开启全局匹配模式可以为一个正则表达式设置多个匹配模式，顺序无所谓 let str=&quot;1a2b3c4d5e6f&quot; let result = str.match(/[0-9]/g) //输出[1,2,3,4,5,6] replace()语法:string.search(被替换的内容，新的内容)可以将字符串中指定内容替换为新内容，被替换的内容可以是正则表达式。 默认只替换第一个不影响原来的字符串，返回新的字符串 可以使用它去空格 //会去掉全部的空格 str = str.replace(/\s/g,&quot;&quot;) //去掉开头的空格 str = str.replace(/^\s*/,&quot;&quot;) //去掉结尾的空格 str = str.replace(/\s*$/,&quot;&quot;) //去掉开头和结尾的空格 str = str.replace(/^\s*|\s*$/g,&quot;&quot;) 这里去掉字符串的头尾空格可以使用字符串的trim()方法 字符串的扩展属性string.includes(str) 判断是否包含指定的字符串返回值：包含true,不包含false string.startsWith(str) 判断是否以指定字符串开头返回值：是true,否false string.endsWith(str) 判断是否以指定字符串结尾返回值：是true,否false string.repeat(count) 指定目标字符串重复的次数返回值:重复后的字符串 string.trim()/string.trimStart()/string.trimEnd() trim()清除字符串左侧与右侧的空格trimStart()清除字符串左侧的空格trimEnd()清除字符串右侧的空格 String.prototype.matchAll() 实用 常用来获取正则批量匹配的结果，返回可迭代对象，可以用for of进行遍历或者扩展运算符展开。爬虫常用 let str = `&lt;ul&gt; &lt;li&gt; &lt;a&gt;ranan&lt;/a&gt; &lt;p&gt;喜欢粉色&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;a&gt;linin&lt;/a&gt; &lt;p&gt;喜欢白色&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; ` const reg = /&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\/a&gt;.*?&lt;p&gt;(.*?)&lt;\/p&gt;/sg const result = str.matchAll(reg) for (let v of result) { console.log(v); } //输出[exec匹配返回的结果1],[exec匹配返回的结果2]]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度克隆]]></title>
    <url>%2F2020%2F07%2F27%2F%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[深拷贝浅拷贝深浅拷贝只是针对引用数据类型。 浅拷贝：修改拷贝以后的数据会影响原数据，拷贝的引用。使得原数据不安全。(只拷贝一层)深拷贝：修改拷贝以后的数据不会影响原数据，拷贝的时候生成新数据。 js的数据类型 基本数据类型： Undefined、Null、Boolean、Number、String和Symbol(ES6)引用数据类型： Object(Array, Date, RegExp, Function) 拷贝数据的方法1.引用类型直接赋值是浅拷贝2.Object.assign() let obj = { a: { a1: &#39;a1&#39; }, b: &#39;b&#39; } let ass = Object.assign({}, obj); ass.a.a1 = &#39;aaa&#39;; ass.b=&quot;c&quot; console.log(obj); /* 输出：a:{a1:&quot;aaa&quot;}, b:&quot;b&quot; */ 说明: Obejct.assign()只能对一层进行深拷贝,如果拷贝的层数超过了一层的话，那么就会进行浅拷贝。 这种克隆方式，只能克隆原始对象自身的值，不能克隆它的继承值。 function clone(origin) { return Object.assign({}, origin); } 如果要保持继承链。 function clone(origin) { //Object.getPrototypeOf方法返回指定对象的原型（内部[[Prototype]]属性的值） let originProto = Object.getPrototypeOf(origin); //Object.create方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。 return Object.assign(Object.create(originProto), origin); } 3.三点运算符对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。 let obj = { a: { a1: &#39;a1&#39; }, b: &#39;b&#39; } let ass = {...obj}; ass.a.a1 = &#39;aaa&#39;; ass.b = &#39;bbb&#39; console.log(obj); /* 输出：a:{a1:&quot;aaa&quot;}, b:&quot;b&quot; */ 说明:扩展运算符只能对一层进行深拷贝,如果拷贝的层数超过了一层的话，那么就会进行浅拷贝。 Object.assign(）和展开原算符对于深浅拷贝的结果是一样。 4.Array.prototype.concat() concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。 let arr= [1,3,{name:&#39;ran&#39;}] let arr2 = arr.concat() // arr2[1]=55 //输出[1，3，{name:&#39;ran&#39;}] arr2[3].name = &#39;ke&#39; console.log(arr); //输出 [1,3,{name:&#39;ke&#39;}] 遍历arr数组时得到arr数组的元素，把该元素赋值给arr2对应的位置，当遍历的元素是对象时，因为对象的赋值浅拷贝，所有会改变原来的值。 5.Array.prototype.slice(startindex,endindex) let arr= [1,3,{name:&#39;ran&#39;}] let arr2 = arr.slice() arr2[1]=55 arr2[2].name = &#39;ke&#39; console.log(arr); // 输出[1,3,{name:&#39;ke&#39;}] 因此，slice和concat这两个方法，仅适用于对不包含引用对象的一维数组的深拷贝 6.JSON.parse(JSON.stringify()) 深拷贝 JSON.stringify()：将JavaScript对象转换为JSON字符串JSON.parse()：可以将JSON字符串转为一个对象。 let arr= [1,3,{name:&#39;ran&#39;}] let arr2 = JSON.parse(JSON.stringify(arr)) //在JSON.stringify()完成后，对象就转为了字符串，也就可以说实实在在的复制了一个字符串，字符串是基本数据类型。 arr2[1]=55 arr2[2].name = &#39;ke&#39; console.log(arr);//输出[1,3,{name:&#39;ran&#39;}] 缺点：拷贝会忽略undefined,symbol,function、也有可能导致原型链缺失。 补充1 判断数组是否包含某对象，或者判断对象是否相等。 转化成字符串比较。 //判断数组是否包含某对象 let data = [ {name:&#39;echo&#39;}, {name:&#39;听风是风&#39;}, {name:&#39;天子笑&#39;}, ], val = {name:&#39;天子笑&#39;}; JSON.stringify(data).indexOf(JSON.stringify(val)) !== -1;//true //判断两数组/对象是否相等 let a = [1,2,3], b = [1,2,3]; JSON.stringify(a) === JSON.stringify(b);//true 补充2 localStorage/sessionStorage默认只能存储字符串，而实际开发中，我们往往需要存储的数据多为对象类型，那么这里我们就可以在存储时利用json.stringify()将对象转为字符串，而在取缓存时，只需配合json.parse()转回对象即可 补充3JSON.stringify()与toString()的区别，这两者虽然都可以将目标值转为字符串，但本质上还是有区别的。 let arr = [1,2,3]; JSON.stringify(arr);//&#39;[1,2,3]&#39; arr.toString();//1,2,3 JSON.stringify常用于对象，toString()常用于数组 参考文章 如何实现深拷贝？拷贝的数据里面不能有引用类型。如果有，只要拿到的是基本数据类型，然后再去赋值，就可以实现深拷贝 如何判断数据类型typeof返回的数据类型:String,Number,Boolean,Undefined,Object(Array,null也是),Function，不能准确的确定数据的类型。 Object.prototype.toString.call() Object.prototype.toString.call()可以区分各种类型，但它无法区分自定义对象类型，自定义类型可以采用instanceof区分。 console.log(Object.prototype.toString.call(&quot;jerry&quot;));//[object String] console.log(Object.prototype.toString.call(12));//[object Number] console.log(Object.prototype.toString.call(true));//[object Boolean] console.log(Object.prototype.toString.call(undefined));//[object Undefined] console.log(Object.prototype.toString.call(null));//[object Null] console.log(Object.prototype.toString.call({name: &quot;jerry&quot;}));//[object Object] console.log(Object.prototype.toString.call(function(){}));//[object Function] console.log(Object.prototype.toString.call([]));//[object Array] console.log(Object.prototype.toString.call(new Date));//[object Date] console.log(Object.prototype.toString.call(/\d/));//[object RegExp] function Person(){}; console.log(Object.prototype.toString.call(new Person));//[object Object] 那么为什么Object.prototype.toString.call()可以区分？ toString方法返回反映这个对象的字符串（除了null和undefined之外） console.log({name:&quot;张三&quot;}.toString());//[object Object] console.log([1,2].toString());//1,2 console.log(typeof [1,2].toString())//String obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？ 因为toString为Object的原型方法，而Array,function等类型作为Object的实例重写了toString方法，调用toString方法时，优先调用的是重写之后的toString方法，所以要使用Object原型上的toString才可以反映对象的具体类型。 获取标识类 Object.prototype.toString.call()返回的是字符串类型的[object xxx],但是我们只需要后面的标识数据类型的xxx，可以使用Array的slice方法。 let data = [1,3] //slice包含开始的位置，不包含结束的位置，结束位置为-1 console.log(Object.prototype.toString.call(data).slice(8,-1));//Array 最终实现//检测数据类型的功能函数 function checkedType(target) { return Object.prototype.toString.call(target).slice(8,-1) } //实现深度克隆 数组/对象 function clone(target) { let result,targetType=checkedType(target) switch (targetType) { case &#39;Object&#39;: result = {}; break; case &#39;Array&#39;: result = [] break; default: return target } //遍历，基本数据类型的赋值 for (let i in target){ //获取数据结构的每一项值 let value = target[i] //判断目标结构里的每一值是否存在对象/数组 if (checkedType(value) === &#39;Object&#39; || checkedType(value) === &#39;Array&#39;){ //继续遍历获取到的value result[i] = clone(value) }else { //获取到的value值是基本的数据类型或者函数 result[i] = value } } return result }]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象的方法]]></title>
    <url>%2F2020%2F07%2F27%2F%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[对象的扩展属性Obejct.setPrototypeOf/getPrototypeOf Obejct.setPrototypeOf(对象，对象的原型指向的元素)设置原型proto Object.getPrototypeOf(对象)获取指定对象的proto指向的值,没有返回null Object.is(v1,v2) 判断对象v1与v2是否完全相等。 console.log(0 === -0) //true console.log(NaN == NaN)//false NaN与任何数都不相等 console.log(Object.is(0,-0)) //false console.log(Object.is(NaN,NaN))//true 由上面代码可知该方式是以字符串是否相等来判断的 Object.assign(target,source1,source2..) 这个Object静态方法允许我们进行多个对象的合并，遍历需要合并给target的对象（仅可枚举属性），用等号进行赋值(这里可能有深浅拷贝的问题) 注意如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 const target = { a: 1, b: 1 }; const source1 = { b: 2, c: 2 }; const source2 = { c: 3 }; Object.assign(target, source1, source2); target // {a:1, b:2, c:3} 常见用途 1.关于拷贝的用法2.为属性指定默认值 ``` const DEFAULTS = { logLevel: 0, outputFormat: &#39;html&#39; }; //options对象是用户提供的参数。 function processContent(options) { options = Object.assign({}, DEFAULTS, options); console.log(options); // ... } ``` Object.keys(obj)获取对象自身的所有的键名，返回数组 Object.values(obj)获取对象所有的值，返回数组 Object.entries(obj)返回数组[[键名，键值],[键名，键值]]，此方法可以用于创建Map对象。 const m = new Map(Object.entries(obj)) Object.fromEntries()用于创建一个对象，参数为二维数组或者Map Object.fromEntries([ [&quot;name&quot;,&quot;ranan&quot;], [&quot;like&quot;,&quot;pink&quot;,&quot;white&quot;] ]) //{name:&quot;ranan&quot;,like:&quot;pink,white&quot;} Object.entries(obj)/Object.fromEntries(二维数组)互为逆运算。 Object.create(prototype,[descriptors]) 作用：以指定对象为原型创建新的对象。为新的对象指定新的属性，并对属性进行描述 第一个参数指定原型，第二个参数为实例添加属性。 let obj = {name:&quot;ranan&quot;,age:2} //第一个参数指定原型，第二参数为实例添加属性 let obj1 = Object.create(obj,{sex:{ value:&quot;女&quot;,//value指定值 //属性的描述 writable:true,//标识当前属性是否可以被删除，默认为false configurable:true,//表示当前属性是否可以被删除，默认为false enumerable:true,//标识当前属性是否能用for-in枚举，默认false }}) //obj1的原型__proto__指向obj console.log(obj1); 克隆保持原型链 function clone(origin) { //Object.getPrototypeOf方法返回指定对象的原型（内部[[Prototype]]属性的值） let originProto = Object.getPrototypeOf(origin); //Object.create方法创建一个新对象，originProto为原型创建新对象 return Object.assign(Object.create(originProto, origin)); getOwnPropertyDescriptor/getOwnPropertyDescriptors就是获取内部属性的描述,可以用于深层次的克隆。 const obj = Object.create(null,{ //内部属性的描述 name:{ value:&#39;尚硅谷&#39;, //属性特性 writable:true, //修改 configurable:true //删除 enumerable:true //枚举 } }) 如果不指定configurable, writable, enumerable ，则这些属性默认值为false，如果不指定value, get, set，则这些属性默认值为undefined。 Object.defineProperties(object,descriptors) 作用:为指定的object对象扩展多个属性 一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 Object的defineProperty/defineProperties主要功能就是用来定义或修改这些内部属性。 语法: Object.defineProperty(obj, prop, descriptor) obj: 需要被操作的目标对象prop: 目标对象需要定义或修改的属性的名称descriptor: 将被定义或修改的属性的描述符 var obj = new Object(); Object.defineProperty(obj, &#39;name&#39;, { configurable: false, writable: true, enumerable: true, value: &#39;张三&#39; }) console.log(obj.name) //张三 语法: Object.defineProperties(obj, props) obj: 将要被添加属性或修改属性的对象props: 该对象的一个或多个键值对定义了将要为对象添加或修改的属性的具体配置 方法直接在一个对象上定义一个或多个新的属性或修改现有属性，并返回该对象。 var obj = new Object(); Object.defineProperties(obj, { name: { value: &#39;张三&#39;, configurable: false, writable: true, enumerable: true }, age: { value: 18, configurable: true } }) console.log(obj.name, obj.age) // 张三, 18 该方法的存储器属性(setter,getter)可以实现简单的数据双向绑定 &lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;input1&quot;&gt; &lt;div&gt; 上面输入的数据是 &lt;span id=&quot;span&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; let oInput1 = document.getElementById(&#39;input1&#39;); let oSpan = document.getElementById(&#39;span&#39;); let obj = {}; Object.defineProperties(obj, { //惰性求值，get之后才有值 val1: { configurable: true,//可修改 get: function() { oInput1.value = 0; oSpan.innerHTML = 0; return 0 }, set: function(newValue) { oSpan.innerHTML = newValue } }, }) //设置默认值为0 调用get方法 oInput1.value = obj.val1; oInput1.addEventListener(&#39;keyup&#39;, function() { //调用set方法 obj.val1 = oInput1.value; }, false) &lt;/script&gt; get/set propertyName(){} 对象本身的两个方法，用法和上面的get/set一样 let obj = {firstName:&quot;xx&quot;,lastName:&quot;xx&quot;, get fullName(){ return this.firstName+ this.lastName }} 判断对象是否是数组/对象的元素/属性格式： 变量 in 对象/数组当是数组时，变量指的是索引(不常用)当是对象时，变量指的是对象的属性名]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[class类]]></title>
    <url>%2F2020%2F07%2F26%2Fjs-%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[ES6的class可以看作只是一个语法糖，只是让对象原型的写法更加清晰，更像面向对象编程的语言。 //定义一个人物的类 class Person{ //类的构造方法,es5写在构造函数上的 constructor(){} //这里不需要逗号 //其余(原型)方法的写法必须使用该语法(静态的可以不用)。方法名(){} es6简写 //es5写在原型上的,实例都可以使用 call(){ } } 构造方法名字不能修改且当new实例对象时，会自动执行。注意 类里面方法的写法。方法名(){} console.log(typeof Person);//function console.log(Person===Person.prototype.constructor);//true 从上面的代码可以看出类实质上就是一个函数，可以任务ES6的类就是构造函数的另外一种写法。实际上类的所有方法都定义在类的prototype属性上。constructor内的属性可以称为实例属性（和前面说的实例成员一样）,constructor外声明的属性都是定义在原型上的，可以称为原型属性（即定义在class上) 注意 class不存在变量提升，所以需要先定义再使用 static实例对象和函数对象的属性是独立的，实例对象的属性和该构造函数的原型上的属性是相通的。 实例对象和函数对象的独立属性称为静态成员/方法，只能函数对象使用。在ES6中，在方法/属性前加上static关键字，该类属性属于类不属于识类对象。 class Foo{ static classMethod() { return &#39;hello&#39;; } } //Foo.classMethod()使用 私有属性私有属性前面加#,私有属性类外部直接获取不到结果会报错，只能通过类里面使用。 class Person{ //公有属性 name; //私有属性 #age; constructor(name,age,weight){ this.name = name; this.#age = age ; this.#weight = weight; } } extends继承ES5的继承 function Father(name,age){ this.name = name; this.age = age; } Father.prototype.money= ()=&gt;{ console.log(&#39;父亲要上班&#39;); } function Son(name,age) { Father.call(this,name,age) } Son.prototype = new Father(); Son.prototype.constructor = Son ES6的extends继承 class Son extends Father{ //子类的构造方法 constructor(name,age,height){ // 调用父类的构造方法，这里也要注意参数 //父类的方法也会继承 super(name,age) //子类自己的方法 this.height = height; } } 子类继承父类相当于子类的proto指向父类Father。 get和set class Phone{ get price(){ console.log(&quot;该属性被读取了&quot;) return &quot;属性调用的返回值&quot; } set price(newVal){ console.log(&quot;该属性被修改了&quot;) } } let s = new Phone() s.price s.price = &quot;free&quot;]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代器]]></title>
    <url>%2F2020%2F07%2F26%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署了iterator接口(对象里面的一个属性)，就可以用来完成遍历操作。 iterator接口是解构赋值，三点运算符，生成器，for-of循环的基础，主要供for-of消费。 默认具有iterator接口的数据结构有以下几个，注意普通对象默认是没有iterator接口的（可以自己创建iterator接口让普通对象也可以迭代） Array Map Set String TypedArray（类数组） 函数的 arguments 对象 NodeList 对象 工作原理:1.symbol.iterator对应的函数创建一个指针对象，指向数据结构的起始位置。2.第一次调用next方法，指针自动指向数据结构的第一个成员3.接下来不断调用next方法，直到指向最后一个成员4.每次调用next方法返回的是一个包含value和done的对象 注意：第一个next方法是symbol.iterator对应函数执行的返回值，每次调用next方法返回的是一个包含value和done的对象{value:当前成员的值，done：布尔值}其中done对用的布尔值表示当前的数据的结构是否遍历结束。当遍历结束的时候返回的value值是undefined，done值为true let zimu = [a,b,c,d] //返回一个iterator对象,该对象对象里面有next方法 let iterator = zimu[Symbol.iterator](); //调用对象的next方法,返回值{value:a,done:false} console.log(iterator.next()); 1.可迭代的数据结构会有一个[Symbol.iterator]方法,2.[Symbol.iterator]执行后返回一个iterator对象 自定义部署iterator接口 let obj = { data: [&quot;a&quot;, &quot;b&quot;], [Symbol.iterator]() { const self = this //用于返回值对象 let index = 0 //索引变量 return {//遍历器对象，返回iterator对象 next() { if (index &lt; self.data.length) { return { value: self.data[index++], done: false } } else { return { value: undefined, done: true } } } } } } for..of以前我们遍历数组中的元素的时，最开始使用的是for let arr = [1,2,3] for(let i = 0;i&lt;arr.length;i++){ console.log(arr[i]) //输出1，2，3 } 自ES5之后，可以使用forEach arr.forEach(function (value) { console.log(value); //输出1，2，3 }); 但是foeEach有两个缺点：1.不能使用break语句中断循环2.不能使用return语句返回到外层函数 ES6增加了for-of循坏，是现在简洁、最直接的遍历数组元素的语法。for-of不仅仅可以遍历数组，具有iterator接口的，都可以使用for-of进行遍历 for (var value of arr) { console.log(value); // 1,2,3 } 与for-in的区别：1.for-in 获取的是对象的键名，for-of获取的是键值2.for-in 会遍历对象的整个原型链,性能非常差不推荐使用。 使用场景 1.对数组和Set结构进行结构赋值时2.扩展运算符3.yieId后面跟的是一个可遍历的结构4.由于数组的遍历会调用遍历器接口，所以任何接收数组作为参数的场合其实都调用了遍历器接口。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[箭头函数]]></title>
    <url>%2F2020%2F07%2F24%2F%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[用处：常用在回调函数 let a = ()=&gt;{ … } 形参 只有一个形参的时候，()可以省略 其余时候，()不能省略 函数体 函数体内只有一条语句或者表达式，{}可省略，省略后自动return 其余情况不可以省略，并且需要返回值时，需要加上return 注意：由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 //报错 let getTempItem = id =&gt; { id, name: &quot;Temp&quot; }; // 不报错 let getTempItem = id =&gt; ({ id, name: &quot;Temp&quot; }); 特点：1.箭头函数没有arguments，但是如果在箭头函数需要参数时，可以使用rest运算符来取代arguments2.箭头函数没有prototype属性，不能用作构造函数（不能用new关键字调用）3.箭头函数本身是没有this，它的this不是调用的时候决定的，而是声明时所在作用域下的this值。 let obj = { getName(){ btn2.onclick = ()=&gt;{ console.log(this) } } } obj.getName() //输出obj let obj = { getName:()=&gt;{ btn2.onclick = ()=&gt;{ console.log(this) } } } obj.getName() //输出window 因此，箭头函数替代了以前需要显式的声明一个变量保存this的操作，使得代码更加的简洁。还有一个好处在数组的迭代中使用箭头函数更加简洁，并且省略了return关键字。 let arr = [1,2,3] arr.filter (item=&gt; item === 2)//[2] arr.map(item =&gt; item*2 ) //[2,4,6] arr.reduce((acc,cur) = acc+cur) //6 总结 1.箭头函数适合与this无关的问题，定时器、数组的方法回调2.箭头函数不适合与this有关的回调，事件回调，对象的方法]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6(含之后的版本)]]></title>
    <url>%2F2020%2F07%2F24%2Fes6%2F</url>
    <content type="text"><![CDATA[let/const特点: 不能重复定义 在块级作用域内有效,不影响作用域链 不存在变量提升 const不可以被修改，声明时必须赋值 补充:1.新增块级作用域：if、else\while、for后面的{}或者直接的{}2.数组和对象常量的元素是可以修改的，因为常量地址是没有变化的。 变量的声明提前:使用var关键字声明的变量。会在所有的代码执行前被声明（但是不会赋值）函数的声明提前：使用function 函数名{}声明的函数会在所有的代码执行前就被创建 使用let/const定义的变量在没声明前是无法使用的。 在循环使用中常用。如下述代码，结果会全部输出2，原因是：点击事件是回调函数进入队列，等同步执行的代码执行完毕之后，再执行,i是全局变量，此时的i已经是最后一次循环之后的i了。es6中的let也可以解决这个问题，因为let有自己的块级作用域，使用i值的时候，仅当次循环有用。 //html &lt;button&gt;测试1&lt;/button&gt; &lt;button&gt;测试2&lt;/button&gt; &lt;button&gt;测试3&lt;/button&gt; //js let btns = document.getElementsByTagName(&quot;button&quot;); for (var i = 0;i&lt;btns.length;i++) { var btn = btns[i]; btn.onclick =function () { alert(i) } } //执行回调时此时的i已经是最后一次循环之后的i了 //{var i = 0} {var i = 1} {var i = 2} 还有一点是let/const不属于顶层全局变量，不用担心污染全局的window对象。 let a = 0 console.log(window.a)//undefined var b = 1 console.log(window.b)//1 变量的解构赋值理解：从对象或数组中提取数据，并赋值给变量(多个)。常用：函数形参对象的解构赋值。 例：交换对象,解构的目标是数组，所以以数组的形式来接收。 let a = 1 let b = 2 [a,b] = [b,a] //a=2 , b =1 模板字符串作用：简化字符串的拼接使用：模板字符串必须用包含，变化的部分使用${xxx}定义 对象属性/方法简写对象属性简写：当对象的属性和值相同时，省略属性名 省略的是属性名而不是值 必须是一个变量 方法的简写：当对象的属性是一个方法，可以使用简写形式。 //es5 let obj ={ func:function(){} } } //es6 let obj2={ func(){} //不太常用 func:()=&gt;{} //常用箭头函数 } 箭头函数箭头函数 形参默认值在定义函数时可以定义形参的默认值，当不传入参数的时候默认使用形参里的默认值。一般有默认值的形参放在最后。 //定义形参默认值 function add(a=0,b=1) { return a+b } console.log(add()); //输出1 …rest参数... 把实参封装成数组，rest参数中的变量代表一个数组。主要用于形参，且rest参数之后不能有其他参数。在ES9中，封装成对象也可以了。 剩余运算符：用来代替arguments，比arguments灵活。 补充:arguments.callee()方法的意思是：调用函数本身。 function foo(...value){ //收集传过来的2，65两个元素 console.log(value)//输出[2,65]是一个真数组 } function foo(value){ console.log(arguments)//2,65是一个伪数组 } foo(2,65) 扩展运算符...将数组转换为逗号分割的参数序列，常用于函数调用ES9中也可以将对象转换为逗号分割的参数序列。 扩展运算符可以和数组的解构赋值一起使用，但是必须放在最后一个，因为剩余/扩展运算符的原理其实是利用了数组的迭代器，它会消耗3个点后面的数组的所有迭代器，读取所有迭代器生成对象的value属性，剩余/扩展运算符后不能在有解构赋值，因为剩余/扩展运算符已经消耗了所有迭代器，而数组的解构赋值也是消耗迭代器，但是这个时候已经没有迭代器了，所以会报错 let [first,...arr]=[1,2,3,4,5]//不会报错 let[...arr,last] = [1,2,3,4,5] //报错 SymbolSymbol主要用于解决ES5的对象属性名都是字符串，容易造成属性名的冲突问题。是一种类似于字符串的数据类型。 Symbol是ES6中添加的新的数据类型(原来的有：String，Number,Boolean,Object,Null(空对象指针),Undefined(声明的变量未被初始化时)) 特点: Symbol的值是唯一的，解决命名冲突问题。(类似id) Symbol值不能与其他数据进行计算，包括同字符串拼接 Symbol可以转化为布尔值 Symbol定义的对象属性不能用for/in 循环遍历，可以使用Reflect.ownKeys来获取对象的所有键名。 //创建Symbol，通过Symbol函数创建 let symbol = Symbol(); console.log(symbol) //输出Symbol //Symbol(&#39;对实例的描述&#39;),Symbol是唯一的与如何描述实例无关 //对实例进行描述，主要是用于控制台输出时容易区分 let s1 = Symbol(&quot;a&quot;) let s2 = Symbol(&quot;a&quot;) console.log(s1===s2) //false //Symbol.for 创建 let s3 = Symbol.for(&quot;b&quot;) let s4 = Symbol.for(&quot;b&quot;) console.log(s3===s4) //true symbol的作用场景就是给对象添加属性/方法 1.当symbol作为对象的属性时，用[Symbol]形式，不用XX.Symbol形式。并且在定义的时候也需要加中括号2.除了自己定义使用的Symbol值以外，ES6还提供了11个内置的Symbol方法，比如Symbol.iterator属性 Symbol.prototype.description 获取创建symbol实例时对其的描述。 iterator迭代器iterator迭代器 Generator函数概念：ES6提供的解决异步编程的方案之一。 特点：1.写法:function函数名*2.内部用yield表达式来定义不同的状态3.其返回值是一个Iterator迭代器（指针对象）4.通过调用返回值的next()方法执行函数内部语句 比如某个事物只有三种状态（状态A，状态B，状态C），而这三种状态的变化是 状态A =&gt; 状态B =&gt; 状态C =&gt; 状态A ，这就是状态机。Generator特别适用于处理这种状态机。 // A，B，C三种状态循环 function* state(){ while(1){ yield &#39;A&#39;; yield &#39;B&#39;; yield &#39;C&#39;; } } let status = state();//返回的是指针对象,迭代器对象 //碰到yield返回 console.log(status.next()); // 先暂停到A，后面的代码不执行，返回{value: &quot;A&quot;, done: false} console.log(status.next()); // 执行下一条指令，暂停到B，返回{value: &quot;B&quot;, done: false} console.log(status.next()); // {value: &quot;C&quot;, done: false} console.log(status.next()); // {value: &quot;A&quot;, done: false} console.log(status.next()); // {value: &quot;B&quot;, done: false} function* state(){ yield &#39;A&#39;; yield &#39;B&#39;; yield &#39;C&#39;; } for(let v of gen(){ console.log(v) //输出A,B,C }) Iterator迭代器遍历结束时，返回的是：{value: undefined, done: true},Generator函数可以使用return来改变最后的返回值 next传的参数可以作为yield语句(默认返回undefined)的返回值。第一个next表示启动，第二个next对应的才是第一个yieId语句。 function * state(){ let result = yield &#39;hello&#39; console.log(result)//输出xxx } let iterator = state() iterator.next(&quot;aaa&quot;) iterator.next(&quot;xxx&quot;) 实例如何实现异步 //需求:1s 输出111，2s后输出 222，3s输出 333 //定时器方法 setTimeout(() =&gt; { console.log(111); setTimeout(() =&gt; { console.log(222); setTimeout(() =&gt; { console.log(333); }, 3000) }, 2000) }, 1000) //使用生成器函数 function one(){ setTimeout(()=&gt;{ console.log(111); iterator.next(); },1000) } function two(){ setTimeout(()=&gt;{ console.log(111); iterator.next() },2000) } function three(){ setTimeout(()=&gt;{ console.log(111); iterator.next() },3000) } function * gen(){ yield one(); yield two(); yield three(); } //调用生成器函数 let iterator = gen() Promise对象Promise是JS中进行异步编程的新的解决方案，之前是纯回调的方法。 回调函数的一些缺点:1.多重嵌套，导致回调地狱 Promise引入了链式调用的概念，每个then方法同样也是一个promise，所以可以链式调用下去。其次将异步操作以同步的流程表达出来，更方便阅读。2.不清楚回调是否都是异步调用的（可以同步调用ajax，在收到响应前会阻塞整个线程，会陷入假死状态，非常不推荐）3.第三方库可能没有提供错误处理 Promise在异步请求发送错误的时候，即使没有捕获错误，也不会阻塞主线程的代码 更深入的内容，在之前的博客中Promise学习笔记 Set/Map容器Set容器：无序不可重复的多个value的集合体,类似数组但成员唯一，集合实现了iterator接口。 new Set(array)创建方法 add(value)添加方法 delete(value)删除方法 has(value)判断是否存在方法 clear()清空方法 let set = new Set([1,3,2,2]) console.log(set);//输出唯一出现的值 //add(value)添加方法 set.add(7) console.log(set.size,set)//set.size相当于数组的length 遍历可以使用Set/Map实例对象的keys()，values()，entries()方法进行遍历。由于Set的键名和键值是同一个值，它的每一个元素的key和value是相同的，所有keys()和values()的返回值是相同的，entries()返回的元素中的key和value是相同的。 let set = new Set([4, 5, &#39;hello&#39;]) for(let item of set.keys()) { console.log(item) //输出4，5，hello } for(let item of set.values()) { console.log(item) // 输出4，5，hello } for(let item of set.entries()) { console.log(item) //[4,4],[5,5],[&#39;hello&#39;,&#39;hello&#39;] } Map容器:Map是一组键值对(key-value，只取前两个元素)的结构,key不重复。 let a = new Map() m.set(&#39;Adam&#39;, 67); //添加新的key-value m.has(&#39;Adam&#39;);//是否存在key&quot;Adam&quot; true m.get(&#39;Adam&#39;); //获得key为Adam的value 67 m.delete(&#39;Adam&#39;);//删除key&quot;Adam&quot; m.clear() //清空Map容器 一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉。 classclass类 数值扩展Number.EPSILON 属性的值表示JavaScript里面的最小值 进制表示法二进制用0b，八进制用0o console.log(0b1010);//输出10 Number.isFinite(i) 判断i是否有限大的数返回值：是true,否false Number.isFinite(Infinity)//false Number.isNaN(i) 判断i是否NaN返回值：是true,否false Number.isInteger(i) 判断i是否整数返回值：是true,否false Number.isInteger(120.0)//true Number.parseInt(str) 将字符串转换为对应的数值返回值：对应的数值 Math.trunc(i) 直接i的去除小数部分返回值:整数部分 Math.sign(i) 判断i是正数、负数、还是零 指数运算符(幂) console.log(3 ** 3); //3的3次方=27 BigInt 在普通数据后面加上n，数据类型是大整型。用于很大的数值运算，只能大整型与大整型运算。 //创建大整型 let n = 521n //正数转化成大整型 let n = 123 console.log(BigInt(n)) //输出123n 模块化模块功能主要由两个命令构成export 命令用于规定模块的对外接口import 命令用于输入其他模块提供的功能 //分别暴露 export let name = &quot;ranan&quot; export let fun = function(){} //统一暴露 export {name,fun} //默认暴露 export default { name : &quot;ranan&quot; , fun : function(){} } //通用导入的方式 as 别名 from 地址 import * as data from &quot;path&quot; //如果是默认暴露方式，使用时应该是 data.default.fun() //解构赋值形式,如果重复了可以使用as别名 import {name,fun} from &quot;path&quot; import {name as na,function} from &quot;path&quot; //默认暴露的写法，必须要写别名 import {default as data} from &quot;path&quot; //简便形式 针对默认暴露 import data from &quot;path&quot; console.log(data) //输出{name : &quot;ranan&quot; ,fun : functio(){}} 动态import加载 实现懒加载/按需加载,使用import()函数，返回值是promise对象,pormise返回的成功值就是暴露的对象。 import(path).then(data =&gt; data.xx) ProxyProxy也就是在目标对象之前设置一层拦截，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。 Proxy的作用 拦截和监视外部对对象的访问 降低函数或类的复杂度 在复杂操作前对操作进行校验或对所需资源进行管理 语法：new Proxy(target,handler) target就是被设置一层拦截的对象，可以是任何类型的对象(包括原生数组，函数，甚至另一个代理) handler是一个对象，用来定制拦截行为 Proxy一般和Reflect配套使用,前者拦截对象,后者返回拦截的结果,Proxy上有的的拦截方法Reflect都有 1.set/get方法 set方法接收两个常用参数 target：得到的目标值 key：目标的key值，相当于对象的属性 set方法可以接收四个参数 target:目标值。 key：目标的Key值。 value：要改变的值。 receiver：改变前的原始值。 let handler = { get:function (target,key) { if (target.hasOwnProperty(key)){ return target[key]//key为属性名，target[key]为属性值 } else{ console.warn(`对不起，没有这个${key}`) return } }, set:function (target,key,value) { console.log(&quot;set&quot;,target,key,value); target[key] =value //设置了p.a才打印1 }, //删除属性 deleteProperty:function (target,key) { console.log(`删除${key}属性的${target[key]}值`); delete target[key] }, // 拦截key in object操作 has(target, key) { // 自定义限制：只暴露a属性 if (key === &#39;a&#39;) { return target[key]; } else { return false; } }, } let p = new Proxy({},handler) p.a=1 //set {} a 1 p.b=2 console.log(&#39;b&#39; in p); // false,没有暴露 console.log(&#39;a&#39; in p); //true //console.log(p.a); //delete p.b //删除了b属性的2值 //console.log(p.b); //undefined 可以使用Proxy实现表单验证。 Object.defineProperty也可以实现数据拦截，Proxy有什么优势吗？1.支持数组数组的key是下标，对象的key是属性名 let arr = [1,2,3] let proxy = new Proxy(arr, { get (target, key, receiver) { console.log(&#39;get&#39;, key) return Reflect.get(target, key, receiver) }, set (target, key, value, receiver) { console.log(&#39;set&#39;, key, value) return Reflect.set(target, key, value, receiver) } }) proxy.push(4) // get push (寻找 proxy.push 方法) // get length (获取当前的 length) // set 3 4 (设置 proxy[3] = 4) // set length 4 (设置 proxy.length = 4) 2.Object.defineProperty()的升级版 外界对某个对象的访问，都必须经过这层拦截。因此它是针对整个对象，而不是对象的某个属性。 可选链操作符可选链操作符?.允许读取一个被连接对象的深层次的属性的值而无需明确校验链条上每一个引用的有效性，类似.运算。.:如果对象链.上有数据为null或undefiend，操作符会抛出一个错误?.:如果对象链上有数据为null或undefiend，操作符则会按照短路计算的方式进行处理，返回 undefined。 比如读取一个对象的深层属性 const obj = { foo: { bar: { baz: 42, fun: ()=&gt;{} }, }, }; // 不使用?. 需要层层判断防止报错 let baz = obj &amp;&amp; obj.foo &amp;&amp; obj.foo.bar &amp;&amp; obj.foo.bar.baz; // 使用?. 不需要层层判断 let baz = obj?.foo?.bar?.baz; // 结果：42 绝对全局对象globalThis不管是浏览器还是nodejs还是其他环境，globalThis永远表示全局对象，比如浏览器环境表示window，nodejs下表示global]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript高级]]></title>
    <url>%2F2020%2F07%2F22%2FJavaScript%E9%AB%98%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[判断数据类型typeoftypeof返回数据类型的字符串表达,它的返回值都是’数据类型’ undefined -&gt; ‘undefined’string -&gt; ‘string’boolean -&gt;’boolean’null -&gt; ‘object’ 因为该类型只有一个值，所以可以用=== 来判断类型object -&gt;’object’object(function) -&gt; ‘function’object(array) -&gt;’object’ 总结typeof不能明确的区别null和object、object和array instanceof可以使用instanceof对对象进行细分 A instanceof 构造函数 通过instanceof可以检查一个对象是否一个构造函数的实例，instanceof原来是寻找实例对象A的原型链 function -&gt; Function object -&gt; Object array-&gt; Array 综合例题 let a = { age: 12 } function fu(obj) { obj = { age: 13 } } fu(a) console.log(a.age); //输出12 //开始传参可以理解成obj=a，函数执行时obj重新指向另外一个空间 //函数执行完毕函数作用域销毁，obj自动释放，obj所指对象的空间在后面的某个时刻由垃圾回收器回收 函数回调函数回调函数 立即执行函数防止污染全局命名空间,编写js模块匿名函数自调用;(function(){})() 分号的问题需要加分号的语句,一般js最终执行时会压缩。1.小括号开头的前一条语句，如匿名函数自调用2.中括号开头的前一条语句 this指针this指针 原型与原型链原型与原型链 变量提升与函数提升通过var声明的变量，会被提升。定义的函数，可以在定义语句前执行，这就是函数提升。 var a=3 function fu(){ console.log(a) var a = 4 //输出undefined 局部函数定义个变量a会提升到函数的最开始 } fn() 在全局代码执行前，JS引擎会创建一个栈来存储管理所有的执行上下文。在全局执行上下文(window)确定后，将其添加到栈中，在函数执行上下文(调用函数时产生)，将其添加到栈中。在当前函数执行完后，函数执行上下文出栈，最后所有代码执行完后，栈中只剩下window 作用域是静态的，开始就存在且不会变化。函数上下文是动态的。 var x = 10; //fn作用域，开始就存在了 function fn(){ console.log(x) } //show作用域 function show(f){ var x = 20 f() //执行时先在fn的作用域里面找x是不存在的，然后再从全局作用域中找 所以输出10 } show(fn) //输出10 全局执行上下文 在执行全局代码前，将window确定为全局执行上下文对全局数据进行预处理:var 定义的全局变量 -&gt; undefined 添加为window的属性function 声明的全局函数 -&gt; 赋值，添加为window的方法this -&gt; 赋值(window)开始执行全局代码 函数执行上下文在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象（虚拟对象，因为函数执行完毕会销毁）对局部数据进行预处理:1.函数的上下文对象 this2.封装实参的对象 arguments 是一个类数组对象/有length、可以通过索引操作的对象3.形参变量 -&gt; 赋值 -&gt; 添加为执行上下文的属性其余类似全局执行上下文 闭包闭包 宏队列与微队列宏队列与微队列 H5 Web Workers(多线程) Web Workers 是 HTML5 提供的一个javascript多线程解决方案（常用于计算），但是子线程完全受主线程控制，且不得操作DOM，所以这个新标准并没有改变javascript单线程的本质。 1.创建一个分线程执行的js文件 分线程的全局对象不再是window了，所以分线程不得操作DOM var onmessage = function(event){ //不能用函数声明，只能用赋值的形式 var upper = event.data //通过event.data获得主线程发来的数据 postMessage(upper) //将数据发给主线程 } 2.在主线程中的js中发消息并设置回调 //创建一个Woker对象 var worker = new Worker(&quot;分线程执行的js文件地址&quot;) //向分线程发送消息 worker.postMessage(&quot;向分线程执行的js发送数据&quot;) //接收worker传过来的数据函数 worker.onmessage = function(event){ alert(event.data) //分线程返回的数据在event.data里面 }]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM]]></title>
    <url>%2F2020%2F07%2F21%2FBOM%2F</url>
    <content type="text"><![CDATA[BOM 浏览器对象模型，可以通过js代码操作浏览器 BOM对象window代表的是整个浏览器窗口，同时window也是网页中的全局对象navigator代表的当前浏览器的信息，通过该对象识别不同的浏览器location代表当前浏览器的地址栏信息，可以操作页面重定向history代表浏览器的历史记录，可以通过该对象操作浏览器的历史记录，由于隐私获取不到具体的历史记录，只能操作浏览器后退与前进，只在当次访问时有效screen代表用户的屏幕信息 这些BOM对象在浏览器中作为window对象的属性保存，可以通过window对象来使用，也可以直接使用。 navigator由于历史原因，navigator对象中的大部分属性都已经不能帮助我们识别浏览器了。一般只会使用userAgent属性来判断浏览器的信息/chrom/i.test(navigator.userAgent) 测试是否是chrom浏览器,但是最新的IE判断不出来了 historyhistory.length 可以获取当前访问了的页面数history.back() 返回上一个页面，类似浏览器的回退按钮history.forword() 可以跳转到下一个页面，类似浏览器前进history.go(整数) 可以跳转到指定页面 -1回退一个界面，1前进一个页面 location如果直接打印location，则可以获得当前页面的完整路径通过location修改的路径，会有历史记录(可回退)。 location.assign(path) 用来跳转到其他页面，类似直接修改location路径。location.reload() 刷新页面，默认会情况缓存。location.replace(path) 用新页面代替当前页面，不会生成历史记录。 window定时器 setInterval(回调函数,时间)回调函数每个一段时间就被调用一次。返回一个Number类型的数据，用于标识定时器，利用返回值可以关闭定时器clearInterval(标识是哪一个定时器)，可以接收任意参数，如果参数不是一个有效的标识，也不会报错只是什么 都不做。 为了防止开启多个定时器，导致定时器重叠，在开启定时器之前，需要将上一个定时器关闭。 延时调用延时调用一个函数不马上执行，而是隔一段时间后在执行，而且只会执行一次setTimeout(回调函数,时间)clearTimeout(标识是哪一个定时器)]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM]]></title>
    <url>%2F2020%2F07%2F18%2FDOM%2F</url>
    <content type="text"><![CDATA[DOM全程Document Object Model文档对象模型。文档表示的是整个的HTML网页文档;对象表示将网页中的每一个部分都转换成了一个对象;模型来表示对象之间的关系,方便我们获取对象。 Document对象：实际上是window对象的属性。这个对象的独特之处是唯一一个既属于BOM又属于DOM的对象。在页面中可以直接使用，代表的是整个网页。 注意点 1.取消默认行为可以通过在响应函数的最后return false来取消默认行为，或者使用event.preventDefault()2.如果需要读取元素节点属性，直接使用 元素.属性名，但是class属性不能采用这种方式，需要使用className。3.window.onload = function(){//页面加载完之后再执行，确保所有的DOM对象已经加载完毕} node.nodeType 得到节点类型 //比如:&lt;div id=&quot;test&quot;&gt;xxxx&lt;/div&gt; //标签节点 const elementNode = ducument.getElementById(&quot;test&quot;) //属性节点 const attrNode = elementNode.getAttributeNode(&quot;id&quot;) //textNode.textContent === xxxx //文本节点 const textNode = elementNode.firstChild DOM查询innerText 获取到元素内部的文本内容，会自动将html标签去除innerHTML 获取到元素内部的文本内容，会保存html标签 获取元素节点，通过document对象调用document.getElementById() 通过id获取domdocument.getElementsByClassName() 通过类名获取domdocument.getElementsByName() 通过name属性获取domdocument.getElementsByTagName() 通过标签名获取domdocument.querySelector() 该方法总会返回唯一的一个元素document.querySelectorAll() 返回数组。 获得元素节点的子节点，通过具体的元素节点调用getElementsByTagName() 方法，返回当前节点指定标签名的后代节点childNodes 属性，表示当前节点的所有子节点,会获取包括文本节点在内的所有结点，DOM标签与标签之间的换行也会看成文本结点。children 属性可以获取当前元素的所有子元素firstChild 属性，表示当前节点的第一个子节点，包括空白文本结点firstElementChild 属性获取当前元素的第一个子元素lastChild 属性，表示当前节点的最后一个子节点 获取父节点和兄弟结点,通过具体的节点调用parentNode 属性，表示当前节点的父节点previousSibling 属性，表示当前节点的前一个兄弟节点，可能会获取到空白文本previousElementSibling 属性，表示当前节点的前一个兄弟元素nextSibling 属性，表示当前节点的后一个兄弟节点 补充获取body,document中有一个属性body，它保存的就是body的引用document.body 获取html,document.documentElement DOM 增删改document.createElement() 参数为标签名，用于创建一个元素节点对象，并返回创建好的对象document.createTextNode() 参数为文本内容，根据内容创建文本节点，并返回新的节点父节点.appendChild() 向一个父节点中添加新的子节点父节点.insetBefore() 在指定的子节点前插入新的子节点,(新节点,旧节点)父节点.replaceChild() 使用指定的子节点替换已有的子节点，(新节点,旧节点)父节点.removeChild() 删除一个子节点 DOM操作cssjs通常返回的是不带单位的数值 内联样式 语法:元素.style.样式名 = 样式值 如果css的样式名中含有-,需要改成驼峰命名法。通过style属性设置/读取的样式都是内联样式，内联样式有很高的优先级。 通过style属性来修改元素的样式，每修改一个样式，浏览器需要重新渲染一次页面 如果要同时修改多个样式，直接通过类名修改对象.className = “” 当前正在显示的样式语法:元素.currentStyle.样式名 只有ie浏览器支持,没设置的值获取默认值，其他浏览器可以使用window.getComputedStyle()来获取。 第一个参数是要获取样式的元素第二个参数可以传递伪元素，一般都传null返回值是当前元素对应的样式的对象,后接样式名获取样式如果该样式没设置获取到的是真实值而不是默认值 通过以上两种方式获取到的样式都是只读的,如果需要修改只能使用style属性 处理兼容性问题 定义一个函数来获取指定元素当前的样式，参数obj要获取样式的元素，style要获取的样式名字符串 function getStyle(obj,style){ if(window.getComputedStyle){ //正常浏览器有getComputedStyle方法 return getComputedStyle(obj,null)[style] } else{ //IE8浏览器没有定义getComputedStyle return obj.currentStyle[style] } } 注意if里面用getComputedStyle不行，要用window.getComputedStyle没使用window时getComputedStyle是一个变量需要去作用域中寻找，没定义就是用会报错，后续代码不会执行使用window之后属于属性，没找到属性返回undefined 其他样式相关属性 element.clientWidth/clientHeight这两个属性可以获取元素的可见(内容和内边距)宽度和高度,返回的是数字，不带px，因为包括的是可见区域所以设置起来无法分配,所以这两个属性都是只读属性。element.offsetWidth/offsetHeight获取元素的整个大小,包括内容、内边距、边框，其他特点与clientWidth/clientHeight属性相似。 element.offsetParent可以获取当前元素的定位父元素,都没有定位返回bodyelement.offsetLeft/offsetTOP当前元素相对于其定位的水平偏移量和垂直偏移量element.scrollHeight/scrollLeft/scrollTop/scrollWidth表示元素整个滚动区域的宽度/高度,可以获取滚动条滚动的距离当满足下面等式的时候，说明滚动条滚动到最底，水平滚动条类似。总长度 - 看不见的长度 = 可见的长度element.scrollHeight - element.scrollTop = clientHeight 事件当事件的响应函数被触发时，浏览器每次都会将一个事件对象(event)作为实参传递给响应函数，封装当前事件相关的一切信息，比如：鼠标坐标，键盘哪个键被按。但是IE8不会传,事件对象作为window对象的属性保存的window.event 可以使用 event = event || window.event 来解决兼容性问题 事件对象event.clientX 可以获取鼠标指针的水平坐标，返回数值，不带单位event.clientY 可以获取鼠标指针的垂直坐标，返回数值，不带单位用于获取鼠标在当前的可见窗口的坐标event.pageX/event.pageY获取鼠标相对于当前页面(document)的坐标,但是IE8不支持，可以通过对top = scrollTop + clientX实现offsetX/offsetY screenX/screenY 补充:chrome认为浏览器的滚动条是body的，通过body.scrollTop获取，但是火狐等浏览器认为是html的，通过documentElement.scrollTop获取 现在浏览器的滚动条都是html的了 event.wheelDalta 获得滚轮的方向 正向上滚，负向下滚event.target 触发事件的对象event.keyCode 获取按键的编码 event.altKey/ctrlKey/shiftKey判断alt/ctrl/shift是否被按下 onscroll 该事件会在元素的滚动条滚动时触发onmousemove 该事件会在鼠标在元素中移动时被触发onmousedown 该事件会在鼠标按下被触发onmouseup 该事件会在鼠标弹上被触发onwheel 该事件会在鼠标滚轮滚动时被触发 onmouseenter/onmouseleave 与 onmouseover/onmouseout 区别是前面的一组移入子元素是不会触发的 键盘事件一般绑定给可以获取焦点的对象或者是documentonkeydown 键盘按下触发，一直按着不松手会连续触发，在文本框中输入内容，属于onkeydown的默认行为根据此性质可以限定文本框内容输入的类型onkeyup 按键被松开，不会连续触发 事件的冒泡所谓的冒泡指的是事件向上传递，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发。在开发中大部分情况冒泡都是有用的，如果不希望发生事件冒泡可以通过事件对象取消冒泡event.cancelBubble = true 事件的委派需求场景：给a标签绑点点击事件，后添加的a标签也有该绑定事件。解决:可以尝试把时间绑定到元素共有的祖先元素。事件委派利用了冒泡，从父元素到子元素 事件的绑定 对象.事件 = 函数 的形式绑定响应函数，同时只能为一个事件绑定一个响应函数 addEventListener可以为一个事件同时绑定多个响应函数，后面的不会覆盖前面的对象.addEventListener() 第一个参数事件的字符串，不要on，第二个参数时间触发时的回调函数，第三个参数是否在捕获阶段触发事件，一般都是false DocumentFragment文档片段接口，高效批量更新多个节点(只更新一次)一个fragment对象就是内存中的节点容器(只存在于内存中、页面不显示) 用一个fragment对象包裹住需要更新的节点（原处的节点消失了，因为节点的父节点只能有一个），处理fragment的所有子节点，将fragment添加为div的子节点(fragment不会进入div,fragment的所有子节点进入div) 由于处理fragment的所有子节点都是在内存中进行的不更新界面，最后把fragment的所有子节点添加进div时才更新界面，所以实现了页面仅更新一次就批量操作多个节点。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2020%2F07%2F16%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式创建正则表达式的对象 构造函数方式语法:let 变量 = new RegExp(“正则表达式”,”匹配模式”)字面量方式语法:let 变量 = /正则表达式/匹配模式 具体用法 匹配模式i 忽略大小写g 全局匹配模式 test()检查一个字符串是否符合正则表达式的规则参数为被检查的字符串返回值为布尔值 //正则表达式规则:字符串是否含有a let reg = new RegExp(&quot;a&quot;) let str = &quot;a&quot; reg.test(str) 或|表示或 reg=/a|b/ -&gt; a或者b[]里的内容也是或 reg=/a-z/ -&gt; 任意的小写字母[^ ] 查找任何除了[]里的字符 reg=/[^ab]/ -&gt; 除了a或b的字符 //以a开头c结尾中间是b或d或e reg = /a[bde]c/ //c是除了ab的字符，所以返回true reg = /[^ab]/ reg.test(&#39;abc&#39;) 量词通过量词可以设置一个内容出现的次数，量词只对它前面的一个内容起作用，如果要对多个加括号。 a{n} 表示n个连续的aa{1,3} 表示最少一个a最多3个连续aa+ 表示至少一个a,{1,}a* 表示0个或多个,{0,}a? 表示0个会1个,{0,1}^a 表示以a开头a$ 表示以a结尾 注意: ^a$只表示a 元字符 .表示任意字符,如果要检查.需要转义/./,new RegExp(“\.”)使用构造函数时，它的参数是一个字符串，而\是字符串中转义字符，所以使用\需要转义成\使用\w 任意字母、数字、_ 相当于[A-z0-9_]\W 除了字母、数字、_ 相当于[^A-z0-9_]\d 任意的数字\D 除了数字\s 空格 \S除了空格\b 单词边界，\bxxx\b独立的单词 \D 除了单词边界 字符串和正则相关的方法split()语法：string.split(“,”)/string.split(/[0-9]/)join()的功能相反,可以将一个字符串拆分为一个数组参数为拆分规则,如例子的根据字符串里的逗号拆分数组,参数可以是正则表达式 默认全拆不修改原字符串，返回值为数组 let str=&quot;1a2b3c4d5e6f&quot; let result = str.split(/[0-9]/) //输出[a,b,c,d,e,f] search()语法:string.search(搜索的内容)搜索字符串中是否含有指定内容,返回第一次(g失效)出现的索引或者-1参数是指定内容可以是正则表达式 match()语法:string.match(条件)根据正则表达式，从一个字符串中将符合条件的内容提取出来,返回值是数组 默认返回符合条件的第一个内容要找所有内容，开启全局匹配模式可以为一个正则表达式设置多个匹配模式，顺序无所谓 let str=&quot;1a2b3c4d5e6f&quot; let result = str.match(/[0-9]/g) //输出[1,2,3,4,5,6] replace()语法:string.search(被替换的内容，新的内容)可以将字符串中指定内容替换为新内容，被替换的内容可以是正则表达式。 默认只替换第一个不影响原来的字符串，返回新的字符串 可以使用它去空格 //会去掉全部的空格 str = str.replace(/\s/g,&quot;&quot;) //去掉开头的空格 str = str.replace(/^\s*/,&quot;&quot;) //去掉结尾的空格 str = str.replace(/\s*$/,&quot;&quot;) //去掉开头和结尾的空格 str = str.replace(/^\s*|\s*$/g,&quot;&quot;) 这里去掉字符串的头尾空格可以使用字符串的trim()方法 常用正则检查是否合法手机号 手机号11位,以1开头,第二位3-9，三位以后任意数字9个 /^1[3-9][0-9]{9}$/ 电子邮件 hello.nihao@qbc.com.cn 任意字母数字下划线 \w{3,}.任意字母数字下划线 (.\w+)*@任意字母数字 [A-Za-z0-9]+.任意字母(2-5位) .任意字母(2-5位) (.[A-Za-z]{2,5}){1,2} let emailReg=/^\w{3,}(\.\w+)*@[A-Za-z0-9]+/ (\.[A-Za-z]{2,5}){1,2}$/ 贪婪与懒惰贪婪模式:匹配尽可能多的字符懒惰模式:匹配尽可能少的字符，会不断的回溯 常用场景.*与.*?，使用?来表示使用懒惰模式匹配 正则扩展exec()捕获()括号包裹的内容 加了()表示子匹配，匹配外部大正则的情况下同时匹配()里的内容保存$1、$2… 语法:RegExpObject.exec(string)方法用于检索字符串中的正则表达式的匹配。如果 exec() 找到了匹配的文本，则返回一个结果数组。否则，返回 null。不管是否/g开启全局，只返回匹配的第一个。如果要返回匹配的多个可以使用while(reg.exec(str))或者使用String.prototype.matchAll()方法。 let str = `&lt;ul&gt; &lt;li&gt; &lt;a&gt;ranan&lt;/a&gt; &lt;p&gt;喜欢粉色&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;a&gt;linin&lt;/a&gt; &lt;p&gt;喜欢白色&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; ` const reg = /&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\/a&gt;.*?&lt;p&gt;(.*?)&lt;\/p&gt;/s const result = reg.exec(str) console.log(result); //输出一个数组，第一个元素是匹配的文本，第二个值第一个(.*?)返回值，第三个值第二个(.*?)返回值 命名捕获分组 通过?&lt;对捕获到的元素进行命名&gt;,返回的数组中有一个groups属性。 let str = &#39;&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;&#39; const reg = /&lt;a href=&quot;(?&lt;url&gt;.*)&quot;&gt;(?&lt;text&gt;.*)&lt;\/a&gt;/ const result = reg.exec(str) console.log(result) //数组前面3个返回值与上述方法相同，[....,goups:{url:http://www.baidu.com},text:&quot;尚硅谷&quot;] //result.groups使用。 反向断言 判断匹配结果是否正确 正向断言,常用表示(?=pattern),从当前匹配位置开始测试后面(右边)匹配字符串是否成立。(?!patter)为其否定写法。 //正向断言 let str = &#39;JS51566哈哈哈11嗯嗯&#39; const reg = /\d+(?=嗯)/ const result = reg.exec(str) //输出[11] 反向断言，常见表达式(?&lt; pattern)或者(?&lt;!pattern),表示当前位置左边将出现匹配字符 dotAll模式 . 代表元字符查找单个字符，除了换行和行结束符。dotAll /正则/s，新增修饰符s使.可以匹配任意字符。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型与原型链]]></title>
    <url>%2F2020%2F07%2F15%2F%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[原型(prototype)此图中的实例对象也称为原型对象 我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype 函数的prototype属性，这个属性指向着一个对象(原型对象),原型对象相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，所以我们可以将对象中共有的内容，统一设置到原型对象中。 如果函数作为普通函数调用prototype没有任何作用。如果函数作为构造函数调用，它所创建的对象中都有一个属性__proto__指向构造函数的原型对象。 注理解一定要把握对象的proto指向的是构造函数的prototype（原型）。 显式原型与隐式原型 每个对象都有隐式原型·proto·这个属性，而function既有隐式原型（proto）又有显式原型（prototype），因为函数在js里面既是函数也是对象。 prototype也是一个对象，只要是对象就有proto. 对象的隐式原型的值为其对应构造函数的显式原型的值，prototype与__proto__里面保存一样的地址值。 原型链当访问一个对象的属性时，先在自身属性中查找，找到返回。如果没有，则会去原型对象中寻找（根据元素本身的proto去找），找到返回，如果最终没有找到，返回undefined,所以Object的原型对象是原型链的尽头，Object的原型对象没有原型。(Object.prototype.ptoto === null) 注意函数的产生：所有函数都是Function的实例包括它本身，所以Function.proto === Function.prototype function Foo(){} //实际上 var Foo = new Function() //Function是它自身的实例 Function = new Function() Function.__proto__ === Function.prototype //true //构造函数object funtion Object(){} let Object = new Function() //所以Object的__proto__指向Function.prototype 原型继承构造函数的实例对象自动拥有构造函数原型对象的属性(方法)，原理是利用原型链 补充知识点1.静态成员与实例成员实例成员就是构造函数内部通过this添加的成员。实例成员只能通过实例化的对象来访问。（不可以通过构造函数来访问实例成员）静态成员在构造函数本身上添加的成员(Fn.xxx=&quot;xxx&quot;)。静态成员只能通过函数对象访问。（不可以通过实例对象来访问） 2.构造函数、实例、原型对象三者之间的关系__proto__和原型对象中(xx.prototype)都有一个属性constructor，它指向函数对象（xx.prototype.constructor===xx）。主要用来记录该对象引用哪个构造函数 3.继承(ES5)补充：call()函数，调用这个函数并改变运行时this的指向，调用函数.call(参数)。 如：obj1.(method).call(obj2,argument1,argument2)call的作用就是把obj1的方法放到obj2上使用，后面的argument1..这些做为参数传入。 ES6之前没有提供extends继承。可以通过构造函数+原型对象模拟实现继承，被称为组合继承。核心原理:通过 call()把父类型的this指向子类型的this，这样就可以实现子类型继承父类型的属性，然后通过子类型的原型等于父类型的实例，看见父类型原型上的方法 //父构造函数 this指向父构造函数的对象实例 function Father(name,age){ this.name = name; this.age = age; } Father.prototype.money= ()=&gt;{ console.log(&#39;父亲要上班&#39;); } //子构造函数 this指向子构造函数的对象实例 function Son(name,age) { //把指向父构造函数的对象实例的this改变成指向子构造函数的对象实例的this，这样可以继承属性 Father.call(this,name,age) } //让Son的原型对象指向Father的实例对象，那么就可以访问到Father实例对象上的方法 //这个new Father()是一个原型对象，相当于{}，这样写会覆盖掉Son的原型对象的constructor Son.prototype = new Father(); //所以还需要constructor指回原来的构造函数 Son.prototype.constructor = Son 4.Function和Object的关系1.Object, Function, Array等等这些都被称作是构造“函数”，他们都是函数。2.所有的函数都是构造函数Function的实例。 3.原型链机制的的角度来说，那就是说所有的函数都能通过原型链找到创建他们的Function构造函数的Function.protorype原型对象 所以 console.log(Object instanceof Function)//true 4.Function.prototype是一个对象，所以他的构造函数是Object. 从原型链机制的的角度来说，那就是说所有的函数都能通过原型链找到创建他们的Object构造函数的构造原型Object.prototype对象 所以 console.log(Function instanceof Object)//true]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this指针]]></title>
    <url>%2F2020%2F07%2F15%2Fthis%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[解析器在调用函数时，每次都会向函数内部传递一个隐含的参数this，this指向的是一个对象。根据函数的调用方式不同，this会指向不同的对象。 任何函数本质上都是通过某个对象来调用的。它的值是调用函数的当前对象，谁调用指向谁,如果没调用时，没有指明是哪个对象调用的则是window。 function Person(color) { console.log(this); this.color = color; this.getColor = function () { console.log(this); return this.color; }; this.setColor = function (color) { console.log(this); this.color = color; } } //this是谁 Person(&quot;red&quot;); //window let p = new Person(&quot;yello&quot;) //Person的实例，p p.getColor();//P let obj= {}; p.setColor.call(obj,&quot;black&quot;) //obj let test = p.setColor; test()//window function fun1(){ function fun2() { console.log(this); } fun2() } fun1()//window 补充： new在执行时完成的4件事情：1.在内存中创造一个新的空对象,在堆内存中分配空间2.让this指向这个新的对象3.执行构造函数里面的代码，给这个新对象添加属性和方法4.返回这个新对象(所以构造函数里面不需要return) 最终this指向的是调用它的对象进行了更准确的描述 var o = { a:10, b:{ a:12, fn:function(){ console.log(this.a); //12 } } } o.b.fn(); 知识点1：这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象 var o = { a:10, b:{ fn:function(){ console.log(this.a); //undefined } } } o.b.fn(); 尽管对象b中没有属性a，这个this指向的也是对象b，因为this只会指向它的上一级对象，不管这个对象中有没有this要的东西。 知识点2：this永远指向的是最后调用它的对象，也就是看它执行的时候是谁调用的 var o = { a:10, b:{ a:12, fn:function(){ console.log(this.a); //undefined console.log(this); //window } } } var j = o.b.fn; j(); 除此之外，文章还对this用法进行了补充，当this碰到return的时候 知识点3当this遇见return时，如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。 function fn() { this.user = &#39;xx&#39;; return function(){}; } var a = new fn; console.log(a.user); //undefined function fn() { this.user = &#39;xx&#39;; return 1; } var a = new fn; console.log(a.user); //xx function fn() { this.user = &#39;xx&#39;; return null; } var a = new fn; console.log(a.user); //xx 知识点4Dom事件回调的函数里this是发生事件的标签undefined与null调用的this仍然指向window]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack5]]></title>
    <url>%2F2020%2F07%2F13%2Fwebpack5%2F</url>
    <content type="text"><![CDATA[下载webpack5 npm i webpack@next webpack-cli -D 开发环境 //---------webpack4写法 const {resolve} = require(&quot;path&quot;) module.exports={ entry:&quot;./src/js/index.js&quot;, output:{ //默认的chunk名称是main filename:&quot;js/[name].js&quot;, path:Resolve(__dirname,&quot;build&quot;) }, mode:&quot;development&quot;, } //--------webpack5写法 module.exports= { //其余值为默认值 mode:&quot;development&quot;, } 生产环境 1.用了es6模块化2.production模式 满足以上条件webpack4会自动tree shaking但是在实际中依赖关系复杂时webpack4的tree shaking会失效webpack5对此进行了优化tree shaking会更加强大 //---------webpack4写法 const {resolve} = require(&quot;path&quot;) module.exports={ entry:&quot;./src/js/index.js&quot;, output:{ //默认的chunk名称是main filename:&quot;js/[name].js&quot;, path:Resolve(__dirname,&quot;build&quot;) }, mode:&quot;production&quot; } //--------webpack5写法 module.exports= { mode:&quot;production&quot;, } webpack5主要的关注内容： 通过持久缓存提高构建性能 使用更好的算法和默认值来改善长期缓存 通过更好的tree shaking和代码生成来改善捆绑包的大小 Output webpack 4默认只能输出ES5代码webpack 5设置output.ecmaVersion:2015来胜出ES6/ES2015的代码 SplitChunk //webpack4 统一设置 minSize:30000 //webpack5 minSize:{ javascript:30000 style:5000 } cache 可以通过配置cache实现长久缓存，让第二次打包性能更加高效 之前的webpack总是在第一次构建是输出全部文件，但是监视重新构造时只更新修改的文件。webpack5在第一次构建时会找到输出文件看是否有变化，从而决定要不要输出全部文件。 跨域 解决开发环境ajax请求跨域问题 –&gt; webpack-devServer里面配置代理proxy]]></content>
      <categories>
        <category>前端</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack详细配置]]></title>
    <url>%2F2020%2F07%2F12%2Fwebpack%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[entryentry入口起点，值有三种情况1.string —–&gt;’./src/index.js’打包形成一个chunk，输出一个bundle文件,此时的chunk默认名称是main 2.array —–&gt;[‘./src/index.js’,’./src/add.js’]所有入口文件最终只会形成一个chunk，输出一个bundle文件，此时的chunk默认名称是main作用：HMR功能中html热更新生效 3.object —–&gt;{index:’./src/index.js’,add:’./src/add.js’}有几个入口文件就形成几个chunk，输出几个bundle，chunk的名称是key 特殊用法：2.3结合,value值为一个数组 //----------string module.exports={ entry:&quot;./src/js/index.js&quot;, output:{ //默认的chunk名称是main filename:&quot;js/[name].js&quot;, path:Resolve(__dirname,&quot;build&quot;) }, plugins:[new HtmlWebpackPlugin()], mode:&quot;development&quot;, } outputlibrary一般结合DLL使用 module.exports={ entry:&quot;./src/js/index.js&quot;, output:{ //文件名称（指定名称+目录） filename:&quot;js/[name].js&quot;, //输出文件目录，将来所有资源输出的公共目录 path:Resolve(__dirname,&quot;build&quot;), //所有资源引入公共路径前缀 --&gt;imgs/a.jpg --&gt; /imgs/a.jpg 默认不加一般用于生产环境 publicPath:&quot;/&quot;, //非入口chunk的名称 import动态导入 optimization设置 chunkFilename:&quot;js/[name]_chunk.js&quot;, //整个库向外暴露的变量名 //main.js (function(modules){...} ---&gt; var main = (function(modules){...} library:&#39;[name]&#39; //变量名添加到哪个上，之后如何引入window-browser global-node conmmojs //var main =... --&gt; window[&quot;main&quot;] = ... libraryTarget:&#39;window&#39; }, plugins:[new HtmlWebpackPlugin()], mode:&quot;development&quot;, } moduleLoader让Webpack能够去处理那些非JavaScript文件（Webpack自身只理解JavaScript/json） module.exports={ entry:&quot;./src/js/index.js&quot;, output:{ filename:&quot;js/[name].js&quot;, path:Resolve(__dirname,&quot;build&quot;) }, module:{ //loader配置 rules:[ { test:/\.js$/, //多个loader用use use:[,] //单个loeader用loader //loader:&quot;&quot; //排除node_modules下的js文件 exclude:/node_modules/, //只检查src下的js文件 include:resolve(__dirname,&quot;src&quot;), //优先执行 pre 延后执行 post 默认无顺序 enforce:&quot;post&quot;, //配置属性 options:{} }, { //以下配置只会执行一个 oneOf:[] } ] } plugins:[new HtmlWebpackPlugin()], mode:&quot;development&quot;, } resolve 路径别名module.exports={ entry:&quot;./src/js/index.js&quot;, output:{ filename:&quot;js/[name].js&quot;, path:Resolve(__dirname,&quot;build&quot;) }, module:{ rules:[] } plugins:[new HtmlWebpackPlugin()], mode:&quot;development&quot;, //解析模块的规则 resolve:{ //配置解析模块路径别名，vue里面的@，避免使用../../../过多的情况 //优点 简写路径 缺点 路径没有提示 alias:{ @:resolve(__dirname,src/css) }, //配置省略文件路径的后缀名 extensions:[&#39;.js&#39;,&#39;.json&#39;], //告诉webpack解析模块是去找哪个目录 //可以直接写出找的路径，也可以仅写文件名一层一层去找 modules:[resolve(__dirname,&quot;../../node_modules&quot;),&#39;node_modules&#39;] } } devServerdev是develop的简写，用于开发坏境 利用devServer快速开启一个服务器。 只有在通过devServer启动webpack时，配置文件里的devServer才会生效，因为这些参数所对应的功能都是devServer提供的，webpack本事并不认识devServer的配置项。 module.exports={ entry:&quot;./src/js/index.js&quot;, output:{ filename:&quot;js/[name].js&quot;, path:Resolve(__dirname,&quot;build&quot;) }, module:{ rules:[] } plugins:[new HtmlWebpackPlugin()], mode:&quot;development&quot;, resolve:{}, devServer:{ //运行代码的目录 contentBase:resolve(__dirname,&#39;build&#39;), //监视contentBase目录下的所有文件，一旦文件发生变化就会reload watchContentBase:true, //监视文件的一些配置 watchOptions:{ //忽略文件 ignored:/node_modules/, }, //启动gzip的压缩 compress:true, //端口,域名 port:5000, host:&#39;localhost&#39;, //自动打开浏览器 open:true, //开启HMR功能 hot:true, //不显示启动服务器日志信息 clientLogLevel:&quot;none&quot;, //除了一些基本启动信息以外，其他内容都不显示 quiet:true, //如果出错了，不要全屏提示 overlay:false, //浏览器和代理服务器没有跨域问题，和服务器有跨域问题，通过代理服务器转发 //服务器代理 --&gt; 解决开放环境跨域问题 proxy:{ //一旦devServer(5000)接收到/api/xxx的请求，就会把请求转发到另外一个服务器(3000) &#39;/api&#39;:{ target:&#39;http://localhost:3000&#39;, //发送请求时，请求路径重写：将/api/xxx --&gt; /xxx pathRewrite:{ &quot;^/api&quot;:&#39;&#39; } } } } } optimization用于生产环境 module.exports={ entry:&quot;./src/js/index.js&quot;, output:{ filename:&quot;js/[name].[contenthash:10].js&quot;, path:Resolve(__dirname,&quot;build&quot;), chunkFilename:&#39;js/[name].[contenthash:10]_chunk.js&#39; }, module:{ rules:[] } plugins:[new HtmlWebpackPlugin()], mode:&quot;production&quot;, resolve:{ }, optimization:{ splitChunk:&#39;all&#39;, //以下为默认值 //分割的chunk最小为30kb minSize:30 * 1024, maxSize:0, //最大没有限制 minChunks:1, //要提取的chunk最少被引用一次 maxAsyncRequests:5,//按需加载时并行加载的文件的最大数量 maxInitialRequests:3,//入口js文件最大并行请求数量 automaticNameDelimiter:&quot;~&quot;,//名称连接符 name:true, //可以使用命名规则 cacheGroups:{ //分割chunk的组 vendors:{ //node_modules文件会被打包到vendors组的chunk中 --&gt;vendors~xxx.js //上面的规则对分组里的都生效 test:/[\\/]node_modules[\\/]/, //优先级 priority:-10 }, default:{ //要提取的chunk最少被引用2次 minChunks:2, priority:-20, //如果当前要打包的模块，和之前已经被提取的模块是同一个，直接复用不用重新打包模块 reuseExistingChunk:true } }, //将当前模块记录其他模块的hash单独打包为一个文件runtime //解决缓存失效的问题 runtimeChunk:{ name: entrypoint =&gt; `runtime-${entrypoint.name}` }, //配置生成环境的压缩方案:js和css minimizer:[ //需要下载引入 new TerserWebpackPlugin({ //开启缓存 cache:true, //开启多进程打包 parallel:true, //启动source-map sourceMap:true }) ] } } 存在问题使用contenthash，当index.js动态引入a.js打包成两个chunk，输出的main.js中记录了a.js的hash值，所以a变化时重新打包时hash变化，main.js也会变会重新打包。导致缓存失效。 解决办法：设置runtimeChunk]]></content>
      <categories>
        <category>前端</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack优化配置]]></title>
    <url>%2F2020%2F07%2F10%2Fwebpack%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[开发环境性能优化 优化打包构建速度 HMR 只重新构建发生变化的模块 优化代码调试（错误在哪里） source-map 生产环境优化 优化打包构建速度 oneOf 找到一个loader就不会继续遍历了 babel缓存 第二次构建时，会读取之前的缓存，只重新构建变化的文件 多进程打包 externals 让某些库不打包，通过link引入 dll 让某些库不打包（把库单独先打包好），后面直接用 代码分为node_modules别人的库，和源代码，源代码可以通过import拆分打包，node_modules可以通过dll拆分打包 优化代码运行的性能 缓存（hash-chunkhash-contenthash） tree shaking 去掉没有使用的代码 code split 代码分割 懒加载/预加载（js代码） pwa 离线也可以访问 开发环境性能优化HMR：hot module replacement 热模块替换，作用：一块发生变化，只会重新打包这一个模块（而不是打包所有模块）HTML文件：默认不使用HMR功能，同时会导致问题：html文件不能热更新了。解决办法:修改entry入口，将html文件引入之后html可以热更新了，但是仍然不能使用HMR功能。（html不用做HMR功能）样式文件：可以使用HMR功能是因为style-loader内部实现了，所以在开发环境可以使用style-loader，而在生产环境为了把 css单独提取成一个文件就不使用了。js文件：默认不能使用HMR功能–&gt;需要修改js代码，添加支持HMR功能的代码。（不适用过于麻烦） module.exports={ entry:[&quot;./src/js/index.js&quot;,&quot;./src/index.html&quot;] .... devServer:{ contentBase:resolve(__dirname,&quot;build&quot;), compress:true, port:3000, open:true, //开启HMR功能 //当修改webpack配置，新配置想要生效，必须重启服务器。 hot:true } } source-map：提供源代码到构建后代码映射的技术，如果构建后代码出错了，会通过映射追踪到源代码错误。 [inline-|hidden-|eval-][nosources-][cheap-[module]]source-mapsource-map：外部，错误代码准确信息和可以追踪源代码的错误位置。inline-source-map:内联，只生成一个内联的source-map，错误代码准确信息，可以追踪源代码的错误位置。hidden-source-map:外部，错误代码错误原因，不能追踪到源代码的错误，只能提示到构建后代码的错误位置。eval-source-map:内联，每一个文件都生成对应的source-map，错误代码准备信息和可以追踪源代码的错误位置。nosources-source-map:外部，错误代码准确信息，但是查看不了源代码。cheap-source-map：外部，错误代码准确信息可以追踪源代码的错误位置，只精确到行，精确不到列。cheap-module-source-map：外部，错误代码准确信息可以追踪源代码的错误位置，module会将loader的source map加入内联和外部的区别：1.外部生成了文件，内联没有（直接在生成的输出js中） 2.内联构建速度快3.内联会让体积变得非常大，所以在生成环境不适用内联。 推荐开发坏境：速度快，调试更友好。 速度快(eval&gt;inline&gt;cheap&gt;…)eval-cheap-source-map&gt;eval-source-map.. 调试友好 source-map cheap-module-source-map 一般使用：eval-source-map 生成环境：源代码要不要隐藏？调试要不要更友好？ 源代码隐L藏：hidden-source-map（只隐藏源代码，会提示构建后代码的错误信息） nosources-source-map（全部隐藏） 一般使用source-map module.exports = { ..... //devtool:&quot;source-map&quot; devtool:&quot;inline-source-map&quot; } 生产环境性能优化oneOf：oneOf以下的loader只会匹配一个，一旦匹配到，则不会在继续匹配下面的loader了。不能有两个配置处理同一种类型的文件，所以之前的两个js处理loader需要有一个放在外部。 module.exports = { module:{ rules:[ {eslint...}, { oneOf:[{...},{另外一个js...}...] } ] } } babel缓存：第二次构建时，会读取之前的缓存，只重新构建变化的文件。文件资源缓存：输出的文件(没使用hash)，缓存在浏览器，一定时间内不会重新获取。1.hash:输出文件后面加上hash值（所有文件相同），这样在缓存期如果hash值变化（每次打包都会变化）都会重新获取。存在问题：重新打包就会改变hash，即使没有修改的文件。2.chunkhash：根据chunk生成的hash值，如果打包来源于同一个chunk，那么hash就一样。存在问题css与js的hash值一样，因为css被打包进了js，所以同属于一个chunk。修改项目的文件，只有这个文件和于这个文件相关联的打包文件的hash码变化（css和js还是相同），其他的不变。3.contenthash：根据文件的内容生成hash值，不同文件的hash值不一样。内容变化hash值才改变。 output:{ filename:&quot;js/built.[hash:10].js&quot; //filename:&quot;js/built.[chunkhash:10].js&quot; } //兼容性处理 { test:/\.js$/, exclude:/node_modules/, loader: &quot;babel-loader&quot;, options: { presets:[ &quot;@babel/preset-env&quot;, { useBuiltIns:&quot;usage&quot;, corejs:{version:3}, targets:{ chrome:&quot;60&quot;, } } ], //开启babel缓存 cacheDirectory:true } }, tree shaking：去除没有使用的代码，减少代码体积前提：必须使用ES6模块化且开发环境 在package.json中配置”sideEffects”:false所有代码都可以进行tree shaking，但是有些版本可能会把css文件删掉，所以最好配置”sideEffects”:[“*.css”] code split代码分割拆分文件按需加载 //第一种多入口页面 module.exports={ entry:{ //多入口：有一个入口，输出就有一个bundle main:&quot;./src/js/index.js&quot;, test:&quot;./src/js/test.js&quot; }, output:{ //[name]去入口文件的文件名 filename:&quot;js/[name].[contenthash:10].js&quot;, path:Resolve(__dirname,&quot;build&quot;) }, plugins:[...], mode:&quot;production&quot;, } //第二种配置splitChunks module.exports={ entry:&quot;./src/js/index.js&quot;, output:{...}, plugins:[...], /* 1.可以将node——mudules中代码单独打包成一个chunk输出 2.会自动分析多入口chunk中，有没有公共的文件，如果有会打包成单独的一个chunk不会重复打包 */ optimization:{ splitChunks:{ chunks:&quot;all&quot; } }, mode:&quot;production&quot;, } //第三种通过js代码，让某个文件被单独打包成一个chunk //import动态导入语法能将某个文件单独打包,添加该注释可以设置打包的名字 //单页面常用这种方法 import(/* webpackChunkName:&quot;test&quot; */ &quot;./test&quot;).then().catch() 懒加载和预加载懒加载当文件需要用时才加载预加载等其他资源加载完毕，浏览器空闲了，在偷偷加载资源，ie会有兼容性问题正常加载可以认为是并行加载，同时加载多个文件 //懒加载，当文件需要用时才加载 //仅在点击按钮之后再加载，第二次加载直接从缓存中读取 document.getElementById(&quot;btn&quot;).onclick=function(){ import(&quot;./test&quot;).then().catch } //预加载,会提前加载在浏览器 document.getElementById(&quot;btn&quot;).onclick=function(){ import((/* webpackChunkName:&quot;test&quot;,webpackPrefetch:true */&quot;./test&quot;).then().catch } PWAPWA 逐进式网络开发应用程序，离线课访问 workbox –&gt; workbox-weboack-plugin //安装 npm i workbox-weboack-plugin //引入清除文件插件 const WorkboxWeboackPlugin = require(&#39;workbox-weboack-plugin&#39;); plugins:[ new WorkboxWeboackPlugin.GenerateSW({ /* 1.帮助serviceworker快速启动 2.删除旧的serviceworker 生成一个serviceworker配置文件， */ clientsClaim:true, skipWaiting:true }) ] //一般在index.js里面注册serviceworker //——————————indexjs //注册serviceworker //处理兼容性问题 if(&quot;serviceWorker&quot; in navigator){ window.addEventListener(&quot;load&quot;,()=&gt;{ navigator.serviceWorker.register(&#39;/service-worker.js&#39;) .then(()=&gt;{}) .catch(()=&gt;{}) }) } 可能出现的问题1.eslit不认识window、navigator全局变量解决：需要修改package.json中eslintConfig配置 &quot;env&quot;:{ &quot;browser&quot;：true //支持浏览器端全局变量 } 2.sw代码必须运行在服务器上npm i serve -gserve -s build 启动服务器，将build目录下所有资源作为静态资源暴露出去 externalsexternals拒绝打包某资源，自己手动引入 module.exports={ entry:&quot;./src/js/index.js&quot;, output:{...}, plugins:[...], mode:&quot;production&quot;, externals:{ //库名 -- npm包名 //想使用link在html中引入，拒绝jQuery被打包进来，拒绝被打包时需要手动引进来 jquery:&#39;jQuery&#39; } } DLL使用dll技术，对某些库（第三方）进行单独打包当运行webpack时，默认查找webpack.config.js 配置文件需求：需要运行wbpack.dll.js文件–&gt; webpack –config webpack.dll.js //————————webpack.dll.js const{ resolve } =require(&quot;path&quot;); const webpack = require(&quot;webpack&quot;); module.exports = { entry:{ //最终打包生成的name为属性名，属性值为要打包的库 jquery:[&#39;jquery&#39;] }, output:{ filename:&#39;[name].js&#39;, path:resolve(__dirname),&#39;dll&#39;, library:&quot;[name]_[hash]&quot; //打包的库里面向外暴露出去的内容叫什么 }, //以上内容专门用于打包jquery plugins:[ //打包生成一个 manifest.json --&gt; 提供和jquery映射 new webpack.DllPlugin( name:&#39;[name]_[hash]&#39;,//映射库的暴露的内容名称 path:resolve(__dirname,&quot;dll/manifest.json&quot;) //输出文件的路径 }) ] ， mode:&quot;production&quot; } 打包之后配置webpack.config.js,这样可以重复打包webpack.config.js时不再打包jquery库了 //-----webpack.config.js const webpack = require(&quot;webpack&quot;); const AddAssetHtmlWebpackPlugin = require(&quot;add-asset-html-webpack-plugin&quot;) .... //告诉webpack哪些库不参与打包，同时使用时的名称也要变 new webpack.DllReferencePlugin({ manifest:resolve(__dirname,&quot;dll/manifest.json&quot;) }), //将某个文件打包输出去，并在html中自动引入该文件 new AddAssetHtmlWebpackPlugin({ filepath:resolve(__dirname,&quot;dll/jquery.js&quot;) }) clean-webpack-pluginclean-webpack-plugin:在打包时，先删除原来的再进行打包新的。 //安装 npm i clean-webpack-plugin -D //引入清除文件插件 const CleanWebpackPlugin = require(&#39;clean-webpack-plugin&#39;); //使用 plugins:[ //匹配删除的文件 new CleanWebpackPlugin([ &#39;dist&#39;, //删除dist文件夹 &#39;build/*.*&#39;, //删除build文件夹下的所有文件 ],{ //下面可以省略 root: __dirname, //根目录 verbose: true, //开启在控制台输出信息 dry: false //启用删除文件 }), ]]]></content>
      <categories>
        <category>前端</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础（7.15更新）]]></title>
    <url>%2F2020%2F07%2F09%2FJavaScript%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[综述JavaScript（实现） = ECMAScript（标准） + DOM + BOM BOM是浏览器对象模型，用来获取或设置浏览器的属性、行为，例如：新建窗口、获取屏幕分辨率、浏览器版本号等。简单的说：bom是浏览器可视窗口操作DOM是文档对象模型，用来获取或设置文档中标签的属性，例如获取或者设置input表单的value值。 BOM的内容不多，主要还是DOM。 由于DOM的操作对象是文档（Document），所以dom和浏览器没有直接关系。 Window对象：是整个BOM的核心，所有对象和集合都以某种方式回接到window对象。Window对象表示整个浏览器窗口，但不必表示其中包含的内容。Document对象：实际上是window对象的属性。这个对象的独特之处是唯一一个既属于BOM又属于DOM的对象。 编写基本要求1.html不区别大小写，而JavaScript严格区别大小写2.如果不写分号，浏览器会自动添加，但是会消耗系统资源，所以开发中必须写分号3.JS中会忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化 基本语法 1.字面量与变量字面量：一些不可改变的值，可直接使用，比如：1 2 3 4 5 ，一般不用变量：变量可以保存字面量，且可以任意改变，所以一般用变量 2.标识符在JS中所有可以由我们自主命名，比如：变量名、函数名、属性名可以是字符、数字（不可开头）、__、$不可以是ES中的关键字或保留字标识符一般采用驼峰命名法 数据类型基本数据类型： Undefined、Null、Boolean、Number、String和Symbol(ES6)引用数据类型： Object(Array, Date, RegExp, Function) 基本数据类型栈内存中保存的是值，引用数据类型栈内存中保存的是堆内存的地址。 字符串中可以使用\进行转义字符 数字的最大值：Number.MAX_VALUE,最小正值：Number.MIN_VALUE超过最大值返回Infinity表示正无穷。NAN（类型仍然是number）是一个特殊的数字，表示NOT A NUMBER。JS进行浮点运算，可能得到一个不精确的结果（不要用JS进行对精确度比较高的运算） 注意：Null类型的值只有一个null，null专门用来表示为空的对象，所以使用typeof会返回ObjectUndefined类型的值只有一个undefined，当声明一个变量，但并不给变量赋值时返回undefined 强制类型转化主要指其他数据类型转换成String，Number，Boolean typeof 就是运算符，获得一个值的类型以字符串返回 转化成String：1.XXX.toString返回转换结果(null,undefined没有该方法)。2.调用String(需要转化的值)函数，对于Number和Boolean实际上调用的是toString方法，对于null/undefined直接转化为”null/undefined”。3.所以非数字类型的运算都转化成数字类型再运算，但是加法中的字符串除外，所以可以利用字符串拼串x+&quot;&quot;（技巧）， 转化成Number：1.调用Number(需要转化的值)函数，如果有非数字类容/undefined转换NaN，空串/null/false转换成0,true转换成12.对于字符串，parseInt():把一个字符串转换成整数,第二个参数可以指定数字的进制。parseFloat():把一个字符串转化成浮点数。非字符串将其转化成字符串再操作，返回转化结果。3.由于任何值做减法、乘法、除法运算时都会自动转化为Number，所以可以利用x - 0 转化为布尔值：1.调用Boolean(需要转化的值)函数：0、NaN、空串、null、undefined都是false2.两个取反操作可以转化成布尔值。 布尔值运算：&amp;&amp; js中的“与运算”属于短路的与，如果第一个值为false，则不会看第二个值。|| js中的“或运算”属于短路的或，如果第一个值为true，则不会检查第二个值。 对于非布尔值进行与或运算时，会将其转化成布尔值运算后返回原数值，结合短路原则分析返回的数值。 条件分支 switch switch(值，不会转化){ case 值: //switch判值,严格判等=== 代码块; break; default: 代码块; //类似else } switch(true){ //case可以为表达式 case score &gt;= 90 &amp;&amp; score &lt;100: alert(&quot;a&quot;) break; } break只会出现在switch和循环语句中，在switch中代表跳出switch语句，在循环中，会跳出离它最近的那一层循环。 continue与break continue:立刻结束本次循环，执行下次循环break:在循环中，跳出离它最近的整个循环 对象in 运算符“属性名” in 对象通过该运算符可以检查一个对象中是否含有指定的属性如果对象中没有但原型中有，也会返回true hasOwnProperty对象的hasOwnProperty来检查对象自身中是否含有该属性 比较两个引用数据类型时，比较的是内存地址。 let obj = new Object(); let obj2 = new Object(); obj.name = &quot;ranan&quot;; obj2.name = &quot;ranan&quot;; console.log(obj.name == obj2.name) //输出false 我们直接在页面中打印一个对象时，实际上是输出Object原型对象上的toString()的返回值。 在JS中拥有自动的垃圾回收机制，我们需要将不用的对象设置为null局部变量:函数执行完自动释放对象：成为垃圾对象，由垃圾回收器回收 Date对象 //返回的当前代码执行的时间 new Date() //需要在构造函数中传递一个表示时间的字符串作为参数 let d = new Date(&quot;12/03/2016 11:10:30&quot;) //获得当前的日期 d.getDate() //0表示周日 d.getDay() //0表示1月 d.getMonth() //获得当前对象的时间戳，从1970.1.1 0 0 0 到当前日期的毫秒数 d.getTime() //获得当前的时间戳 Date.new() Math对象但是它不是构造函数，仅做工具使用 Math.ceil(1.5) //2 向上取整 Math.floor(1.5) //1 向下取整 Math.round(1.4) //1 四舍五入 //0~1的随机数 //生成一个0-y之间的随机数 Math.round(Math.random()*y) //生成一个x-y之间的随机数Math.round(Math.random*(y-x)+x) Math.random() //获取多个数中的最大值 Math.max(10,20,52) //返回值为最大值 包装类JS中提供让那个了三个包装类，通过三个包装类可以将基本数据类型转为对象 String() 可以将基本数据类型字符串转化成String对象Number() 可以将基本数据类型数字转化成Number对象Boolean() 可以将基本数据类型布尔值转化成Boolean对象 方法和属性只能添加给对象，不能添加给基本数据类型。包装类的作用：当我们对一些基本数据类型的值去调用属性和方法时，浏览器会临时使用包装类将其转换成对象，调用完了在转化回来。 函数函数也是一个对象 使用函数声明来创建一个函数，调用函数时解析器不会检查实参的类型与数量。在调用函数时，浏览器每次都会传递进两个隐含的参数1.函数的上下文对象 this2.封装实参的对象 arguments 是一个类数组对象/有length、可以通过索引操作的对象 补充:arguments.callee()方法的意思是：调用函数本身。 function fun(){ arguments.callee()//调用fun函数本身 return ;//返回值，执行了后面的代码将不会执行，默认返回undefined } //匿名函数赋值形式，最好叫上分号 let fun = function{}; //第一个括号是表示这个函数是一个整体 框起来，第二个括号表执行。 (function(){})() return 可以结束整个函数，后面的代码将不会被执行。 构造函数 构造函数习惯首字母大写，构造函数通过new构造。构造函数也被成为类，通过构造函数创建的对象称为实例 new在执行时完成的4件事情：1.在内存中创造一个新的空对象,在堆内存中分配空间2.让this指向这个新的对象3.执行构造函数里面的代码，给这个新对象添加属性和方法4.返回这个新对象(所以构造函数里面不需要return) instanceof对象 instanceof Person通过instanceof可以检查一个对象是否一个类的实例所有的对象都是Object的后代 构造函数使用的优化构造函数方法存在浪费内存的问题，在构造函数中的复杂数据类型（比如函数），实例化对象的时候，会专门开辟一个空间来存放。那么当实例对象过多的时候，就会开辟更多的空间来存放。解决办法:将共享的方法在全局作用域中定义存在的问题：将函数定义在全局作用域，污染了全局作用域的命名空间并且不安全。解决办法:当我们希望所有的对象使用同一个函数时，最好使用prototype，这也是为什么方法一般定义在原型中，属性一般通过构造函数定义在对象本身。原型 数组数组也是一个对象 naw Array(10)//创建一个长度为10的数组 arr = [[1,2,3],[4,5,6]] //二维数组] //向数组的末尾添加数据，返回值为新数组的长度 arr.push(&quot;添加的元素&quot;,&quot;添加的元素2&quot;) //删除数组的最后一个元素，返回值为被删除的元素 arr.pop() //向数组的开头添加一个或多个元素，返回值为新数组的长度 arr.unshift(&quot;添加的元素&quot;,&quot;添加的元素2&quot;) //删除数组的第一个元素，返回值为被删除的元素 arr.shift() JSONjs中的对象只有JS自己支持,其他的语言都不认识，可以转换成任何语言都认识的字符串。JSON就是一个特殊格式的字符串，并可以转换成任意语言中的对象。JSON分为对象、数组 ‘{“属性名”：”属性值”}’ ‘[“值”]’ 对象的属性名一定要加引号JSON允许的值字符串、数值、布尔值、null、普通对象、数组 JSON.parse(json字符串) JSON字符串转换为JS中的对象返回JSON.stringify(js对象) JS对象转换为JSON字符串 eval() 这个函数可以用来执行一段字符串形式的JS代码，并将结果值返回，如果执行的字符串中含有{},它会将{}当成代码块，需要给字符串加()。此方法常用于IE7以下JSON失效的情况，此方法不要使用性能比较差并且不安全。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack基本配置]]></title>
    <url>%2F2020%2F07%2F09%2Fwebpack%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[综述Webpack是一种前端资源构建工具，一个静态模块打包器。将根据模块的依赖关系进行静态分析，打包生成对应的静态资源（bundle） Webpack五个核心概念 Entry:入口指示Webpack以哪个文件为入口起点开始打包，分析构建内部依赖图。 Output:输出指示Webpack打包后的资源bundles输出到哪里去，以及如何命名。 Loader:Loader让Webpack能够去处理那些非JavaScript文件（Webpack自身只理解JavaScript/json） Plugins:插件可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等。 Mode:模式指示Webpack使用相应模式的配置 development：能让代码本地调式运行的环境 production：能让代码优化上线运行的环境 生产环境和开发环境使用生产环境:npm run build 实际用的webpack在内存中进行编译打包，生成内存中的打包文件。保存到本地，也就是在本地生成打包文件 使用开发环境:npm run dev 实际用的webpack-dev-server在内存中进行编译打包，生成内存中的打包文件。启动服务器，运行内存中的打包文件，可以通过浏览器虚拟地址访问 开发环境示例：webpack.config.js webpack-dev-server 修改代码自动打包 /* 开发环境配置，能让代码运行起来 */ /* webpack.config.js webpack的配置文件 作用：当运行webpack指令时，会加载里面的配置，打包结果会输出出去 所有的构建工具都基于nodejs平台运行的，模块化默认采用commonjs */ /* loader：1.下载 2.配置（使用） plugins：1.下载 2.引入 3.使用 */ //resolve用来拼接绝对路径的方法 const {resolve} = require(&quot;path&quot;) //引用处理html的插件 const HtmlWebpackPlugin =require(&quot;html-webpack-plugin&quot;); module.exports = { //webpack配置 //入口起点 entry: { filename:static/js/[name].js, path:path.resolve(__dirname.&#39;dist&#39;) }, //输出是对象 output:{ //输出文件名 filename: &quot;js/built.js&quot;, //输出路径 //__dirname是nodejs的变量，代表当前文件的文件夹绝对路径 path:resolve(__dirname,&quot;build&quot;) }, //loader配置 module:{ rules:[ //详细loader配置 //不同文件配置不同loader处理 { //匹配哪些文件,以.css结尾的文件 test:/\.css$/, //使用哪些loader进行处理 use:[ //use数组中loader执行顺序：从后往前 //创建style标签，将js中的样式资源插入进行，添加到head中生效 &quot;style-loader&quot;, //将css文件变成commonjs模块加载js中，里面内容是样式字符串，所以css文件不会单独输出 &quot;css-loader&quot; ] }, { test:/\.less$/, use:[&quot;style-loader&quot;, &quot;css.loader&quot;, //将less文件编译成css文件 //需要下载less-loader和less &#39;less-loader&#39; ] }, //打包其他资源（除了html/js/css资源以外的资源） //字体不建议这种写法，因为需要排除的东西过多 { //排除css、js、html以外的资源 exclude:/\.(css|js|html|less|jpg|png|gif)$/, loader:&quot;file-loader&quot; options:{ name:&quot;[hash:10].[ext]&quot; } } //处理图片资源 { //问题：处理html中的img图片 test:/\.(jpg|png|gif)$/, //使用一个loader时，可直接用loader引用，不用use, loader: &quot;url-loader&quot;, options: { //图片大小小于8kb，就会被base64处理 //优点：减少请求数量（减轻服务器压力） //缺点：图片体积会更大（文件请求速度更慢） limit:8*1024, //问题：因为url-loader默认使用es模块化解析，而html-loader引入图片是commonjs //解析时会出现问题：[object Module] //解决：关闭url-loader的es模块化，使用commonjs解析 esModule:false, //打包之后文件名的hash值取10位，保持原来的后缀名 name:&quot;[hash:10].[ext]&quot;, //设置图片的输出路径 outputPath:&quot;imgs&quot; } }, { //处理html文件的img图片（负责引入img，从而能被url-loader进行处理） test:/\.html$/, loader:&quot;html-loader&quot; } ] }, //plugins的配置 plugins: [ //html-webpack-plugin 处理html资源 //功能：默认会创建一个空的HTML，自动引入打包输出的所有资源（js/css） // new HtmlWebpackPlugin() //需求：需要有结构的HTML文件 new HtmlWebpackPlugin({ //复制&quot;index.html&quot;,并自动引入打包输出的所有资源（js/css） template:&quot;index.html&quot; path:&quot;index.html&quot; }) //详细pulgins的配置 ], //模式 mode:&#39;development&#39; // mode:&quot;production&quot; //启动devServer指令为：npx webpack-dev-server（需要安装对应的包） //localhost:3000本地服务器查看 devServer:{ //构建后的路径 contentBase:resolve(__dirname,&quot;build&quot;), //启动gzip压缩，使代码体积更小，运行更快。 compress:true, //指定开发服务器的端口号 port:3000, //自动打开默认浏览器 open:true } } 总结： module-&gt;rules-&gt;use 数组(使用多个loader)是从后往前执行的，使用一个可以直接用loader loader：①下载 ②配置（使用），plugins：①下载 ②引入 ③使用。 url-loader可以用于图片和字体 webpack需要实时打包，可使用开发服务器devServer实现自动化。 因为url-loader默认使用es模块化解析，而html-loader解析html中的图片的解析是commonjs。所以需要在url-loader中的选项配置中使用esModule:false关闭默认的es模块解析 devServer开发服务器 devServer用来实现自动化，比如自动编译，自动打开浏览器，自动刷新浏览器。只会在内存中编译打包，不会有任何输出文件，比如删除build后，使用devServer不会输出新的build文件。相当于打包后放在本地服务器上运行。 生产环境mini-css-extract-plugin插件打包过后的css在js文件里，通过下面的插件可以把css单独抽出来。 //安装 npm i mini-css-extract-plugin -D //引入 const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;) //loader配置 module:{ rules:[ { test:/\.css$/, use:[ //创建style标签，将js中的样式资源插入进行，添加到head中生效 //&quot;style-loader&quot;, //作用：提取js中的css成单独文件 MiniCssExtractPlugin.loader &quot;css-loader&quot; ] }, ]} plugins:[ new MiniCssExtractPlugin({ //输出的css文件重新命名 filename:&#39;css/built.css&#39; }) ] 以上的写法有一个问题是css如果中有文件，需要在该插件的publicPath中重新配置文件路径。 { loader:MiniCssExtractPlugin.loader, options:{ // 这里可以指定一个 publicPath // 默认使用 webpackOptions.output中的publicPath publicPath: &#39;../&#39; } css兼容与压缩css兼容性处理：postcss –&gt; postcss-loader postcss-preset-env（在webpack中使用） //安装 npm i postcss-loader postcss-preset-env -D //使用 module:{ rules:[ { test:/\.css$/, use:[ MiniCssExtractPlugin.loader //使用loader的默认配置的写法 &quot;css-loader&quot; //修改loader的配置写法 { loader:&quot;postcsss-loader&quot; options:{ ident:&quot;postcsss&quot; plugins:()=&gt;[ //返回一个数组 postcss的插件 //此插件帮助postcss找到package.json中browserslist里面的配置，通过配置加载指定的css兼容性样式，默认找的是browerslist里面的生产环境 //如果要找开发环境的，就需要在webpack.config.js中设置node.js坏境变量process.env.NODE_ENV=&quot;development&quot; require(&quot;postcss-preset-env&quot;)() ] } } ] }, ]} //====================package.json &quot;browserslist&quot;:{ &quot;development&quot;:[ //兼容最近的chrome版本 &quot;last 1 chrome version&quot; ] &quot;production&quot;:[ &quot;&gt;0.2%&quot;,//兼容98%的浏览器 &quot;not dead&quot;,//已经死了的浏览器 &quot;not op_mini all&quot; ] } css压缩插件：optimize-css-assets-webpack-plugin //安装插件 npm i optimize-css-assets-webpack-plugin -D //引用 const OptimizeCssAssetsWebpackPlugin = require(&quot;optimize-css-assets-webpack-plugin&quot;) //使用 plugins:[{ //压缩css，默认配置已经可以解决问题了。 new OptimizeCssAssetsWebpackPlugin() }] js语法检查与兼容性语法检查：eslint-loader eslint注意：只检查自己写的js源代码，第三方的库是不用检查的设置检查规则：在package.json中eslintConfig中设置推荐使用airbnb规则： eslint eslint-plugin-import eslint-config-airbnb-base //新版在根目录创建.eslintrc //老版本 { test:/\.js$/, loader:&quot;eslint-loader&quot;, //一定要排除 exclude:/node_modules/, options:{ //自动修复eslint错误 fix:true } } //===========package.json &quot;eslintConfig&quot;:{ &quot;extends&quot;:&quot;airbnb-base&quot; } 兼容性处理ES6：babel-loader @babel/preset-env @babel/core基本的js兼容性处理 –&gt; @babel/preset-env 问题：只能转换基本语法，promise不能全部js兼容性处理 –&gt; @babel/polyfill 被弃用，体积还会变大。需要做兼容行处理的就做：按需加载 –&gt;corejs { test:/\.js$/, //一定要排除 exclude:/node_modules/, loader:&quot;babel-loader&quot;, options:{ //预设:指示babel做什么样的兼容性处理 presets:[&quot;@babel/preset-env&quot;] } } //========corejs npm i core-js -D //配置 presets:[ [&quot;@babel/preset-env&quot;, //预设包:包含多个常用插件的包 { //按需加载 useBuiltIns:&quot;usage&quot;, //指定core-js版本 corejs:{ version:3 }, //指定兼容性做到哪个版本浏览器 targets:{ chrome: &quot;60&quot;, firefox:&quot;60&quot;, ie:&quot;9&quot; } } ]] js压缩与html压缩 //生产坏境下自动压缩js mode:&quot;production&quot;, new HtmlWebpackPlugin({ //复制&quot;./src/index.html&quot;,并自动引入打包输出的所有资源（js/css） template:&quot;./src/index.html&quot; //压缩html代码 minify:{ //移除空格 collapseWhitespace:true, //移除注释 removeComments:true } }) 生产环境的基本配置正常来讲，一个文件只能被一个loader处理，当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序:先执行eslint,在执行babel。 配置vue的相关信息可以在vue官网文档查看，注意vue.esm.js文件的设置 const {resolve} = require(&quot;path&quot;) //用于将css从js中抽离成单独文件 const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;) //css兼容 const OptimizeCssAssetsWebpackPlugin= requir(&quot;optimize-css-assets-webpack-plugin&quot;) const HtmlWebpackPlugin= require(&quot;html-webpack-plugin&quot;) //css兼容 const commonCssLoader = [ { loader:MiniCssExtractPlugin.loader, options:{ publicPath: &#39;../&#39; } }, &quot;css-loader&quot;, { //兼容性,还需要在package.json中定义browserslist loader: &quot;post-loader&quot;, options: { ident:&quot;postcss&quot;, plugins:()=&gt;[ require(&quot;postcss-preset-env&quot;)() ] } } ] module.exports={ entry:&quot;./src/js/index.js&quot;, output: { filename: &quot;js/built.js&quot;, path: resolve(__dirname,&quot;build&quot;) }, module: { rules: [ { test:/\.css$/, use:[...commonCssLoader] }, { test:/\.less$/, use:[...commonCssLoader, &quot;less-loader&quot;] }, //配置eslint { //在package.json中eslintCofig中配置--&gt;airbnb //npm install -D eslint eslint --init可以按需配置eslint test:/\.js$/, exclude:/node_modules/, //设置优先执行。 enforce: &quot;pre&quot;, loader: &quot;eslint-loader&quot;, options: { fix:true } }, //兼容性处理 { test:/\.js$/, exclude:/node_modules/, loader: &quot;babel-loader&quot;, options: { presets:[ &quot;@babel/preset-env&quot;, { useBuiltIns:&quot;usage&quot;, corejs:{version:3}, targets:{ chrome:&quot;60&quot;, } } ] } }, { test:/\.(jpg|png|gif)/, loader: &quot;url-loader&quot;, options: { limit:8*1024, name:&quot;[name].[hash:10].[ext]&quot;, outputPath:&quot;imgs&quot;, esModule:false } }, { test:/\.html$/, loader: &quot;html-loader&quot; }, { exclude:/\.(js|css|less|html|jpg|png|gif)/, loader: &quot;file-loader&quot;, options: { outputPath:&quot;media&quot; } } ] }, plugins: [ new MiniCssExtractPlugin({ filename:&quot;css/built.css&quot; }), //只需要调用 new OptimizeCssAssetsWebpackPlugin(), new HtmlWebpackPlugin({ template:&quot;./src/index.html&quot;, minify:{ collapseWitespace:true, removeComments:true } }) ], mode: &quot;production&quot; }]]></content>
      <categories>
        <category>前端</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Less学习笔记]]></title>
    <url>%2F2020%2F07%2F08%2Fless%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[less less属于css的一种预处理器处理在浏览器运行前, 作为css的扩展、增强版，是一种动态样式语言。 注释 //less中的单行注释，不会被编译到css文件中，以/ /注释的内容会被编译到css文件 less嵌套规则 和html结构相似，层层嵌套&amp; 代表的上一层选择器的名字 /* Less */ #header{ &amp;:after{ content:&quot;Less is more!&quot;; } .title{ font-weight:bold; } &amp;_content{//理解方式：直接把 &amp; 替换成 #header margin:20px; } &gt; .title{ font-weight:bold; } } /* 生成的 CSS */ #header::after{ content:&quot;Less is more!&quot;; } #header .title{ //嵌套了 font-weight:bold; } #header_content{//没有嵌套！ margin:20px; } #header &gt; .title{ //嵌套了 font-weight:bold; } less的继承extend 是 Less 的一个伪类。它可继承 所匹配声明中的全部样式。extend（这里放规则）是一个函数 /* Less */ //规则的定义，没有参数 .animation{ transition: all .3s ease-out; .hide{ transform:scale(0); } } #main{ &amp;:extend(.animation); } #con{ &amp;:extend(.animation .hide){ color:red; } } /* 生成后的 CSS */ .animation,#main{ transition: all .3s ease-out; } .animation .hide , #con{ transform:scale(0); } #con{ color:red } 更简单的写法 .p1 { width:100px } .p2{ //相当于复制p1，性能不太好 p1(); } all全局搜索替换使用选择器匹配到的 全部声明。 /* Less */ #main{ width: 200px; } #main { &amp;:after { content:&quot;Less is good!&quot;; } } #wrap:extend(#main all) {} /* 生成的 CSS */ #main,#wrap{ width: 200px; } #main:after, #wrap:after { content: &quot;Less is good!&quot;; } 从表面 看来，extend 与 方法 最大的差别，就是 extend 是同个选择器共用同一个声明，而 方法 是使用自己的声明。 ~”XXXXX” less之中避免编译，让浏览器编译 变量 以 @ 开头定义变量，使用是直接 @定义的名称 变量做类名使用时必须在@后使用大括号包裹 声明变量（类比于写好的css引用）类似于混合方法 结构: @name: { 属性: 值 ; }; 使用：@name(); 使用@来申明一个变量: @pink:pink //不要添加引号 作为普通属性值只是来使用：直接使用@pink 作为选择器和属性名: @{selector的值}的形式（不常用） 作为URL：@{url} （@images:’../img’ 注意要加引号） 变量的延迟加载（一个块级域解析完再加载变量） /* Less */ @color: #999; @bgColor: skyblue;//不要添加引号 @width: 50%; #wrap { color: @color; width: @width; } /* 选择器变量 */ @mySelector: #wrap; @Wrap: wrap; @{mySelector}{ //变量名 必须使用大括号包裹 color: #999; width: 50%; //如果继承width的值可以直接用$width height: $width; } .@{Wrap}{ color:#ccc; } #@{Wrap}{ color:#666; } /* url 变量*/ @images: &quot;../img&quot;;//需要加引号 body { background: url(&quot;@{images}/dog.png&quot;);//变量名 必须使用大括号包裹 } /* 声明变量 */ @background: {background:red;}; #main{ @background(); } @Rules:{ width: 200px; height: 200px; border: solid 1px red; }; #con{ @Rules(); } /* 生成的 CSS */ #main{ background:red; } #con{ width: 200px; height: 200px; border: solid 1px red; } 变量的运算 注意点： 加减法时，以第一个数据的单位为基准 乘除法时，注意单位一定要统一 less中的混合 混合：将一系列的规则集引入另一个规则集中。 类名后面不添加括号，这个样式会在css编译出来并且作用到该类名上。 类名后面添加了括号之后就不是一个选择器了，只是创建了一个mixins，专门给别人用的。 混合使用 . 或 # 的形式来定义；声明变量使用的是 @ 来定义，@变量名（）来使用 普通混合 /* Less */ .card { // 等价于 .card() background: #f6f6f6; -webkit-box-shadow: 0 1px 2px rgba(151, 151, 151, .58); box-shadow: 0 1px 2px rgba(151, 151, 151, .58); } #wrap{ .card;//等价于.card(); } //其中 .card 与 .card() 是等价的。 带参数的混合 注意点： Less 可以使用默认参数，如果没有传参数，那么将使用默认参数。冒号后面的是默认值 @arguments代表全部参数，实参列表 传的参数中必须带单位，且按顺序，如果不按顺序，需要在参数中带上参数名类似@width:100px /* Less */ .border(@a:10px,@b:50px,@c:30px,@color:#000){ border:solid 1px @color; box-shadow: @arguments;//指代的是 全部参数 } #main{ .border(0px,5px,30px,red);//必须带着单位 } #wrap{ .border(0px); } /* 命名参数 */ #wrap{ .border(@color:black); } #content{ .border;//等价于 .border() } /* 生成的 CSS */ #main{ border:solid 1px red; box-shadow:0px,5px,30px,red; } #wrap{ border:solid 1px #000; box-shadow: 0px 50px 30px #000; } #content{ border:solid 1px #000; box-shadow: 10px 50px 30px #000; } 匹配模式注意点： 第一个参数 left 要会找到方法中匹配程度最高的，如果匹配程度相同，将全部选择，并存在着样式覆盖替换。 如果匹配的参数 是变量， @_ 表示的会被调用任意标志的 。 /* Less */ .triangle(top,@width:20px,@color:#000){ border-color:transparent transparent @color transparent ; } .triangle(right,@width:20px,@color:#000){ border-color:transparent @color transparent transparent ; } .triangle(bottom,@width:20px,@color:#000){ border-color:@color transparent transparent transparent ; } .triangle(left,@width:20px,@color:#000){ border-color:transparent transparent transparent @color; } .triangle(@_,@width:20px,@color:#000){ border-style: solid; border-width: @width; } #main{ .triangle(left, 50px, #999) } /* 生成的 CSS */ #main{ border-color:transparent transparent transparent #999; border-style: solid; border-width: 50px; } 方法的命名规范注意点： 在 CSS 中 &gt; 选择器，选择的是 儿子元素，就是 必须与父元素 有直接血源的元素。 在引入命令空间时，如使用 &gt; 选择器，父元素不能加 括号。 不得单独使用命名空间的方法 必须先引入命名空间，才能使用 其中方法。 子方法 可以使用上一层传进来的方法 /* Less */ #card(){ background: #723232; .d(@w:300px){ width: @w; #a(@h:300px){ height: @h;//可以使用上一层传进来的方法 width: @w; } } } #wrap{ #card &gt; .d &gt; #a(100px); // 父元素不能加 括号 } #main{ #card .d(); } #con{ //不得单独使用命名空间的方法 //.d() 如果前面没有引入命名空间 #card ，将会报错 #card; // 等价于 #card(); .d(20px); //必须先引入 #card } /* 生成的 CSS */ #wrap{ height:100px; width:300px; } #main{ width:300px; } #con{ width:20px; } //通过import引入其他的less文件 @import &quot;&quot;;]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>Less</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[meta标签]]></title>
    <url>%2F2020%2F07%2F08%2Fmeta%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[仅仅记录我已经使用过的，如果后续有使用过新的，会补充在文章中 meta标签主要用于设置网页中的一些元数据，元数据不是给用户看的。 charset 指定网页的字符集 name 指定数据的名称 content 指定的数据的内容 http-quiv 向浏览器传信息 keywords表示网站的关键字，搜索时用于识别。 description用于指定网站的描述，网站的描述会显示在搜索引擎的搜索结果中 补充：title标签的内容会作为搜索结果的超链接的文字显示 网页重定向，3秒后跳转到百度 viewport是HTML5新增的，常用于移动端。 width:可视区域的宽度，值可为数字或关键词device-width intial-scale:页面首次被显示是可视区域的缩放级别，取值1.0则页面按实际尺寸显示，无任何缩放 maximum-scale=1.0, minimum-scale=1.0;可视区域的缩放级别，user-scalable:是否可对页面进行缩放，no 禁止缩放]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS学习笔记]]></title>
    <url>%2F2020%2F06%2F20%2FCSS%2F</url>
    <content type="text"><![CDATA[目录 伪类选择器 单位 移动端适配 媒体查询 省略 雪碧图 CSS盒模型 过渡约束 外边距折叠 轮廓和圆角 浮动 高度塌陷 BFC 清除浮动 外边距折叠的解决 clearfix 定位 层级 居中 垂直居中 水平居中 动画 过渡 弹性盒子 其他 三角形 伪类选择器伪类带一个冒号，伪元素带两个冒号。 常见伪类 li:first-childli:last-childli:nth-child(n) //n从1开始，2n/even选中偶数位，2n+1/odd奇数位 这三个 排序是根据所有的子元素进行的，并不是li中的第几个。 li:first-child{ color: orange; } //第一个li元素并不会变色，因为在子元素中第一个元素是span &lt;span&gt;abc&lt;/span&gt; &lt;li&gt;ff&lt;/li&gt; &lt;li&gt;zz&lt;/li&gt; :first-of-type:last-of-type:nth-of-type() 这几个伪类与上述相似，不过是在同类型元素中选择排序。 :not()否定伪类 ul&gt;li:not(li:nth-of-type(3)) //当前后相同时，也可以写成 ul&gt;li:not(:nth-of-type(3)) 超链接的伪类 :link 用来表示没访问过的链接（正常的链接）:visited 用来表示访问过的链接，由于隐私的原因，该伪类只能改变颜色（所以不常用）上述两个伪类只用于a标签:hover 用来表示鼠标移入的状态:active 用来鼠标点击 顺序:lvha 伪元素 伪元素表示页面中一些特殊的并不真实存在的元素 p::first- letter 表示标签p里的第一个字母::first-line 表示第一行::selection 表示选中的内容div::before 表示div标签内的开始位置div::after 表示div标签内的最后一个位置 before,after添加的文字不可以被选中 单位在前端像素分为两种：css像素和物理像素。编写网页时，所用的像素是CSS像素。浏览器在加载网页时，会将CSS像素转化成物理像素。默认情况在pc端1个css像素=1个物理像素 视口(viewport)就是屏幕中用来网页显示的区域，可以通过html查看。物理像素是设备的宽度。 编写移动端的页面时，通过调整视口大小来调整像素比，meta标签设置，content=&quot;width=device-width&quot;可以将像素比设置为最佳像素比的视口大小。 em是相对于自身元素的字体大小来计算的，1 em = 1 font-sizerem是相对于根元素（html）的字体大小来计算的。行高（line-height）指的是文字占有的实际高度，行高如果是整数，则是该元素字体大小的倍数 移动端不适用px来布局，常常使用vw来布局。vw表示视口的宽度 100vw=1个视口的宽度 常用的vw适配方案 比如当前最佳视口大小375px,设计图宽度750px,100vw = 750px(这个750指的是设计图中的宽度),那么设计图中的 1px = 0.1333 vw。 给font-size设置0.133vw对应的是设计图中的1px，所以设计图中的10px可以写成10rem。 但是一般浏览器对字体的大小有限制，所以会对font-size进行放大比如放大了40倍，那么使用的时候需要缩小40倍。 html{ //100vw/750 = 0.1333vw font-size:100vw/750 * 40 } .box{ width:设计图中该元素的宽度/40 rem } 媒体查询@media(min-width:xxx/max-width:xxx){} @media not (){}//除了 @media(),(){} //两个条件满足一个就可以了 @media()and(){} //两个条件全部满足 样式切换的分界点称为断点，常用断点： 小于768 超小屏幕 max-width=768px大于768 小屏幕 min-width=768ox大于992 中型屏幕 min-width=992px大于1200 大屏幕 min-width=1200px 响应式设计的网站:移动端优先 字体字体框就是字体存在的格子，设置font-size实际上就是在设置字体框的高度。行高会在字体框的上下平均分配。font属性：字体大小/行高 字体族， //可以将服务器中的字体直接提供给用户去使用 //问题：1.加载速度 2.版权 @font-face { //xx为你给该字体起的名 font-family:&quot;xx&quot;; //服务器中字体的路径 src:url(); } 图标字体在使用图标时，可以将图标直接设置为字体，通过font-face的形式来字体进行引用。 //使用iconfont的方式,本地引用icconfont.css //伪元素引用 p::before{ content:&quot;\xxxx&quot;; //字体图标的编码 font-family:&quot;iconfont&quot;; font-size:xxx; } //类名引用 &lt;i class=&quot;iconfont icon-qitalaji&quot;&gt;&lt;/i&gt; text-align文本的水平对齐vertical-align 设置元素垂直对齐 图片默认的基线对齐，但是基线可能和外边框之间有缝隙，所以图片常常设置vertical-align的值来改变对齐方式。 省略 width:xx; white-space:nowrap; //white-space 设置网页如何处理空白 normal 正常 nowrap 不换行 pre 保留原格式 overflow:hidden; text-overflow:ellipsis; 背景 background-clip 背景范围background-origin 背景图片的偏移量计算的源点，默认在内边距开始可选值 border-box 默认值 padding-box，content-box background-size 背景图片的大小 cover 图片比例不变，将元素铺满高度100% contain 图片比例不变，将图片在元素中完整显示，宽度100%background-attachment 背景图片是否跟随元素移动 scroll默认移动，fixed背景会固定在页面中background-image还可以设置渐变的背景色 解决图片闪烁问题（CSS-Sprite）：可以将多个小图片统一保存在一个大图片（雪碧图），通过图片背景定位来解决问题。 隐藏文字 常常使用text-indext:-9999px来隐藏文字,需配合overflow使用。 CSS盒模型CSS将页面中的所有元素都设置为一个矩形的盒子，对页面的布局就变成了将不同的盒子摆放到不同的位置。 盒子 = 内容content + 内边距padding + 边框border + 外边距margin（看不见，其余为可见框） 由width和height决定的是content的大小。 块级元素盒模型控制布局的时候最好对块级元素进行布局，块级元素占一行。 过渡约束水平布局 一个块级元素在其父元素中，水平布局必须满足margin-left + border-left + padding-left + width + padding-right + border-right + margin-right = 其父元素内容的宽度，如果相加结果不相等，则称为过渡约束。这七个值中可以设置为auto：width，margin。如果发生过渡约束，等式会自动调整，宽度优先，左右平分：1.如果7个值无auto的情况，则浏览器会自动调整margin-right2.如果某个值为auto，则会自动调整auto的值是等式成立。3.如果一个宽度和一个外边距设置为auto，则优先把宽度调整到最大。4.如果两个外边距设置为auto，宽度固定，则会将外边距设置为相同的值。利用这个特点实现一个元素在其父元素水平居中。 (width:xx;margin:xx auto） 垂直布局 若父元素没设置高度，则默认父元素的高度被内容撑开。使用overflow属性来设置父元素如何处理溢出的子元素，设置在子元素。 overflow:visible //默认值，子元素会从父元素中溢出 overflow:hidden //溢出内同被裁剪不会显示 overflow:scroll //生成双向滚动条 overflow:auto //根据需要生成滚动条 overflow-x/overflow-y 外边距的折叠相邻的垂直方向外边距会发生重叠方向。兄弟元素间的相邻垂直外边距会取两者之间的绝对值较大值，若一正一负取和。兄弟元素之间的外边距重叠对开发有利，不需要处理。 父子元素的相邻外边距，子元素会传递给父元素(上边距)。 行内元素盒模型行内元素不支持设置宽度和高度，行内元素可以设置padding/border/margin，但是垂直方向padding/border/margin不会影响页面的布局。垂直方向取最大，水平方向取和。 使用display来设置元素的类型，与display:none相似的还有visibility：hidden。区别是前者隐藏后不占据位置，后者仍然占据位置只是不可见。 visibility：hidden //元素隐藏不显示，但是仍然占据位置 visibility：visible //元素可见 display:inline display:block //块元素占一行 display:inline-block //行内块元素，宽高生效但不占一行，尽量不用换行符会解析 display:none //元素不显示 display:table //将元素设置为一个表格 CSS3的盒模型CSS3新增box-sizing属性，该属性设置width与height的作用范围。 box-sizing: border-box //使用ie盒模型 box-sizing: content-box //使用标准盒模型，默认 box-sizing:padding-box //width/height设置的是左右padding+content 标准盒子模型的width/height设置的是content的高度与宽度。IE盒子模型的width/height设置的是content+左右padding+左右border之和。 可以记忆成属性值为什么从哪个地方开始到对应的地方结束 轮廓和圆角outline轮廓outline与border用法相同，轮廓outline不会影响布局，不会撑大盒子。 box-shadowbox-shadow用来设置元素的阴影，前两个值为左侧下侧偏移量，第三个值为模糊程度，第四个值为颜色，不会影响布局。 border-radiusborder-radius用来设置圆角，指定画圆的半径，值为50%则是一个圆。第一个值是x方向半径，第二个值是y方向半径。 浮动通过浮动float可以使一个元素相对于父元素进行向左向右浮动，默认不会从父元素中移动。元素设置浮动以后，水平布局的等式margin-left + border-left + padding-left + width + padding-right + border-right + margin-right = 其父元素内容的宽度失效并且脱离文档流不占用文档流的位置。如果浮动元素上面是在文档流中的，则浮动元素从该位置后面进行排序，而不是上移。浮动元素不会超过它上一个浮动的兄弟元素高度，最多就是一样高。浮动元素不会盖住文字，文字会自动环绕在图片的周围。元素从文档流中脱离，会具有行内块元素的特性。 高度塌陷一般父元素的高度不会写死，高度根据子元素高度决定。当子元素浮动后，完全脱离文档流，子元素将无法撑起父元素的高度，导致父元素的高度丢失。 //style .box1{ border:10px red solid; } .box2{ width:100px; height:100px; background-color:green; float:left } //html &lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;/div&gt; 解决办法：BFCBlock Formatting Context 块级格式化环境，是CSS中的一个隐含的属性，可以为一个元素开启BFC，开启BFC该元素会变成一个独立的布局区域。 元素开启BFC后的特点1.开启BFC的元素不会被浮动元素所覆盖。2.开启BFC的元素子元素和父元素外边距不会重叠。（不会发生子元素设置外边距，父元素跟着动的情况）3.开启BFC的元素可以包含浮动的子元素，使其不会发生高度塌陷。 启动特殊方式开启元素的BFC方法一：设置元素的浮动（不推荐）副作用：会从文档中脱离。方法二：变成行内块元素（不推荐）方法三：将元素的overflow设置为一个非visible的值，一般用hidden（常用方式） 清除浮动给受影响的盒子添加clear属性，clear元素的原理是设置清除浮动以后，浏览器会自动为元素添加上外边距，所以添加了clear的属性不可以手动添加margin-top。 clear:left //清除左侧浮动元素对当前元素的影响 clear:right //清除右侧浮动元素对当前元素的影响 clear:both //清除两侧中最大影响的那侧 高度塌陷的最终解决方案：使用after伪类 在父元素的后面添加一个空标签(行内元素)，清除浮动对其的影响并使其为块元素，浏览器自动改变margin-top使其可以撑开父元素。 因为行内元素【如span】的padding-top,padding-bottom,margin-top,margin-bottom（垂直方向）属性设置无效。 //表示box1(父元素)盒子里面内容的最后 .box1::after{ content:&quot;&quot;; display:block; clear:both } 使用这种思想同时可以解决外边距重叠的问题。 &lt;style&gt; .box1{ width: 200px; height: 200px; background: green; } .box2{ width: 100px; height: 100px; background: orange; margin-top: 100px; } &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 解决办法：让其外边距不相邻 //box1盒子内容的最前面 .box1::before{ content:&quot;&quot;; display:table; } clearfix解决外边距重叠与高度塌陷的问题，谁塌陷这个类名加在谁的身上。 .clearfix::before, .clearfix::aftee{ content:&quot;&quot;; display:table; clear:both; } 定位可以通过定位将元素摆到页面的任意位置（一般使用在微小的地方，大布局使用浮动），当元素开启了定位以后，可以通过偏移量(top bottom left right 仅对开启定位的元素有用)来设置元素的位置。 positon属性的值: static 默认值，元素是静止的没有开启定位 relative 相对定位 sticky 粘滞定位 absolute 绝对定位 fixed 固定定位 relative相对定位 开启绝对定位后，如果不设置偏移量元素不会发生变化relative是参照于开启相对定位的元素在文档流中的位置（元素本身）进行定位的。相对定位会提升元素的层次相对定位不会让元素脱离文档流并且不会改变元素的性质。脱离文档流后，元素会变成行内块元素（不会独占一行，宽高属性生效） absolute绝对定位 开启绝对定位后，如果不设置偏移量元素的位置不会发生变化。元素会从文档流中脱离，绝对定位的元素会提升层级。absolute定位元素是相对与其包含块（块级元素）进行定位正常情况下，包含块就是离当前元素最近的祖先块元素。绝对定位的包含块就是离它最近的开启了定位的祖先元素。 注意：平时使用的width:100%是指的是相对于包含块的长度 absolute定位的特点是父相子绝，使用绝对定位的元素会向上寻找第一个使用相对定位的父元素。 水平布局等式margin-left + border-left + padding-left + width + padding-right + border-right + margin-right = 其父元素内容的宽度 当开启了绝对定位之后的水平布局等式变成了left + margin-left + border-left + padding-left + width + padding-right + border-right + margin-right + right = 包含块的宽度这9个值中可以设置为auto：width，margin，left，right。如果发生过渡约束，等式会自动调整，宽度优先，right/left其次，左右平分：1.如果9个值无auto的情况，则浏览器会自动调整right2.如果某个值为auto，则会自动调整auto的值是等式成立。3.如果一个宽度和一个外边距设置为auto，则优先把宽度调整到最大。4.如果两个外边距设置为auto，宽度固定，则会将外边距设置为相同的值。利用这个特点实现一个元素在其父元素水平居中。 (width:xx;margin:xx auto） 注意left和right的默认值是auto，所以如果不知道left和right，则等式不满足会自动调整这两个值。所以以上4点要在left/right设置的情况下进行。 当我们开启绝对定位后，垂直方向也需要满足垂直方向的等式也需要满足（正常的不会）,其规则类似水平布局。 所以可以利用其特点，进行元素的垂直居中 //垂直居中的元素 width:xxx; height:xxx; position:absolute; //父相子绝,在谁中间就给谁相对定位 margin:auto left:0; right:0; top:0; bottom:0; fixed固定定位 固定定位也是绝对定位的一种，所以固定定位的大部分特点都和绝对定位一样。不同点是固定定位永远参照与浏览器的视口（可视区域，固定不动）进行定位 sticky粘滞定位 粘滞定位和相对定位的特点基本一致，不同的是粘滞定位当元素到达一定高度的时候固定住，常常和top结合。sticky定位的元素元素仅在其父元素内生效且父元素的高度不能低于sticky定位 元素的高度，所以如果滚动到父元素的高度低于sticky定位元素的高度，该定位失效。 层级定位的层级大于浮动的层级 z-index属性可以来指定元素的层级，数越大层级越高。 如果优先级一样，优先显示结构上靠下的元素 祖先元素的层级再高也不会盖住后代元素。 居中垂直居中1.文字的垂直居中 要让文字在父元素中垂直居中，只需将父元素的line-height设置为和父元素的高度一样。 2.利用定位 //垂直居中的元素 width:xxx; height:xxx; position:absolute; //父相子绝,在谁中间就给谁相对定位，也可以实现垂直水平居中，原理是利用布局等式 margin:auto top:0; bottom:0; 3.利用tabel的性质（很少使用） //将元素设置为单元格td display:table-cell; //元素类的子元素垂直居中 vertical-align:middle; 4.利用transform 当元素的大小并不明确的时候，以水平为例子，垂直类似。 .box{ position:absolute; left:50%;//相对与包含块的50% transform:translateX(-50%)//相对于元素自身的50% } 水平居中一个元素在父元素中水平居中,该代码写在该元素的样式中，该代码仅对块级元素有效。 width:xx; margin:xx auto 这种办法的原理是利用水平布局的margin-left + border-left + padding-left + width + padding-right + border-right + margin-right = 其父元素内容的宽度等式。 所有元素也可以通过对父元素设置 text-align：center；的方式来实现居中。而对于块元素来说，对要居中的元素自身进行设置text-align:center也能实现居中，而无需对其父元素进行设置。 动画过渡transition过渡三要素:起始位置 过渡时间 终止位置 transition-property 表示执行过渡的属性transition-duration 指定用于过渡的持续时间transition-timing-function 指定过渡的时序函数transition-delay 指定过渡效果的延迟 在简写中，如果有2个时间，则第一个为持续时间，第二个为延迟时间。 动画animation动画可以自动触发动态效果。设置动画效果，必须先设置一个关键帧，关键帧设置了动画执行每一个步骤。 //定义关键帧 @keyframes name{ //第一种 from{} to{} //第二种 0%{} 5%{} } //使用动画 animation-name... //其余属性同transition animation-iteration-count //迭代次数 animation-direction //动画方向 animation-play-state //设置动画的执行状态 执行或者暂停 animation-fill-mode //动画开始/停止的位置，默认动画执行完毕回到原来的位置 使用图片实现动画的一些小技巧 .box{ background-image:url(&quot;&quot;); //开启平铺 animation:name 1s steps(几个图片就几次) infinite; } @keyframes name{ from{ background-position:0 0; } to{ background-position:-图片的长度 0; } } 变形变形不会影响页面的布局，只会改变元素的形状或位置。 平移 可以与定位结合实现居中的效果。 //百分比是相对于自身计算的，并不是根据包含块 transform:translateX()/translateY()/translateZ() Z轴平移，正常情况就是调整人和元素之间的距离，距离越大，元素离人越近。如果想要看见效果必须要设置网页的视距。一般设置在html，perspective:1000px 表示人眼距离网页的距离 旋转与缩放 通过旋转可以使元素沿轴旋转指定的角度沿X轴转的时候，设置视距可以看见近大远小的效果。转了轴也会跟着转。 transform:rotateZ（45deg）/rotateZ(.5turn) //旋转的背面是否可以看见 backface-visibility:hidden; transform:scaleX() //缩放的是轴 即使设置了视距可以看见近大远小的效果，但是仍然仅仅是2D的效果，如果想看见3D的效果还需要设置transform-style:preserve-3d 弹性盒子flex是CSS3中新增的布局手段，它主要用来代替浮动来完成页面的布局。 弹性容器：要使用弹性盒，必须先将一个容器设置为弹性容器,display:flex设置为块级弹性容器，display:inline-flex设置为行内的弹性容器。 主轴：弹性元素的排列方式为主轴 侧轴：与主轴垂直方向为侧轴 弹性容器的样式 flex-direction 指定容器中弹性元素的排列方式 flex-wrap 指定弹性元素是否在容器中按侧轴换行 flex-flow是上述两个属性的简写属性 justify-content 如果分配主轴的空白空间 align-items 元素在侧轴如何对齐,控制元素间的对齐 align-content 侧轴空白空间的分配 弹性元素：弹性容器的子元素 弹性元素的样式 flex-grow 指定弹性元素的伸展的系数，当父元素有多余空间时，子元素如何分配。 flex-shrink 指定弹性元素的收缩性，当父元素的空间无法容纳所有的子元素时，如何对子元素进行收缩。 align-self 用来覆盖当前弹性元素上的align-items flex-basis 指定元素在主轴上的基础长度，如果主轴是横向的，那么指定的就是元素的宽度 flex 是上述的三个属性的简写，顺序也是上述的顺序 order决定弹性盒子的排列顺序 一个元素可以同时是弹性盒子和弹性元素。 其他三角形border四个方向的边框实际是一个梯形并不是矩形。当内容区域的高度宽度为0时，边框就会变成小三角形。 .box1{ width: 0; height: 0; border: 20px red solid; border-color: border-color: red orange greenyellow yellow; } //常常用伪类添加三角效果 //把不需要的方向颜色换成transparent就可以了。或者为了防止占位，可以添加 border-top:none 等来设计。 .xxx::before{ width: 0; height: 0; content:&quot;&quot;; display:block; border:10px solid transparent; border-top:none; border-bottom-color:white //如果开始不显示设置为display:none } //那么hover的时候可以用下面的写法使其显示 //xxxhover的时候他的伪元素怎么样 .xxx:hover::after{ display:block }]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[exports与module.exports的区别]]></title>
    <url>%2F2020%2F05%2F26%2Fexports%2F</url>
    <content type="text"><![CDATA[CommonJS规范CommonJS加载模块是同步 知识点1 Node中，一个js文件就是一个模块 引入：require(路径)，使用相对路径，必须以.或..开头引入模块以后，该函数会返回一个对象，这个对象代表的是引入的模块。 模块分成两大类：核心模块：由node引擎提供的模块，核心模块的标识就是模块的名字文件模块：由用户自己创建的模块，文件模块的标识为路径 知识点2在Node中，每一个js文件中的js代码都是独立运行在一个函数体中。所以如果想要其他文件访问，必须要将数据暴露出来暴露：exports.x = “xxxx” //当node在执行模块中的代码时，它首先在代码的最顶部，添加如下代码 function(exports,require,module,__filename,__dirname){ //里面才是自己写的 name=XX } 形参中 exports：将变量或函数暴露到外部 require：用来引入外部的模块 module：代表当前模块本身 __filename：当前模块的完整路径 __dirname：当前模块所在文件夹的完整路径 exports与module.exports的区别本质上exports就是module的属性，module.exports===exports exports只能用.的方式来向外暴露内部变量，比如：exports.name = XXX module.exports即可以通过.，也可以直接赋值暴露 //可以这样写 module.exports = {} //错误写法 exports = {} 首先无论用module.exports还是exports都是改变的module的exports属性。 本质是exports与module.exports指向的是同一个对象。 //module指向a空间 let module = {}; //在a空间中分配一块空间b给exports module.exports = {}; //引用类型赋值，exports变量指向空间b let exports = module.exports //使用.赋值是ok的，相当于修改b空间里给name分配的c空间 exports.name = &quot;xxx&quot; //使用直接赋值是不行的，因为引用类型在内存中存放的是指向数据的地址指针 //直接赋值相当于修改的指针使其不在指向b，让指针指向别处。 exports = {}]]></content>
      <categories>
        <category>前端</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm包管理]]></title>
    <url>%2F2020%2F05%2F25%2Fnpm%E5%8C%85%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[NPM（Node Package Manager）CommonJS包规范是理论（CommonJS的包规范 = 包结构+包描述文件），NPM是其中一种实践。npm是Node.js的软件包管理，对于Node而言，NPM帮助其完成了第三方模板的发布、安装、依赖等。借助NPM，Node与第三方模块之间形成了很好的一个生态系统。 基本的操作：查看版本：npm -v搜索模块包：npm search 包名安装包：npm install 包名 安装包并添加到依赖 （最好在要安装包的位置创建package.json文件） npm install 包名 -g 全局安装 初始化package.json:npm init (名字不用大写)删除包：npm remove 包名 通过npm下载的包都在node_mudules文件夹中，直接通过包名即可引用。node在使用模块名字来引入模块时，它会首先在当前目录的node_modules中寻找是否含有该模块，如果没有去上一级目录的node_modules中寻找，直到找到磁盘的根目录。 问题1：全局安装与本地安装npm install xxx # 本地安装npm install xxx -g # 全局安装 本地安装 将安装包放在 ./node_modules 下（运行npm时所在的目录） 可以通过 require() 来引入本地安装的包 全局安装 将安装包放在 /usr/local 下 可以直接在命令行里使用 问题2：-d与-s的区别npm install -d 就是npm install –save-devnpm insatll -s 就是npm install –save 我们在使用npm install 安装模块或插件的时候，上述两种命令都可以把他们写入到 package.json 文件里面去。首先dev是develop的简写，-save-dev安装的插件，被写入到 devDependencies 域里面去，而使用 –save 或者默认没写 安装的插件，则是被写入到 dependencies区块里面去。devDependencies 里面的插件只用于开发环境，不用于生产环境，而dependencies是生产环境也就是项目运行在服务器需要的插件。 例子：比如我们写一个项目要依赖于jQuery，没有这个包的依赖运行就会报错，这时候就把这个依赖写入dependencies ；而我们使用的一些构建工具比如glup、webpack这些只是在开发中使用的包，上线以后就和他们没关系了，所以将它写入devDependencies。 问题3：什么是npxnpm从5.2版本，增加了npx命令。npx主要作用是调用项目内部安装的模块和方法。现在的工具包一般都安装在局部，而不是全局。 //安装在开发环境的webpack-dev-server npm install webpack-dev-server -D //命令行中启动webpack-dev-server npx webpack-dev-server npx的原理是运行的时候会到node_modules/.bin路径和path里面，查看命令是否存在。 注意：Bash内置的命令不在Path中，所以类似cd的Bash命令不可以使用npx。 npx还可以运行一些需要全局安装的依赖（但不安装该依赖），npx将会把该依赖下载到一个临时目录，使用以后再删除，所以可以避免全局安装模块。 可以在package.json中scripts属性中配置命令如”build”:webpack ,npm run build 实现npx同样的效果。 –no-install与–ignore-existing参数 –no-install:可以时npx强制使用本地模块，不下载远程模块，所以如果本地不存在该模块，就会报错。–ignore-existing:可以使npx强制安装使用远程模块，忽略本地的同名模块。 -p参数用于指定npx所要安装的模块。 //-p也可以省略 npx -p node@0.12.8 总结 利用npx可以下载模块使用过后再删除的特点，可以在某些场景切换版本。 使用npx可以不需要全局安装依赖，较少使用本机的存储空间。 使用本地已安装的可执行工具，而不需要配置scripts。 可以执行依赖包中的命令，安装完成自动运行。]]></content>
      <categories>
        <category>前端</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unexpected-token< 报错]]></title>
    <url>%2F2020%2F03%2F22%2Funexpected-token%2F</url>
    <content type="text"><![CDATA[因为团队信息的后台返回数据格式发生了变化，前端字段应该做相应变化。改完之后，本地是没有问题的，打包上线到服务器之后发现了报错了Uncaught SyntaxError: Unexpected token &lt; 所以原因要么在服务器，要么就是打包的问题。 首先进行排查的是文档类型，因为报错的三行都是与js相关。点击控制台错误的代码提示，查看network对应的文件加载状态,发现返回的不是js形式。而是doctype html,那么很大概率是服务器把js文件当作html响应，导致解析错误。正常情况返回content-type:applocation/javascript，而现在的错误情况js文档的响应信息，变成了text/html 把上一个版本部署上去，发现没问题。那么排除了服务器的问题，应该是打包的问题。 确定是打包的问题之后查看config/index.js,找到了原因。 默认的是在路径前面添加/,但是此项目的路由设置了所有路径都会跳转到/manage/xx,所以需要在修改assetPublicPath属性。]]></content>
      <categories>
        <category>questions</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>软件超市</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XHR的ajax封装(简单版本)]]></title>
    <url>%2F2020%2F03%2F01%2FXHR%E7%9A%84ajax%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[目的:熟练XHR的基本使用 特点1.函数的返回值为promise，成功的结果为response，失败的结果为error2.能处理多种类型的请求：GET/POST/PUT/DELETE3.函数的参数为一个配置对象 { url:&quot;&quot;,//请求地址 method:&quot;&quot;,//请求方式 params:{},//GRT/DELETE请求的query参数 data:{},//POST或DELETE请求的请求体参数 } 4.响应json数据自动解析为js5.response只实现了data，status，statusText6.put请求提交的是请求体参数，delete提交query参数 补充1.query，params，body req.params,req.query是用在get请求当中 query参数 返回值：对数据过滤产生一个新数组 param参数:常用于REST API风格 localhost:3000/posts?id=1 返回值：定位到对应的对象 返回值：定位到对应的对象 localhost:3000/posts/1 req.body是用在post请求中的，body 不是 nodejs 默认提供的，你需要载入 body-parser 中间件才可以使用，req.body此方法通常用来解析 POST 请求中的数据。 2.OPTIONS请求，预检查（get不需要）是否跨域等，没有响应体。 注意:1.axios的params是指定get或者delete请求的query参数（拼接在url后面）2.发送json格式请求体参数，需要设置请求头 function axios({ url, method=&quot;GET&quot;, //设置默认值 parmas={},//默认空对象 data={}//设置默认值 }) { //返回一个Promise对象 return new Promise((resolve, reject) =&gt; { //处理query参数，拼接到url let queryString=&#39;&#39; for (key in params){ queryString+=`${key}=${parmas[key]}&amp;` } if (queryString){ //去掉最后的&amp; queryString = queryString.substring(0,queryString.length-1) //拼接 url += &quot;?&quot;+queryString } //处理method为大写 method = method.toUpperCase() //1.执行异步ajax请求 //创建xhr对象 const request = new XMLHttpRequest(); //初始化请求(异步) request.open(method,url,true) //绑定状态改变的监听,send是异步的，所以绑定监听写在send后面也可以 request.onreadystatechange = function () { //如果请求没有完成，直接结束 if (request.readyState!==4){ return } } switch (method){ case &quot;GET&quot;||&quot;DELETE&quot; : //get的参数通过url传 request.send(); break; case &quot;POST&quot;||&quot;PUT&quot;: //发送请求 // post请求的data不能是对象需要是字符串 //发送JSON格式，需要加请求头 request.setRequestHeader(&quot;Content-Type&quot;,&quot;application/json;charset=utf&quot;)//告诉服务器请求体的格式是json request.send(JSON.stringify(data)) break; } //如果响应状态码在【200，300)之间代表成功，否则失败 const {status,statusText} = request if (status&gt;=200&amp;&amp;status&lt;=299){ //2.1如果请求成功了，调用resolve() //准备结果response对象 const response = { //服务器返回的是JSON数据需要转换成对象 //响应json数据自动解析为js的对象/数组 data:JSON.parse(request.response), status, statusText, } resolve(response) }else { //2.2如果请求失败,调用reject() reject(new Error(`request error status is ${status}`)) } }) }]]></content>
      <categories>
        <category>前端</category>
        <category>库</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios]]></title>
    <url>%2F2020%2F02%2F27%2Faxios%2F</url>
    <content type="text"><![CDATA[HTTP相关交互的基本过程 客户端 ===》（请求行，请求头，请求体）服务器服务器 ===》（状态行，响应头，响应体）客户端 请求报文请求行：method url多个请求头：host主机，cookie，Content-Type(请求体的内容类型)application/json 或者 application/x-www.form.urlencoded请求体（get请求没有）：{“username”:”tom”,”pwd”:123} 或者 username=tom&amp;pwd=123 响应报文状态行：status statusText多个响应头：Content-Type(响应体的内容类型):text/html;charset=uft-8 Set-Cookie:BD_CK_SAM=1;path=/响应体：html 文本/json 文本/js/css/图片… post请求体参数格式Content-Type:application/x-www.form.urlencoded例如：username=tom&amp;pwd=123 Content-Type:application/json例如：{“username”:”tom”,”pwd”:123} Content-Type:multipart/form-data用于文件上传请求 常见的响应状态码200 ok 请求成功，一般用于GET与POST请求201 created 已创建。成功请求并创建了新的资源401 Unauthorized 未到授权/请求要求用户的身份认证404 Not Found 服务器无法根据客户端的请求找资源500 Internal Serve Error 服务器内部错误，无法完成请求 常用请求类型 GET:从服务器端读取数据POST:向服务器端添加新数据PUT:更新服务器端已有数据DELETE:删除服务器端数据 API的分类1.REST API: restful 发送请求进行操作由请求方式决定 同一个请求路径可以进行多个操作（如同一个路径的get、delete） 请求方式会用到GET/POST/PUT/DELETE2.非REST API restless 请求方式不决定请求的操作 一个请求路径只能对用一个操作 一般只有GET/POST json-server工具包可快速搭建REST API XHR的理解和使用XHR对象可以从URL获取数据，而无需让整个页面刷新 一般的http请求与ajax请求1.ajax请求是一种特别的http请求2.对服务端来说，没有任何区别，区别在浏览器端3.浏览器端发请求：只有XHR或fetch发出的才是ajax请求4.浏览器端接收响应： 一般请求：浏览器一般会直接显示响应体数据，也就是我们常说的刷新/跳转页面 ajax请求：浏览器不会对界面进行任何更新操作，只是调用监视的回调函数并传入响应相关数据。 APIXHR对象的属性：XMLHttpRequest():创建XHR对象的构造函数readyState（请求的状态）： 0：初始 1：open()之后 2：send()之后 3：请求中 4：请求完成onreadystatechange：绑定readyState改变的监听responseType:指定响应数据类型，如果是’json’,得到响应后自动解析响应体数据response：响应体数据，类型取决于responseTypeopen(method，url[,async]):初始化一个请求,默认async：truesend(data)：发送请求abort()：中断请求getResponseHeader(name)：获取指定名称的响应头值getAllResponseHeaders():获取所有响应头组成的字符串setResponseHeaders(name,value):设置请求头status：由服务器返回的HTTP状态代码statusText：由服务器返回的HTTP状态文本 ajaxajax技术的核心是XMLHttpRequest对象(简称XHR)， XHR的ajax简单封装 axiosaxios的post请求头默认是application/x-www-form-urlencoded,如果data是对象,默认Json。axios请求的方式可以通过函数axios(config)使用，也可以通过对象axios.get()使用 特点1.基于promise的异步ajax请求库（基于promise的 HTTP 库）2.浏览器端/node端都可以使用3.支持请求/响应拦截器4.支持请求取消5.请求/响应数据转换6.批量发送多个请求 axios.create(config)自定义配置新建一个新的axios实例，新axios只是没有取消请求和批量发请求的方法，其他所有语法都是一致的。 const instance = axios.create({ baseURL:&quot;http://localhost:3000&quot; }) //使用instance发请求 instance({ url:&quot;/posts&quot; //请求端口3000 }) 这个语法的用处： 需求：项目中有部分接口需要的配置与另一部分接口需要的配置不太一样 解决：创建2个新的axios，每个都有自己特有的配置，分别应用到不同要求的接口请求中 axios.default.baseURL = &quot;http://localhost:4000&quot; axios({ url:&quot;/posts&quot; //请求的端口4000 }) const instance = axios.create({ baseURL:&quot;http://localhost:3000&quot; }) //使用instance发请求 instance({ url:&quot;/posts&quot; //请求端口3000 }) axios的处理链流程axios拦截器 请求拦截器axios.interceptor.request.use(callback)响应拦截器axios.interceptor.response.use(callback) axios.interceptors.request.use(config=&gt;{ console.log(&quot;request interceptor1 &quot;); //拦截请求，处理请求之后，必须要返回该配置，若不返回相当于axios请求没有添加配置 return config },error=&gt;{ console.log(&quot;request interceptor1 err&quot;); return Promise.reject(error) }) axios.interceptors.request.use(config=&gt;{ console.log(&quot;request interceptor2 &quot;); return config },error=&gt;{ console.log(&quot;request interceptor2 err&quot;); return Promise.reject(error) }) axios.interceptors.response.use(response=&gt;{ console.log(&quot;response interceptor1 &quot;); return response },error=&gt;{ console.log(&quot;response interceptor1 err&quot;); return Promise.reject(error) }) axios.interceptors.response.use(response=&gt;{ console.log(&quot;response interceptor2 &quot;); //拦截response结果处理之后，要返回结果 return response },error=&gt;{ console.log(&quot;response interceptor2 err&quot;); return Promise.reject(error) }) axios.get(&quot;http://localhost:/posts&quot;).then(response =&gt;{ console.log(&quot;response data&quot;); }).catch(error=&gt;{ console.log(&quot;response error&quot;); }) /* 输出 request interceptor2 request interceptor1 response interceptor1 err response interceptor2 err response error */ 注意点：1.请求拦截器后添加先执行。2.拦截请求，处理请求之后，必须要返回该配置，若不返回相当于axios请求没有添加配置3.拦截response结果处理之后，要返回结果。 取消请求应用场景:如果发送请求2的时候，发现请求1还没有完成则取消请求1 let cancel //保存用于取消请求的函数 function getProducts1(){ if (typeof cancel === &quot;function&quot;){ //需要使用取消请求时调用 //如果请求取消了，则该请求进入请求失败的流程，请求失败的error是Cancel对象类型，Cancel里面有message属性 cancel(&quot;这里可以传消息提示&quot;) } axios.get(&quot;/user&quot;,{ cancelToken:new axios.CancelToken( //执行器回调，同步进行 c =&gt; {//c是用于取消当前请求的函数 cancel = c } ) }).then(response =&gt;{ cancel = null //如果请求完成就不要取消请求了 },error =&gt;{ if (axios.isCancel(error)){ // 取消请求 console.log(&quot;请求取消了&quot;,error.message); } else{ //请求本身出错 cancel = null console.log(error); } }) } function getProducts2(){ if (typeof cancel === &quot;function&quot;){ cancel(&quot;这里可以传消息提示&quot;) } axios.get(&quot;/user/1&quot;,{ cancelToken:new axios.CancelToken( c =&gt; {cancel = c} ) }).then(response =&gt;{ cancel = null },error =&gt;{ if (axios.isCancel(error)){ console.log(&quot;请求取消了&quot;,error.message); } else{ cancel = null console.log(error); } }) } 改进版本 //添加请求拦截器 axios.interceptors.request.use(config=&gt;{ if (typeof cancel === &quot;function&quot;){ cancel(&quot;这里可以传消息提示&quot;) } config.cancelToken =new axios.CancelToken( c =&gt; { cancel = c } ) return config }) //添加响应拦截器 axios.interceptors.response.use( respose=&gt;{ cancel = null return respose }, error =&gt;{ if (axios.isCancel(error)){ console.log(&quot;请求取消了&quot;,error.message); //中断promise链接 return new Promise(()=&gt;{}) } else{ cancel = null //将错误继续向下传递 // throw error return Promise.reject(error) } }) let cancel function getProducts1(){ axios.get(&quot;/user&quot;).then(response =&gt;{ //其他数据响应 },error =&gt;{ //只需要处理请求失败 }) } function getProducts2(){ axios.get(&quot;/user/1&quot;).then(response =&gt;{ //其他数据响应 },error =&gt;{ //只需要处理请求失败 }) }]]></content>
      <categories>
        <category>前端</category>
        <category>库</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js（3.28更新）]]></title>
    <url>%2F2020%2F02%2F25%2Fnode-js%2F</url>
    <content type="text"><![CDATA[综述Node.js是能够在服务器端运行JavaScript的开放源代码、跨平台JavaScript运行环境 Node是对ES标准一个实现，Node也是一个JS引擎 通过Node可以使js代码在服务器端执行 Node仅仅对ES标准进行了实现，所以在Node中不包含DOM和BOM Node中可以使用所有的内建对象（String Number Boolean Math Date RegExp Function Object Array）而BOM（操作浏览器）和DOM（文档对象模型）都不能使用，但是可以用console也可以用定时器 Node可以在后台来编写服务器，Node服务器都是单线程的服务器。 补充：1.node中有一个全局对象global，它的作用和网页中window类似，在全局创建的变量/方法都会作为global的属性/方法保存2.代码风格：建议无论有分号代码或者无分号代码，都建议如果一（、[、\`开头，最好都在前面补上一个分号。 Buffer（缓存区）Buffer的结构和数组很像，操作的方法也和数组类似。数组中不能存储二进制的文件，而Buffer专门用来存储二进制数据(图片/mp3/视频 二进制文件) 使用：buffer不需要引入模块，直接使用即可 常用操作Buffer.from(str[,encoding]) str 需要编码的字符串 encoding 默认’utf8’把字符串转换成二进制,buffer中每个元素的范围从00-ff（8bit）,如果要转换成字符串用toString() Buffer.lengthBuffer占用的内存大小 Buffer.alloc(size[, fill[, encoding]]) size，分配的内存长度 fill，用于预填充新Buffer的值，默认值：0 encoding，如果fill是一个字符串，则这是它的字符编码，默认’utf8’ //创建一个10个字节的buffer let buf = Buffer.alloc(10) //通过索引，来操作buf中的元素 buf[0] = 88 注意：Buffer的大小一旦确定，则不能在修改，因为Buffer是对内存的直接操作 只要数字在控制台或页面中输出一定是10进制 如果要16进制输出，number的toString(进制)里面可以传参。 ``` let buf = Buffer.alloc(10) buf[1]=0xaa; console.log(buf[1].toString(16)); //输出aa ``` Buffer.allocUnsafe(size) 创建一个指定大小的buffer，但是buffer中可能含有敏感数据（分配空间并没有预设默认值0） fs（文件系统）文件系统简单来说就是通过Node来操作系统的文件。服务器的本质就是将本地的文件发送给远程的客户端。fs模块中所有的操作都有同步和异步两种形式选择，同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码，异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回。 使用：使用文件系统，需要先引入fs模块，fs是核心模块，直接用名字引入不需要下载。 同步/异步文件写入同步的文件的写入：1.打开文件 fs.openSync(path[, flags, mode]) - path 打开文件的路径 - flags 打开文件要做的操作的类型 默认&#39;r&#39; - mode 设置文件的操作权限，一般不传 返回值：该方法会返回一个文件的描述符作为结果，我们可以通过该描述符对文件进行各种操作 2.向文件中写入内容 fs.writeSync(fd, buffer[, offset[, length[, position]]]) - fd 文件的描述符，需要传递要写入的文件的描述符 - buffer 要写入的内容 - offset 写入的位置 3.保存并关闭文件 fs.closeSync(fd) let fs = require(&quot;fs&quot;) //打开文件 let fd = fs.openSync(&quot;hello.txt&quot;,&quot;w&quot;) //向文件中写入内容 console.log(fd); fs.writeSync(fd,&quot;hello&quot;) //保存并关闭文件 fs.closeSync(fd) 异步方法(不可能有返回值):1.打开文件 fs.open(path[, flags[, mode]], callback) ，结果是通过回调函数返回的,回调函数路两个参数。 - err 错误对象，如果没有错误则为null（js的设计思想，错误优先） - fd 文件描述符 2.向文件中写入内容 fs.write(fd, buffer[, offset[, length[, position]]], callback）3.关闭文件 fs.close(fd, callback) let fs = require(&quot;fs&quot;) //打开文件 fs.open(&quot;hello.txt&quot;,&quot;w&quot;,function (err,fd) { if (!err) { console.log(&quot;打开成功&quot;); //向文件中写入内容 fs.write(fd,&quot;这是异步写入的内容&quot;,function (err) { if (!err){ console.log(&quot;写入成功&quot;); } //关闭文件 fs.close(fd, function (err) { console.log(&quot;文件关闭&quot;); }) }) } else console.log(err); }) (常用)简单的文件写入fs.writeFile(file, data[, options], callback) file 要操作的文件的路径 data 要写入的数据 options 选项，可以对写入进行一些设置 callback 当写入完成以后执行的函数 const fs = require(&quot;fs&quot;) fs.writeFile(&quot;hello.text&quot;,&quot;这是通过writeFile写入的内容&quot;,function (err) { if (!err){ console.log(&quot;写入成功&quot;); } }) 文件打开常用模式：w：写入文件，如果不存在则创建，文件写入默认从头开始写会覆盖文件。r+:读写文件，写操作时会覆盖，文件不存在则出现异常。w+:读写文件，文件不存在先创建，会覆盖。a: 写入文件，打开文件用于追加，如果不存在则新建。a+：读写文件，文件不存在先建立，追加r：读取文件，文件不存在则出现异常rb/wb：分别与r/w相似，但是用于读写二进制文件 流式文件写入同步、异步、简单文件的写入都不适合大文件的写入（只要写一次），性能较差，容易导致内存溢出。只要流存在，可以分多次写入。 创建一个可写流：fs.createWriteStream(path,[,options]) - path：文件路径 - options 配置的参数 - 有返回值，该方法会返回一个文件的描述符作为结果，我们可以通过该描述符对文件进行各种操作 const fs = require(&quot;fs&quot;) //流失文件写入 //创建一个可写流 let ws = fs.createWriteStream(&quot;hello.txt&quot;) //可以通过监听流的open和close事件来监听流的打开和关闭 ws.once(&quot;open&quot;,function () { //open只会触发一次，on绑定了事件会一直存在，所以用once绑定一次性事件。 console.log(&quot;已经打开流&quot;); }) ws.once(&quot;close&quot;,function () { console.log(&quot;流关闭&quot;); }) ws.write(&quot;写入成功&quot;) ws.write(&quot;哈哈哈哈&quot;) ws.write(&quot;写入成功&quot;) ws.write(&quot;哈哈哈哈&quot;) //关闭流，关闭的接收方， ws.close() 文件的读取操作基本上和文件的写入差不多，具体看API。注意：1.读取到的数据会返回一个Buffer2.如果要读取一个可读流中的数据，必须要为可读流绑定一个data事件，data事件绑定完毕，它会自动开始读取数据，读取完毕后可读流自动关闭 const fs = require(&quot;fs&quot;) //流失文件读取，可以分多次将文件读取到内存中 //创建一个可读流 let rs = fs.createReadStream(&quot;消息提醒.png&quot;) //创建一个可写流 let ws = fs.createWriteStream(&quot;xxx.png&quot;) //可以通过监听流的open和close事件来监听流的打开和关闭 rs.once(&quot;open&quot;,function () { console.log(&quot;已经打开流&quot;); }) rs.once(&quot;close&quot;,function () { console.log(&quot;流关闭&quot;); //读取完毕后可读流自动关闭，所以在这个时候关闭可写流 ws.close() }) //如果要读取一个可读流中的数据，必须要为可读流绑定一个data事件，data事件绑定完毕，它会自动开始读取数据，读取完毕后自动关闭 rs.on(&quot;data&quot;,function (data) { console.log(data); ws.write(data); //ws.close()，可能导致只读了一条数据就关闭 }) pipe()更简单的写法pipe(),rs.pipe(ws)在可读流rs与可写流ws之间架起一个管道，自动将可读流中的内容，直接输出可写流。 fs其他常用方法验证路径是否存在 fs.existsSync(path) 返回值：存在true，不存在false获取文件状态 fs.stat(path,callback)/fs.statSync(path) 返回对象：文件的状态删除文件 fs.unlink(path,callback)/fs.unlinkSync(path)读取一个目录的目录结构 fs.readdir(path[,options],callback)/fs.readdirSync(path[,options]) 返回一个字符串数组，每一个元素就是一个文件夹或文件的名字截断文件 fs.truncate(path,len,callback)/fs.truncateSync(path,len) 将文件修改成指定的len大小（一个汉字3个字节）创建文件夹 fs.mkdir(path[,mode],callbcak)/fs.mkdirSync(path[,mode])删除文件夹 fs.rmdir(path,callbcak)/fs.rmdirSync(path)重命名文件/剪贴文件 fs.rename(oldPath(oldName),newPath,callback)/fs.renameSync(oldPath,newPath)监视文件的修改 fs.watchFile(filename[,options],listener) listener回调函数，当文件发生变化时，回调函数会执行。 ip地址和端口号 ip地址用来定位计算机 端口号用来定位具体的应用程序 一切需要联网通信的软件都会占用一个端口号 端口号的范围从0-65536 在计算中有写一些默认端口号，最好不要去使用。如：http服务的80 httprequest 请求事件处理函数，需要接收两个参数：request，response。 const http = require(&quot;http&quot;) const server = http.createServer() server.on(&quot;request&quot;,function (request,response) { console.log(&quot;请求路径是&quot; + request.url); //在服务端默认发送的数据，其实是utf8编码的内容 //但是浏览器不知道是utf8的内容，在不知道服务器响应内容的编码的情况下会按照当前操作系统默认编码解析 //text/plain;普通文本 //response对象有一个方法：write可以用来给客服端发送响应数据； //write可以使用多次，但最后一定要使用end来结束响应，否则客服端会一致等待 //响应的数据只能是二进制(默认)或字符串 fs.readFile(xxx,function(err,data){ response.setHeader(&#39;Content-type&#39;,&quot;text/html;charset=utf-8&quot;) response.end(data) }) } }) server.listen(3000,function () { console.log(&quot;服务器启动成功&quot;); }) urlurl：统一资源定位符，url核心模块在为我们解析url地址时提供了非常方便的APIurl.parse()方法可以解析一个url地址，通过传第二个参数(true)把包含有查询字符串的query转化成对象 const url = require(&quot;url&quot;) let httpUrl = &quot;https://sale.vmall.com/hwmate.html#abc?cid=10602&quot; let urlObj = url.parse(httpUrl) console.log(urlObj); //Url { // protocol: &#39;https:&#39;, 协议 // slashes: true, // auth: null, // host: &#39;sale.vmall.com&#39;, 主机 // port: null, 端口号 // hostname: &#39;sale.vmall.com&#39;, // hash: &#39;#abc?cid=10602&#39;, // search: &#39;?cid=10602&#39;, 查找的内容 // query: &#39;cid=10602&#39;, query问号后面的内容 // pathname: &#39;/hwmate.html&#39;, 路径的名称 // path: &#39;/hwmate.html?cid=10602&#39;, // href: &#39;https://sale.vmall.com/hwmate.html?cid=10602&#39; } url.resolve()方法合成url，第一个参数基url，第二个参数目标url const url = require(&quot;url&quot;) let targetUrl=&quot;http://www.taobao.com/&quot; let httpUrl = &quot;./xxx.html&quot; console.log(url.resolve(targetUrl, httpUrl)); //自动去掉./ //http://www.taobao.com/xxx.html]]></content>
      <categories>
        <category>前端</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F2020%2F02%2F23%2F%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[ES5时，有个经典的需求：点击某个按钮，提示”点击的是第n个按钮” //html &lt;button&gt;测试1&lt;/button&gt; &lt;button&gt;测试2&lt;/button&gt; &lt;button&gt;测试3&lt;/button&gt; //js var btns = document.getElementsByTagName(&quot;button&quot;); //遍历加监听 for (var i = 0;i&lt;btns.length;i++) { var btn = btns[i]; btn.onclick =function () { alert(i) } 这里有个关于效率的问题,btns是伪数组，for循环中btns.length每次都要计算一遍才能得到结果，这里循环就会计算多次。改进之后的代码: var btns = document.getElementsByTagName(&quot;button&quot;); //遍历加监听 for (var i = 0,length=btns.length;i&lt;length;i++) { var btn = btns[i]; btn.onclick =function () { alert(i) } } 但是点击按钮之后发现每个按钮都打印的3。因为点击之后的函数是回调函数，需要放在宏队列中执行，而for循环已经执行结束(i已经等于3了) ES6之前的解决办法：解决办法1：将btn所对应的下标保存在btn上 var btns = document.getElementsByTagName(&quot;button&quot;); //遍历加监听 for (var i = 0,length=btns.length;i&lt;length;i++) { var btn = btns[i]; btn.index = i btn.onclick =function () { alert(this.index) } } 解决办法2:闭包 var btns = document.getElementsByTagName(&quot;button&quot;); for (var i = 0;i&lt;btns.length;i++) { var btn = btns[i]; (function (i) {//这i是局部的 btn.onclick = function () { alert(i) } })(i)//这个i是全局i } 问题1:如何产生闭包？当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时，就产生了闭包。 问题2：闭包到底是什么?(用chrome调试查看)闭包是嵌套的内部函数注意:闭包存在于嵌套函数的内部函数中 问题3：产生闭包的条件1.函数嵌套2.内部函数引用了外部函数的数据 函数定义时就会产生闭包，调用一次外部函数产生一个新的闭包。做闭包的题的时候仔细分析哪个变量导致闭包且是否有新的闭包产生。 常见的闭包1.将函数作为另一个函数的返回值 function fn1() { var a = 2 function fn2() { a++; console.log(a); }//仅一个闭包 return fn2 } //f指向了fn2的函数对象(局部变量fn2已经不在了，因为fn2不在闭包里面)，这也是闭包一直存在的原因 var f = fn1()//已经产生了闭包，执行完后，a还在 f()//3 f()//4 局部函数调用时存在，调用结束消失。外部函数执行几次，就产生几个闭包。所以此例子只产生了一个闭包。 2.将函数作为实参传递给另一个函数调用 function showDelay(msg,time) { //setTimeout()是在执行这个函数 setTimeout(function () {//闭包是在定义内部函数时生成的 alert(msg)//回调函数是内部函数，且用了外部函数的msg值 },time) } showDelay(&quot;xxx&quot;,2000) //产生了闭包 闭包的作用(又想隐藏，又想使用) 使用函数内部的变量在函数执行完后，仍然存活在内存中(延长了局部变量的生命周期) 让函数外部可以操作(读写)到函数内部的数据 闭包的生命周期产生：在嵌套内部函数定义执行完成时就产生了(不是在调用)死亡：在嵌套的内部函数成为垃圾对象时 function fn1() { var a = 2//此时闭包就已经产生了(函数提升，内部函数对象已经创建了) function fn2() { a++; console.log(a); } return fn2 } var f = fn1() f = null //闭包死亡(包含闭包的函数对象成为垃圾对象) 闭包的应用1.定义JS模块 具有特定功能的JS文件 将所有的数据和功能都封装在函数内部（私有的）//对象的属性外部直接可以见，所以封装在对象里不算私有 只向外暴露一个包含n个方法的对象或函数 //module.js function myModule(){ //私有数据 var msg = &quot;xxx&quot; function doSomething(){ console.log(&quot;doSomething&quot;+msg.toUpperCase()) } function doOtherthing(){ console.log(&quot;doOtherthing&quot;+msg.toLowerCase()) } //向外暴露对象 return{doSomething,doOtherthing} } } //其他界面调用时，需要一个函数来接收 匿名函数自调用 //module2.js (function myModule(window){ //私有数据 var msg = &quot;xxx&quot; function doSomething(){ console.log(&quot;doSomething&quot;+msg.toUpperCase()) } function doOtherthing(){ console.log(&quot;doOtherthing&quot;+msg.toLowerCase()) } //向外暴露对象 window.module2 = {doSomething,doOtherthing} })(window) //其他界面调用时，直接module2.doSomethig 闭包的缺点及解决缺点：函数执行完后，函数内的局部变量没有释放，占用内存时间会变长。(容易造成内存泄漏)解决：能不用闭包就不用，及时释放（让内部函数称为垃圾对象–&gt;回收闭包） 内存溢出一种程序运行出现的错误。当程序运行需要的内存超过了剩余的内存时，就会抛出溢出的错误。 内存泄漏占用的内存没有及时释放就是内存泄露，内存泄漏积累多了就容易导致内存溢出。常见的内存泄漏：意外的全局变量，没有及时清理的计时器（如启动循环定时器后不清理）或回调函数，闭包。 let intervalId = setInterval(function(){//启动循环定时器后不清理 console.log(&quot;---&quot;) },1000) //清除定时器 clearInterval(intervalId) 面试题 var name = &quot;The Window&quot;; var object = { name:&quot;My object&quot;, getNameFunc : function () { return function () { return this.name; } } } console.log(object.getNameFunc()());//The Window var name = &quot;The Window&quot;; var object = { name:&quot;My object&quot;, getNameFunc : function () { var that = this return function () { return that.name; //that等于的this是 调用了getNameFunc的对象 } } } console.log(object.getNameFunc()());//My object]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回调函数]]></title>
    <url>%2F2020%2F02%2F23%2F%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一直都知道回调函数这种说法，但是并不能很准确的回答什么是回调函数？ 这个是知乎常溪玲的答案，非常的通俗易懂 你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。 或者说回调函数的特征:你定义的，你没有调，但它最终执行了。 常见回调函数 dom事件回调函数 定时器回调函数 ajax请求回调函数 生命周期回调函数 document.getElementById(&quot;btn&quot;).onclick=function () {//dome事件回调函数 alert(this.innerHTML) } //定时器 setTimeout(function () { //定时器回调函数 alert(&quot;到点了&quot;) },2000)]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git&GitHub]]></title>
    <url>%2F2020%2F02%2F14%2Fgit-1%2F</url>
    <content type="text"><![CDATA[git介绍结构 工作区（本身文件）：写代码 = git add =&gt; 暂存区：临时存储 = git commit =&gt; 本地库（.git）：存储历史版本 Git和代码托管中心 代码托管中心(如GitHub):帮忙维护远程库 本地库和远程库 团队内部协作 跨团队协作 外团队人员fork该团队远程库A（复制新的远程库B），clone到本地修改后push到B，之后外团队人员pull request =&gt; 该团队人 审核 =&gt; merge 远程库A的内容更新成远程库B的内容。 git命令行操作本地库初始化命令：git init效果：出现隐藏文件.git注意：.git目录中存放的是本地库相关的子目录和文件，不要删除，也不要乱修改 设置签名形式: 用户名：XXX Email地址：XXXXX 作用：区分不同开发人员的身份辨析：这里设置的签名和代码托管中心的账号、密码没有任何关系命令: 项目级别/仓库级别：仅在当前本地库起作用 git config user.name XX git config user.email XX 系统用户级别：登陆当前操作系统的用户范围， git config --global git config --global user.name XX git config --global user.email XX 级别优先级：项目级别优于系统用户级别 基本操作状态检查命令: git status作用：查看工作区、暂存区状态 移除暂存区命令: git rm –cached [filename] 添加到暂存器命令：git add[filename] 添加所有git add . 添加所有修改的git add -A 提交命令：git commit -m”commit message”[filename] 提交所有git commit -m”版本留言描述”作用：将暂存区的内容提交到本地库 查看历史任务命令： 完整形式 git log 若多屏显示控制方式：空格向下翻页 b向上翻页 q退出 以一个漂亮的格式显示 git log –pretty=oneline/git log–oneline(后面的更简洁) git reflog :索引值更简洁，其中HEAD@{移动到当前版本需要多少步} &lt;img src=&quot;/img/git/历史任务.png&quot; /&gt; 前进后退可以配合git reflog使用本质:操作HEAD的指针，默认是指向最近的版本。基于索引值操作（推荐）: git reset –hard [局部索引值] 例（上图）：git reset–hard a6ace91使用^(异或)符号（只能后退）： git reset –hard HEAD^ 注:一个^表示后退一步，n 个表示后退 n 步使用~符号（只能后退）: git reset –hard HEAD~n 注:表示后退 n 步 reset 命令的三个参数对比–soft参数： 仅仅在本地库移动 HEAD 指针 只回退了commit的信息，如果还要提交，直接commit –mixed参数：① 在本地库移动 HEAD 指针 ② 重置暂存区 默认方式 git reset –mixed + git add . = git reset –soft –hard参数：①在本地库移动 HEAD 指针 ② 重置暂存区 ③ 重置工作区 彻底回退到某个版本，本地的源码也会变成上一个版本的内容 删除文件与恢复前提：删除前，文件存在时的状态提交到了本地库。操作：rm [filename]注：rm之后通过 git add [filename] 可把文件再次添加到缓存区 可利用 git reset –hard[指针位置] 回退到之前版本找回文件。 前提：删除的文件在暂存区，但还没有提交到本地库命令: git reset –hard HEAD（刚刚创建时） 比较文件差别命令：git diff[文件名]作用：将工作区中的文件和暂存区进行比较 命令：git diff[本地库中历史版本][文件名]作用：将工作区中的文件和本地库历史记录比较 注意:不带文件名比较多个文件 分支管理优势： 同时并行推进多个功能开发，提高开发效率 各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可 分支操作创建分支命令：git branch[分支名] 查看分支命令：git branch -v 切换分支命令：git checkout[分支名] 合并分支如把hot_fix上的修改合并到master上 第一步：切换到合并的分支上 git checkout[master]第二步：执行 merge 命令 git merge[hot_fix] 解决冲突合并时同时修改同一个文件的同一个地方 第一步:自行修改冲突文件第二步:git add[文件名]第三步:git commit-m”日志信息” 注意：此时 commit 一定不能带具体文件名 GitHub连接远程库命令： git remote-v 查看当前所有远程地址别名 git remote add [别名] [远程地址] (常用别名：origin)作用：下次上传可以直接用别名上传 推送命令：git push [别名][分支名] 克隆命令：git clone 仓库地址作用；完整的把远程库下载到本地；创建origin远程地址别名；初始化本地库。 团队成员邀请 变成团队成员就可以把自己的修改推送进入远程仓库了。 拉取pull命令: git fetch[远程库地址别名][远程分支名] git merge[远程库地址别名/远程分支名] git pull[远程库地址别名][远程分支名]作用: pull=fetch+merge。 fetch 把远程库抓取下来，并没有修改本地文件。 merge 把远程的master合并到本地的master，本地文件修改。 解决冲突要点：如果不是基于GitHub远程库的最新版本所作的修改，不能推送，必须先拉取下来如若pull下来之后进入冲突状态，其余同分支冲突处理办法一样。 跨团队操作外团队人员fork该团队远程库A（复制新的远程库B、外团队人员的仓库），clone到本地修改后push到B，之后外团队人员pull request （GitHub远程库B操作）=&gt; 该团队人（GitHub远程库A） 审核 =&gt; merge 远程库A的内容更新成远程库B的内容。 SSH登陆第一步：生成ssh（在家目录）ssh-keygen ct rsa -C 邮箱账号 //注意C大写注：在主目录下生成的密钥在 /c/Users/用户名/.ssh/id_rsa 里第二步：查看并复制ssh（需在.ssh目录下执行 cd .ssh进入）cat id_rsa.pub第三步：复制密钥内容添加到 github 上 使用ssh协议上传文件到仓库 git initgit add .git commit -m “ “git remote add 别名 git@github.com:…git push -u 别名 master Git工作流在项目开发过程中使用的Git的方式 GitFlow工作流(常用)Gitflow 工作流通过为功能开发、发布准备和维护设立了独立的分支，让发布 迭代过程更流畅。严格的分支模型也为大型项目提供了一些非常必要的结构。]]></content>
      <categories>
        <category>前端</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[富文本tinymce]]></title>
    <url>%2F2020%2F02%2F09%2F%E5%AF%8C%E6%96%87%E6%9C%ACtinymce%2F</url>
    <content type="text"><![CDATA[安装//安装tinymce-vue npm install @tinymce/tinymce-vue -S //安装tinymce,版本为5.X npm install tinymce -S //引入中文语言包 中文下载包 使用在 node_modules中找到 tinymce/skins目录，然后将skins目录拷贝到static目录下的tinymce 初始化引入基本文件 //初始化tinymce import tinymce from &#39;tinymce/tinymce&#39; import Editor from &#39;@tinymce/tinymce-vue&#39; import &#39;tinymce/themes/silver&#39; 注册组件 &lt;Editor&gt;&lt;/Editor&gt; //js components: {Editor} 初始化配置 &lt;Editor :init=&quot;init&quot;&gt;&lt;/Editor&gt; data() { return { init:{ //语言 language_url: &#39;/static/tinymce/zh_CN.js&#39;, language: &#39;zh_CN&#39;, //skin路径 skin_url: &#39;/static/tinymce/skins/ui/oxide&#39;, } } }, mounted () { tinymce.init({}) }, 初始化配置之后最基本的符文就有了，接下来丰富它的功能 数据同步 //子组件 &lt;Editor v-model=&quot;myValue&quot;&gt;&lt;/Editor&gt; data() { return { myValue: this.value } }, props: { value: { default: &#39;&#39;, type: String }, } watch: { value(newValue) { this.myValue = newValue }, myValue(newValue) { this.$emit(&#39;input&#39;, newValue) } }, //父组件 onEditorUploadSuccess为图片上传成功的回调 &lt;editor v-model=&quot;value&quot; @on-upload-success=&quot;onEditorUploadSuccess&quot; &gt;&lt;/editor&gt; 完整代码 &lt;template&gt; &lt;div&gt; &lt;Editor :init=&quot;init&quot; v-model=&quot;myValue&quot;&gt;&lt;/Editor&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; //这个是接口文件 import {ImgUpload} from &#39;@/api/notice&#39; //初始化tinymce import tinymce from &#39;tinymce/tinymce&#39; import Editor from &#39;@tinymce/tinymce-vue&#39; //引入主题 import &#39;tinymce/themes/silver&#39; /* 引入插件 */ import &#39;tinymce/plugins/image&#39; import &#39;tinymce/plugins/table&#39; import &#39;tinymce/plugins/preview&#39; import &#39;tinymce/plugins/fullscreen&#39; import &#39;tinymce/plugins/link&#39; import &#39;tinymce/plugins/code&#39; import &#39;tinymce/plugins/lists&#39; import &#39;tinymce/plugins/hr&#39; import &#39;tinymce/plugins/advlist&#39; import &#39;tinymce/plugins/paste&#39; import &#39;tinymce/plugins/importcss&#39; import &#39;tinymce/plugins/media&#39; export default { data() { return { myValue: this.value, init:{ //语言 language_url: &#39;/static/tinymce/zh_CN.js&#39;, language: &#39;zh_CN&#39;, //设置皮肤 skin_url: &#39;/static/tinymce/skins/ui/oxide&#39;, //高度 height: 400, //菜单栏 menubar: false, //隐藏商标 // branding: false, //工具栏|分类 配置插件 toolbar: `styleselect | fontselect | formatselect | fontsizeselect | forecolor backcolor | bold italic underline strikethrough | image | table | alignleft aligncenter alignright alignjustify | outdent indent | numlist bullist | preview removeformat hr | code link | undo redo | fullscreen `, //自动聚焦 auto_focus: true, //引入插件 plugins: ` paste importcss image code table advlist fullscreen link media lists hr preview`, //图片标题 image_caption: true, //上传本地图片 image_uploadtab:true, // Image imagetools_toolbar: &#39;rotateleft rotateright | flipv fliph | editimage imageoptions&#39;, // 设置Tab // tabfocus_elements: &#39;:prev,:next&#39;, // object_resizing: true, //设置可选段落样式 style_formats: [ { title: &#39;首行缩进&#39;, block: &#39;p&#39;, styles: { &#39;text-indent&#39;: &#39;2em&#39; } }, { title: &#39;行高&#39;, items: [ { title: &#39;1&#39;, styles: { &#39;line-height&#39;: &#39;1&#39; }, inline: &#39;span&#39; }, { title: &#39;1.5&#39;, styles: { &#39;line-height&#39;: &#39;1.5&#39; }, inline: &#39;span&#39; }, { title: &#39;2&#39;, styles: { &#39;line-height&#39;: &#39;2&#39; }, inline: &#39;span&#39; }, { title: &#39;2.5&#39;, styles: { &#39;line-height&#39;: &#39;2.5&#39; }, inline: &#39;span&#39; }, { title: &#39;3&#39;, styles: { &#39;line-height&#39;: &#39;3&#39; }, inline: &#39;span&#39; } ] } ], //字体列表 font_formats: ` 微软雅黑=微软雅黑; 宋体=宋体; 黑体=黑体; 仿宋=仿宋; 楷体=楷体; 隶书=隶书; 幼圆=幼圆; Andale Mono=andale mono,times; Arial=arial, helvetica, sans-serif; Arial Black=arial black, avant garde; Book Antiqua=book antiqua,palatino; Comic Sans MS=comic sans ms,sans-serif; Courier New=courier new,courier; Georgia=georgia,palatino; Helvetica=helvetica; Impact=impact,chicago; Symbol=symbol; Tahoma=tahoma,arial,helvetica,sans-serif; Terminal=terminal,monaco; Times New Roman=times new roman,times; Trebuchet MS=trebuchet ms,geneva; Verdana=verdana,geneva; Webdings=webdings; Wingdings=wingdings,zapf dingbats`, //内容样式, 在最后呈现的页面也要写入这个基本样式保证前后一致 content_style: ` * { padding:0; margin:0; } html, body { height:100%; } img { max-width:100%; display:block;height:auto; } a { text-decoration: none; } iframe { width: 100%; } p { line-height:1.6; margin: 0px; font-family:&quot;宋体&quot;; } table { word-wrap:break-word; word-break:break-all; max-width:100%; border:none; border-color:#999; } .mce-object-iframe { width:100%; box-sizing:border-box; margin:0; padding:0; } ul,ol { list-style-position:inside; } `, insert_button_items: &#39;image link | inserttable&#39;, //回车添加的标签 forced_root_block:&quot;p&quot;, //强制每行添加&lt;p&gt;标签 force_p_newlines: true, importcss_append: true, //字体大小栏选项 fontsize_formats: &#39;10px 11px 12px 14px 16px 18px 20px 24px&#39;, // paste设置 paste_data_images: true,//可以粘贴图片 paste_word_valid_elements: &#39;*[*]&#39;,//word过滤 paste_retain_style_properties:&#39;all&#39;, //允许保留word粘贴过来的格式 paste_convert_word_fake_lists: false,//禁止word的列表内容转换html的ul和ol格式 paste_merge_formats: true,//合并相似格式 nonbreaking_force_tab: false, paste_auto_cleanup_on_paste: false, statusbar: false, // 隐藏编辑器底部的状态栏 images_upload_handler: this.uploadImg//图片上传 }, } }, props: { //图片最大大小 maxSize: { default: 2097152, type: Number }, //图片可接收类型 accept: { default: &#39;image/jpeg, image/png, image/jpg, image/svg, image/gif&#39;, type: String }, //上传地址 url: { default: &#39;&#39;, type: String }, //数据 value: { default: &#39;&#39;, type: String }, }, methods: { //上传图片 uploadImg(blobInfo, success, failure) { const that = this //符合大小 if (blobInfo.blob().size &gt; this.maxSize) { failure(&#39;文件体积过大&#39;); } //符合类型 if (this.accept.indexOf(blobInfo.blob().type) &gt; -1) { let form = new FormData(); form.append(&#39;file&#39;, blobInfo.blob(), blobInfo.filename()); ImgUpload(form).then(res=&gt;{ //给父组件传值 that.$emit(&#39;on-upload-success&#39;, { res, success, failure }) }).catch(err =&gt; { failure(&#39;上传失败: &#39; + err); }) } else failure(&#39;图片格式错误&#39;); }, }, watch: { value(newValue) { this.myValue = newValue }, myValue(newValue) { this.$emit(&#39;input&#39;, newValue) } }, components: {Editor}, mounted () { tinymce.init({}) }, } &lt;/script&gt; &lt;!--scoped 样式仅仅在当前组件使用--&gt; &lt;style scoped&gt; &lt;/style&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>库</category>
      </categories>
      <tags>
        <tag>富文本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件超市项目后台管理界面开发流程3]]></title>
    <url>%2F2020%2F02%2F06%2F%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82%E9%A1%B9%E7%9B%AE%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B3%2F</url>
    <content type="text"><![CDATA[vue全局配置项目有很多重复用到的变量和方法，新建一个global/index.js来存放。具体的实现是通过在Vue的原型上添加方法和属性，也就是使用Vue.prototype，最后要在main.js引入文件`import “./global”; Messsage.vue一级导航用于显示消息通知,里面包含了两个组件，一个用于分页的ProjectPagination，一个是用于消息提醒的MessageRemind。这里实现了流程1提到的:如果有未读消息，进入管理页面后直接显示消息通知，如果没有未读消息，则显示第一个路由。 //登陆之后是先跳转到message，此时的pageEnterStatetrue=true。 if (this.pageEnterState) { //如果没有消息就跳到第一个路由 if (this.msgLen === 0) { const route = this.$store.getters.addRouter; this.$router.push(route[0].path); } else { //如果有消息就显示，tableData就是登陆时传给state的消息 this.data = this.tableData; this.isLoading = false; } this.$store.commit(&quot;SET_PAGE_ENTER_STATE&quot;, false); } else { this.loadData(); } } 分页ProjectPagination结合element-ui的pagination加上一些修改。前一篇博客中提到了父组件向子组件传值的方法，这里同时也用到了子组件向父组件传值的方法 &lt;!-- 分页器 --&gt; &lt;template&gt; &lt;el-pagination class=&quot;x-page&quot; layout=&quot;total,sizes, prev, pager, next, jumper&quot; @current-change=&quot;handleCurrentChange&quot; @size-change=&quot;handleSizeChange&quot; :current-page.sync=&quot;currentPage&quot; :page-sizes=&quot;pageSizes&quot; :page-size=&quot;pageSize&quot; :total=&quot;total&quot;&gt;&lt;/el-pagination&gt; &lt;/template&gt; &lt;script&gt; export default { name: &quot;ProjectPagination&quot;, //接收父组件传来的值 props: { //data为所有数据 data: Array, //filterData做为一个筛选容器 filterData: Array }, data() { return { //当前页数 currentPage: 1, //默认的一页显示条数 pageBase: 10 }; }, computed: { // 数据总数目 total() { return this.data.length; }, // 一页有多少条数据 pageSize() { //如果基础数据大于总数，则显示总数 let size = this.total &gt;= this.pageBase ? this.pageBase : this.total; return size; }, // 提供每页条数的选择，返回值为一个数组 pageSizes() { let count = Math.ceil(this.total / this.pageSize); let sizes = []; for (let i = 1; i &lt;= count; i++) { sizes.push(this.pageSize * i); } return sizes; } }, methods: { //pageSize改变执行，回调参数:每页条数 handleSizeChange(val) { // 获取项目条数 //子组件像父组件传值，更新filterData。 this.$emit(&quot;update:filterData&quot;, this.data.slice(0, val)); }, // 页面页数改变 handleCurrentChange(val) { // 获取下一页数据 this.$emit( &quot;update:filterData&quot;, this.data.slice((val - 1) * this.pageSize, val * this.pageSize) ); } }, created() { //发送一个update:filterData，显示pageSize个数据 this.$emit(&quot;update:filterData&quot;, this.data.slice(0, this.pageSize)); }, watch: { // 监控数据变化时获取数据 data() { this.$emit(&quot;update:filterData&quot;, this.data.slice(0, this.pageSize)); } }, //路由要求刷新 activated() { if (this.$route.meta.isRefresh) { this.currentPage = 1; } } }; &lt;/script&gt; &lt;style scoped&gt; .x-page { margin-top: 10px; float: right; } &lt;/style&gt; $emit(update: prop, “newPropVulue”)$emit(update: prop, “newPropVulue”) 这个模式，使子组件向父组件传达：更新属性，并抛出新的属性值。 从上述代码中可以看出首先更新的值要是从父组件中接收的，也就是props里面的值。其次父组件该值需要写成 &lt;ProjectPagination :data=&quot;data&quot; :filter-data=&quot;filterData&quot; @update:filter-data=&quot;filterData=$event&quot;&gt;&lt;/ProjectPagination&gt; 更简单的写法是.sync修饰符 &lt;ProjectPagination :filter-data=&quot;filterData&quot; :filter-data.sync=&quot;filterData&quot;&gt;&lt;/ProjectPagination&gt; 注意:这里有一个Vue.sync修饰符与$emit(update:xxx)写法的坑使用.sync修饰符 //有效 this.$emit(&quot;update:filterData&quot;, this.data.slice(0, val)); //无效 this.$emit(&quot;update:filter-Data&quot;, this.data.slice(0, val)); 不使用.sync修饰符 //无效 this.$emit(&quot;update:filterData&quot;, this.data.slice(0, val)); //有效 this.$emit(&quot;update:filter-Data&quot;, this.data.slice(0, val)); MessageRemind消息提醒的MessageRemind使用了element-ui的消息提醒，这里最后的实现比较容易，但是在实现的过程中遇到了一个关于路由监控的坑。 路由监听失效：需要在父路由的组件内才可以监听到子路由的信息。 Notice.vue仅管理员拥有的组件。主要有左边的导航和中间显示部分组成。显示公告列表，增删改查等实现比较容易就没有记录下来。 这里记录一个文章显示的css，超出部分滚动，但不显示滚轮 .article{ height: 100%; overflow-x:hidden; overflow-y: scroll; } // -webkit-scrollbar css3新特性 .article::-webkit-scrollbar { display: none; } 框架 &lt;template&gt; &lt;div class=&quot;notice&quot;&gt; &lt;div class=&quot;nav&quot;&gt; &lt;el-menu default-active=&quot;publish&quot; class=&quot;el-menu-vertical-demo&quot; @select=&quot;handleSelect&quot; &gt; &lt;el-menu-item index=&quot;publish&quot; &gt; &lt;i class=&quot;el-icon-edit-outline&quot;&gt;&lt;/i&gt; &lt;span slot=&quot;title&quot;&gt;发布公告&lt;/span&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;allNotice&quot;&gt; &lt;i class=&quot;el-icon-document&quot;&gt;&lt;/i&gt; &lt;span slot=&quot;title&quot;&gt;所有公告&lt;/span&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;dustbin&quot;&gt; &lt;i class=&quot;el-icon-delete&quot;&gt;&lt;/i&gt; &lt;span slot=&quot;title&quot;&gt;回收站&lt;/span&gt; &lt;/el-menu-item&gt; &lt;/el-menu&gt; &lt;/div&gt; &lt;router-view class=&quot;view&quot;&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; handleSelect(key) { let path=&#39;/notice/&#39;+key; this.$router.push({path:path}) } 富文本tinymce默认显示的是发布公告,选用的是tinymce这款富文本。 学习笔记 项目问题1表单规则验证 &lt;el-form-item label=&quot;学/工号&quot; prop=&quot;captainInformation.studentId&quot; &gt; &lt;el-input v-model.number=&quot;form.captainInformation.studentId&quot; &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; data() { return { form:{ teamName:&quot;&quot;, captainInformation:{ name:&quot;&quot;, studentId:&quot;&quot;, }, }, rules: { teamName: [ { required: true, message: &#39;请输入团队名称&#39;, trigger: &#39;blur&#39; }, { min: 3, max: 10, message: &#39;长度在 3 到 10 个字符&#39;, trigger: &#39;blur&#39; } ], //这个位置注意一定要加引号 &quot;captainInformation.studentId&quot;: [ { required: true, message: &#39;请输入学号&#39;, trigger: &#39;blur&#39; }, {type: &#39;integer&#39;, message: &#39;格式错误&#39;, trigger: &#39;blur&#39;} ], } 问题二过滤器 后台传来的数据只有分数，未评分的分数为-1，这里需要将其显示成状态已完成或未评分，并且可以根据状态筛选数据。 &lt;el-table-column prop=&quot;score&quot; sortable label=&quot;状态&quot; :filters=&quot;tags&quot; :filter-method=&quot;filterTag&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-tag disable-transitions style=&quot;font-size:12px&quot; :type=&quot;stateColor(scope.row.score)&quot;&gt;{{scope.row.score| filterState}}&lt;/el-tag&gt; &lt;/template&gt; &lt;/el-table-column&gt; //js //筛选标签 filterTag(value, row) { if (value === -1) { return row.score === -1; } else { return row.score &gt;= value; } }, //过滤器 filters: { filterState(val) { return val === -1 ? &quot;未评分&quot; : &quot;已完成&quot;; } }, 问题三返回刷新问题从详情返回列表，列表不需要刷新，而从其他页面进入列表，列表需要刷新。首先需要了解两个生命周期： // 数据缓存 beforeRouteEnter(to, from, next) { //如果不是从teamDetail来的界面需要刷新 if (![&quot;teamDetail&quot;].includes(from.name)) { to.meta.isRefresh = true; } next() }, activated() { //需要刷新的界面 if (this.$route.meta.isRefresh) { // 先重置 this.$route.meta.isRefresh = false; //重新获取数据 this.isLoading = true; this.getLoadData(); } }, 后面重复的操作比较多，多为增删查改，重复的东西将不在记录了。有关于vue我不熟悉的知识点，会重新学习了解之后更新博客。]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>软件超市</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件超市项目后台管理界面开发流程2]]></title>
    <url>%2F2020%2F01%2F31%2F%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82%E9%A1%B9%E7%9B%AE%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B2%2F</url>
    <content type="text"><![CDATA[设置权限时动态加载路由 路由分为两类，一类是静态路由（不需要登陆验证），一类是动态路由（需要登陆验证） 当用户登陆后，获取用role（权限），将role和路由表每个页面的需要的权限作比较，生成用户可访问的路由表 调用router.addRoutes(store.getters.addRouters)添加用户可访问的路由。 使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。 permission.js首先新建store/permission.js，用来控制生成的路由表。 //是否有权限访问，role为当前权限 function hasPermission(role, route) { if (route.meta &amp;&amp; route.meta.roles) { //如果该路由的meta存在，并且有要求权限 const roles = route.meta.roles; //如果路由要求的权限有当前权限，返回成功 return roles.includes(role); } else { //如果不存在说明不需要权限 return true; } } const permission ={ state: { //默认路由 routers: constantRouterMap, //添加的路由 addRouters: [] }, mutations: { SET_ROUTERS: (state, routers) =&gt; { //往数组中添加符合条件的路由 state.addRouters = routers; //符合权限的路由变成默认路由可访问。 state.routers = constantRouterMap.concat(routers); } }, actions: { //定义产生路由的方法 async GenerateRoutes({ commit }, { role }) { //返回符合权限的异步路由 const accessedRouters = await asyncRouterMap.filter(route =&gt; hasPermission(role, route) ); commit(&quot;SET_ROUTERS&quot;, accessedRouters); return accessedRouters; } } } export default permission; 这里可以把permission.js看成一个模块，因为它拥有自己的state,mutation,action。所以还需要把permission挂载在vuex里。 export default new Vuex.Store({ modules:{ permission }, state, actions, mutations, getters }); 问题一addRoutes在哪里调用登录后，获取用户的权限信息，然后筛选有权限访问的路由，再调用addRoutes添加路由。这个方法是可行的。但是不可能每次进入应用都需要登录，用户刷新浏览器又要登陆一次。所以addRoutes还是要在全局路由守卫里进行调用。 if(token){ //已经登陆了 if (to.path ===&quot;/login&quot;) next({path:&quot;/&quot;}) // else{ if (!store.getters.role){ //如果没有当前权限信息,role仅getUserInfor后可以获得 //用户登陆之后，根据缓存获取登陆信息 store.dispatch(&quot;getUserInfor&quot;).then(role=&gt;{ //产生符合权限路由的方法 store.dispatch(&quot;GenerateRoutes&quot;, { role }) .then( data =&gt; { // 生成可访问的路由表 router.addRoutes(data); next({ ...to, replace: true }); }) ..... } } } 问题一 next()的使用 首先调用next()时会直接进入to路由，不会再调用beforeEach(),所以刷新页面可能会进入无限循环，调用next(‘xxx’)后会拦截路由使得路由重定向xxx，并再次调用beforeEach()。 如果把replace设置为true，那么导航不会留下history记录，点击浏览器回退按钮不会再回到这个路由。router.addRoutes之后的next()可能会失效，因为可能next()的时候路由并没有完全add完成，next({…to}) 的时候重新指定以下刷新前的路径。 问题二 404页面404路由写在动态路由中，否则可能会有闪屏和路由为空时加载的404页面。原因是：当页面刷新，会导致vue重新实例化，路由也恢复了初始路,addRoutes 还没有添加上路由就开始跳转， 所以找不到路由就跳转到404页面了。 Layout页面Layout作为整个后台管理页面的框架，主要有Header、根据权限生成的Sidebar和中间的显示界面组成。 框架//Layout组件 &lt;div id=&quot;manage&quot;&gt; &lt;Header&gt;&lt;/Header&gt; &lt;div class=&quot;container&quot;&gt; &lt;Sidebar&gt;&lt;/Sidebar&gt; &lt;router-view class=&quot;content&quot; &gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; 通过把一级路由与二级路由的path设置成同一个，来同时加载Header组件、Sidebar组件和中间对应的显示界面 //仅用其中一个举列子 const project ={ path: { path: &quot;/projectManage&quot;, name: &quot;projectManage&quot;, component: Layout }, check: [ { path: &quot;check&quot;, name: &quot;projectCheck&quot;, component: () =&gt; import( /* webpackChunkName: &quot;ProjectCheck&quot; */ &quot;../views/projectManage/components/ProjectCheck&quot; ) }, ], } export const asyncRouterMap = [ { ...project.path, children: [ { path: project.path.path, redirect: &quot;/projectManage/check&quot;, component: () =&gt; import(/* webpackChunkName: &quot;ProjectDeveloper&quot; */ &quot;../views/projectManage/ProjectDeveloper&quot;), children: [...project.check] },] } ] 注意:这里有个简单的重定向问题我晕了好久QAQ 首先是path加/和不加/有什么区别。/xx就是根路径。下面代码去到children是/#/child而不是/#/fa/child。而不以斜杠开头的，都会被当成普通的字符串拼到当前路径的后面。 path: /fa children: { path: /child } 然后这里重新定向之后projectManage/check路由到底算几级路由？通过把redirect注释之后终于弄懂了。这里是因为children控制的是第几个router-view,第一个children控制的是第二个router-view，即使它重定向/projectManage/check,第二个router-view显示的还是ProjectDeveloper组件。 Siderbar导航图标上显示未读消息数量 主要实现是使用element-ui里面的badge组件+父子间传值实现的。这里以导航图标上显示未读消息数量为例子，后续类似操作将不做记录。 新建一个MessageNue.vue记录未处理的消息数量，作为子组件，接收父组件传来的值。这里接收两个值：customClass样式，因为这个组件会重复使用，并且不同消息显示的位置可能不同，所以关于定位的信息要单独接收。menu接收的是显示的哪一个消息。 &lt;template&gt; &lt;span class=&quot;badgebox&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;el-badge :value=&quot;getMsgN(menu)&quot; :style=&quot;customClass&quot; class=&quot;item&quot; :max=&quot;99&quot; :hidden=&quot;!getMsgN(menu)&quot;&gt;&lt;/el-badge&gt; &lt;/span&gt; &lt;/template&gt; &lt;script&gt; export default { name: &quot;MessageNum&quot;, props: { menu: Object, customClass: String }, methods: { getMsgN(menu) { return this.count[menu.path]; } }, computed: { count() { return this.$store.state.msgNum; } } }; &lt;/script&gt; //state.js //需要显示的消息数量 msgNum: { publishExamine: 0, delayExamine: 0, alterExamine: 0, undertakeExamine: 0, projectExamine: 0, porjectRun: 0, projectCheck: 0, projectFinish: 0, projectManage: 0 }, Sidebar.vue 作为父组件，把组件挂载好之后。menu值是传的动态值所以用v-bind:绑定，而customClass是一个静态值所以直接传值就行。 这里有一个命名的坑:props属性支持驼峰命名,不支持连接线命名。HTML特性是不区分大小写的，所以在HTML之中的驼峰写法要变成连接线写法。 &lt;message-num :menu=&quot;{path:router.name}&quot; custom-class=&quot;top:-12px;right:-12px&quot;&gt; &lt;i class=&quot;iconfont&quot; :class=&quot;&#39;icon-&#39;+router.meta.icon&quot;&gt;&lt;/i&gt; &lt;/message-num&gt; Header.vue主要功能有： 1.显示用户名，可退出2.如果身份是开发团队的队长，且同时有几个团队，显示当前团队，并可切换其他团队。3.点击logo的时候，可以操作侧边栏展开 ①下拉框用的是Element-ui的el-dropdown组件,下拉的时候出现退出键。 // @command=&quot;handleCommand&quot;为绑定下拉框点击事件，command为值 &lt;el-dropdown class=&quot;exit&quot; @command=&quot;handleCommand&quot; trigger=&quot;click&quot;&gt; &lt;span class=&quot;el-dropdown-link&quot;&gt; {{ username }} &lt;i class=&quot;el-icon-arrow-down el-icon--right&quot;&gt;&lt;/i&gt; &lt;/span&gt; &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt; &lt;el-dropdown-item command=&quot;exit&quot;&gt;退出&lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/el-dropdown&gt; // 退出登录或者切换用户管理界面 handleCommand(command) { console.log(command); if (command === &quot;exit&quot;) { //退出之后清除 this.exit(); }， exit() { // 退出清除缓存和登录 //登录成功之后重定向到登录页 this.$store.dispatch(&quot;Logout&quot;); } ②做第二个功能的时候，首先团队名称是通过axios获取的，并且刷新的时候还要在。所以应该把数据存在session中，同时要解决数据渲染的问题,采用了在state里面设置get和set的方法。 //state.js get teams() { let vlaue = sessionStorage.getItem(&quot;teams&quot;); return typeof vlaue === &quot;string&quot; ? JSON.parse(vlaue) : []; }, set teams(vlaue) { sessionStorage.setItem(&quot;teams&quot;, JSON.stringify(vlaue)); }, get teamId() { return sessionStorage.getItem(&quot;teamId&quot;); }, set teamId(vlaue) { sessionStorage.setItem(&quot;teamId&quot;, vlaue); }, 这里切换团队之后页面刷新用了上一篇博客提到的provide/inject组合刷新的办法。 ③第三个功能是兄弟Header和Sidebar组件的通讯，因为做这个项目主要是学习为主，所以选择了借助中央事件总线：在外部新建一个utils/eventBus.js文件。 //eventBus.js import Vue from &#39;vue&#39; export default new Vue(); //Header.vue import eventBus from &quot;../../utils/eventBus.js&quot;; extendNav() { //通过eventBus中央事件总线用$emit发送一个showNav事件 eventBus.$emit(&quot;showNav&quot;); } //Sidebar.vue mounted() { //通过eventBus中央事件总线用$on监听组件1中发送的showNav事件，第二个参数为回调函数。 eventBus.$on(&quot;showNav&quot;, this.change); }, 上述是最开始的做法，后面发现更简便的方法。主要是省略了外部的js文件，把总线放在main.js里的vue实例中 new Vue({ data:{ eventBus:new Vue() } }) 兄弟组件调用的时候,用this.$root.eventBus.$on代替eventBus.$on]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>软件超市</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件超市项目后台管理界面开发流程1]]></title>
    <url>%2F2020%2F01%2F29%2F%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82%E9%A1%B9%E7%9B%AE%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[3.3 组件编写3.3.1 Manage.vue 存放目录：src/views/Manage.vue 作用：作为Layout容器 详情：包含了Header组件与Sidebar组件 3.3.2 Login.vue 存放目录：src/views/login/Login 作用：登陆界面 详情：通过前台展示界面进入，进入时选择身份，ID的不同身份权限不一样。 具体实现 需要根据前台显示的页面获取信息： getStudentIdByRequest get请求获取登陆的学号ID getUserId?studentId= 通过登陆的studentId获取userId getRole?userId= 通过userId获取角色权限，通过不用的权限生成不同的导航栏。 getMessageByUserGet?userGet=userId 通过userId获取消息，如果有未读消息，进入管理页面后直接显示消息通知，如果没有未读消息，则显示第一个路由。 权限、登陆时效等相关（重要） 问题一：跨域问题由于vue-cli脚手架工具开发时，由于项目本身启动本地服务是需要占用一个端口的，所以必然会有跨域问题。解决办法：config/index（webpack构建下），更改开发环境下(在dev里配置)的proxyTable。将请求代理到目标域名 proxyTable: { &quot;/v1&quot;:{ target:&quot;http://software.sicau.edu.cn:8080&quot;, changeOrigin: true//是否开启代理 } }, 问题二：axios的cookie问题由于用的是学校的统一认证平台，采用的是cookie，在使用axios的时候，发现http响应头中少了Set-Cookie属性（axios隐藏了这部分）。解决办法：axios.defaults.withCredentials = true。withCredentials属性主要功能是指定跨域的请求是否应该使用证书（如cookie或授权头header） 问题三：vue组件刷新问题。（这个方法在添加删除之中比较好用，最后虽然没有采用但还是把记录下来）用vue-router重新路由到当前页面，页面是不进行刷新的。采用window.reload,或者router.go(0)刷新时，整个浏览器进行了重新加载，闪烁，体验感不好。解决办法：provide/inject组合provide：选项应该是一个对象或返回一个对象的函数。该对象包含可传递其子孙的属性。inject：一个字符串数组，或一个对象，对象的 key 是本地的绑定名 app.vue 中通过provide将父组件中的数据传给子组件 &lt;router-view v-if=&quot;isRouterAlive&quot;&gt;&lt;/router-view&gt; &lt;script&gt; export default { name: &quot;App&quot;, provide() { return { reload: this.reload } }, data() { return { isRouterAlive: true } }, methods: { reload() { this.isRouterAlive = false this.$nextTick( ()=&gt; this.isRouterAlive = true ) } } }; &lt;/script&gt; 在要使用的组件中inject:[‘reload’],调用this.reload()既可实现刷新。 问题4：错误捕获问题由于前端要根据返回的不同错误类型，进行不同的处理，在抛出问题时，不知道用async/await的错误如何捕获。解决办法：try catch只能捕获同步代码，不能捕获异步代码，在async函数内，使用await可以捕获异步代码，这里实际上是异步代码变成了同步代码。 在 async 函数内部使用 try catch 捕获异步错误 promise 内部使用 .catch 方法来捕获 promise 内部代码错误 async getRequest({commit,dispatch}){ try{ let resGetStudentIdByRequest = await getStudentIdByRequest(); if (resGetStudentIdByRequest.status==0){ ... } else throw resGetStudentIdByRequest.msg; }catch(err){ throw {err, msg: &quot;无效登录&quot;, code: 1 } } }, 问题5：token验证 ——————————————————待补充 之前的项目用的是session，偶然见看见一篇关于token的文章。https://blog.csdn.net/mydistance/article/details/84545768 点击进入管理界面时，先根据选择的不同身份，设置不同的不同的角色信息，在进加密。 进行路由拦截 //main.js router.beforeEach((to, from, next) =&gt; { let token = sessionStorage.getItem(&quot;token&quot;); if(token){...} else{ //如果没有token ,如果to.path在白名单中,则免登陆。如果不在白名单中，定向去登陆页面 (whiteList.includes(to.path)) == true ? next(): next(&quot;/login&quot;) } } 登陆时设置token //action.js //设置角色 async setRole({commit,dispatch},roleId){ //给身份加密 setRole(roleId); //设置token setToken(); }, //auth.js const verify = 45416289438485; //给角色权限加密 export const setRole = roleId =&gt; { let token = verify * roleId; sessionStorage.setItem(&quot;xxx&quot;, token); }; //设置登陆token export const setToken = () =&gt; { let token = randomString(32); sessionStorage.setItem(&quot;token&quot;, token); }; //产生随机数 function randomString(len) { len = len || 32; /****默认去掉了容易混淆的字符oOLl,9gq,Vv,Uu,I1****/ const $chars = &quot;ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678&quot;; const maxPos= $chars.length; let pwd = &quot;&quot;; for (let i = 0; i &lt; len; i++) { pwd += $chars.charAt(Math.floor(Math.random() * maxPos)); } return pwd; } 然后为了防止用户直接手动按f5刷新页面，这个时候会重新构建vue实例，而又没有重新登录，所以vuex里面的东西会清空，所以将登录后的数据存放在sessionStroage中，在刷新页面，重新构建vue实例的时候，会有判断。 问题6：button按钮添加回车事件最开始的写法，发现login方法根本没有执行，开始以为是@keyup.enter.native的问题，但是写在封装好的组件中的时候加.native才能监听原生的事件。后面发现是输入框事件，在button上面不起效果。 &lt;el-button @click=&quot;login&quot; @keyup.enter.native=&quot;login&quot; class=&quot;btn&quot; :loading=&quot;btnLoading&quot;&gt;进入管理页面&lt;/el-button&gt; 修改后，用了自定义指令的办法。 &lt;el-button @click=&quot;login&quot; v-enter=&quot;this&quot; class=&quot;btn&quot; :loading=&quot;btnLoading&quot;&gt;进入管理页面&lt;/el-button&gt; directives: { // 按enter键登录 enter(el, { value }) { document.onkeydown = e =&gt; { e = e || window.event; if (e.keyCode === 13) { value.login(); } }; } }, 问题7：封装好外部链接通过新建一个元素a，调用函数时点击a来实现外部跳转 const HOME_URL = &quot;主页&quot;; const LOGIN_URL = &quot;统一认证界面&quot;; //新建a export const goto = url =&gt; { const link = document.createElement(&quot;a&quot;); link.href = url; link.click(); }; goto.home = () =&gt; goto(HOME_URL); goto.login = () =&gt; goto(LOGIN_URL);]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>软件超市</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie、LocalStorage、sessionStorage的区别]]></title>
    <url>%2F2020%2F01%2F29%2FCookie%E3%80%81LocalStorage%E3%80%81sessionStorage%2F</url>
    <content type="text"><![CDATA[注意数组和对象要转化成JSON格式 主要区别 方法 localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等 setItem存储value sessionStorage.setItem(&quot;key&quot;, &quot;value&quot;); localStorage.setItem(&quot;key&quot;, &quot;value&quot;); getItem获取value let value = sessionStorage.getItem(&quot;key&quot;); let key = localStorage.getItem(&quot;key&quot;); removeItem删除key sessionStorage.removeItem(&quot;key&quot;); localStorage.removeItem(&quot;key&quot;); clear清除所有的key/value sessionStorage.clear(); localStorage.clear(); localStorage和sessionStorage的key和length属性实现遍历 let storage = window.localStorage; for(var i=0, len=storage.length; i&lt;len;i++){ var key = storage.key(i); var value = storage.getItem(key); console.log(key + &quot;=&quot; + value); }]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[note-双指针]]></title>
    <url>%2F2020%2F01%2F04%2Fnote-%E5%8F%8C%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[快慢指针快慢指针主要解决链表中的问题，比如判断链表是否有环、链表的交点，以及环的入口都是使用快慢指针。 由于链表不支持随机访问，因为如果要获取链表中间项或倒数第几项等特定元素就需要快慢指针。比如找链表中间项可以用两个指针，一个大步走(一次走两步)，一个小步走(一次走一步)，这样快指针走到头，慢指针刚好在中间。比如找链表倒数第二个结点，可以让快指针先走一步，慢指针再走，这样快指针走到头，慢指针刚好在倒数第二个。 141.环形链表 142.环形链表2 offer22.链表中倒数第k个节点 141.环形链表核心思想：如果不含环，跑的快的会先遇见null。如果含环，最终快慢指针会相遇。 public boolean hasCycle(ListNode head) { ListNode fast,slow; fast = slow = head; while(fast !=null &amp;&amp;fast.next != null){ fast = fast.next.next; slow = slow.next; if(fast == slow) return true; } return false; } 142.环形链表2,需要返回这个环的起点 核心思想：相遇之后一个节点指向头节点，两个节点每次只走一步，相遇处就是环的起点。 1.第一次相遇时：slow走了s步，fast走了2s步2.假设相遇点离环的起点距离为m3.fast比slow多走了 n 个环的长度，即 f = nb + s4.由1,3可得 s = nb f= 2nb5.假设f回到头节点，同时开始一步一步走，那么f走m到入口节点，s走了了nb+m也到了入口节点。所以第二次相遇点就是环的入口节点。 offer22.链表中倒数第k个节点核心思想：快指针先走k步，然后快慢指针同时开始走，当快指针走到链表尾null的时候，慢指针走到倒数第k个节点。 左右指针左右指针一般用在有序数组问题，实际是指两个索引值，一般初始化为left=0，right=nums.length-1。 二分查找 数组反转 滑动窗口 数组的反转 void reverse(int[] nums){ int left = 0; int right = nums.length-1; while(left&lt;right){ int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; left++; right--; } }]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[软件超市-返回刷新问题]]></title>
    <url>%2F2019%2F06%2F28%2F%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82-%E8%BF%94%E5%9B%9E%2F</url>
    <content type="text"><![CDATA[在对项目进行优化的时候，发现返回上一页的函数很多组件都会使用，于是打算把这个函数抽离出来。 在此之前需要先解决首页进入列表页面刷新，而详情页返回列表页面不刷新的问题的问题 方法一：keep-alive与vue-router配合使用实现在定义了两个字段 keepAlive:true 标识是否使用keep-alive组件字段,ifDoFresh:false标识是否刷新数据字符 /*------router/index-----*/ { path: &#39;/project&#39;, name:&#39;项目列表&#39; component:resolve =&gt; require([&quot;@/pages/Project/Project&quot;],resolve), meta: { keepAlive:true, ifDoFresh:false, showNav: true } }, 在根组件中根据keepAlive 字符判断是否使用keep-alive组件 /*------app.vue----*/ &lt;div class=&quot;main&quot;&gt; &lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;/&gt; &lt;/keep-alive&gt; &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;/&gt; &lt;/div&gt; 在目标列表页的beforeRouteEnter判断从哪个页面进入的，根据需求更改ifDoFresh变量。这里与activated联合用。 beforeRouteEnter(to,from,next){ //需要刷新的页面 if (from.name!=&quot;团队详情&quot;) { to.meta.ifDoFresh = true; } next() }, activated(){ if (this.$route.meta.ifDoFresh){ // 先重置 this.selected=0 this.$route.meta.ifDoFresh=false this.$store.dispatch(&#39;getTeam&#39;,{teamId:0}) } } 按逻辑来说这样就可以了，但是有个的问题出现了！！！！ 返回只显示一个团队了！！好气啊，不断调试中发现我团队详情的团队信息居然和我列表的团队信息存储在同一个变量里！！！！所以点进详情页后，改变了team，而keep-alive缓存的是team里的数据。我是白痴吗？？？？ 还有一个问题就是从列表到首页，在从首页到列表页，分页的缓存仍然存在。 解决办法：在分页器组件内提前判断（因为使用分页器组件时并没有传当前页码） activated(){ if (this.$route.meta.ifDoFresh) { this.currentPage = 1 } }, 方法二：keep-alive标签内部添加 keep-alive的总结]]></content>
      <categories>
        <category>questions</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>软件超市</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件超市-改变v-html内容的图片样式]]></title>
    <url>%2F2019%2F06%2F26%2F%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82-%E9%97%AE%E9%A2%98v-if%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在通过v-html把后台传过来的内容渲染到页面之后，发现后台传来的图片是限制了宽和高的。 通过查资料发现，这里解析是把v-html传来的数据作为了一个新的组件，所以在scoped下的style里面设置样式不起作用。那么根据原理，或许可以把scoped直接去掉，但是为了防止组件之间的样式污染，使用了其他办法。 方法一 &gt;&gt;&gt;(深度作用选择器) 或者 有些sass类的预处理器无法正确解析可以使用 /deep/ /*----html----*/ &lt;div class=&quot;announcement_img&quot; v-html=&quot;announcement.content&quot;&gt;&lt;/div&gt; /*----style----*/ .announcement_img&gt;&gt;&gt;img{ width: 100%; display: block; height: auto; } 方法二 updated周期函数中，js动态配置样式。 首先需要清楚updated周期函数在什么时候起作用，①data里面需要有该数据变量如arr ②在页面重新渲染arr完成后才进入updated。更深入的会在以后学习。 updated:function(){ console.log(&quot;1==我会先执行&quot;); this.$nextTick(function(){ //在下次 DOM 更新循环结束之后执行这个回调。在修改数据之后立即使用这个方法，获取更新后的DOM. console.log(&quot;3==我只能等页面渲染完了才会立即执行&quot;); }) console.log(&quot;2==我虽然在最后但会比$nextTick先执行&quot;) } 如果后期发现更好的或者更多的办法会重新更新。]]></content>
      <categories>
        <category>questions</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>软件超市</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown]]></title>
    <url>%2F2019%2F05%2F15%2Fmarkdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[写博客的时候有些不常用的语法会有遗漏，今天重新学习markdown常用语法并把记录下来。 综述 兼容HTML。不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。 用于瞄点测试 基本语法标题方法一： ``` # 第一级标题 `&lt;h1&gt;` ## 第二级标题 `&lt;h2&gt;` ### 第三级标题 `&lt;h3&gt;` #### 第二四级标题 `&lt;h4&gt;` ##### 第五级标题 `&lt;h5&gt;` ###### 第六级标题 `&lt;h6&gt;` ``` 方法二： 任何数量的 = 和 - 都可以有效果。 ``` 一级标题 = 二级标题 - ``` 字体如果* 和 _ 两边都有空白的话，它们就只会被当成普通的符号如果要在文字前后直接插入普通的星号或底线，可以用反斜线。 斜体 *内容*或者_内容_ （em）加粗 **内容**或者__内容__ （strong）倾斜加粗 ***内容***删除线 ~~内容~~ 链接行内式 ``` [我的博客](https://biubiuins.github.io/) 自动生成连接 &lt;https://biubiuins.github.io/&gt; ``` 效果：我的博客自动生成连接 https://biubiuins.github.io/ 添加图片形式和链接类似。 ``` 格式：![图片描述](url) ![GitHub set up](http://zh.mweb.im/asset/img/set-up-git.gif) ``` 效果： 分割线可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。 代码块 只要简单地缩进 4 个空格或是 1 个制表符就可以。 需要和普通段落之间存在空行！ `内容` 多行代码块与语法高亮：在需要高亮的代码块的前一行及后一行使用三个单反引号`包裹，就可以了。 代码块中包含html代码。在代码区块里面， &amp; 、&lt; 和 > 会自动转成 HTML 实体 引用 在被引用的文本前加上&gt;符号，以及一个空格就可以了，如果只输入了一个&gt;符号会产生一个空白的引用。 引用可以嵌套 引用的区块内也可以使用其他的Markdown 语法 列表符号后面一定要有一个空格，起到缩进的作用。还需要注意的是在使用列表时，只要是数字后面加上英文的点，就会无意间产生列表，比如2017.12.30 这时候想表达的是日期，有些软件把它被误认为是列表。解决方式：在每个点前面加上\就可以了。 无序列表使用 *，+，- 表示无序列表。 有序列表使用数字和一个英文句点表示有序列表。 表格姓名|分数 -|- 张三|50 李四|80 效果： 姓名 分数 张三 50 李四 80 表格对齐方式：我们可以指定表格单元格的对齐方式，冒号在左边表示左对齐，右边表示有对齐，两边都有表示居中。 姓名|分数 :-|-: 张三|50 李四|80 效果： 姓名 分数 张三 50 李四 80 反斜杠Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号 常用技巧换行方法1: 连续两个以上空格+回车方法2：使用html语言换行标签 其他特殊字符unicode字符编码 内容目录在段落中填写 [TOC] 以显示全文内容的目录结构，需要独占一行才能生效。 字体样式Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3。 &lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt; &lt;font color=gray size=5&gt;color=gray&lt;/font&gt; &lt;font color=#0099ff size=5 face=&quot;黑体&quot;&gt;color=#0099ff size=5 face=&quot;黑体&quot;&lt;/font&gt; 背景色需要借助 table, tr, td 等表格标签的 bgcolor 属性来实现背景色的功能。 &lt;table&gt;&lt;tr&gt;&lt;td bgcolor=pink&gt;背景色是：pink&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 效果： 背景色是：pink 瞄点自定义瞄点 标签形式的锚点目标的id特性值中是不能含有中文字符； //建立一个跳转链接 [说明文字](#jump) //需要跳转到的位置 &lt;span id = &quot;jump&quot;&gt;跳转到的位置&lt;/span&gt; 效果：瞄点 Markdown会自动给每一个h1~h6标题生成一个锚，其id就是标题内容。如表格 单选框- [ ] ranan - [x] ranan 效果: ranan ranan]]></content>
      <categories>
        <category>前端</category>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[element-ui总结]]></title>
    <url>%2F2019%2F04%2F19%2Felement-ui%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在一次项目中用到了element-ui框架，对在使用过程中遇见的问题进行总结（持续更新）。 表单1.数据为二级对象时数据为二级对象时，验证的数据要用字符串形式。 rules:{ &quot;captainInformation.name&quot;: [ { required: true, message: &#39;请输入姓名&#39;, trigger: &#39;blur&#39; }, ], } 2.动态添加的数据动态添加的输入框或表单绑定数据时注意 :prop=&quot;&#39;v-for绑定的数组.&#39; + index + &#39;.v-model绑定的变量&#39;&quot; 我是直接把验证写在标签里面的 &lt;el-form-item label=&quot;姓名&quot; :prop=&quot;&#39;memberInformation.&#39;+index+&#39;.name&#39;&quot; :rules=&quot;[ { required: true, message: &#39;请输入姓名&#39;, trigger: &#39;blur&#39; }]&quot;&gt; 增加与减少成员 //增加成员 addmember() { let newmember = { name: &quot;&quot;, studentId: &quot;&quot;, } this.form.memberInformation.push(newmember) }, //减少成员 reducemember(index) { this.form.memberInformation.splice(index, 1) }, 这个是我在项目中用到的办法，在阅读时发现了另一种情况的解决办法：https://blog.csdn.net/weixin_41041379/article/details/81908788 3.普通输入验证```js rules:{ data1:[ //必填，trigger是触发类型 { required: true, message: &#39;请输入学号&#39;, trigger: &#39;blur&#39; }, //数字类型 &#39;number&#39;, 整数: &#39;integer&#39;, 浮点数: &#39;float&#39; //使用整数的时候，首先要保证数据类型为数字，可以v-model.number绑定数据 {type: &#39;integer&#39;, message: &#39;格式错误&#39;, trigger: &#39;blur&#39;}, //长度限制 { min: 2, max: 4, message: &#39;长度在 2 到 4 个字符&#39;, trigger: &#39;blur&#39; } ] } ``` 4.手动验证 第一种是直接写在rules的里面 rules:{ data1:[ { validator:(rule,value,callback)=&gt;{ if(/^\d+$/.test(value) == false){ callback(new Error(&quot;只能输入数字&quot;)); }else{ callback(); } }, trigger: &#39;blur&#39; } } ] 第二种写法是抽离出来 //注意书写位置 data(){ let checkAge = (rule, value, callback) =&gt; { if (!value) { return callback(new Error(&#39;年龄不能为空&#39;)); } if (!Number.isInteger(value)) { callback(new Error(&#39;请输入数字值&#39;)); } else { if (value &lt; 18) { callback(new Error(&#39;必须年满18岁&#39;)); } else { callback(); } } } return { rules:{ age: [ { trigger: &#39;blur&#39;, validator: checkAge } ] } } 5.手动上传文件```html //html &lt;el-upload action ref=&quot;upload&quot; //覆盖默认的上传行为，自定义上传的实现 :http-request=&quot;finish&quot; //取消自动上传 :auto-upload=&quot;false&quot; &gt; &lt;el-button slot=&quot;trigger&quot; size=&quot;small&quot; type=&quot;primary&quot;&gt;选取文件&lt;/el-button&gt; &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;请上传您的项目功能清单&lt;/div&gt; &lt;/el-upload&gt; //js finish() { this.$refs.form.validate(valid =&gt; { // 验证成功 if (valid) { //这里的需求是必须上传文件 const file = this.$refs.upload.uploadFiles[0]; if (!file) { this.$message({ type: &quot;warning&quot;, message: &quot;请选择文件&quot; }); return; } //数据处理 let formData = new FormData(); formData.append(&quot;projectId&quot;, this.runId); formData.append(&quot;timeNode&quot;,JSON.stringify(this.form.timeNode)); formData.append(&quot;teamId&quot;, 1); formData.append(&quot;functionFile&quot;,file.raw ); //....中间的弹框确定等省略 submitApply(formData) } } } ``` 6.动态获取选项+模糊查询]]></content>
      <categories>
        <category>前端</category>
        <category>库</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
</search>
