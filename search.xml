<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python学习笔记]]></title>
    <url>%2F2020%2F07%2F31%2Fpython%2F</url>
    <content type="text"><![CDATA[基础Python是解释型语言，用途有Web应用、爬虫程序、科学计算、自动化运维、大数据、云计算、人工智能等。 补充:解释型语言:不会在执行前对代码进行编译，而是在执行的同时一边执行一边编译。 Python开发环境搭建开发环境搭建就是安装Python的解释器安装解释器的同时会安装python开发工具IDLE，在IDLE中可以通过TAB键来查看代码的提示。交互模式写一行执行一行，并不适用于我们日常的开发。 基本语言1.Python中严格区分大小写2.Python中的每一行就是一条语句，每条语句以换行结束3.Pyhton中每一行语句不要太长4.一条语句可以分多行编写，以\结尾5.Python是缩进严格的语言6.注释符#，习惯上注释符后跟一个空格 字面量和变量字面量表示的意思就是它的字面的值，在程序中可以直接使用，比如:1,2,’hello’变量可以用来保存字面量 Python中使用变量，不需要声明，直接变量赋值，但不能使用没有赋值的变量。Python是一个动态类型的语言，可以为变量赋任意类型的值。 数据类型数值Python数值分成了整数、浮点数、复数。在python中所有的整数都是int类型，如果数字的长度过大，可以使用下划线作为分隔符，比如123456可以写成123_456 其他进制的整数二进制0b 八进制0o 十六进制0x 在python中所有小数都是float类型，对浮点数进行运算时，可能得到一个不精确的结果。 字符串 大部分同JS类似。1.用三重引号来表示JS中的模板字符串。2.字符串不能和其他类型进行加法运算3.在创建字符串时，可以在字符串中指定占位符,%s在字符串中表示任意字符4.格式化字符串，可以通过在字符串引号外面添加f来创建一个格式化字符串,在格式化字符串中可以直接嵌入变量,该变量必须已经赋值。 # 表示用孙悟空替换%s b = &#39;Hello %s&#39;%&#39;孙悟空&#39; b = &#39;Hello %s 你好%s&#39;%(&#39;tom&#39;,&#39;孙悟空&#39;) # 还可以限制位数，不够就补空格 b = &#39;Hello %2s&#39;%&#39;孙悟空&#39; # 表示限制在3-5之间 b = &#39;Hello %3.5s&#39;%&#39;孙悟空&#39; # %f 浮点数占位符,会四舍五入 # %d 整数占位符，不会四舍五入 b = &#39;Hello %.5f&#39;%123.123 # 打印时 print(&quot;a=&quot;,a) print(&quot;a=%s&quot;%a) print(f&#39;a={a}&#39;) # 格式化字符串 c = f&#39;hello{a}&#39; 字符串的复制字符串和数字相乘，则解释器会将字符串重复指定的次数并返回。 a=&#39;abc&#39; a= a*2 print(a) abcabc 布尔值和空值 True表真，False表假，注意开头大写，布尔值实际上也属于整型，True相当于1，False相当于0。 None空值专门表示不存在]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue基础]]></title>
    <url>%2F2020%2F07%2F31%2Fvue%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[创建vue实例 //————html &lt;div id=&quot;app&quot;&gt; &lt;a href = &quot;msg&quot;&gt;&lt;/a&gt; &lt;button v-on:click=&quot;test&quot;&gt;test&lt;/button&gt; &lt;/div&gt; //——————js const vm =new Vue({ //配置对象:属性名是一些特定的名称 el:&quot;#app&quot; , //值是选择器 element 用来查找根元素 该根元素所覆盖的htlm+js为模板页面 data:{ //包含多个可变数据的对象,为模板页面提供数据 msg:&quot;xxx&quot; }, //data还可以是函数，一定要有返回值 //data(){return{}} methods:{ //包含n个事件回调函数 test(event){ event.target.innerHTML } } }) vm会自动拥有data中所有属性，页面中可以直接访问使用不用使用this数据代理:由vm对象来代理对data中所有属性的操作 问题1：js以什么形式存在 指令:vue自定义标签属性 例子:v-model 插值:动态显示数据，可以写表达式 例子: 知识点1:强制数据绑定v-bind: 为某个标签属性绑定动态data时，要在属性前面添加: 知识点2:绑定事件监听v-on: 简写@事件名=”回调函数” 也可以写成@事件名=”回调函数(参数)” methods里面常常放回调函数 Object.definePropertiy 该方法的存储器属性(setter,getter)可以实现简单的数据双向绑定 const p = { firstName:&quot;A&quot;, lastName:&quot;B&quot; //还可以在这直接写get/set //get fullName(){} } Object.defineProperty(p,&quot;fullName&quot;,{ //当读取属性值时自动调用(回调)，函数返回值作为属性值 get(){ //this是对象p return this.firstName +&#39;-&#39;+ this.lastName }, //当设置属性时自动调取,监视属性值的变化 set(value){ const names = value.split(&quot;-&quot;) this.firstName = names[0] this.lastName = name[1] } }) console.log(p.fullName); computed 计算属性，通过已有数据(依赖数据)计算动态产生一个要显示的结果数据，相当于使用了属性的get方法。执行的时机： 1.初始显示第一次执行，得到初始值显示 2.依赖数据发生改变就会再次调用。 注意：所有vue控制的回调函数的this都是vm或者组件对象。 computed：{ //计算属性的套路 filterPersons(){ //1.得到依赖的数据 const {searchName,persons} = this //2.进行计算处理，产生结果数据并返回 const newPersons = persons.filter(p =&gt; p.name.includes(searchName)) return newPersons } } 问题2:如果页面中需要fullName多次渲染，是否computed里的fullName函数会执行多次？ 答：不会执行多次，计算属性会先去缓存取，取不到在执行一次getter计算，计算的结果放入缓存。 问题3:用什么结构来缓存计算属性？用对象来缓存计算属性，对象的属性名永远是字符串。 getter和setter属性的set方法称为setter、属性的get方法称为getter,如果要自己设置get与set，那么该计算属性后面接对象。 computed：{ fulllName:{ get(){ return this.firstName +&#39;-&#39;+ this.lastName } set(value){ const names = value.split(&quot;-&quot;) this.firstName = names[0] this.lastName = name[1] } } } 总结1.只用getter，计算属性就是一个函数2.使用getter/setter，计算属性是一个包含geeter的setter的对象 watch监视 当监视的属性变化时自动调用，初始显示的时候不调用。 //用于监视vm的哪个属性的变化 watch:{ firstName(newValue,oldValue)=&gt;{ //当firstName发生改变时自动调用 } } 深度监视: class动态绑定/style动态绑定 动态绑定的class会和静态绑定的class合并。 //值为字符串 &lt;p :class=&quot;classA&quot;&gt; //动态绑定多个class &lt;p :class=&quot;{classA:true,classB:false}&quot;&gt; //hasA，hasB是data里面的变量，通常操作hasA，hasB变量的改变改变样式 &lt;p :class=&quot;{classA:hasA,classB:hsaB}&quot;&gt; //style的值为对象 &lt;p :style = &quot;{color:myColor,fontSize:mySize+&#39;px&#39;}&quot;&gt; 使用场景:值为字符串 –&gt; 类名不确定时使用值为对象 –&gt; 类名确定，不确定是否有该类的样式 重点:HTML不区分大小写，所以HTML之中用连接线写法，而Js之中用驼峰写法 条件渲染 v-if/v-else的标签二选一， v-show是通过改变标签的样式实现显示与隐藏的 v-for遍历 &lt;li v-for = &quot;(p,index) in persons&quot; :key=&quot;p.id&quot;&gt;&lt;/li&gt; data:{ persons:[] }, methods:{ updataP(index,newP){ //这种方法不会更新页面 //this.persons[index] = newP //这种方法可以更新页面 this.persons[index].name = newP.age this.persons.splice(index,1,newp) } } 问题4：vue的数据绑定如何实现1.vue会监视data中所有层次的属性2.对象中的属性数据通过添加set方法来实现监视3.数组中的元素也实现了监视data的数据,重写数组一系列更新元素的方法。首先调用原生对应的方法对元素进行处理，再更新界面。 重写的数组方法:push()、pop()、shift()、unshift()、splice()、sort()、reverse() 在定义数据时，可以考虑根据状态赋值，如数组排序，比如有不排序，升序，降序三种状态，可以考虑用一个数字来表示该状态 0-不排序、1-升序、2-降序 事件处理 1.绑定监听 当函数需要操作事件对象时，可以显示的传$event &lt;button @click=&quot;test(&#39;x&#39;,$event)&quot;&gt;&lt;/buuton&gt; 2.事件修饰符 阻止(prevent)事件的默认行为 / 停止(stop)事件冒泡 / once 只触发一次 &lt;button @click.prevent=&quot;test(&#39;x&#39;)&quot;&gt;&lt;/buuton&gt; 3.按键修饰符 @keyup.enter 表示回车按键起来时执行 还可以自定义按键修饰符 Vue.config.keyCodes.f1 = 112 //@key.f1=&quot;&quot;使用]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo遇见的坑]]></title>
    <url>%2F2020%2F07%2F30%2Fhexo%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[今天发现博客无法访问，报错是ERR_CONNECTION_REFUSED。开始慢慢寻找原因。 先重新上传了本地库，发现可以上传成功并且hexo s启动后本地可以访问。然后用手机流量可以访问博客。那么问题就到了PC端。ping了网址发现是127.0.0.1,检查了浏览器没开代理。通过朋友的帮助，在hosts文件中，添加185.199.111.153 biubiuins.github.io，让DNS在解析该域名时解析成前面的ip。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise]]></title>
    <url>%2F2020%2F07%2F28%2Fpromise%2F</url>
    <content type="text"><![CDATA[Promise预备知识1.函数对象与实例对象函数对象：将函数作为对象使用实例对象：new函数产生的对象 括号左边是函数，点左边是对象 function Fn(){ //Fn函数 } const fn = new Fn() //这里的Fn是构造函数，fn是实例对象（new返回的，简称对象） Fn.prototype //Fn本身是个函数，但是使用了XX.XXX(使用了.)，把该函数作为对象来使用，所以这里的Fn是函数对象 2.两种类型的回调函数/*-----------同步回调函数--------------*/ const arr = [1,3,5] arr.forEach(item =&gt;{ //遍历回调，同步回调函数，一上来就执行，不会放入队列 console.log(item) }) //forEach是一个函数，回调函数也是一个函数。说明该回调函数是同步回调函数，等完全执行完毕之后才执行最后一个打印语句 console.log(&quot;forEach()执行完毕之后&quot;) //输出 //1，3，5 forEach()执行完毕之后 /*-----------异步回调函数--------------*/ setTimeout(()=&gt;{//异步回调函数，会放入队列中将来执行 console.log(&quot;timeout callback()&quot;) },0) console.log(&quot;setTimeout()之后&quot;) //输出 //setTimeout()之后 timeout callback() 同步回调 理解：立即执行，完全执行完了才结束，不会放入回调队列中例子：数组遍历相关的回调函数 /promise的excutor函数 异步回调 理解：不会立即执行，会放入回调队列中来执行例子：定时器回调 /ajax回调 /promise的成功与失败的回调 3.error处理错误类型 Error:所有错误的父类型子类型(常见的)：ReferenceError: 引入错误，引用的变量不存在TypeError: 数据类型不正确的错误RangeError：数据值不在其所允许的范围内。SyntaxError：语法错误 错误处理 若没有捕获error，后续的代码是不会执行的捕获错误:try{}catch(error){}抛出错误:throw new Error(message) //抛出错误，自己定义错误 function something(){ if(Date.now()%2 ===1){ console.log(&quot;当前时间为奇数,可以执行任务&quot;) }else{ // throw new Error(里面为传出的message) 固定格式 throw new Error(&#39;当前时间为偶数，无法执行任务&#39;) } try{ something() } catch(error){ //error下面两个属性message与stack console.log(error.message)//错误相关信息 console.log(error.stack)//函数调用栈记录信息 } } Promise的理解和使用Promise是JS中进行异步编程的新的解决方案（旧的是纯回调的方式）从语法来说：Promise是一个构造函数从功能上说：Promise对象用来封装一个异步操作并可以获取其结果 Promise的状态 pending变为resolved（成功） pending变为rejected (失败) 说明：只有这两种变化，且一个Promise对象只能改变一次。无论是成功还是失败，都会有一个结果数据。成功的结果数据一般称为value，失败的结果数据一般称为reason //1.创建一个新的promise对象,里面传一个回调函数 const p = new Promise((resolve,reject)=&gt;{ //执行器函数excutor 同步回调 //2.执行异步操作,promise常用于封装异步函数。 setTimeout(()=&gt;{ const time = Date.now() //如果当前时间是偶数代表成功，否则代表失败 if(time%2 ==0){ //3.1 如果成功了，调用resolve(value) resolve(&quot;成功的数据,time=&quot;+time) }else{ //3.2 如果失败了，调用reject（reason） reject(&quot;成功的数据,time=&quot;+time) } },1000); }) p.then( value =&gt;{ //接收得到成功的value数据 onResolved console.log(&quot;成功的回调&quot;,value) }, reason =&gt; { //接收得到失败的reason数据 onRejected console.log(&quot;失败的回调&quot;,reason) } ) //输出 成功的回调 成功的数据,time=XXXX 优势 指定回调函数的方式更加灵活。旧的，必须在启动异步任务前指定回调函数;promise：启动异步任务 =&gt; 返回peomise对象 =&gt; 给promise对象绑定回调函数(甚至可以在异步执行之后才指定他的回调函数) 支持链式调用，可以解决回调地狱问题（回调函数嵌套调用，不便于阅读/不便于异常）。 几个关键问题 1.如何改变promise的状态？（1）resolve(value):如果当前是pending就会变为resolved（2）reject（reason）：如果当前是pending就会变为rejected（3）抛出异常(throw)：如果当前是pending就会变成rejected throw new Error(&quot;出错了&quot;) reason值是你抛出的东西 2.一个promise指定多个成功/失败的回调函数，都会调用吗？ 当promise改变为对应状态时都会调用 3.改变promise状态和指定回调函数谁先执行。 /*---------先指定回调函数后改状态------------*/ new Promise((resolve,reject)=&gt;{ setTimeout(()&gt;{ resolve(1)//后改变的状态，同时指定数据，异步执行回调函数 },1000); }).then(//先指定回调函数，保存当前指定的回调函数 value=&gt;{},reason=&gt;{} ) /*---------先改状态后指定回调函数------------*/ new Promise((resolve,reject)=&gt;{ //同步回调 resolve(1)//先改变的状态，同时指定数据 ); }).then(//异步回调 value=&gt;{},reason=&gt;{}//后指定回调函数，异步执行回调函数 ) 4.promise.then()返回的新的promise的结果状态由什么决定 then方法返回的结构也是promise，返回的promise的状态由then执行的回调函数结果决定。 回调函数中return的值是非promise类型的数据，则返回的promise的状态为成功，value为return值。若return的值是新promise，由返回的promise状态决定。 5.promise异常传透和中止 当使用promise的then链式调用时，可以在最后指定失败的回调，因为没有处理异常相当于 reason =&gt; {throw reason}，会一层一层往下寻找异常处理直到找到。 当使用promise的then链式调用时，若想中断promise链，可以return new Promise(()=&gt;{})返回一个处于pending的promise。 自定义promise链接：https://github.com/biubiuins/promise-/tree/master promise方法Promise.resolve()/reject() Promise.resolve()：该方法返回一个新的成功的promise，值为参数Promise.reject():该方法返回一个新的失败的promise，值为参数。 Promise.race() 返回一个新的promise，第一个完成的promise的结果就是最终返回的promise结果。 Promise.allSettled() 该方法接收promise数组，返回promise对象，该对象的状态永远为成功，该对象的值为一个数组，数组的元素为参数中每一个promise的当前值与当前状态。 Promise.all(iterable) 包含n个promise的数组(可迭代对象)，返回一个新的promise，所有promise都成功返回的新的promise状态才成功。成功则返回一个数组，里面包含参数中promise成功的返回值，顺序与参数顺序一致。失败则返回失败的原因。 async与await本质:Generator语法糖，async取代Generator函数的星号*.await取代的是yield ES7的async/await进一步的优化Promise的写法，async函数始终返回一个Promise，await可以实现一个”等待”的功能，async/await被称为异步编程的终极解决方案，即用同步的形式书写异步代码，并且能够更优雅的实现异步代码顺序执行。 1.async 函数async是’异步’的简写，用于申明这个函数是异步的。函数的返回值为Promise对象，promise对象的结果由async函数执行的返回值决定。 2.await 表达式await相当于then的语法糖。当await后面的表达式为promise，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，得到的结果就是promise成功的value。如果右侧表达不是promise，得到的结果就是它本身。 注意：1.await必须放在async函数里面2.await只能得到成功的结果，失败的结果需用try-catch3.try catch只能捕获同步代码，不能捕获异步代码，在async函数内，使用await可以捕获异步代码，这里实际上是异步代码变成了同步代码。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise链式调用顺序]]></title>
    <url>%2F2020%2F07%2F28%2Fpromise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[第一题 setTimeout(()=&gt;{ console.log(1); },0) Promise.resolve().then(()=&gt;{ console.log(2); }) Promise.resolve().then(()=&gt;{ console.log(3); }) console.log(4); /* 输出：4 2 3 1 */ 第二题 setTimeout(() =&gt; { console.log(1); }, 0) //Promise为构造函数 new Promise(resolve =&gt; { console.log(2); //同步执行 resolve()//成功 }).then(() =&gt; { //成功的回调 console.log(3); }).then(() =&gt; {//此处的then等上一个执行完之后再放入微队列执行 console.log(4); }) console.log(5);//同步执行 /* 输出:2 5 3 4 1 */ 注意：链式的then要等前一个then执行完毕才知道状态，才可以进入微队列执行。 第三题 //定义了一个返回promise的函数 const first = () =&gt; (new Promise((resolve, reject) =&gt; { console.log(1); //同步执行1 //返回promise的函数 let p = new Promise((resolve, reject) =&gt; { console.log(2); //同步执行2 //放入宏队列1 setTimeout(() =&gt; { console.log(3); resolve(4) //最后执行宏队列时状态已经修改，不再是等待，所以该行代码不执行 }, 0) resolve(5) //立刻执行，p的状态立刻成功 }) resolve(6) //first的状态变成成功 //成功的回调放入微队列1 p.then((arg) =&gt; { console.log(arg); }) })) //成功的回调放入为微队列2 first().then((arg)=&gt;{ console.log(arg); }) console.log(7);//同步执行3 /*输出 1 2 7 5 6 3 开始：输出 1 2 7 宏[3] 微[5 6] 输出微队列：5 6 输出宏队列：3 */ 第四题 //加入宏队列1 setTimeout(()=&gt;{ console.log(0); },0) new Promise((resolve,reject) =&gt;{ console.log(1); //同步执行1 resolve() //成功的回调加入微队列1 }).then(()=&gt;{ console.log(2); new Promise((resolve, reject) =&gt; { console.log(3); resolve() //成功的回调加入微队列3 }).then(()=&gt;{ console.log(4); //成功的回调加入微队列5 }).then(()=&gt;{ console.log(5); }) //成功的回调加入微队列4 }).then(()=&gt;{ console.log(6); }) new Promise((resolve, reject) =&gt; { console.log(7); // 同步执行2 resolve() //成功的回调加入微队列2 }).then(()=&gt;{ console.log(8); }) /* 输出：1 7 2 3 8 4 6 5 0 状态1：同步执行输出1 7 宏[0] 微[2 8] 状态2,执行微任务1（整个then）：输出2 3 宏[0] 微[8 4 6] 状态3,执行微任务2：输出 8 宏[0] 微[4 6] 状态4,执行微任务3：输出4 宏[0] 微[6 5] .... */ 这道题我错在6和5的顺序上面，不太懂为什么6在5前面。阅读了一篇文章之后才明白，下面是对知识点进行摘录+总结。 知识点1 当执行 then 方法时，如果前面的 promise 已经是 resolved 状态，则直接将回调放入微队列中。 then方法是同步执行的，但是then中的回调是异步执行的。 在同步执行then方法时，会进行判断： 如果前面的 promise 已经是 resolved 状态，则会立即将回调推入微队列 如果前面的 promise 是 pending 状态则会将回调存储在 promise 的内部(不会被执行，也不会被放入微队列中)，一直等到 promise 被 resolve 才将回调推入微队列 知识点2 resolve的作用除了将当前的 promise 由 pending 变为 resolved，还会遍历之前通过 then 给这个 promise 注册的所有回调，将它们依次放入微队列中，很多人以为是由 then 方法来触发它保存回调，而事实上是由 promise 的 resolve 来触发的，then 方法只负责注册回调。 对于 then 方法返回的 promise 它是没有 resolve 函数的，取而代之只要 then 中回调的代码执行完毕并获得同步返回值，这个 then 返回的 promise 就算被 resolve new Promise((resolve,reject) =&gt;{ console.log(1); resolve() //第一个then }.then(()=&gt;{ ... //第二个then }).then(()=&gt;{ ... }) 首先Promise是实例化，同步执行函数，打印1，执行resolve函数，将 promise 变为 resolved，但由于此时 then 方法还未执行。由知识点2：resolve会触发保存它的回调。then是同步的，所以会依次保存第一个then和第二个then [主]外部第一个 then，外部第二个 then [微] 空 然后执行第一then,由于前面的promise已经被resolve了，所以将第一then的回调放入微队列。 [主]外部第二个 then [微]外部第一个 then的回调 但是这个回调还没有执行，所以第一then返回的promise 仍为 pending 状态，所以同步执行第二个then。由于前面的 promise 是 pending 状态，所以外2then 的回调也不会被推入微任务队列也不会执行 [主]空 [微]外一 then的回调 现在主线程空了，执行微任务，也就外一 then的回调，首先打印出2，随后实例化内部promise，打印3，执行resolve函数,遍历then保存。 new Promise((resolve,reject) =&gt;{ .... //外1 }.then(()=&gt;{ console.log(2); new Promise((resolve, reject) =&gt;{ console.log(3); resolve() }.then(()=&gt;{ //内部第一个then console.log(4); }).then(()=&gt;{ //内部第二个then console.log(5); }) } //外2 .then(()=&gt;{ ..... }) [主]内1 then 内2的then [微]空 然后执行内1的then，由于前面的 promise 已被 resolve，所以将回调放入微任务队列中。 [主]内2的then [微]内1then的回调 然后执行内2的then，因为内部第一个then的回调还未执行所以状态为pending，所以内2then 的回调和外2then 的回调一样，不注册不执行。 [主]空 [微]内1then的回调 外1的回调全部执行完毕，这里尤其注意:内2then的回调没执行，但是内2then是执行了的，相当于回调执行完毕。外1then 返回的 promise 的状态由 pending 变为 resolved，同时遍历之前通过 then 给这个 promise 注册的所有回调，将它们的回调放入微任务队列中。 [主]空 [微]内1then的回调 外2then 的回调 主线程执行完毕，取出内1then的回调执行 [主]内1then的回调 [微]外2then 的回调 打印4，内1then返回的promise状态由 pending 变为 resolved，同时遍历之前通过 then 给这个 promise 注册的所有回调，将它们的回调放入微任务队列中。 [主] 空 [微]外2then 的回调 内2的回调]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js异步:宏队列与微队列]]></title>
    <url>%2F2020%2F07%2F28%2F%E5%AE%8F%E9%98%9F%E5%88%97%E4%B8%8E%E5%BE%AE%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[异步执行的函数(回调函数)放入队列中执行。队列分为宏队列与微队列。 宏队列：用来保存执行的宏任务（回调），比如：dom事件回调，ajax回调，定时器回调微队列：用来保存执行的微任务（回调），比如：promise回调，mutation回调 1.JS为单线程引擎，必须先执行所有的初始化同步任务代码。2.每次取出第一个宏任务执行前，都要将所有的微任务执行完毕。 注:取到栈里执行，若有嵌套的情况如下列代码，执行第一个setTimeout回调时，把里面的微任务放入微队列，执行第二宏任务前，先将所有的微任务执行完毕。 setTimeout(()=&gt;{ //会立即放入宏队列 console.log(&quot;timeout callback1()&quot;); Promise.resolve(3).then( value =&gt;{ //会立即放入微队列 console.log(&quot;Promise onResolved3()&quot;,value); } ) },0) setTimeout(()=&gt;{ //会立即放入宏队列 console.log(&quot;timeout callback2()&quot;); },0) Promise.resolve(1).then( value =&gt;{ //会立即放入微队列 console.log(&quot;Promise onResolved1()&quot;,value); } ) Promise.resolve(2).then( value =&gt;{ //会立即放入微队列 console.log(&quot;Promise onResolved2()&quot;,value); } ) /* 输出:Promise onResplved(),1 Promise onResplved(),2 timeout callback1() Promise onResolved3() timeout callback2() ) */]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组的方法]]></title>
    <url>%2F2020%2F07%2F27%2F%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[数组的方法slice()与splice()语法:array.slice(start,end)第一个参数截取开始的位置索引，包含第二个参数为结束的位置索引，不包含 不修改原数组 返回截取的新数组 语法:array.splice(start,length,increase1,increase2..)删除数组中的指定元素，并为数组添加新元素第一个参数是开始的索引第二个参数是删除的数量第三个参数及以后是新添加的元素，添加的位置在开始索引之前。 修改原数组 返回值为删除的元素，有添加的元素返回值是整个数组 concat()语法:array.concat(array2,array3..)concat()可以连接两个或多个数组 不修改原数组 返回值为新数组 join()语法:arrayy.join(连接符)join()将数组转换为一个字符串，默认逗号 不修改原数组 返回值为转换的字符串 reverse()语法:array.reverse()反转数组 修改元素组 sort()语法:array.sort()对数组中的元素进行排序,默认按照Unicode编码进行排序，默认升序 修改原数组 指定排序的规则,浏览器将会分别使用数组中的元素作为实参去调用回调函数，回调函数需要定义两个形参。浏览器根据回调函数的返回值来决定元素的顺序，返回值大于0则元素a、b交换位置,其余不变语法:array.sort(function(a,b){ //a一定在b前面,比如升序 return a&gt;b?1: 0 //return a-b 更简单}) 数组的扩展Array.from(v) 把v的伪数组(字符串也可)转换为真数组类数组(伪数组)最基本的要求就是具有length属性的对象,该类数组对象的属性名必须为数值型或字符串型的数字。 let arrayLike = { 0: &#39;tom&#39;, 1: &#39;65&#39;, 2: &#39;男&#39;, 3: [&#39;jane&#39;,&#39;john&#39;,&#39;Mary&#39;], &#39;length&#39;: 4 } let arr = Array.from(arrayLike) console.log(arr) // [&#39;tom&#39;,&#39;65&#39;,&#39;男&#39;,[&#39;jane&#39;,&#39;john&#39;,&#39;Mary&#39;]] Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。如下： let arr = [1,2,2,2,3,4,5] let set = new Set(arr) console.log(Array.from(set, item =&gt; item + 1)) // [2,3,4,5,6] Array.of(v1,v2,v3) 将v1，v2..等元素转换成数组 find() 找到第一个满足条件返回true的元素 let arr = [2,4,6] console.log(arr.find((value, index) =&gt; value &gt; 4)); //输出6 findIndex() 找到第一个满足条件返回true的元素下标 let arr = [2,4,6] console.log(arr.findIndex((value, index) =&gt; value &gt; 4)); //输出2 Array.prototype.includes(value) 字符串与数组都有includes方法，判断数组中是否包含指定的value，返回值为布尔值。以前判断用indexOf返回的是数字。 Array.prototype.indexOf(value)/lastIndexOf(value) 返回value在数组中出现的第一个下标和最后一下下标，没有出现则返回-1 应用场景：两个方法结合判断下标是否相等，可以用来判断数组中唯一出现的值 Array.prototype.flat()/flatMap() Array.prototype.flat()将多维数组转化为低维数组,从外层括号开始删，默认一次删一个，比如从三维到一维，需要删2个则flat()传参2 const arr = [1,2,3,4,[5,6,[7,8]]] console.log(arr.flat())//输出[1,2,3,4,5,6,[7,8]] Array.prototype.flatMap()类似map()。先执行map在执行flat，也就是先返回数组再降低维度。 数组的遍历Array.prototype.forEach()语法: array.forEach(function(currentValue, index, array){})调用数组的每个元素，并将元素传递给回调函数。第一个参数，当前遍历的元素。第二个参数，当前遍历的元素索引第三个元素，当前遍历的数组 特点 不返回新数组 不能中断 对空数组不执行回调 for-in/for-ofArray.prototype.map()语法: array.map(function(currentValue,index,arr), thisValue) 按照原始数组元素顺序依次处理元素，结果放在一个新数组里返回。 /*------从接口得到数据------*/ const users=res.items.map(item =&gt; ({ url: item.html_url, img: item.avatar_url, name: item.login, }) ); 特点 返回新数组，不改变原始数组。 for-of / for-infor-of不仅仅可以遍历数组，具有iterator接口的，都可以使用for-of进行遍历 for (var value of arr) { console.log(value); // 1,2,3 } 与for-in的区别：1.for-in 获取的是键名，数组的键名是索引，for-of获取的是键值2.for-in 会遍历对象的整个原型链,性能非常差不推荐使用。 Array.prototype.filter()语法：array.filter(function(currentValue,index,arr), thisValue) 创建一个新的数组，指定数组中符合条件的元素放入新数组。 返回一个新数组，按照约定条件筛选数组元素时比较常用 /*-----去重问题----*/ var arr = [1, 2, 2, 3, 4, 5, 5, 6, 7, 7,8,8,0,8,6,3,4,56,2]; var arr2 = arr.filter((x, index,self)=&gt;self.indexOf(x)===index) console.log(arr2); //[1, 2, 3, 4, 5, 6, 7, 8, 0, 56] every()/some()语法: array.every(function(currentValue,index,arr), thisValue) 对整个数组进行检查，如有一个元素不满足，整个表达式返回false，且其余元素不检查。否则返回true。 不会改变原数组 语法:array.some(function(currentValue,index,arr),thisValue) 对整个数组进行检查，如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。反之返回false。 不会改变原数组 这两个方法在实际开发中，大有可用之处。比如在判定用户是否勾选了不可操作的数据，或者是否勾选了一条可以操作的数据可以使用这两个方法遍历循环数组。 reduce()/reduceRight()语法:arr.reduce(callback,[initialValue]) callback （执行数组中每个值的函数，包含四个参数） previousValue 必选。上一次调用回调返回的值，或者是提供的初始值（initialValue） currentValue 必选。数组中当前被处理的元素 index 可选。当前元素在数组中的索引。 arr 可选。当前元素所属的数组对象。 initialValue （作为第一次调用 callback 的第一个参数。） 将数组元素做“叠加”处理，返回一个值。 reduce方向从左向右，reduceRight方向从右向左 var arr = [1, 2, 3, 4]; var sum = arr.reduce(function(prev, cur, index, arr) { console.log(prev, cur, index); return prev + cur; }) console.log(arr, sum); /*-----打印结果---*/ 1 2 1 3 3 2 6 4 3 [1, 2, 3, 4] 10 index是从1开始的，第一次的prev的值是数组的第一个值。数组长度是4，但是reduce函数循环3次。 var arr = [1, 2, 3, 4]; var sum = arr.reduce(function(prev, cur, index, arr) { console.log(prev, cur, index); return prev + cur; }，0) //注意这里设置了初始值 console.log(arr, sum); /*----打印结果----*/ 0 1 0 1 2 1 3 3 2 6 4 3 [1, 2, 3, 4] 10 这个例子index是从0开始的，第一次的prev的值是我们设置的初始值0，数组长度是4，reduce函数循环4次。 如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始 对空数组来说，不设置初始值会报错，设置了初始值不会报错，所以一般来说我们提供初始值通常更安全。 使用场景也很多，具体可以看 参考文档]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串的方法]]></title>
    <url>%2F2020%2F07%2F27%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[字符串的属性在底层字符串是以字符数组的形式保存的[“h”,”e”] charAt()语法：string.charAt()根据索引获取指定的字符，返回值为获取的字符 concat()语法:string.concat(str1，str2….)连接一个或多个字符串，返回值为新的字符串 indexof()语法:string.indexof(“x”,start)在string中寻找x的位置，找到返回索引，没找到返回-1第一个参数为查找的字符第二个参数为开始查找的位置indexof()是从前往后找lastindexof()是从后往前找 slice()/substring()语法:string.slice(start,end)第一个参数截取开始的位置索引，包含第二个参数为结束的位置索引，不包含 如果为-1值的是从后往前的第一个 不修改原字符串 返回截取的字符串 语法:string.substring(start,end) 与slice类似区别： substring不可以传递负值，传了默认为0 如果第二个参数小于第一个参数，会自动调整参数的位置 toUpperCase()/toLowerCase()语法：string.toUpperCase() 字符串转换成大写 不修改原字符串 返回转化的大写字符串 split()语法：string.split(“,”)/string.split(/[0-9]/)join()的功能相反,可以将一个字符串拆分为一个数组参数为拆分规则,如例子的根据字符串里的逗号拆分数组,参数可以是正则表达式 默认全拆不修改原字符串，返回值为数组 let str=&quot;1a2b3c4d5e6f&quot; let result = str.split(/[0-9]/) //输出[a,b,c,d,e,f] search()语法:string.search(搜索的内容)搜索字符串中是否含有指定内容,返回第一次(g失效)出现的索引或者-1参数是指定内容可以是正则表达式 match()语法:string.match(条件)根据正则表达式，从一个字符串中将符合条件的内容提取出来,返回值是数组 默认返回符合条件的第一个内容要找所有内容，开启全局匹配模式可以为一个正则表达式设置多个匹配模式，顺序无所谓 let str=&quot;1a2b3c4d5e6f&quot; let result = str.match(/[0-9]/g) //输出[1,2,3,4,5,6] replace()语法:string.search(被替换的内容，新的内容)可以将字符串中指定内容替换为新内容，被替换的内容可以是正则表达式。 默认只替换第一个不影响原来的字符串，返回新的字符串 可以使用它去空格 //会去掉全部的空格 str = str.replace(/\s/g,&quot;&quot;) //去掉开头的空格 str = str.replace(/^\s*/,&quot;&quot;) //去掉结尾的空格 str = str.replace(/\s*$/,&quot;&quot;) //去掉开头和结尾的空格 str = str.replace(/^\s*|\s*$/g,&quot;&quot;) 这里去掉字符串的头尾空格可以使用字符串的trim()方法 字符串的扩展属性string.includes(str) 判断是否包含指定的字符串返回值：包含true,不包含false string.startsWith(str) 判断是否以指定字符串开头返回值：是true,否false string.endsWith(str) 判断是否以指定字符串结尾返回值：是true,否false string.repeat(count) 指定目标字符串重复的次数返回值:重复后的字符串 string.trim()/string.trimStart()/string.trimEnd() trim()清除字符串左侧与右侧的空格trimStart()清除字符串左侧的空格trimEnd()清除字符串右侧的空格 String.prototype.matchAll() 实用 常用来获取正则批量匹配的结果，返回可迭代对象，可以用for of进行遍历或者扩展运算符展开。爬虫常用 let str = `&lt;ul&gt; &lt;li&gt; &lt;a&gt;ranan&lt;/a&gt; &lt;p&gt;喜欢粉色&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;a&gt;linin&lt;/a&gt; &lt;p&gt;喜欢白色&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; ` const reg = /&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\/a&gt;.*?&lt;p&gt;(.*?)&lt;\/p&gt;/sg const result = str.matchAll(reg) for (let v of result) { console.log(v); } //输出[exec匹配返回的结果1],[exec匹配返回的结果2]]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度克隆]]></title>
    <url>%2F2020%2F07%2F27%2F%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[深拷贝浅拷贝深浅拷贝只是针对引用数据类型。 浅拷贝：修改拷贝以后的数据会影响原数据，拷贝的引用。使得原数据不安全。深拷贝：修改拷贝以后的数据不会影响原数据，拷贝的时候生成新数据。 js的数据类型 基本数据类型： Undefined、Null、Boolean、Number、String和Symbol(ES6)引用数据类型： Object(Array, Date, RegExp, Function) 拷贝数据的方法1.引用类型直接赋值是浅拷贝2.Object.assign() let obj = { a: { a1: &#39;a1&#39; }, b: &#39;b&#39; } let ass = Object.assign({}, obj); ass.a.a1 = &#39;aaa&#39;; ass.b=&quot;c&quot; console.log(obj); /* 输出：a:{a1:&quot;aaa&quot;}, b:&quot;b&quot; */ 说明: Obejct.assign()只能对一层进行深拷贝,如果拷贝的层数超过了一层的话，那么就会进行浅拷贝。 这种克隆方式，只能克隆原始对象自身的值，不能克隆它的继承值。 function clone(origin) { return Object.assign({}, origin); } 如果要保持继承链。 function clone(origin) { //Object.getPrototypeOf方法返回指定对象的原型（内部[[Prototype]]属性的值） let originProto = Object.getPrototypeOf(origin); //Object.create方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。 return Object.assign(Object.create(originProto), origin); } 3.三点运算符对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。 let obj = { a: { a1: &#39;a1&#39; }, b: &#39;b&#39; } let ass = {...obj}; ass.a.a1 = &#39;aaa&#39;; ass.b = &#39;bbb&#39; console.log(obj); /* 输出：a:{a1:&quot;aaa&quot;}, b:&quot;b&quot; */ 说明:扩展运算符只能对一层进行深拷贝,如果拷贝的层数超过了一层的话，那么就会进行浅拷贝。 Object.assign(）和展开原算符对于深浅拷贝的结果是一样。 4.Array.prototype.concat() concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。 let arr= [1,3,{name:&#39;ran&#39;}] let arr2 = arr.concat() // arr2[1]=55 //输出[1，3，{name:&#39;ran&#39;}] arr2[3].name = &#39;ke&#39; console.log(arr); //输出 [1,3,{name:&#39;ke&#39;}] 遍历arr数组时得到arr数组的元素，把该元素赋值给arr2对应的位置，当遍历的元素是对象时，因为对象的赋值浅拷贝，所有会改变原来的值。 5.Array.prototype.slice(startindex,endindex) let arr= [1,3,{name:&#39;ran&#39;}] let arr2 = arr.slice() arr2[1]=55 arr2[2].name = &#39;ke&#39; console.log(arr); // 输出[1,3,{name:&#39;ke&#39;}] 因此，slice和concat这两个方法，仅适用于对不包含引用对象的一维数组的深拷贝 6.JSON.parse(JSON.stringify()) 深拷贝 JSON.stringify()：将JavaScript对象转换为JSON字符串JSON.parse()：可以将JSON字符串转为一个对象。 let arr= [1,3,{name:&#39;ran&#39;}] let arr2 = JSON.parse(JSON.stringify(arr)) //在JSON.stringify()完成后，对象就转为了字符串，也就可以说实实在在的复制了一个字符串，字符串是基本数据类型。 arr2[1]=55 arr2[2].name = &#39;ke&#39; console.log(arr);//输出[1,3,{name:&#39;ran&#39;}] 缺点：拷贝会忽略undefined,symbol,function、也有可能导致原型链缺失。 补充1 判断数组是否包含某对象，或者判断对象是否相等。 转化成字符串比较。 //判断数组是否包含某对象 let data = [ {name:&#39;echo&#39;}, {name:&#39;听风是风&#39;}, {name:&#39;天子笑&#39;}, ], val = {name:&#39;天子笑&#39;}; JSON.stringify(data).indexOf(JSON.stringify(val)) !== -1;//true //判断两数组/对象是否相等 let a = [1,2,3], b = [1,2,3]; JSON.stringify(a) === JSON.stringify(b);//true 补充2 localStorage/sessionStorage默认只能存储字符串，而实际开发中，我们往往需要存储的数据多为对象类型，那么这里我们就可以在存储时利用json.stringify()将对象转为字符串，而在取缓存时，只需配合json.parse()转回对象即可 补充3JSON.stringify()与toString()的区别，这两者虽然都可以将目标值转为字符串，但本质上还是有区别的。 let arr = [1,2,3]; JSON.stringify(arr);//&#39;[1,2,3]&#39; arr.toString();//1,2,3 JSON.stringify常用于对象，toString()常用于数组 参考文章 如何实现深拷贝？拷贝的数据里面不能有引用类型。如果有，只要拿到的是基本数据类型，然后再去赋值，就可以实现深拷贝 如何判断数据类型typeof返回的数据类型:String,Number,Boolean,Undefined,Object(Array,null也是),Function，不能准确的确定数据的类型。 Object.prototype.toString.call() Object.prototype.toString.call()可以区分各种类型，但它无法区分自定义对象类型，自定义类型可以采用instanceof区分。 console.log(Object.prototype.toString.call(&quot;jerry&quot;));//[object String] console.log(Object.prototype.toString.call(12));//[object Number] console.log(Object.prototype.toString.call(true));//[object Boolean] console.log(Object.prototype.toString.call(undefined));//[object Undefined] console.log(Object.prototype.toString.call(null));//[object Null] console.log(Object.prototype.toString.call({name: &quot;jerry&quot;}));//[object Object] console.log(Object.prototype.toString.call(function(){}));//[object Function] console.log(Object.prototype.toString.call([]));//[object Array] console.log(Object.prototype.toString.call(new Date));//[object Date] console.log(Object.prototype.toString.call(/\d/));//[object RegExp] function Person(){}; console.log(Object.prototype.toString.call(new Person));//[object Object] 那么为什么Object.prototype.toString.call()可以区分？ toString方法返回反映这个对象的字符串（除了null和undefined之外） console.log({name:&quot;张三&quot;}.toString());//[object Object] console.log([1,2].toString());//1,2 console.log(typeof [1,2].toString())//String obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？ 因为toString为Object的原型方法，而Array,function等类型作为Object的实例重写了toString方法，调用toString方法时，优先调用的是重写之后的toString方法，所以要使用Object原型上的toString才可以反映对象的具体类型。 获取标识类 Object.prototype.toString.call()返回的是字符串类型的[object xxx],但是我们只需要后面的标识数据类型的xxx，可以使用Array的slice方法。 let data = [1,3] //slice包含开始的位置，不包含结束的位置，结束位置为-1 console.log(Object.prototype.toString.call(data).slice(8,-1));//Array 最终实现//检测数据类型的功能函数 function checkedType(target) { return Object.prototype.toString.call(target).slice(8,-1) } //实现深度克隆 数组/对象 function clone(target) { let result,targetType=checkedType(target) switch (targetType) { case &#39;Object&#39;: result = {}; break; case &#39;Array&#39;: result = [] break; default: return target } //遍历，基本数据类型的赋值 for (let i in target){ //获取数据结构的每一项值 let value = target[i] //判断目标结构里的每一值是否存在对象/数组 if (checkedType(value) === &#39;Object&#39; || checkedType(value) === &#39;Array&#39;){ //继续遍历获取到的value result[i] = clone(value) }else { //获取到的value值是基本的数据类型或者函数 result[i] = value } } return result }]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象的方法]]></title>
    <url>%2F2020%2F07%2F27%2F%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[对象的扩展属性Obejct.setPrototypeOf/getPrototypeOf Obejct.setPrototypeOf(对象，对象的原型指向的元素)设置原型proto Object.getPrototypeOf(对象)获取指定对象的proto指向的值,没有返回null Object.is(v1,v2) 判断对象v1与v2是否完全相等。 console.log(0 === -0) //true console.log(NaN == NaN)//false NaN与任何数都不相等 console.log(Object.is(0,-0)) //false console.log(Object.is(NaN,NaN))//true 由上面代码可知该方式是以字符串是否相等来判断的 Object.assign(target,source1,source2..) 这个Object静态方法允许我们进行多个对象的合并，遍历需要合并给target的对象（仅可枚举属性），用等号进行赋值(这里可能有深浅拷贝的问题) 注意如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 const target = { a: 1, b: 1 }; const source1 = { b: 2, c: 2 }; const source2 = { c: 3 }; Object.assign(target, source1, source2); target // {a:1, b:2, c:3} 常见用途 1.关于拷贝的用法2.为属性指定默认值 ``` const DEFAULTS = { logLevel: 0, outputFormat: &#39;html&#39; }; //options对象是用户提供的参数。 function processContent(options) { options = Object.assign({}, DEFAULTS, options); console.log(options); // ... } ``` Object.keys(obj)获取对象所有的键名，返回数组 Object.values(obj)获取对象所有的值，返回数组 Object.entries(obj)返回数组[[键名，键值],[键名，键值]]，此方法可以用于创建Map对象。 const m = new Map(Object.entries(obj)) Object.fromEntries()用于创建一个对象，参数为二维数组或者Map Object.fromEntries([ [&quot;name&quot;,&quot;ranan&quot;], [&quot;like&quot;,&quot;pink&quot;,&quot;white&quot;] ]) //{name:&quot;ranan&quot;,like:&quot;pink,white&quot;} Object.entries(obj)/Object.fromEntries(二维数组)互为逆运算。 Object.create(prototype,[descriptors]) 作用：以指定对象为原型创建新的对象。为新的对象指定新的属性，并对属性进行描述 第一个参数指定原型，第二个参数为实例添加属性。 let obj = {name:&quot;ranan&quot;,age:2} //第一个参数指定原型，第二参数为实例添加属性 let obj1 = Object.create(obj,{sex:{ value:&quot;女&quot;,//value指定值 //属性的描述 writable:true,//标识当前属性是否可以被删除，默认为false configurable:true,//表示当前属性是否可以被删除，默认为false enumerable:true,//标识当前属性是否能用for-in枚举，默认false }}) //obj1的原型__proto__指向obj console.log(obj1); 克隆保持原型链 function clone(origin) { //Object.getPrototypeOf方法返回指定对象的原型（内部[[Prototype]]属性的值） let originProto = Object.getPrototypeOf(origin); //Object.create方法创建一个新对象，originProto为原型创建新对象 return Object.assign(Object.create(originProto, origin)); getOwnPropertyDescriptor/getOwnPropertyDescriptors就是获取内部属性的描述,可以用于深层次的克隆。 const obj = Object.create(null,{ //内部属性的描述 name:{ value:&#39;尚硅谷&#39;, //属性特性 writable:true, //修改 configurable:true //删除 enumerable:true //枚举 } }) 如果不指定configurable, writable, enumerable ，则这些属性默认值为false，如果不指定value, get, set，则这些属性默认值为undefined。 Object.defineProperties(object,descriptors) 作用:为指定的object对象扩展多个属性 一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 Object的defineProperty/defineProperties主要功能就是用来定义或修改这些内部属性。 语法: Object.defineProperty(obj, prop, descriptor) obj: 需要被操作的目标对象prop: 目标对象需要定义或修改的属性的名称descriptor: 将被定义或修改的属性的描述符 var obj = new Object(); Object.defineProperty(obj, &#39;name&#39;, { configurable: false, writable: true, enumerable: true, value: &#39;张三&#39; }) console.log(obj.name) //张三 语法: Object.defineProperties(obj, props) obj: 将要被添加属性或修改属性的对象props: 该对象的一个或多个键值对定义了将要为对象添加或修改的属性的具体配置 方法直接在一个对象上定义一个或多个新的属性或修改现有属性，并返回该对象。 var obj = new Object(); Object.defineProperties(obj, { name: { value: &#39;张三&#39;, configurable: false, writable: true, enumerable: true }, age: { value: 18, configurable: true } }) console.log(obj.name, obj.age) // 张三, 18 该方法的存储器属性(setter,getter)可以实现简单的数据双向绑定 &lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;input1&quot;&gt; &lt;div&gt; 上面输入的数据是 &lt;span id=&quot;span&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; let oInput1 = document.getElementById(&#39;input1&#39;); let oSpan = document.getElementById(&#39;span&#39;); let obj = {}; Object.defineProperties(obj, { //惰性求值，get之后才有值 val1: { configurable: true,//可修改 get: function() { oInput1.value = 0; oSpan.innerHTML = 0; return 0 }, set: function(newValue) { oSpan.innerHTML = newValue } }, }) //设置默认值为0 调用get方法 oInput1.value = obj.val1; oInput1.addEventListener(&#39;keyup&#39;, function() { //调用set方法 obj.val1 = oInput1.value; }, false) &lt;/script&gt; get/set propertyName(){}对象本身的两个方法，用法和上面的get/set一样 let obj = {firstName:&quot;xx&quot;,lastName:&quot;xx&quot;, get fullName(){ return this.firstName+ this.lastName }}]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[class类]]></title>
    <url>%2F2020%2F07%2F26%2Fclass%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[ES6的class可以看作只是一个语法糖，只是让对象原型的写法更加清晰，更像面向对象编程的语言。 //定义一个人物的类 class Person{ //类的构造方法,es5写在构造函数上的 constructor(){} //这里不需要逗号 //其余(原型)方法的写法必须使用该语法(静态的可以不用)。方法名(){} //es5写在原型上的 call(){ } } 构造方法名字不能修改且当new实例对象时，会自动执行。注意 类里面方法的写法。方法名(){} console.log(typeof Person);//function console.log(Person===Person.prototype.constructor);//true 从上面的代码可以看出类实质上就是一个函数，可以任务ES6的类就是构造函数的另外一种写法。实际上类的所有方法都定义在类的prototype属性上。constructor内的属性可以称为实例属性（和前面说的实例成员一样）,constructor外声明的属性都是定义在原型上的，可以称为原型属性（即定义在class上) 注意 class不存在变量提升，所以需要先定义再使用 static实例对象和函数对象的属性是独立的，实例对象的属性和该构造函数的原型上的属性是相通的。 实例对象和函数对象的独立属性称为静态成员/方法，只能函数对象使用。在ES6中，在方法/属性前加上static关键字，该类属性属于类不属于识类对象。 class Foo{ static classMethod() { return &#39;hello&#39;; } } //Foo.classMethod()使用 私有属性私有属性前面加#,私有属性类外部直接获取不到结果会报错，只能通过类里面使用。 class Person{ //公有属性 name; //私有属性 #age; constructor(name,age,weight){ this.name = name; this.#age = age ; this.#weight = weight; } } extends继承ES5的继承 function Father(name,age){ this.name = name; this.age = age; } Father.prototype.money= ()=&gt;{ console.log(&#39;父亲要上班&#39;); } function Son(name,age) { Father.call(this,name,age) } Son.prototype = new Father(); Son.prototype.constructor = Son ES6的extends继承 class Son extends Father{ //子类的构造方法 constructor(name,age,height){ // 调用父类的构造方法，这里也要注意参数 //父类的方法也会继承 super(name,age) //子类自己的方法 this.height = height; } } 子类继承父类相当于子类的proto指向父类Father。 get和setclass Phone{ get price(){ console.log(&quot;该属性被读取了&quot;) return &quot;属性调用的返回值&quot; } set price(newVal){ console.log(&quot;该属性被修改了&quot;) } } let s = new Phone() s.price s.price = &quot;free&quot;]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代器]]></title>
    <url>%2F2020%2F07%2F26%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署了iterator接口(对象里面的一个属性)，就可以用来完成遍历操作。 iterator接口是解构赋值，三点运算符，生成器，for-of循环的基础，主要供for-of消费。 默认具有iterator接口的数据结构有以下几个，注意普通对象默认是没有iterator接口的（可以自己创建iterator接口让普通对象也可以迭代） Array Map Set String TypedArray（类数组） 函数的 arguments 对象 NodeList 对象 工作原理:1.symbol.iterator对应的函数创建一个指针对象，指向数据结构的起始位置。2.第一次调用next方法，指针自动指向数据结构的第一个成员3.接下来不断调用next方法，直到指向最后一个成员4.每次调用next方法返回的是一个包含value和done的对象 注意：第一个next方法是symbol.iterator对应函数执行的返回值，每次调用next方法返回的是一个包含value和done的对象{value:当前成员的值，done：布尔值}其中done对用的布尔值表示当前的数据的结构是否遍历结束。当遍历结束的时候返回的value值是undefined，done值为true let zimu = [a,b,c,d] //返回一个iterator对象,该对象对象里面有next方法 let iterator = zimu[Symbol.iterator](); //调用对象的next方法,返回值{value:a,done:false} console.log(iterator.next()); 1.可迭代的数据结构会有一个[Symbol.iterator]方法,2.[Symbol.iterator]执行后返回一个iterator对象 自定义部署iterator接口 let obj = { data: [&quot;a&quot;, &quot;b&quot;], [Symbol.iterator]() { const self = this //用于返回值对象 let index = 0 //索引变量 return {//遍历器对象，返回iterator对象 next() { if (index &lt; self.data.length) { return { value: self.data[index++], done: false } } else { return { value: undefined, done: true } } } } } } for..of以前我们遍历数组中的元素的时，最开始使用的是for let arr = [1,2,3] for(let i = 0;i&lt;arr.length;i++){ console.log(arr[i]) //输出1，2，3 } 自ES5之后，可以使用forEach arr.forEach(function (value) { console.log(value); //输出1，2，3 }); 但是foeEach有两个缺点：1.不能使用break语句中断循环2.不能使用return语句返回到外层函数 ES6增加了for-of循坏，是现在简洁、最直接的遍历数组元素的语法。for-of不仅仅可以遍历数组，具有iterator接口的，都可以使用for-of进行遍历 for (var value of arr) { console.log(value); // 1,2,3 } 与for-in的区别：1.for-in 获取的是对象的键名，for-of获取的是键值2.for-in 会遍历对象的整个原型链,性能非常差不推荐使用。 使用场景 1.对数组和Set结构进行结构赋值时2.扩展运算符3.yieId后面跟的是一个可遍历的结构4.由于数组的遍历会调用遍历器接口，所以任何接收数组作为参数的场合其实都调用了遍历器接口。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[箭头函数]]></title>
    <url>%2F2020%2F07%2F24%2F%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[用处：常用在回调函数 let a = ()=&gt;{ … } 形参 只有一个形参的时候，()可以省略 其余时候，()不能省略 函数体 函数体内只有一条语句或者表达式，{}可省略，省略后自动return 其余情况不可以省略，并且需要返回值时，需要加上return 注意：由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 //报错 let getTempItem = id =&gt; { id, name: &quot;Temp&quot; }; // 不报错 let getTempItem = id =&gt; ({ id, name: &quot;Temp&quot; }); 特点：1.箭头函数没有arguments，但是如果在箭头函数需要参数时，可以使用rest运算符来取代arguments2.箭头函数没有prototype属性，不能用作构造函数（不能用new关键字调用）3.箭头函数本身是没有this，它的this不是调用的时候决定的，而是声明时所在作用域下的this值。 let obj = { getName(){ btn2.onclick = ()=&gt;{ console.log(this) } } } obj.getName() //输出obj let obj = { getName:()=&gt;{ btn2.onclick = ()=&gt;{ console.log(this) } } } obj.getName() //输出window 因此，箭头函数替代了以前需要显式的声明一个变量保存this的操作，使得代码更加的简洁。还有一个好处在数组的迭代中使用箭头函数更加简洁，并且省略了return关键字。 let arr = [1,2,3] arr.filter (item=&gt; item === 2)//[2] arr.map(item =&gt; item*2 ) //[2,4,6] arr.reduce((acc,cur) = acc+cur) //6 总结 1.箭头函数适合与this无关的问题，定时器、数组的方法回调2.箭头函数不适合与this有关的回调，事件回调，对象的方法]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6(含之后的版本)]]></title>
    <url>%2F2020%2F07%2F24%2Fes6%2F</url>
    <content type="text"><![CDATA[let/const特点: 不能重复定义 在块级作用域内有效,不影响作用域链 不存在变量提升 const不可以被修改，声明时必须赋值 补充:1.新增块级作用域：if、else\while、for后面的{}或者直接的{}2.数组和对象常量的元素是可以修改的，因为常量地址是没有变化的。 变量的声明提前:使用var关键字声明的变量。会在所有的代码执行前被声明（但是不会赋值）函数的声明提前：使用function 函数名{}声明的函数会在所有的代码执行前就被创建 使用let/const定义的变量在没声明前是无法使用的。 在循环使用中常用。如下述代码，结果会全部输出2，原因是：点击事件是回调函数进入队列，等同步执行的代码执行完毕之后，再执行,i是全局变量，此时的i已经是最后一次循环之后的i了。es6中的let也可以解决这个问题，因为let有自己的块级作用域，使用i值的时候，仅当次循环有用。 //html &lt;button&gt;测试1&lt;/button&gt; &lt;button&gt;测试2&lt;/button&gt; &lt;button&gt;测试3&lt;/button&gt; //js let btns = document.getElementsByTagName(&quot;button&quot;); for (var i = 0;i&lt;btns.length;i++) { var btn = btns[i]; btn.onclick =function () { alert(i) } } //执行回调时此时的i已经是最后一次循环之后的i了 //{var i = 0} {var i = 1} {var i = 2} 还有一点是let/const不属于顶层全局变量，不用担心污染全局的window对象。 let a = 0 console.log(window.a)//undefined var b = 1 console.log(window.b)//1 变量的解构赋值理解：从对象或数组中提取数据，并赋值给变量(多个)。常用：函数形参对象的解构赋值。 例：交换对象,解构的目标是数组，所以以数组的形式来接收。 let a = 1 let b = 2 [a,b] = [b,a] //a=2 , b =1 模板字符串作用：简化字符串的拼接使用：模板字符串必须用包含，变化的部分使用${xxx}定义 对象属性/方法简写对象属性简写：当对象的属性和值相同时，省略属性名 省略的是属性名而不是值 必须是一个变量 方法的简写：当对象的属性是一个方法，可以使用简写形式。 //es5 let obj ={ func:function(){} } } //es6 let obj2={ func(){} //不太常用 func:()=&gt;{} //常用箭头函数 } 箭头函数箭头函数 形参默认值在定义函数时可以定义形参的默认值，当不传入参数的时候默认使用形参里的默认值。一般有默认值的形参放在最后。 //定义形参默认值 function add(a=0,b=1) { return a+b } console.log(add()); //输出1 …rest参数... 把实参封装成数组，rest参数中的变量代表一个数组。主要用于形参，且rest参数之后不能有其他参数。在ES9中，封装成对象也可以了。 剩余运算符：用来代替arguments，比arguments灵活。 补充:arguments.callee()方法的意思是：调用函数本身。 function foo(...value){ //收集传过来的2，65两个元素 console.log(value)//输出[2,65]是一个真数组 } function foo(value){ console.log(arguments)//2,65是一个伪数组 } foo(2,65) 扩展运算符...将数组转换为逗号分割的参数序列，常用于函数调用ES9中也可以将对象转换为逗号分割的参数序列。 扩展运算符可以和数组的解构赋值一起使用，但是必须放在最后一个，因为剩余/扩展运算符的原理其实是利用了数组的迭代器，它会消耗3个点后面的数组的所有迭代器，读取所有迭代器生成对象的value属性，剩余/扩展运算符后不能在有解构赋值，因为剩余/扩展运算符已经消耗了所有迭代器，而数组的解构赋值也是消耗迭代器，但是这个时候已经没有迭代器了，所以会报错 let [first,...arr]=[1,2,3,4,5]//不会报错 let[...arr,last] = [1,2,3,4,5] //报错 SymbolSymbol主要用于解决ES5的对象属性名都是字符串，容易造成属性名的冲突问题。是一种类似于字符串的数据类型。 Symbol是ES6中添加的新的数据类型(原来的有：String，Number,Boolean,Object,Null(空对象指针),Undefined(声明的变量未被初始化时)) 特点: Symbol的值是唯一的，解决命名冲突问题。(类似id) Symbol值不能与其他数据进行计算，包括同字符串拼接 Symbol可以转化为布尔值 Symbol定义的对象属性不能用for/in 循环遍历，可以使用Reflect.ownKeys来获取对象的所有键名。 //创建Symbol，通过Symbol函数创建 let symbol = Symbol(); console.log(symbol) //输出Symbol //Symbol(&#39;对实例的描述&#39;),Symbol是唯一的与如何描述实例无关 //对实例进行描述，主要是用于控制台输出时容易区分 let s1 = Symbol(&quot;a&quot;) let s2 = Symbol(&quot;a&quot;) console.log(s1===s2) //false //Symbol.for 创建 let s3 = Symbol.for(&quot;b&quot;) let s4 = Symbol.for(&quot;b&quot;) console.log(s3===s4) //true symbol的作用场景就是给对象添加属性/方法 1.当symbol作为对象的属性时，用[Symbol]形式，不用XX.Symbol形式。并且在定义的时候也需要加中括号2.除了自己定义使用的Symbol值以外，ES6还提供了11个内置的Symbol方法，比如Symbol.iterator属性 Symbol.prototype.description 获取创建symbol实例时对其的描述。 iterator迭代器iterator迭代器 Generator函数概念：ES6提供的解决异步编程的方案之一。 特点：1.写法:function函数名*2.内部用yield表达式来定义不同的状态3.其返回值是一个Iterator迭代器（指针对象）4.通过调用返回值的next()方法执行函数内部语句 比如某个事物只有三种状态（状态A，状态B，状态C），而这三种状态的变化是 状态A =&gt; 状态B =&gt; 状态C =&gt; 状态A ，这就是状态机。Generator特别适用于处理这种状态机。 // A，B，C三种状态循环 function* state(){ while(1){ yield &#39;A&#39;; yield &#39;B&#39;; yield &#39;C&#39;; } } let status = state();//返回的是指针对象,迭代器对象 //碰到yield返回 console.log(status.next()); // 先暂停到A，后面的代码不执行，返回{value: &quot;A&quot;, done: false} console.log(status.next()); // 执行下一条指令，暂停到B，返回{value: &quot;B&quot;, done: false} console.log(status.next()); // {value: &quot;C&quot;, done: false} console.log(status.next()); // {value: &quot;A&quot;, done: false} console.log(status.next()); // {value: &quot;B&quot;, done: false} function* state(){ yield &#39;A&#39;; yield &#39;B&#39;; yield &#39;C&#39;; } for(let v of gen(){ console.log(v) //输出A,B,C }) Iterator迭代器遍历结束时，返回的是：{value: undefined, done: true},Generator函数可以使用return来改变最后的返回值 next传的参数可以作为yield语句(默认返回undefined)的返回值。第一个next表示启动，第二个next对应的才是第一个yieId语句。 function * state(){ let result = yield &#39;hello&#39; console.log(result)//输出xxx } let iterator = state() iterator.next(&quot;aaa&quot;) iterator.next(&quot;xxx&quot;) 实例如何实现异步 //需求:1s 输出111，2s后输出 222，3s输出 333 //定时器方法 setTimeout(() =&gt; { console.log(111); setTimeout(() =&gt; { console.log(222); setTimeout(() =&gt; { console.log(333); }, 3000) }, 2000) }, 1000) //使用生成器函数 function one(){ setTimeout(()=&gt;{ console.log(111); iterator.next(); },1000) } function two(){ setTimeout(()=&gt;{ console.log(111); iterator.next() },2000) } function three(){ setTimeout(()=&gt;{ console.log(111); iterator.next() },3000) } function * gen(){ yield one(); yield two(); yield three(); } //调用生成器函数 let iterator = gen() Promise对象Promise是JS中进行异步编程的新的解决方案，之前是纯回调的方法。 回调函数的一些缺点:1.多重嵌套，导致回调地狱 Promise引入了链式调用的概念，每个then方法同样也是一个promise，所以可以链式调用下去。其次将异步操作以同步的流程表达出来，更方便阅读。2.不清楚回调是否都是异步调用的（可以同步调用ajax，在收到响应前会阻塞整个线程，会陷入假死状态，非常不推荐）3.第三方库可能没有提供错误处理 Promise在异步请求发送错误的时候，即使没有捕获错误，也不会阻塞主线程的代码 更深入的内容，在之前的博客中Promise学习笔记 Set/Map容器Set容器：无序不可重复的多个value的集合体,类似数组但成员唯一，集合实现了iterator接口。 new Set(array)创建方法 add(value)添加方法 delete(value)删除方法 has(value)判断是否存在方法 clear()清空方法 let set = new Set([1,3,2,2]) console.log(set);//输出唯一出现的值 //add(value)添加方法 set.add(7) console.log(set.size,set)//set.size相当于数组的length 遍历可以使用Set/Map实例对象的keys()，values()，entries()方法进行遍历。由于Set的键名和键值是同一个值，它的每一个元素的key和value是相同的，所有keys()和values()的返回值是相同的，entries()返回的元素中的key和value是相同的。 let set = new Set([4, 5, &#39;hello&#39;]) for(let item of set.keys()) { console.log(item) //输出4，5，hello } for(let item of set.values()) { console.log(item) // 输出4，5，hello } for(let item of set.entries()) { console.log(item) //[4,4],[5,5],[&#39;hello&#39;,&#39;hello&#39;] } Map容器:Map是一组键值对(key-value，只取前两个元素。)的结构,key不重复。 let a = new Map() m.set(&#39;Adam&#39;, 67); //添加新的key-value m.has(&#39;Adam&#39;);//是否存在key&quot;Adam&quot; true m.get(&#39;Adam&#39;); //获得key为Adam的value 67 m.delete(&#39;Adam&#39;);//删除key&quot;Adam&quot; m.clear() //清空Map容器 一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉。 classclass类 数值扩展Number.EPSILON 属性的值表示JavaScript里面的最小值 进制表示法二进制用0b，八进制用0o console.log(0b1010);//输出10 Number.isFinite(i) 判断i是否有限大的数返回值：是true,否false Number.isFinite(Infinity)//false Number.isNaN(i) 判断i是否NaN返回值：是true,否false Number.isInteger(i) 判断i是否整数返回值：是true,否false Number.isInteger(120.0)//true Number.parseInt(str) 将字符串转换为对应的数值返回值：对应的数值 Math.trunc(i) 直接i的去除小数部分返回值:整数部分 Math.sign(i) 判断i是正数、负数、还是零 指数运算符(幂) console.log(3 ** 3); //3的3次方=27 BigInt 在普通数据后面加上n，数据类型是大整型。用于很大的数值运算，只能大整型与大整型运算。 //创建大整型 let n = 521n //正数转化成大整型 let n = 123 console.log(BigInt(n)) //输出123n 模块化模块功能主要由两个命令构成export 命令用于规定模块的对外接口import 命令用于输入其他模块提供的功能 //分别暴露 export let name = &quot;ranan&quot; export let fun = function(){} //统一暴露 export {name,fun} //默认暴露 export default { name : &quot;ranan&quot; , fun : function(){} } //通用导入的方式 as 别名 from 地址 import * as data from &quot;path&quot; //如果是默认暴露方式，使用时应该是 data.default.fun() //解构赋值形式,如果重复了可以使用as别名 import {name,fun} from &quot;path&quot; import {name as na,function} from &quot;path&quot; import {default as data} from &quot;path&quot; //默认暴露的写法，必须要写别名 //简便形式 针对默认暴露 import data from &quot;path&quot; console.log(data) //输出{name : &quot;ranan&quot; ,fun : functio(){}} 动态import加载 实现懒加载/按需加载,使用import()函数，返回值是promise对象,pormise返回的成功值就是暴露的对象。 import(path).then(data =&gt; data.xx) ProxyProxy也就是在目标对象之前设置一层拦截，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。 Proxy的作用 拦截和监视外部对对象的访问 降低函数或类的复杂度 在复杂操作前对操作进行校验或对所需资源进行管理 语法：new Proxy(target,handler) target就是被设置一层拦截的对象，可以是任何类型的对象(包括原生数组，函数，甚至另一个代理) handler是一个对象，用来定制拦截行为 Proxy一般和Reflect配套使用,前者拦截对象,后者返回拦截的结果,Proxy上有的的拦截方法Reflect都有 1.set/get方法 set方法接收两个常用参数 target：得到的目标值 key：目标的key值，相当于对象的属性 set方法可以接收四个参数 target:目标值。 key：目标的Key值。 value：要改变的值。 receiver：改变前的原始值。 let handler = { get:function (target,key) { if (target.hasOwnProperty(key)){ return target[key]//key为属性名，target[key]为属性值 } else{ console.warn(`对不起，没有这个${key}`) return } }, set:function (target,key,value) { console.log(&quot;set&quot;,target,key,value); target[key] =value //设置了p.a才打印1 }, //删除属性 deleteProperty:function (target,key) { console.log(`删除${key}属性的${target[key]}值`); delete target[key] }, // 拦截key in object操作 has(target, key) { // 自定义限制：只暴露a属性 if (key === &#39;a&#39;) { return target[key]; } else { return false; } }, } let p = new Proxy({},handler) p.a=1 //set {} a 1 p.b=2 console.log(&#39;b&#39; in p); // false,没有暴露 console.log(&#39;a&#39; in p); //true //console.log(p.a); //delete p.b //删除了b属性的2值 //console.log(p.b); //undefined 可以使用Proxy实现表单验证。 Object.defineProperty也可以实现数据拦截，Proxy有什么优势吗？1.支持数组数组的key是下标，对象的key是属性名 let arr = [1,2,3] let proxy = new Proxy(arr, { get (target, key, receiver) { console.log(&#39;get&#39;, key) return Reflect.get(target, key, receiver) }, set (target, key, value, receiver) { console.log(&#39;set&#39;, key, value) return Reflect.set(target, key, value, receiver) } }) proxy.push(4) // get push (寻找 proxy.push 方法) // get length (获取当前的 length) // set 3 4 (设置 proxy[3] = 4) // set length 4 (设置 proxy.length = 4) 2.Object.defineProperty()的升级版 外界对某个对象的访问，都必须经过这层拦截。因此它是针对整个对象，而不是对象的某个属性。 可选链操作符可选链操作符?.允许读取一个被连接对象的深层次的属性的值而无需明确校验链条上每一个引用的有效性，类似.运算。.:如果对象链.上有数据为null或undefiend，操作符会抛出一个错误?.:如果对象链上有数据为null或undefiend，操作符则会按照短路计算的方式进行处理，返回 undefined。 比如读取一个对象的深层属性 const obj = { foo: { bar: { baz: 42, fun: ()=&gt;{} }, }, }; // 不使用?. 需要层层判断防止报错 let baz = obj &amp;&amp; obj.foo &amp;&amp; obj.foo.bar &amp;&amp; obj.foo.bar.baz; // 使用?. 不需要层层判断 let baz = obj?.foo?.bar?.baz; // 结果：42 绝对全局对象globalThis不管是浏览器还是nodejs还是其他环境，globalThis永远表示全局对象，比如浏览器环境表示window，nodejs下表示global]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript高级]]></title>
    <url>%2F2020%2F07%2F22%2FJavaScript%E9%AB%98%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[判断数据类型typeoftypeof返回数据类型的字符串表达,它的返回值都是’数据类型’ undefined -&gt; ‘undefined’string -&gt; ‘string’boolean -&gt;’boolean’null -&gt; ‘object’ 因为该类型只有一个值，所以可以用=== 来判断类型object -&gt;’object’object(function) -&gt; ‘function’object(array) -&gt;’object’ 总结typeof不能明确的区别null和object、object和array instanceof可以使用instanceof对对象进行细分 A instanceof 构造函数 通过instanceof可以检查一个对象是否一个构造函数的实例，instanceof原来是寻找实例对象A的原型链 function -&gt; Function object -&gt; Object array-&gt; Array 综合例题 let a = { age: 12 } function fu(obj) { obj = { age: 13 } } fu(a) console.log(a.age); //输出12 //开始传参可以理解成obj=a，函数执行时obj重新指向另外一个空间 //函数执行完毕函数作用域销毁，obj自动释放，obj所指对象的空间在后面的某个时刻由垃圾回收器回收 函数回调函数回调函数 立即执行函数防止污染全局命名空间,编写js模块匿名函数自调用;(function(){})() 分号的问题需要加分号的语句,一般js最终执行时会压缩。1.小括号开头的前一条语句，如匿名函数自调用2.中括号开头的前一条语句 this指针this指针 原型与原型链原型与原型链 变量提升与函数提升通过var声明的变量，会被提升。定义的函数，可以在定义语句前执行，这就是函数提升。 var a=3 function fu(){ console.log(a) var a = 4 //输出undefined 局部函数定义个变量a会提升到函数的最开始 } fn() 在全局代码执行前，JS引擎会创建一个栈来存储管理所有的执行上下文。在全局执行上下文(window)确定后，将其添加到栈中，在函数执行上下文(调用函数时产生)，将其添加到栈中。在当前函数执行完后，函数执行上下文出栈，最后所有代码执行完后，栈中只剩下window 作用域是静态的，开始就存在且不会变化。函数上下文是动态的。 var x = 10; //fn作用域，开始就存在了 function fn(){ console.log(x) } //show作用域 function show(f){ var x = 20 f() //执行时先在fn的作用域里面找x是不存在的，然后再从全局作用域中找 所以输出10 } show(fn) //输出10 全局执行上下文 在执行全局代码前，将window确定为全局执行上下文对全局数据进行预处理:var 定义的全局变量 -&gt; undefined 添加为window的属性function 声明的全局函数 -&gt; 赋值，添加为window的方法this -&gt; 赋值(window)开始执行全局代码 函数执行上下文在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象（虚拟对象，因为函数执行完毕会销毁）对局部数据进行预处理:1.函数的上下文对象 this2.封装实参的对象 arguments 是一个类数组对象/有length、可以通过索引操作的对象3.形参变量 -&gt; 赋值 -&gt; 添加为执行上下文的属性其余类似全局执行上下文 闭包闭包 宏队列与微队列宏队列与微队列 H5 Web Workers(多线程) Web Workers 是 HTML5 提供的一个javascript多线程解决方案（常用于计算），但是子线程完全受主线程控制，且不得操作DOM，所以这个新标准并没有改变javascript单线程的本质。 1.创建一个分线程执行的js文件 分线程的全局对象不再是window了，所以分线程不得操作DOM var onmessage = function(event){ //不能用函数声明，只能用赋值的形式 var upper = event.data //通过event.data获得主线程发来的数据 postMessage(upper) //将数据发给主线程 } 2.在主线程中的js中发消息并设置回调 //创建一个Woker对象 var worker = new Worker(&quot;分线程执行的js文件地址&quot;) //向分线程发送消息 worker.postMessage(&quot;向分线程执行的js发送数据&quot;) //接收worker传过来的数据函数 worker.onmessage = function(event){ alert(event.data) //分线程返回的数据在event.data里面 }]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM]]></title>
    <url>%2F2020%2F07%2F21%2FBOM%2F</url>
    <content type="text"><![CDATA[BOM 浏览器对象模型，可以通过js代码操作浏览器 BOM对象window代表的是整个浏览器窗口，同时window也是网页中的全局对象navigator代表的当前浏览器的信息，通过该对象识别不同的浏览器location代表当前浏览器的地址栏信息，可以操作页面重定向history代表浏览器的历史记录，可以通过该对象操作浏览器的历史记录，由于隐私获取不到具体的历史记录，只能操作浏览器后退与前进，只在当次访问时有效screen代表用户的屏幕信息 这些BOM对象在浏览器中作为window对象的属性保存，可以通过window对象来使用，也可以直接使用。 navigator由于历史原因，navigator对象中的大部分属性都已经不能帮助我们识别浏览器了。一般只会使用userAgent属性来判断浏览器的信息/chrom/i.test(navigator.userAgent) 测试是否是chrom浏览器,但是最新的IE判断不出来了 historyhistory.length 可以获取当前访问了的页面数history.back() 返回上一个页面，类似浏览器的回退按钮history.forword() 可以跳转到下一个页面，类似浏览器前进history.go(整数) 可以跳转到指定页面 -1回退一个界面，1前进一个页面 location如果直接打印location，则可以获得当前页面的完整路径通过location修改的路径，会有历史记录(可回退)。 location.assign(path) 用来跳转到其他页面，类似直接修改location路径。location.reload() 刷新页面，默认会情况缓存。location.replace(path) 用新页面代替当前页面，不会生成历史记录。 window定时器 setInterval(回调函数,时间)回调函数每个一段时间就被调用一次。返回一个Number类型的数据，用于标识定时器，利用返回值可以关闭定时器clearInterval(标识是哪一个定时器)，可以接收任意参数，如果参数不是一个有效的标识，也不会报错只是什么 都不做。 为了防止开启多个定时器，导致定时器重叠，在开启定时器之前，需要将上一个定时器关闭。 延时调用延时调用一个函数不马上执行，而是隔一段时间后在执行，而且只会执行一次setTimeout(回调函数,时间)clearTimeout(标识是哪一个定时器)]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM]]></title>
    <url>%2F2020%2F07%2F18%2FDOM%2F</url>
    <content type="text"><![CDATA[DOM全程Document Object Model文档对象模型。文档表示的是整个的HTML网页文档;对象表示将网页中的每一个部分都转换成了一个对象;模型来表示对象之间的关系,方便我们获取对象。 Document对象：实际上是window对象的属性。这个对象的独特之处是唯一一个既属于BOM又属于DOM的对象。在页面中可以直接使用，代表的是整个网页。 注意点 1.取消默认行为可以通过在响应函数的最后return false来取消默认行为，或者使用event.preventDefault()2.如果需要读取元素节点属性，直接使用 元素.属性名，但是class属性不能采用这种方式，需要使用className。3.window.onload = function(){//页面加载完之后再执行，确保所有的DOM对象已经加载完毕} DOM查询innerText 获取到元素内部的文本内容，会自动将html标签去除innerHTML 获取到元素内部的文本内容，会保存html标签 获取元素节点，通过document对象调用document.getElementById() 通过id获取domdocument.getElementsByClassName() 通过类名获取domdocument.getElementsByName() 通过name属性获取domdocument.getElementsByTagName() 通过标签名获取domdocument.querySelector() 该方法总会返回唯一的一个元素document.querySelectorAll() 返回数组。 获得元素节点的子节点，通过具体的元素节点调用getElementsByTagName() 方法，返回当前节点指定标签名的后代节点childNodes 属性，表示当前节点的所有子节点,会获取包括文本节点在内的所有结点，DOM标签与标签之间的换行也会看成文本结点。children 属性可以获取当前元素的所有子元素firstChild 属性，表示当前节点的第一个子节点，包括空白文本结点firstElementChild 属性获取当前元素的第一个子元素lastChild 属性，表示当前节点的最后一个子节点 获取父节点和兄弟结点,通过具体的节点调用parentNode 属性，表示当前节点的父节点previousSibling 属性，表示当前节点的前一个兄弟节点，可能会获取到空白文本previousElementSibling 属性，表示当前节点的前一个兄弟元素nextSibling 属性，表示当前节点的后一个兄弟节点 补充获取body,document中有一个属性body，它保存的就是body的引用document.body 获取html,document.documentElement DOM 增删改document.createElement() 参数为标签名，用于创建一个元素节点对象，并返回创建好的对象document.createTextNode() 参数为文本内容，根据内容创建文本节点，并返回新的节点父节点.appendChild() 向一个父节点中添加新的子节点父节点.insetBefore() 在指定的子节点前插入新的子节点,(新节点,旧节点)父节点.replaceChild() 使用指定的子节点替换已有的子节点，(新节点,旧节点)父节点.removeChild() 删除一个子节点 DOM操作cssjs通常返回的是不带单位的数值 内联样式 语法:元素.style.样式名 = 样式值 如果css的样式名中含有-,需要改成驼峰命名法。通过style属性设置/读取的样式都是内联样式，内联样式有很高的优先级。 通过style属性来修改元素的样式，每修改一个样式，浏览器需要重新渲染一次页面 如果要同时修改多个样式，直接通过类名修改对象.className = “” 当前正在显示的样式语法:元素.currentStyle.样式名 只有ie浏览器支持,没设置的值获取默认值，其他浏览器可以使用window.getComputedStyle()来获取。 第一个参数是要获取样式的元素第二个参数可以传递伪元素，一般都传null返回值是当前元素对应的样式的对象,后接样式名获取样式如果该样式没设置获取到的是真实值而不是默认值 通过以上两种方式获取到的样式都是只读的,如果需要修改只能使用style属性 处理兼容性问题 定义一个函数来获取指定元素当前的样式，参数obj要获取样式的元素，style要获取的样式名字符串 function getStyle(obj,style){ if(window.getComputedStyle){ //正常浏览器有getComputedStyle方法 return getComputedStyle(obj,null)[style] } else{ //IE8浏览器没有定义getComputedStyle return obj.currentStyle[style] } } 注意if里面用getComputedStyle不行，要用window.getComputedStyle没使用window时getComputedStyle是一个变量需要去作用域中寻找，没定义就是用会报错，后续代码不会执行使用window之后属于属性，没找到属性返回undefined 其他样式相关属性 element.clientWidth/clientHeight这两个属性可以获取元素的可见(内容和内边距)宽度和高度,返回的是数字，不带px，因为包括的是可见区域所以设置起来无法分配,所以这两个属性都是只读属性。element.offsetWidth/offsetHeight获取元素的整个大小,包括内容、内边距、边框，其他特点与clientWidth/clientHeight属性相似。 element.offsetParent可以获取当前元素的定位父元素,都没有定位返回bodyelement.offsetLeft/offsetTOP当前元素相对于其定位的水平偏移量和垂直偏移量element.scrollHeight/scrollLeft/scrollTop/scrollWidth表示元素整个滚动区域的宽度/高度,可以获取滚动条滚动的距离当满足下面等式的时候，说明滚动条滚动到最底，水平滚动条类似。总长度 - 看不见的长度 = 可见的长度element.scrollHeight - element.scrollTop = clientHeight 事件当事件的响应函数被触发时，浏览器每次都会将一个事件对象(event)作为实参传递给响应函数，封装当前事件相关的一切信息，比如：鼠标坐标，键盘哪个键被按。但是IE8不会传,事件对象作为window对象的属性保存的window.event 可以使用 event = event || window.event 来解决兼容性问题 事件对象event.clientX 可以获取鼠标指针的水平坐标，返回数值，不带单位event.clientY 可以获取鼠标指针的垂直坐标，返回数值，不带单位用于获取鼠标在当前的可见窗口的坐标event.pageX/event.pageY获取鼠标相对于当前页面(document)的坐标,但是IE8不支持，可以通过对top = scrollTop + clientX实现offsetX/offsetY screenX/screenY 补充:chrome认为浏览器的滚动条是body的，通过body.scrollTop获取，但是火狐等浏览器认为是html的，通过documentElement.scrollTop获取 现在浏览器的滚动条都是html的了 event.wheelDalta 获得滚轮的方向 正向上滚，负向下滚event.target 触发事件的对象event.keyCode 获取按键的编码 event.altKey/ctrlKey/shiftKey判断alt/ctrl/shift是否被按下 onscroll 该事件会在元素的滚动条滚动时触发onmousemove 该事件会在鼠标在元素中移动时被触发onmousedown 该事件会在鼠标按下被触发onmouseup 该事件会在鼠标弹上被触发onwheel 该事件会在鼠标滚轮滚动时被触发 键盘事件一般绑定给可以获取焦点的对象或者是documentonkeydown 键盘按下触发，一直按着不松手会连续触发，在文本框中输入内容，属于onkeydown的默认行为根据此性质可以限定文本框内容输入的类型onkeyup 按键被松开，不会连续触发 事件的冒泡所谓的冒泡指的是事件向上传递，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发。在开发中大部分情况冒泡都是有用的，如果不希望发生事件冒泡可以通过事件对象取消冒泡event.cancelBubble = true 事件的委派需求场景：给a标签绑点点击事件，后添加的a标签也有该绑定事件。解决:可以尝试把时间绑定到元素共有的祖先元素。事件委派利用了冒泡，从父元素到子元素 事件的绑定 对象.事件 = 函数 的形式绑定响应函数，同时只能为一个事件绑定一个响应函数 addEventListener可以为一个事件同时绑定多个响应函数，后面的不会覆盖前面的对象.addEventListener() 第一个参数事件的字符串，不要on，第二个参数时间触发时的回调函数，第三个参数是否在捕获阶段触发事件，一般都是false]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2020%2F07%2F16%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式创建正则表达式的对象 构造函数方式语法:let 变量 = new RegExp(“正则表达式”,”匹配模式”)字面量方式语法:let 变量 = /正则表达式/匹配模式 具体用法 匹配模式i 忽略大小写g 全局匹配模式 test()检查一个字符串是否符合正则表达式的规则参数为被检查的字符串返回值为布尔值 //正则表达式规则:字符串是否含有a let reg = new RegExp(&quot;a&quot;) let str = &quot;a&quot; reg.test(str) 或|表示或 reg=/a|b/ -&gt; a或者b[]里的内容也是或 reg=/a-z/ -&gt; 任意的小写字母[^ ] 查找任何除了[]里的字符 reg=/[^ab]/ -&gt; 除了a或b的字符 //以a开头c结尾中间是b或d或e reg = /a[bde]c/ //c是除了ab的字符，所以返回true reg = /[^ab]/ reg.test(&#39;abc&#39;) 量词通过量词可以设置一个内容出现的次数，量词只对它前面的一个内容起作用，如果要对多个加括号。 a{n} 表示n个连续的aa{1,3} 表示最少一个a最多3个连续aa+ 表示至少一个a,{1,}a* 表示0个或多个,{0,}a? 表示0个会1个,{0,1}^a 表示以a开头a$ 表示以a结尾 注意: ^a$只表示a 元字符 .表示任意字符,如果要检查.需要转义/./,new RegExp(“\.”)使用构造函数时，它的参数是一个字符串，而\是字符串中转义字符，所以使用\需要转义成\使用\w 任意字母、数字、_ 相当于[A-z0-9_]\W 除了字母、数字、_ 相当于[^A-z0-9_]\d 任意的数字\D 除了数字\s 空格 \S除了空格\b 单词边界，\bxxx\b独立的单词 \D 除了单词边界 字符串和正则相关的方法split()语法：string.split(“,”)/string.split(/[0-9]/)join()的功能相反,可以将一个字符串拆分为一个数组参数为拆分规则,如例子的根据字符串里的逗号拆分数组,参数可以是正则表达式 默认全拆不修改原字符串，返回值为数组 let str=&quot;1a2b3c4d5e6f&quot; let result = str.split(/[0-9]/) //输出[a,b,c,d,e,f] search()语法:string.search(搜索的内容)搜索字符串中是否含有指定内容,返回第一次(g失效)出现的索引或者-1参数是指定内容可以是正则表达式 match()语法:string.match(条件)根据正则表达式，从一个字符串中将符合条件的内容提取出来,返回值是数组 默认返回符合条件的第一个内容要找所有内容，开启全局匹配模式可以为一个正则表达式设置多个匹配模式，顺序无所谓 let str=&quot;1a2b3c4d5e6f&quot; let result = str.match(/[0-9]/g) //输出[1,2,3,4,5,6] replace()语法:string.search(被替换的内容，新的内容)可以将字符串中指定内容替换为新内容，被替换的内容可以是正则表达式。 默认只替换第一个不影响原来的字符串，返回新的字符串 可以使用它去空格 //会去掉全部的空格 str = str.replace(/\s/g,&quot;&quot;) //去掉开头的空格 str = str.replace(/^\s*/,&quot;&quot;) //去掉结尾的空格 str = str.replace(/\s*$/,&quot;&quot;) //去掉开头和结尾的空格 str = str.replace(/^\s*|\s*$/g,&quot;&quot;) 这里去掉字符串的头尾空格可以使用字符串的trim()方法 常用正则检查是否合法手机号 手机号11位,以1开头,第二位3-9，三位以后任意数字9个 /^1[3-9][0-9]{9}$/ 电子邮件 hello.nihao@qbc.com.cn 任意字母数字下划线 \w{3,}.任意字母数字下划线 (.\w+)*@任意字母数字 [A-Za-z0-9]+.任意字母(2-5位) .任意字母(2-5位) (.[A-Za-z]{2,5}){1,2} let emailReg=/^\w{3,}(\.\w+)*@[A-Za-z0-9]+/ (\.[A-Za-z]{2,5}){1,2}$/ 贪婪与懒惰贪婪模式:匹配尽可能多的字符懒惰模式:匹配尽可能少的字符，会不断的回溯 常用场景.*与.*?，使用?来表示使用懒惰模式匹配 正则扩展exec()捕获()括号包裹的内容 语法:RegExpObject.exec(string)方法用于检索字符串中的正则表达式的匹配。如果 exec() 找到了匹配的文本，则返回一个结果数组。否则，返回 null。不管是否/g开启全局，只返回匹配的第一个。如果要返回匹配的多个可以使用while(reg.exec(str))或者使用String.prototype.matchAll()方法。 let str = `&lt;ul&gt; &lt;li&gt; &lt;a&gt;ranan&lt;/a&gt; &lt;p&gt;喜欢粉色&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;a&gt;linin&lt;/a&gt; &lt;p&gt;喜欢白色&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; ` const reg = /&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\/a&gt;.*?&lt;p&gt;(.*?)&lt;\/p&gt;/s const result = reg.exec(str) console.log(result); //输出一个数组，第一个元素是匹配的文本，第二个值第一个(.*?)返回值，第三个值第二个(.*?)返回值 命名捕获分组 通过?&lt;对捕获到的元素进行命名&gt;,返回的数组中有一个groups属性。 let str = &#39;&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;&#39; const reg = /&lt;a href=&quot;(?&lt;url&gt;.*)&quot;&gt;(?&lt;text&gt;.*)&lt;\/a&gt;/ const result = reg.exec(str) console.log(result) //数组前面3个返回值与上述方法相同，[....,goups:{url:http://www.baidu.com},text:&quot;尚硅谷&quot;] //result.groups使用。 反向断言 判断匹配结果是否正确 正向断言,常用表示(?=pattern),从当前匹配位置开始测试后面(右边)匹配字符串是否成立。(?!patter)为其否定写法。 //正向断言 let str = &#39;JS51566哈哈哈11嗯嗯&#39; const reg = /\d+(?=嗯)/ const result = reg.exec(str) //输出[11] 反向断言，常见表达式(?&lt; pattern)或者(?&lt;!pattern),表示当前位置左边将出现匹配字符 dotAll模式 . 代表元字符查找单个字符，除了换行和行结束符。dotAll /正则/s，新增修饰符s使.可以匹配任意字符。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call-apply-bind]]></title>
    <url>%2F2020%2F07%2F15%2Fcall-apply-bind%2F</url>
    <content type="text"><![CDATA[函数对象的call方法与apply方法 函数对象：函数像对象一样去使用,函数.xx。 共同点：1.这两个方法都是函数对象的方法，需要通过函数对象来调用2.当对函数调用 call()和apply()时，都会执行该函数3.call()和apply()的第一个参数为对象，执行call()与apply的函数对象里的this指向第一个参数 不同点：call()方法方法可以将实参在第一个参数对象之后依次传递apply()方法需要将实参封装到一个数组中统一传递 bind()、call()、apple()的区别 都能指定函数中的this Array.prototype.call()/Array.prototype.apply()是立即调用函数，Array.prototype.bind()是将函数返回 Array.prototype.call(obj)/Array.prototype.bind()从第二个参数开始依次传，Array.prototype.apply(obj)第二个参数是数组，传入的数据放入数组中 let obj ={name:&quot;ranan&quot;} function f(data,data2) { console.log(this); console.log(data + data2); return data+data2 } f.call(obj,33,22) //{name:&quot;ranan&quot;} 55 f.apply(obj,[33,22])//{name:&quot;ranan&quot;} 55 //所以apply通常用于将数组转化为函数的参数 let bar=f.bind(obj) //bind不调用函数 bar(33,22)//{name:&quot;ranan&quot;} 55 //上面也可以写成 f.bind(obj)(33,22)//{name:&quot;ranan&quot;} 55 Function.prototype.bind(obj) 作用:将函数内的this绑定为obj，并将函数返回(并不调用) 返回原函数的拷贝，我们称这个拷贝的函数为绑定函数。 将函数中的this固定为调用bind方法时的第一个参数， 绑定this之后，无论有哪个对象调用绑定函数，绑定函数中的this依旧之前绑定的第一个参数 如果绑定函数作为构造函数，已经捆绑的this会被忽略掉，this依然指向实例对象 function Person(name){ this.name = name; } var bindPerson = Person.bind({name:&quot;绑定函数&quot;}) new bindPerson(&quot;张三&quot;) // Person {name: &quot;张三&quot;} 通常用于指定回调函数的this，因为apply与call会立即调用 使用场景 保持上下文的方法 var o={ f: function () { var self=this; var fff=function() { console.log(this.value); // bind(this) 中 this 指向的是o，这里也可直接写成 bind(o) }.bind(this); fff(); }, value: &quot;Hello World!&quot; }; o.f(); // Hello World！]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型与原型链]]></title>
    <url>%2F2020%2F07%2F15%2F%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[原型(prototype)此图中的实例对象也称为原型对象 我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype 函数的prototype属性，这个属性指向着一个对象(原型对象),原型对象相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，所以我们可以将对象中共有的内容，统一设置到原型对象中。 如果函数作为普通函数调用prototype没有任何作用。如果函数作为构造函数调用，它所创建的对象中都有一个属性__proto__指向构造函数的原型对象。 注理解一定要把握对象的proto指向的是构造函数的prototype（原型）。 显式原型与隐式原型 每个对象都有隐式原型·proto·这个属性，而function既有隐式原型（proto）又有显式原型（prototype），因为函数在js里面既是函数也是对象。 prototype也是一个对象，只要是对象就有proto. 对象的隐式原型的值为其对应构造函数的显式原型的值，prototype与__proto__里面保存一样的地址值。 原型链当访问一个对象的属性时，先在自身属性中查找，找到返回。如果没有，则会去原型对象中寻找（根据元素本身的proto去找），找到返回，如果最终没有找到，返回undefined,所以Object的原型对象是原型链的尽头，Object的原型对象没有原型。(Object.prototype.ptoto === null) 注意函数的产生：所有函数都是Function的实例包括它本身，所以Function.proto === Function.prototype function Foo(){} //实际上 var Foo = new Function() //Function是它自身的实例 Function = new Function() Function.__proto__ === Function.prototype //true //构造函数object funtion Object(){} let Object = new Function() //所以Object的__proto__指向Function.prototype 原型继承构造函数的实例对象自动拥有构造函数原型对象的属性(方法)，原理是利用原型链 补充知识点1.静态成员与实例成员实例成员就是构造函数内部通过this添加的成员。实例成员只能通过实例化的对象来访问。（不可以通过构造函数来访问实例成员）静态成员在构造函数本身上添加的成员(Fn.xxx=&quot;xxx&quot;)。静态成员只能通过函数对象访问。（不可以通过实例对象来访问） 2.构造函数、实例、原型对象三者之间的关系__proto__和原型对象中(xx.prototype)都有一个属性constructor，它指向函数对象（xx.prototype.constructor===xx）。主要用来记录该对象引用哪个构造函数 3.继承(ES5)补充：call()函数，调用这个函数并改变运行时this的指向，调用函数.call(参数)。 如：obj1.(method).call(obj2,argument1,argument2)call的作用就是把obj1的方法放到obj2上使用，后面的argument1..这些做为参数传入。 ES6之前没有提供extends继承。可以通过构造函数+原型对象模拟实现继承，被称为组合继承。核心原理:通过 call()把父类型的this指向子类型的this，这样就可以实现子类型继承父类型的属性，然后通过子类型的原型等于父类型的实例，看见父类型原型上的方法 //父构造函数 this指向父构造函数的对象实例 function Father(name,age){ this.name = name; this.age = age; } Father.prototype.money= ()=&gt;{ console.log(&#39;父亲要上班&#39;); } //子构造函数 this指向子构造函数的对象实例 function Son(name,age) { //把指向父构造函数的对象实例的this改变成指向子构造函数的对象实例的this，这样可以继承属性 Father.call(this,name,age) } //让Son的原型对象指向Father的实例对象，那么就可以访问到Father实例对象上的方法 //这个new Father()是一个原型对象，相当于{}，这样写会覆盖掉Son的原型对象的constructor Son.prototype = new Father(); //所以还需要constructor指回原来的构造函数 Son.prototype.constructor = Son 4.Function和Object的关系1.Object, Function, Array等等这些都被称作是构造“函数”，他们都是函数。2.所有的函数都是构造函数Function的实例。 3.原型链机制的的角度来说，那就是说所有的函数都能通过原型链找到创建他们的Function构造函数的Function.protorype原型对象 所以 console.log(Object instanceof Function)//true 4.Function.prototype是一个对象，所以他的构造函数是Object. 从原型链机制的的角度来说，那就是说所有的函数都能通过原型链找到创建他们的Object构造函数的构造原型Object.prototype对象 所以 console.log(Function instanceof Object)//true]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this指针]]></title>
    <url>%2F2020%2F07%2F15%2Fthis%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[解析器在调用函数时，每次都会向函数内部传递一个隐含的参数this，this指向的是一个对象。根据函数的调用方式不同，this会指向不同的对象。 任何函数本质上都是通过某个对象来调用的。它的值是调用函数的当前对象，谁调用指向谁,如果没调用时，没有指明是哪个对象调用的则是window。 function Person(color) { console.log(this); this.color = color; this.getColor = function () { console.log(this); return this.color; }; this.setColor = function (color) { console.log(this); this.color = color; } } //this是谁 Person(&quot;red&quot;); //window let p = new Person(&quot;yello&quot;) //Person的实例，p p.getColor();//P let obj= {}; p.setColor.call(obj,&quot;black&quot;) //obj let test = p.setColor; test()//window function fun1(){ function fun2() { console.log(this); } fun2() } fun1()//window 补充： new在执行时完成的4件事情：1.在内存中创造一个新的空对象,在堆内存中分配空间2.让this指向这个新的对象3.执行构造函数里面的代码，给这个新对象添加属性和方法4.返回这个新对象(所以构造函数里面不需要return) 最终this指向的是调用它的对象进行了更准确的描述 var o = { a:10, b:{ a:12, fn:function(){ console.log(this.a); //12 } } } o.b.fn(); 知识点1：这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象 var o = { a:10, b:{ fn:function(){ console.log(this.a); //undefined } } } o.b.fn(); 尽管对象b中没有属性a，这个this指向的也是对象b，因为this只会指向它的上一级对象，不管这个对象中有没有this要的东西。 知识点2：this永远指向的是最后调用它的对象，也就是看它执行的时候是谁调用的 var o = { a:10, b:{ a:12, fn:function(){ console.log(this.a); //undefined console.log(this); //window } } } var j = o.b.fn; j(); 除此之外，文章还对this用法进行了补充，当this碰到return的时候 知识点3当this遇见return时，如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。 function fn() { this.user = &#39;xx&#39;; return function(){}; } var a = new fn; console.log(a.user); //undefined function fn() { this.user = &#39;xx&#39;; return 1; } var a = new fn; console.log(a.user); //xx function fn() { this.user = &#39;xx&#39;; return null; } var a = new fn; console.log(a.user); //xx 还有一点就是虽然null也是对象，但是在这里this还是指向那个函数的实例，因为null比较特殊。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack5]]></title>
    <url>%2F2020%2F07%2F13%2Fwebpack5%2F</url>
    <content type="text"><![CDATA[下载webpack5 npm i webpack@next webpack-cli -D 开发环境 //---------webpack4写法 const {resolve} = require(&quot;path&quot;) module.exports={ entry:&quot;./src/js/index.js&quot;, output:{ //默认的chunk名称是main filename:&quot;js/[name].js&quot;, path:Resolve(__dirname,&quot;build&quot;) }, mode:&quot;development&quot;, } //--------webpack5写法 module.exports= { //其余值为默认值 mode:&quot;development&quot;, } 生产环境 1.用了es6模块化2.production模式 满足以上条件webpack4会自动tree shaking但是在实际中依赖关系复杂时webpack4的tree shaking会失效webpack5对此进行了优化tree shaking会更加强大 //---------webpack4写法 const {resolve} = require(&quot;path&quot;) module.exports={ entry:&quot;./src/js/index.js&quot;, output:{ //默认的chunk名称是main filename:&quot;js/[name].js&quot;, path:Resolve(__dirname,&quot;build&quot;) }, mode:&quot;production&quot; } //--------webpack5写法 module.exports= { mode:&quot;production&quot;, } webpack5主要的关注内容： 通过持久缓存提高构建性能 使用更好的算法和默认值来改善长期缓存 通过更好的tree shaking和代码生成来改善捆绑包的大小 Output webpack 4默认只能输出ES5代码webpack 5设置output.ecmaVersion:2015来胜出ES6/ES2015的代码 SplitChunk //webpack4 统一设置 minSize:30000 //webpack5 minSize:{ javascript:30000 style:5000 } cache 可以通过配置cache实现长久缓存，让第二次打包性能更加高效 之前的webpack总是在第一次构建是输出全部文件，但是监视重新构造时只更新修改的文件。webpack5在第一次构建时会找到输出文件看是否有变化，从而决定要不要输出全部文件。]]></content>
      <categories>
        <category>前端</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack详细配置]]></title>
    <url>%2F2020%2F07%2F12%2Fwebpack%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[entryentry入口起点，值有三种情况1.string —–&gt;’./src/index.js’打包形成一个chunk，输出一个bundle文件,此时的chunk默认名称是main 2.array —–&gt;[‘./src/index.js’,’./src/add.js’]所有入口文件最终只会形成一个chunk，输出一个bundle文件，此时的chunk默认名称是main作用：HMR功能中html热更新生效 3.object —–&gt;{index:’./src/index.js’,add:’./src/add.js’}有几个入口文件就形成几个chunk，输出几个bundle，chunk的名称是key 特殊用法：2.3结合,value值为一个数组 //----------string module.exports={ entry:&quot;./src/js/index.js&quot;, output:{ //默认的chunk名称是main filename:&quot;js/[name].js&quot;, path:Resolve(__dirname,&quot;build&quot;) }, plugins:[new HtmlWebpackPlugin()], mode:&quot;development&quot;, } outputlibrary一般结合DLL使用 module.exports={ entry:&quot;./src/js/index.js&quot;, output:{ //文件名称（指定名称+目录） filename:&quot;js/[name].js&quot;, //输出文件目录，将来所有资源输出的公共目录 path:Resolve(__dirname,&quot;build&quot;), //所有资源引入公共路径前缀 --&gt;imgs/a.jpg --&gt; /imgs/a.jpg 默认不加一般用于生产环境 publicPath:&quot;/&quot;, //非入口chunk的名称 import动态导入 optimization设置 chunkFilename:&quot;js/[name]_chunk.js&quot;, //整个库向外暴露的变量名 //main.js (function(modules){...} ---&gt; var main = (function(modules){...} library:&#39;[name]&#39; //变量名添加到哪个上，之后如何引入window-browser global-node conmmojs //var main =... --&gt; window[&quot;main&quot;] = ... libraryTarget:&#39;window&#39; }, plugins:[new HtmlWebpackPlugin()], mode:&quot;development&quot;, } moduleLoader让Webpack能够去处理那些非JavaScript文件（Webpack自身只理解JavaScript/json） module.exports={ entry:&quot;./src/js/index.js&quot;, output:{ filename:&quot;js/[name].js&quot;, path:Resolve(__dirname,&quot;build&quot;) }, module:{ //loader配置 rules:[ { test:/\.js$/, //多个loader用use use:[,] //单个loeader用loader //loader:&quot;&quot; //排除node_modules下的js文件 exclude:/node_modules/, //只检查src下的js文件 include:resolve(__dirname,&quot;src&quot;), //优先执行 pre 延后执行 post 默认无顺序 enforce:&quot;post&quot;, //配置属性 options:{} }, { //以下配置只会执行一个 oneOf:[] } ] } plugins:[new HtmlWebpackPlugin()], mode:&quot;development&quot;, } resolvemodule.exports={ entry:&quot;./src/js/index.js&quot;, output:{ filename:&quot;js/[name].js&quot;, path:Resolve(__dirname,&quot;build&quot;) }, module:{ rules:[] } plugins:[new HtmlWebpackPlugin()], mode:&quot;development&quot;, //解析模块的规则 resolve:{ //配置解析模块路径别名，vue里面的@，避免使用../../../过多的情况 //优点 简写路径 缺点 路径没有提示 alias:{ @:resolve(__dirname,src/css) }, //配置省略文件路径的后缀名 extensions:[&#39;.js&#39;,&#39;.json&#39;], //告诉webpack解析模块是去找哪个目录 //可以直接写出找的路径，也可以仅写文件名一层一层去找 modules:[resolve(__dirname,&quot;../../node_modules&quot;),&#39;node_modules&#39;] } } devServerdev是develop的简写，用于开发坏境 利用devServer快速开启一个服务器。 只有在通过devServer启动webpack时，配置文件里的devServer才会生效，因为这些参数所对应的功能都是devServer提供的，webpack本事并不认识devServer的配置项。 module.exports={ entry:&quot;./src/js/index.js&quot;, output:{ filename:&quot;js/[name].js&quot;, path:Resolve(__dirname,&quot;build&quot;) }, module:{ rules:[] } plugins:[new HtmlWebpackPlugin()], mode:&quot;development&quot;, resolve:{}, devServer:{ //运行代码的目录 contentBase:resolve(__dirname,&#39;build&#39;), //监视contentBase目录下的所有文件，一旦文件发生变化就会reload watchContentBase:true, //监视文件的一些配置 watchOptions:{ //忽略文件 ignored:/node_modules/, }, //启动gzip的压缩 compress:true, //端口,域名 port:5000, host:&#39;localhost&#39;, //自动打开浏览器 open:true, //开启HMR功能 hot:true, //不显示启动服务器日志信息 clientLogLevel:&quot;none&quot;, //除了一些基本启动信息以外，其他内容都不显示 quiet:true, //如果出错了，不要全屏提示 overlay:false, //浏览器和代理服务器没有跨域问题，和服务器有跨域问题，通过代理服务器转发 //服务器代理 --&gt; 解决开放环境跨域问题 proxy:{ //一旦devServer(5000)接收到/api/xxx的请求，就会把请求转发到另外一个服务器(3000) &#39;/api&#39;:{ target:&#39;http://localhost:3000&#39;, //发送请求时，请求路径重写：将/api/xxx --&gt; /xxx pathRewrite:{ &quot;^/api&quot;:&#39;&#39; } } } } } optimization用于生产环境 module.exports={ entry:&quot;./src/js/index.js&quot;, output:{ filename:&quot;js/[name].[contenthash:10].js&quot;, path:Resolve(__dirname,&quot;build&quot;), chunkFilename:&#39;js/[name].[contenthash:10]_chunk.js&#39; }, module:{ rules:[] } plugins:[new HtmlWebpackPlugin()], mode:&quot;production&quot;, resolve:{ }, optimization:{ splitChunk:&#39;all&#39;, //以下为默认值 //分割的chunk最小为30kb minSize:30 * 1024, maxSize:0, //最大没有限制 minChunks:1, //要提取的chunk最少被引用一次 maxAsyncRequests:5,//按需加载时并行加载的文件的最大数量 maxInitialRequests:3,//入口js文件最大并行请求数量 automaticNameDelimiter:&quot;~&quot;,//名称连接符 name:true, //可以使用命名规则 cacheGroups:{ //分割chunk的组 vendors:{ //node_modules文件会被打包到vendors组的chunk中 --&gt;vendors~xxx.js //上面的规则对分组里的都生效 test:/[\\/]node_modules[\\/]/, //优先级 priority:-10 }, default:{ //要提取的chunk最少被引用2次 minChunks:2, priority:-20, //如果当前要打包的模块，和之前已经被提取的模块是同一个，直接复用不用重新打包模块 reuseExistingChunk:true } }, //将当前模块记录其他模块的hash单独打包为一个文件runtime //解决缓存失效的问题 runtimeChunk:{ name: entrypoint =&gt; `runtime-${entrypoint.name}` }, //配置生成环境的压缩方案:js和css minimizer:[ //需要下载引入 new TerserWebpackPlugin({ //开启缓存 cache:true, //开启多进程打包 parallel:true, //启动source-map sourceMap:true }) ] } } 存在问题使用contenthash，当index.js动态引入a.js打包成两个chunk，输出的main.js中记录了a.js的hash值，所以a变化时重新打包时hash变化，main.js也会变会重新打包。导致缓存失效。 解决办法：设置runtimeChunk]]></content>
      <categories>
        <category>前端</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack优化配置]]></title>
    <url>%2F2020%2F07%2F10%2Fwebpack%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[开发环境性能优化 优化打包构建速度 HMR 只重新构建发生变化的模块 优化代码调试（错误在哪里） source-map 生产环境优化 优化打包构建速度 oneOf 找到一个loader就不会继续遍历了 babel缓存 第二次构建时，会读取之前的缓存，只重新构建变化的文件 多进程打包 externals 让某些库不打包，通过link引入 dll 让某些库不打包（把库单独先打包好），后面直接用 代码分为node_modules别人的库，和源代码，源代码可以通过import拆分打包，node_modules可以通过dll拆分打包 优化代码运行的性能 缓存（hash-chunkhash-contenthash） tree shaking 去掉没有使用的代码 code split 代码分割 懒加载/预加载（js代码） pwa 离线也可以访问 开发环境性能优化HMR：hot module replacement 热模块替换，作用：一块发生变化，只会重新打包这一个模块（而不是打包所有模块）HTML文件：默认不使用HMR功能，同时会导致问题：html文件不能热更新了。解决办法:修改entry入口，将html文件引入之后html可以热更新了，但是仍然不能使用HMR功能。（html不用做HMR功能）样式文件：可以使用HMR功能是因为style-loader内部实现了，所以在开发环境可以使用style-loader，而在生产环境为了把 css单独提取成一个文件就不使用了。js文件：默认不能使用HMR功能–&gt;需要修改js代码，添加支持HMR功能的代码。（不适用过于麻烦） module.exports={ entry:[&quot;./src/js/index.js&quot;,&quot;./src/index.html&quot;] .... devServer:{ contentBase:resolve(__dirname,&quot;build&quot;), compress:true, port:3000, open:true, //开启HMR功能 //当修改webpack配置，新配置想要生效，必须重启服务器。 hot:true } } source-map：提供源代码到构建后代码映射的技术，如果构建后代码出错了，会通过映射追踪到源代码错误。 [inline-|hidden-|eval-][nosources-][cheap-[module]]source-mapsource-map：外部，错误代码准确信息和可以追踪源代码的错误位置。inline-source-map:内联，只生成一个内联的source-map，错误代码准确信息，可以追踪源代码的错误位置。hidden-source-map:外部，错误代码错误原因，不能追踪到源代码的错误，只能提示到构建后代码的错误位置。eval-source-map:内联，每一个文件都生成对应的source-map，错误代码准备信息和可以追踪源代码的错误位置。nosources-source-map:外部，错误代码准确信息，但是查看不了源代码。cheap-source-map：外部，错误代码准确信息可以追踪源代码的错误位置，只精确到行，精确不到列。cheap-module-source-map：外部，错误代码准确信息可以追踪源代码的错误位置，module会将loader的source map加入内联和外部的区别：1.外部生成了文件，内联没有（直接在生成的输出js中） 2.内联构建速度快3.内联会让体积变得非常大，所以在生成环境不适用内联。 推荐开发坏境：速度快，调试更友好。 速度快(eval&gt;inline&gt;cheap&gt;…)eval-cheap-source-map&gt;eval-source-map.. 调试友好 source-map cheap-module-source-map 一般使用：eval-source-map 生成环境：源代码要不要隐藏？调试要不要更友好？ 源代码隐L藏：hidden-source-map（只隐藏源代码，会提示构建后代码的错误信息） nosources-source-map（全部隐藏） 一般使用source-map module.exports = { ..... //devtool:&quot;source-map&quot; devtool:&quot;inline-source-map&quot; } 生产环境性能优化oneOf：oneOf以下的loader只会匹配一个，一旦匹配到，则不会在继续匹配下面的loader了。不能有两个配置处理同一种类型的文件，所以之前的两个js处理loader需要有一个放在外部。 module.exports = { module:{ rules:[ {eslint...}, { oneOf:[{...},{另外一个js...}...] } ] } } babel缓存：第二次构建时，会读取之前的缓存，只重新构建变化的文件。文件资源缓存：输出的文件(没使用hash)，缓存在浏览器，一定时间内不会重新获取。1.hash:输出文件后面加上hash值（所有文件相同），这样在缓存期如果hash值变化（每次打包都会变化）都会重新获取。存在问题：重新打包就会改变hash，即使没有修改的文件。2.chunkhash：根据chunk生成的hash值，如果打包来源于同一个chunk，那么hash就一样。存在问题css与js的hash值一样，因为css被打包进了js，所以同属于一个chunk。修改项目的文件，只有这个文件和于这个文件相关联的打包文件的hash码变化（css和js还是相同），其他的不变。3.contenthash：根据文件的内容生成hash值，不同文件的hash值不一样。内容变化hash值才改变。 output:{ filename:&quot;js/built.[hash:10].js&quot; //filename:&quot;js/built.[chunkhash:10].js&quot; } //兼容性处理 { test:/\.js$/, exclude:/node_modules/, loader: &quot;babel-loader&quot;, options: { presets:[ &quot;@babel/preset-env&quot;, { useBuiltIns:&quot;usage&quot;, corejs:{version:3}, targets:{ chrome:&quot;60&quot;, } } ], //开启babel缓存 cacheDirectory:true } }, tree shaking：去除没有使用的代码，减少代码体积前提：必须使用ES6模块化且开发环境 在package.json中配置”sideEffects”:false所有代码都可以进行tree shaking，但是有些版本可能会把css文件删掉，所以最好配置”sideEffects”:[“*.css”] code split代码分割拆分文件按需加载 //第一种多入口页面 module.exports={ entry:{ //多入口：有一个入口，输出就有一个bundle main:&quot;./src/js/index.js&quot;, test:&quot;./src/js/test.js&quot; }, output:{ //[name]去入口文件的文件名 filename:&quot;js/[name].[contenthash:10].js&quot;, path:Resolve(__dirname,&quot;build&quot;) }, plugins:[...], mode:&quot;production&quot;, } //第二种配置splitChunks module.exports={ entry:&quot;./src/js/index.js&quot;, output:{...}, plugins:[...], /* 1.可以将node——mudules中代码单独打包成一个chunk输出 2.会自动分析多入口chunk中，有没有公共的文件，如果有会打包成单独的一个chunk不会重复打包 */ optimization:{ splitChunks:{ chunks:&quot;all&quot; } }, mode:&quot;production&quot;, } //第三种通过js代码，让某个文件被单独打包成一个chunk //import动态导入语法能将某个文件单独打包,添加该注释可以设置打包的名字 //单页面常用这种方法 import(/* webpackChunkName:&quot;test&quot; */ &quot;./test&quot;).then().catch() 懒加载和预加载懒加载当文件需要用时才加载预加载等其他资源加载完毕，浏览器空闲了，在偷偷加载资源，ie会有兼容性问题正常加载可以认为是并行加载，同时加载多个文件 //懒加载，当文件需要用时才加载 //仅在点击按钮之后再加载，第二次加载直接从缓存中读取 document.getElementById(&quot;btn&quot;).onclick=function(){ import(&quot;./test&quot;).then().catch } //预加载,会提前加载在浏览器 document.getElementById(&quot;btn&quot;).onclick=function(){ import((/* webpackChunkName:&quot;test&quot;,webpackPrefetch:true */&quot;./test&quot;).then().catch } PWAPWA 逐进式网络开发应用程序，离线课访问 workbox –&gt; workbox-weboack-plugin //安装 npm i workbox-weboack-plugin //引入清除文件插件 const WorkboxWeboackPlugin = require(&#39;workbox-weboack-plugin&#39;); plugins:[ new WorkboxWeboackPlugin.GenerateSW({ /* 1.帮助serviceworker快速启动 2.删除旧的serviceworker 生成一个serviceworker配置文件， */ clientsClaim:true, skipWaiting:true }) ] //一般在index.js里面注册serviceworker //——————————indexjs //注册serviceworker //处理兼容性问题 if(&quot;serviceWorker&quot; in navigator){ window.addEventListener(&quot;load&quot;,()=&gt;{ navigator.serviceWorker.register(&#39;/service-worker.js&#39;) .then(()=&gt;{}) .catch(()=&gt;{}) }) } 可能出现的问题1.eslit不认识window、navigator全局变量解决：需要修改package.json中eslintConfig配置 &quot;env&quot;:{ &quot;browser&quot;：true //支持浏览器端全局变量 } 2.sw代码必须运行在服务器上npm i serve -gserve -s build 启动服务器，将build目录下所有资源作为静态资源暴露出去 externalsexternals拒绝打包某资源，自己手动引入 module.exports={ entry:&quot;./src/js/index.js&quot;, output:{...}, plugins:[...], mode:&quot;production&quot;, externals:{ //库名 -- npm包名 //想使用link在html中引入，拒绝jQuery被打包进来，拒绝被打包时需要手动引进来 jquery:&#39;jQuery&#39; } } DLL使用dll技术，对某些库（第三方）进行单独打包当运行webpack时，默认查找webpack.config.js 配置文件需求：需要运行wbpack.dll.js文件–&gt; webpack –config webpack.dll.js //————————webpack.dll.js const{ resolve } =require(&quot;path&quot;); const webpack = require(&quot;webpack&quot;); module.exports = { entry:{ //最终打包生成的name为属性名，属性值为要打包的库 jquery:[&#39;jquery&#39;] }, output:{ filename:&#39;[name].js&#39;, path:resolve(__dirname),&#39;dll&#39;, library:&quot;[name]_[hash]&quot; //打包的库里面向外暴露出去的内容叫什么 }, //以上内容专门用于打包jquery plugins:[ //打包生成一个 manifest.json --&gt; 提供和jquery映射 new webpack.DllPlugin( name:&#39;[name]_[hash]&#39;,//映射库的暴露的内容名称 path:resolve(__dirname,&quot;dll/manifest.json&quot;) //输出文件的路径 }) ] ， mode:&quot;production&quot; } 打包之后配置webpack.config.js,这样可以重复打包webpack.config.js时不再打包jquery库了 //-----webpack.config.js const webpack = require(&quot;webpack&quot;); const AddAssetHtmlWebpackPlugin = require(&quot;add-asset-html-webpack-plugin&quot;) .... //告诉webpack哪些库不参与打包，同时使用时的名称也要变 new webpack.DllReferencePlugin({ manifest:resolve(__dirname,&quot;dll/manifest.json&quot;) }), //将某个文件打包输出去，并在html中自动引入该文件 new AddAssetHtmlWebpackPlugin({ filepath:resolve(__dirname,&quot;dll/jquery.js&quot;) }) clean-webpack-pluginclean-webpack-plugin:在打包时，先删除原来的再进行打包新的。 //安装 npm i clean-webpack-plugin -D //引入清除文件插件 const CleanWebpackPlugin = require(&#39;clean-webpack-plugin&#39;); //使用 plugins:[ //匹配删除的文件 new CleanWebpackPlugin([ &#39;dist&#39;, //删除dist文件夹 &#39;build/*.*&#39;, //删除build文件夹下的所有文件 ],{ //下面可以省略 root: __dirname, //根目录 verbose: true, //开启在控制台输出信息 dry: false //启用删除文件 }), ]]]></content>
      <categories>
        <category>前端</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础（7.15更新）]]></title>
    <url>%2F2020%2F07%2F09%2FJavaScript%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[综述JavaScript（实现） = ECMAScript（标准） + DOM + BOM BOM是浏览器对象模型，用来获取或设置浏览器的属性、行为，例如：新建窗口、获取屏幕分辨率、浏览器版本号等。简单的说：bom是浏览器可视窗口操作DOM是文档对象模型，用来获取或设置文档中标签的属性，例如获取或者设置input表单的value值。 BOM的内容不多，主要还是DOM。 由于DOM的操作对象是文档（Document），所以dom和浏览器没有直接关系。 Window对象：是整个BOM的核心，所有对象和集合都以某种方式回接到window对象。Window对象表示整个浏览器窗口，但不必表示其中包含的内容。Document对象：实际上是window对象的属性。这个对象的独特之处是唯一一个既属于BOM又属于DOM的对象。 编写基本要求1.html不区别大小写，而JavaScript严格区别大小写2.如果不写分号，浏览器会自动添加，但是会消耗系统资源，所以开发中必须写分号3.JS中会忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化 基本语法 1.字面量与变量字面量：一些不可改变的值，可直接使用，比如：1 2 3 4 5 ，一般不用变量：变量可以保存字面量，且可以任意改变，所以一般用变量 2.标识符在JS中所有可以由我们自主命名，比如：变量名、函数名、属性名可以是字符、数字（不可开头）、__、$不可以是ES中的关键字或保留字标识符一般采用驼峰命名法 数据类型基本数据类型： Undefined、Null、Boolean、Number、String和Symbol(ES6)引用数据类型： Object(Array, Date, RegExp, Function) 基本数据类型栈内存中保存的是值，引用数据类型栈内存中保存的是堆内存的地址。 字符串中可以使用\进行转义字符 数字的最大值：Number.MAX_VALUE,最小正值：Number.MIN_VALUE超过最大值返回Infinity表示正无穷。NAN（类型仍然是number）是一个特殊的数字，表示NOT A NUMBER。JS进行浮点运算，可能得到一个不精确的结果（不要用JS进行对精确度比较高的运算） 注意：Null类型的值只有一个null，null专门用来表示为空的对象，所以使用typeof会返回ObjectUndefined类型的值只有一个undefined，当声明一个变量，但并不给变量赋值时返回undefined 强制类型转化主要指其他数据类型转换成String，Number，Boolean typeof 就是运算符，获得一个值的类型以字符串返回 转化成String：1.XXX.toString返回转换结果(null,undefined没有该方法)。2.调用String(需要转化的值)函数，对于Number和Boolean实际上调用的是toString方法，对于null/undefined直接转化为”null/undefined”。3.所以非数字类型的运算都转化成数字类型再运算，但是加法中的字符串除外，所以可以利用字符串拼串x+&quot;&quot;（技巧）， 转化成Number：1.调用Number(需要转化的值)函数，如果有非数字类容/undefined转换NaN，空串/null/false转换成0,true转换成12.对于字符串，parseInt():把一个字符串转换成整数,第二个参数可以指定数字的进制。parseFloat():把一个字符串转化成浮点数。非字符串将其转化成字符串再操作，返回转化结果。3.由于任何值做减法、乘法、除法运算时都会自动转化为Number，所以可以利用x - 0 转化为布尔值：1.调用Boolean(需要转化的值)函数：0、NaN、空串、null、undefined都是false2.两个取反操作可以转化成布尔值。 布尔值运算：&amp;&amp; js中的“与运算”属于短路的与，如果第一个值为false，则不会看第二个值。|| js中的“或运算”属于短路的或，如果第一个值为true，则不会检查第二个值。 对于非布尔值进行与或运算时，会将其转化成布尔值运算后返回原数值，结合短路原则分析返回的数值。 条件分支 switch switch(值，不会转化){ case 值: //switch判值,严格判等=== 代码块; break; default: 代码块; //类似else } switch(true){ //case可以为表达式 case score &gt;= 90 &amp;&amp; score &lt;100: alert(&quot;a&quot;) break; } break只会出现在switch和循环语句中，在switch中代表跳出switch语句，在循环中，会跳出离它最近的那一层循环。 continue与break continue:立刻结束本次循环，执行下次循环break:在循环中，跳出离它最近的整个循环 对象in 运算符“属性名” in 对象通过该运算符可以检查一个对象中是否含有指定的属性如果对象中没有但原型中有，也会返回true hasOwnProperty对象的hasOwnProperty来检查对象自身中是否含有该属性 比较两个引用数据类型时，比较的是内存地址。 let obj = new Object(); let obj2 = new Object(); obj.name = &quot;ranan&quot;; obj2.name = &quot;ranan&quot;; console.log(obj.name == obj2.name) //输出false 我们直接在页面中打印一个对象时，实际上是输出Object原型对象上的toString()的返回值。 在JS中拥有自动的垃圾回收机制，我们需要将不用的对象设置为null局部变量:函数执行完自动释放对象：成为垃圾对象，由垃圾回收器回收 Date对象 //返回的当前代码执行的时间 new Date() //需要在构造函数中传递一个表示时间的字符串作为参数 let d = new Date(&quot;12/03/2016 11:10:30&quot;) //获得当前的日期 d.getDate() //0表示周日 d.getDay() //0表示1月 d.getMonth() //获得当前对象的时间戳，从1970.1.1 0 0 0 到当前日期的毫秒数 d.getTime() //获得当前的时间戳 Date.new() Math对象但是它不是构造函数，仅做工具使用 Math.ceil(1.5) //2 向上取整 Math.floor(1.5) //1 向下取整 Math.round(1.4) //1 四舍五入 //0~1的随机数 //生成一个0-y之间的随机数 Math.round(Math.random()*y) //生成一个x-y之间的随机数Math.round(Math.random*(y-x)+x) Math.random() //获取多个数中的最大值 Math.max(10,20,52) //返回值为最大值 包装类JS中提供让那个了三个包装类，通过三个包装类可以将基本数据类型转为对象 String() 可以将基本数据类型字符串转化成String对象Number() 可以将基本数据类型数字转化成Number对象Boolean() 可以将基本数据类型布尔值转化成Boolean对象 方法和属性只能添加给对象，不能添加给基本数据类型。包装类的作用：当我们对一些基本数据类型的值去调用属性和方法时，浏览器会临时使用包装类将其转换成对象，调用完了在转化回来。 函数函数也是一个对象 使用函数声明来创建一个函数，调用函数时解析器不会检查实参的类型与数量。在调用函数时，浏览器每次都会传递进两个隐含的参数1.函数的上下文对象 this2.封装实参的对象 arguments 是一个类数组对象/有length、可以通过索引操作的对象 补充:arguments.callee()方法的意思是：调用函数本身。 function fun(){ arguments.callee()//调用fun函数本身 return ;//返回值，执行了后面的代码将不会执行，默认返回undefined } //匿名函数赋值形式，最好叫上分号 let fun = function{}; //第一个括号是表示这个函数是一个整体 框起来，第二个括号表执行。 (function(){})() return 可以结束整个函数，后面的代码将不会被执行。 构造函数 构造函数习惯首字母大写，构造函数通过new构造。构造函数也被成为类，通过构造函数创建的对象称为实例 new在执行时完成的4件事情：1.在内存中创造一个新的空对象,在堆内存中分配空间2.让this指向这个新的对象3.执行构造函数里面的代码，给这个新对象添加属性和方法4.返回这个新对象(所以构造函数里面不需要return) instanceof对象 instanceof Person通过instanceof可以检查一个对象是否一个类的实例所有的对象都是Object的后代 构造函数使用的优化构造函数方法存在浪费内存的问题，在构造函数中的复杂数据类型（比如函数），实例化对象的时候，会专门开辟一个空间来存放。那么当实例对象过多的时候，就会开辟更多的空间来存放。解决办法:将共享的方法在全局作用域中定义存在的问题：将函数定义在全局作用域，污染了全局作用域的命名空间并且不安全。解决办法:当我们希望所有的对象使用同一个函数时，最好使用prototype，这也是为什么方法一般定义在原型中，属性一般通过构造函数定义在对象本身。原型 数组数组也是一个对象 naw Array(10)//创建一个长度为10的数组 arr = [[1,2,3],[4,5,6]] //二维数组] //向数组的末尾添加数据，返回值为新数组的长度 arr.push(&quot;添加的元素&quot;,&quot;添加的元素2&quot;) //删除数组的最后一个元素，返回值为被删除的元素 arr.pop() //向数组的开头添加一个或多个元素，返回值为新数组的长度 arr.unshift(&quot;添加的元素&quot;,&quot;添加的元素2&quot;) //删除数组的第一个元素，返回值为被删除的元素 arr.shift() JSONjs中的对象只有JS自己支持,其他的语言都不认识，可以转换成任何语言都认识的字符串。JSON就是一个特殊格式的字符串，并可以转换成任意语言中的对象。JSON分为对象、数组 ‘{“属性名”：”属性值”}’ ‘[“值”]’ 对象的属性名一定要加引号JSON允许的值字符串、数值、布尔值、null、普通对象、数组 JSON.parse(json字符串) JSON字符串转换为JS中的对象返回JSON.stringify(js对象) JS对象转换为JSON字符串 eval() 这个函数可以用来执行一段字符串形式的JS代码，并将结果值返回，如果执行的字符串中含有{},它会将{}当成代码块，需要给字符串加()。此方法常用于IE7以下JSON失效的情况，此方法不要使用性能比较差并且不安全。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack基本配置]]></title>
    <url>%2F2020%2F07%2F09%2Fwebpack%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[综述Webpack是一种前端资源构建工具，一个静态模块打包器。将根据模块的依赖关系进行静态分析，打包生成对应的静态资源（bundle） Webpack五个核心概念 Entry:入口指示Webpack以哪个文件为入口起点开始打包，分析构建内部依赖图。 Output:输出指示Webpack打包后的资源bundles输出到哪里去，以及如何命名。 Loader:Loader让Webpack能够去处理那些非JavaScript文件（Webpack自身只理解JavaScript/json） Plugins:插件可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等。 Mode:模式指示Webpack使用相应模式的配置 development：能让代码本地调式运行的环境 production：能让代码优化上线运行的环境 开发环境示例：webpack.config.js /* 开发环境配置，能让代码运行起来 */ /* webpack.config.js webpack的配置文件 作用：当运行webpack指令时，会加载里面的配置，打包结果会输出出去 所有的构建工具都基于nodejs平台运行的，模块化默认采用commonjs */ /* loader：1.下载 2.配置（使用） plugins：1.下载 2.引入 3.使用 */ //resolve用来拼接绝对路径的方法 const {resolve} = require(&quot;path&quot;) //引用处理html的插件 const HtmlWebpackPlugin =require(&quot;html-webpack-plugin&quot;); module.exports = { //webpack配置 //入口起点 entry: &#39;./src/index.js&#39;, //输出是对象 output:{ //输出文件名 filename: &quot;js/built.js&quot;, //输出路径 //__dirname是nodejs的变量，代表当前文件的文件夹绝对路径 path:resolve(__dirname,&quot;build&quot;) }, //loader配置 module:{ rules:[ //详细loader配置 //不同文件配置不同loader处理 { //匹配哪些文件,以.css结尾的文件 test:/\.css$/, //使用哪些loader进行处理 use:[ //use数组中loader执行顺序：从后往前 //创建style标签，将js中的样式资源插入进行，添加到head中生效 &quot;style-loader&quot;, //将css文件变成commonjs模块加载js中，里面内容是样式字符串，所以css文件不会单独输出 &quot;css-loader&quot; ] }, { test:/\.less$/, use:[&quot;style-loader&quot;, &quot;css.loader&quot;, //将less文件编译成css文件 //需要下载less-loader和less &#39;less-loader&#39; ] }, //打包其他资源（除了html/js/css资源以外的资源） //字体不建议这种写法，因为需要排除的东西过多 { //排除css、js、html以外的资源 exclude:/\.(css|js|html|less|jpg|png|gif)$/, loader:&quot;file-loader&quot; options:{ name:&quot;[hash:10].[ext]&quot; } } //处理图片资源 { //问题：处理html中的img图片 test:/\.(jpg|png|gif)$/, //使用一个loader时，可直接用loader引用，不用use, loader: &quot;url-loader&quot;, options: { //图片大小小于8kb，就会被base64处理 //优点：减少请求数量（减轻服务器压力） //缺点：图片体积会更大（文件请求速度更慢） limit:8*1024, //问题：因为url-loader默认使用es模块化解析，而html-loader引入图片是commonjs //解析时会出现问题：[object Module] //解决：关闭url-loader的es模块化，使用commonjs解析 esModule:false, //打包之后文件名的hash值取10位，保持原来的后缀名 name:&quot;[hash:10].[ext]&quot;, //设置图片的输出路径 outputPath:&quot;imgs&quot; } }, { //处理html文件的img图片（负责引入img，从而能被url-loader进行处理） test:/\.html$/, loader:&quot;html-loader&quot; } ] }, //plugins的配置 plugins: [ //html-webpack-plugin 处理html资源 //功能：默认会创建一个空的HTML，自动引入打包输出的所有资源（js/css） // new HtmlWebpackPlugin() //需求：需要有结构的HTML文件 new HtmlWebpackPlugin({ //复制&quot;./src/index.html&quot;,并自动引入打包输出的所有资源（js/css） template:&quot;./src/index.html&quot; }) //详细pulgins的配置 ], //模式 mode:&#39;development&#39; // mode:&quot;production&quot; //启动devServer指令为：npx webpack-dev-server（需要安装对应的包） //localhost:3000本地服务器查看 devServer:{ //构建后的路径 contentBase:resolve(__dirname,&quot;build&quot;), //启动gzip压缩，使代码体积更小，运行更快。 compress:true, //指定开发服务器的端口号 port:3000, //自动打开默认浏览器 open:true } } 总结： module-&gt;rules-&gt;use 数组(使用多个loader)是从后往前执行的，使用一个可以直接用loader loader：①下载 ②配置（使用），plugins：①下载 ②引入 ③使用。 url-loader可以用于图片和字体 webpack需要实时打包，可使用开发服务器devServer实现自动化。 因为url-loader默认使用es模块化解析，而html-loader解析html中的图片的解析是commonjs。所以需要在url-loader中的选项配置中使用esModule:false关闭默认的es模块解析 devServer开发服务器 devServer用来实现自动化，比如自动编译，自动打开浏览器，自动刷新浏览器。只会在内存中编译打包，不会有任何输出文件，比如删除build后，使用devServer不会输出新的build文件。相当于打包后放在本地服务器上运行。 生产环境mini-css-extract-plugin插件打包过后的css在js文件里，通过下面的插件可以把css单独抽出来。 //安装 npm i mini-css-extract-plugin -D //引入 const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;) //loader配置 module:{ rules:[ { test:/\.css$/, use:[ //创建style标签，将js中的样式资源插入进行，添加到head中生效 //&quot;style-loader&quot;, //作用：提取js中的css成单独文件 MiniCssExtractPlugin.loader &quot;css-loader&quot; ] }, ]} plugins:[ new MiniCssExtractPlugin({ //输出的css文件重新命名 filename:&#39;css/built.css&#39; }) ] 以上的写法有一个问题是css如果中有文件，需要在该插件的publicPath中重新配置文件路径。 { loader:MiniCssExtractPlugin.loader, options:{ // 这里可以指定一个 publicPath // 默认使用 webpackOptions.output中的publicPath publicPath: &#39;../&#39; } css兼容与压缩css兼容性处理：postcss –&gt; postcss-loader postcss-preset-env（在webpack中使用） //安装 npm i postcss-loader postcss-preset-env -D //使用 module:{ rules:[ { test:/\.css$/, use:[ MiniCssExtractPlugin.loader //使用loader的默认配置的写法 &quot;css-loader&quot; //修改loader的配置写法 { loader:&quot;postcsss-loader&quot; options:{ ident:&quot;postcsss&quot; plugins:()=&gt;[ //返回一个数组 postcss的插件 //此插件帮助postcss找到package.json中browserslist里面的配置，通过配置加载指定的css兼容性样式，默认找的是browerslist里面的生产环境 //如果要找开发环境的，就需要在webpack.config.js中设置node.js坏境变量process.env.NODE_ENV=&quot;development&quot; require(&quot;postcss-preset-env&quot;)() ] } } ] }, ]} //====================package.json &quot;browserslist&quot;:{ &quot;development&quot;:[ //兼容最近的chrome版本 &quot;last 1 chrome version&quot; ] &quot;production&quot;:[ &quot;&gt;0.2%&quot;,//兼容98%的浏览器 &quot;not dead&quot;,//已经死了的浏览器 &quot;not op_mini all&quot; ] } css压缩插件：optimize-css-assets-webpack-plugin //安装插件 npm i optimize-css-assets-webpack-plugin -D //引用 const OptimizeCssAssetsWebpackPlugin = require(&quot;optimize-css-assets-webpack-plugin&quot;) //使用 plugins:[{ //压缩css，默认配置已经可以解决问题了。 new OptimizeCssAssetsWebpackPlugin() }] js语法检查与兼容性语法检查：eslint-loader eslint注意：只检查自己写的js源代码，第三方的库是不用检查的设置检查规则：在package.json中eslintConfig中设置推荐使用airbnb规则： eslint eslint-plugin-import eslint-config-airbnb-base //新版在根目录创建.eslintrc //老版本 { test:/\.js$/, loader:&quot;eslint-loader&quot;, //一定要排除 exclude:/node_modules/, options:{ //自动修复eslint错误 fix:true } } //===========package.json &quot;eslintConfig&quot;:{ &quot;extends&quot;:&quot;airbnb-base&quot; } 兼容性处理：babel-loader @babel/preset-env @babel/core基本的js兼容性处理 –&gt; @babel/preset-env 问题：只能转换基本语法，promise不能全部js兼容性处理 –&gt; @babel/polyfill 被弃用，体积还会变大。需要做兼容行处理的就做：按需加载 –&gt;corejs { test:/\.js$/, //一定要排除 exclude:/node_modules/, loader:&quot;babel-loader&quot;, options:{ //预设:指示babel做什么样的兼容性处理 presets:[&quot;@babel/preset-env&quot;] } } //========corejs npm i core-js -D //配置 presets:[ [&quot;@babel/preset-env&quot;, { //按需加载 useBuiltIns:&quot;usage&quot;, //指定core-js版本 corejs:{ version:3 }, //指定兼容性做到哪个版本浏览器 targets:{ chrome: &quot;60&quot;, firefox:&quot;60&quot;, ie:&quot;9&quot; } } ]] js压缩与html压缩 //生产坏境下自动压缩js mode:&quot;production&quot;, new HtmlWebpackPlugin({ //复制&quot;./src/index.html&quot;,并自动引入打包输出的所有资源（js/css） template:&quot;./src/index.html&quot; //压缩html代码 minify:{ //移除空格 collapseWhitespace:true, //移除注释 removeComments:true } }) 生产环境的基本配置正常来讲，一个文件只能被一个loader处理，当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序:先执行eslint,在执行babel。 const {resolve} = require(&quot;path&quot;) //用于将css从js中抽离成单独文件 const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;) //css兼容 const OptimizeCssAssetsWebpackPlugin= requir(&quot;optimize-css-assets-webpack-plugin&quot;) const HtmlWebpackPlugin= require(&quot;html-webpack-plugin&quot;) //css兼容 const commonCssLoader = [ { loader:MiniCssExtractPlugin.loader, options:{ publicPath: &#39;../&#39; } }, &quot;css-loader&quot;, { //兼容性,还需要在package.json中定义browserslist loader: &quot;post-loader&quot;, options: { ident:&quot;postcss&quot;, plugins:()=&gt;[ require(&quot;postcss-preset-env&quot;)() ] } } ] module.exports={ entry:&quot;./src/js/index.js&quot;, output: { filename: &quot;js/built.js&quot;, path: resolve(__dirname,&quot;build&quot;) }, module: { rules: [ { test:/\.css$/, use:[...commonCssLoader] }, { test:/\.less$/, use:[...commonCssLoader, &quot;less-loader&quot;] }, //配置eslint { //在package.json中eslintCofig中配置--&gt;airbnb //npm install -D eslint eslint --init可以按需配置eslint test:/\.js$/, exclude:/node_modules/, //设置优先执行。 enforce: &quot;pre&quot;, loader: &quot;eslint-loader&quot;, options: { fix:true } }, //兼容性处理 { test:/\.js$/, exclude:/node_modules/, loader: &quot;babel-loader&quot;, options: { presets:[ &quot;@babel/preset-env&quot;, { useBuiltIns:&quot;usage&quot;, corejs:{version:3}, targets:{ chrome:&quot;60&quot;, } } ] } }, { test:/\.(jpg|png|gif)/, loader: &quot;url-loader&quot;, options: { limit:8*1024, name:&quot;[hash:10].[ext]&quot;, outputPath:&quot;imgs&quot;, esModule:false } }, { test:/\.html$/, loader: &quot;html-loader&quot; }, { exclude:/\.(js|css|less|html|jpg|png|gif)/, loader: &quot;file-loader&quot;, options: { outputPath:&quot;media&quot; } } ] }, plugins: [ new MiniCssExtractPlugin({ filename:&quot;css/built.css&quot; }), //只需要调用 new OptimizeCssAssetsWebpackPlugin(), new HtmlWebpackPlugin({ template:&quot;./src/index.html&quot;, minify:{ collapseWitespace:true, removeComments:true } }) ], mode: &quot;production&quot; }]]></content>
      <categories>
        <category>前端</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Less学习笔记]]></title>
    <url>%2F2020%2F07%2F08%2Fless%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[less less属于css的一种预处理器处理在浏览器运行前, 作为css的扩展、增强版，是一种动态样式语言。 注释 //less中的单行注释，不会被编译到css文件中，以/ /注释的内容会被编译到css文件 less嵌套规则 和html结构相似，层层嵌套&amp; 代表的上一层选择器的名字 /* Less */ #header{ &amp;:after{ content:&quot;Less is more!&quot;; } .title{ font-weight:bold; } &amp;_content{//理解方式：直接把 &amp; 替换成 #header margin:20px; } &gt; .title{ font-weight:bold; } } /* 生成的 CSS */ #header::after{ content:&quot;Less is more!&quot;; } #header .title{ //嵌套了 font-weight:bold; } #header_content{//没有嵌套！ margin:20px; } #header &gt; .title{ //嵌套了 font-weight:bold; } less的继承extend 是 Less 的一个伪类。它可继承 所匹配声明中的全部样式。extend（这里放规则）是一个函数 /* Less */ //规则的定义，没有参数 .animation{ transition: all .3s ease-out; .hide{ transform:scale(0); } } #main{ &amp;:extend(.animation); } #con{ &amp;:extend(.animation .hide){ color:red; } } /* 生成后的 CSS */ .animation,#main{ transition: all .3s ease-out; } .animation .hide , #con{ transform:scale(0); } #con{ color:red } 更简单的写法 .p1 { width:100px } .p2{ //相当于复制p1，性能不太好 p1(); } all全局搜索替换使用选择器匹配到的 全部声明。 /* Less */ #main{ width: 200px; } #main { &amp;:after { content:&quot;Less is good!&quot;; } } #wrap:extend(#main all) {} /* 生成的 CSS */ #main,#wrap{ width: 200px; } #main:after, #wrap:after { content: &quot;Less is good!&quot;; } 从表面 看来，extend 与 方法 最大的差别，就是 extend 是同个选择器共用同一个声明，而 方法 是使用自己的声明。 ~”XXXXX” less之中避免编译，让浏览器编译 变量 以 @ 开头定义变量，使用是直接 @定义的名称 变量做类名使用时必须在@后使用大括号包裹 声明变量（类比于写好的css引用）类似于混合方法 结构: @name: { 属性: 值 ; }; 使用：@name(); 使用@来申明一个变量: @pink:pink //不要添加引号 作为普通属性值只是来使用：直接使用@pink 作为选择器和属性名: @{selector的值}的形式（不常用） 作为URL：@{url} （@images:’../img’ 注意要加引号） 变量的延迟加载（一个块级域解析完再加载变量） /* Less */ @color: #999; @bgColor: skyblue;//不要添加引号 @width: 50%; #wrap { color: @color; width: @width; } /* 选择器变量 */ @mySelector: #wrap; @Wrap: wrap; @{mySelector}{ //变量名 必须使用大括号包裹 color: #999; width: 50%; //如果继承width的值可以直接用$width height: $width; } .@{Wrap}{ color:#ccc; } #@{Wrap}{ color:#666; } /* url 变量*/ @images: &quot;../img&quot;;//需要加引号 body { background: url(&quot;@{images}/dog.png&quot;);//变量名 必须使用大括号包裹 } /* 声明变量 */ @background: {background:red;}; #main{ @background(); } @Rules:{ width: 200px; height: 200px; border: solid 1px red; }; #con{ @Rules(); } /* 生成的 CSS */ #main{ background:red; } #con{ width: 200px; height: 200px; border: solid 1px red; } 变量的运算 注意点： 加减法时，以第一个数据的单位为基准 乘除法时，注意单位一定要统一 less中的混合 混合：将一系列的规则集引入另一个规则集中。 类名后面不添加括号，这个样式会在css编译出来并且作用到该类名上。 类名后面添加了括号之后就不是一个选择器了，只是创建了一个mixins，专门给别人用的。 混合使用 . 或 # 的形式来定义；声明变量使用的是 @ 来定义，@变量名（）来使用 普通混合 /* Less */ .card { // 等价于 .card() background: #f6f6f6; -webkit-box-shadow: 0 1px 2px rgba(151, 151, 151, .58); box-shadow: 0 1px 2px rgba(151, 151, 151, .58); } #wrap{ .card;//等价于.card(); } //其中 .card 与 .card() 是等价的。 带参数的混合 注意点： Less 可以使用默认参数，如果没有传参数，那么将使用默认参数。冒号后面的是默认值 @arguments代表全部参数，实参列表 传的参数中必须带单位，且按顺序，如果不按顺序，需要在参数中带上参数名类似@width:100px /* Less */ .border(@a:10px,@b:50px,@c:30px,@color:#000){ border:solid 1px @color; box-shadow: @arguments;//指代的是 全部参数 } #main{ .border(0px,5px,30px,red);//必须带着单位 } #wrap{ .border(0px); } /* 命名参数 */ #wrap{ .border(@color:black); } #content{ .border;//等价于 .border() } /* 生成的 CSS */ #main{ border:solid 1px red; box-shadow:0px,5px,30px,red; } #wrap{ border:solid 1px #000; box-shadow: 0px 50px 30px #000; } #content{ border:solid 1px #000; box-shadow: 10px 50px 30px #000; } 匹配模式注意点： 第一个参数 left 要会找到方法中匹配程度最高的，如果匹配程度相同，将全部选择，并存在着样式覆盖替换。 如果匹配的参数 是变量， @_ 表示的会被调用任意标志的 。 /* Less */ .triangle(top,@width:20px,@color:#000){ border-color:transparent transparent @color transparent ; } .triangle(right,@width:20px,@color:#000){ border-color:transparent @color transparent transparent ; } .triangle(bottom,@width:20px,@color:#000){ border-color:@color transparent transparent transparent ; } .triangle(left,@width:20px,@color:#000){ border-color:transparent transparent transparent @color; } .triangle(@_,@width:20px,@color:#000){ border-style: solid; border-width: @width; } #main{ .triangle(left, 50px, #999) } /* 生成的 CSS */ #main{ border-color:transparent transparent transparent #999; border-style: solid; border-width: 50px; } 方法的命名规范注意点： 在 CSS 中 &gt; 选择器，选择的是 儿子元素，就是 必须与父元素 有直接血源的元素。 在引入命令空间时，如使用 &gt; 选择器，父元素不能加 括号。 不得单独使用命名空间的方法 必须先引入命名空间，才能使用 其中方法。 子方法 可以使用上一层传进来的方法 /* Less */ #card(){ background: #723232; .d(@w:300px){ width: @w; #a(@h:300px){ height: @h;//可以使用上一层传进来的方法 width: @w; } } } #wrap{ #card &gt; .d &gt; #a(100px); // 父元素不能加 括号 } #main{ #card .d(); } #con{ //不得单独使用命名空间的方法 //.d() 如果前面没有引入命名空间 #card ，将会报错 #card; // 等价于 #card(); .d(20px); //必须先引入 #card } /* 生成的 CSS */ #wrap{ height:100px; width:300px; } #main{ width:300px; } #con{ width:20px; } //通过import引入其他的less文件 @import &quot;&quot;;]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>Less</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[meta标签]]></title>
    <url>%2F2020%2F07%2F08%2Fmeta%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[仅仅记录我已经使用过的，如果后续有使用过新的，会补充在文章中 meta标签主要用于设置网页中的一些元数据，元数据不是给用户看的。 charset 指定网页的字符集 name 指定数据的名称 content 指定的数据的内容 http-quiv 向浏览器传信息 keywords表示网站的关键字，搜索时用于识别。 description用于指定网站的描述，网站的描述会显示在搜索引擎的搜索结果中 补充：title标签的内容会作为搜索结果的超链接的文字显示 网页重定向，3秒后跳转到百度 viewport是HTML5新增的，常用于移动端。 width:可视区域的宽度，值可为数字或关键词device-width intial-scale:页面首次被显示是可视区域的缩放级别，取值1.0则页面按实际尺寸显示，无任何缩放 maximum-scale=1.0, minimum-scale=1.0;可视区域的缩放级别，user-scalable:是否可对页面进行缩放，no 禁止缩放]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《在线》阅读笔记]]></title>
    <url>%2F2020%2F06%2F23%2F%E3%80%8A%E5%9C%A8%E7%BA%BF%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[互联网的离线到在线，计算机到云计算，信息到数据是贯穿这本书的3个核心概念。王坚博士把在线定义为今天我们这个时代的关键词，读到后面的”互联网的渗透，让我们的生活在线了”让我对他的话有了一点理解和感悟。互联网的渗透，让我们的生活中的行为在互联网中进行实时反馈成数据，对数据进行分析与模拟，真正地利用数据做到更多的事情。互联网成为基础设施，数据成为生产资料，计算成为公共服务。互联网把万物、机器与人连接在一起，每一分钟每一秒都在产生新的资源，即数据。数据经由互联网的计算产生智能，进而推动科技，社会与生活的发展。数据其实不是一个新概念，新的是如何处理数据与利用数据。读这本书的时间太晚了，同时也被王坚博士对互联网科技未来发展的理解感到震惊。他的理解我现在读到的都可以说是正确，很难想象在以前是怎样的眼界能看到现在。希望这本书在之后能给我带来更多的惊喜，回忆以前，最开始好像频繁使用的是座机，拥有一个移动的手机好像也是一件很了不起的事情。再到零几年，手机开始慢慢流行，但手机的常用的功能只是止步与通信或者是离线的小说阅读，像电脑对于我来说好像是从来没有听过的事情。在后面，互联网突然超速前进，智能手机与网上冲浪的盛行开始让人们沉迷于在网络中接触到的新东西，那时候对于普通人来说最流行的还是社交与游戏。现在，互联网开始慢慢成为生活中必不可少的东西，各种传统行业的在线化，生活慢慢开始在线，离开网络似乎变成了一件很难实现的事情。我在不断的经历着在线带来的变化，也能很清晰的感受到网络时代的到来以及未来的发展一定离不开互联网。可是现在的经历很难让我在其中充当推动者的角色，哪怕是小小的一个推动者。经常会思考为什么会生活会这样变化?别人是怎么从中抓住机遇？以后到底会怎么样？我想不出结果，似乎也想不出自己的未来计划。是想要去接触更多的东西扩大眼界去做一个真正的对社会有用的人。如果仅仅有想法而不去做是很难把想法实际化的。我更像一个把自己圈在自己想法世界的人，有很多不足，也开始慢慢跨出那一步去改变自己这种状态。我希望渴望变得更好的愿望能促使我坚持下去。谷歌曾把惊人的计算能力成为‘云’，云计算的核心思想基础就是把计算成为一种公共服务。我理解的云计算像是电网一样的一个集中式计算的平台，可以随处接入随时使用与无限扩展。云计算并不是真正的把计算传回本地，而是把你的请求传回到云（数据中心），处理之后再把结果传回给你，计算是在云上的计算设备完成的。让大数据通过云计算产生价值。城市大脑计划真的是一个很酷的决定，更加直白的让数据开始为社会产生价值。利用科技完成人们很难完成的事情，中国的未来真的很令人憧憬。读完了这本书有很多感想，但很难用我贫瘠的语言能力表述出来。似乎通过这本书，看见了未来。 本书最喜欢的两句话坚持相信的，相信坚持的。梦想永在凌云意意气风发，代码成就万事基积沙镇海。 现在还年轻，虽然无法拥有经历和学识带来的眼界，但热气腾腾的野心和时间似乎可以带我赶上技术创新的时代。未知总是能给人带来希望，希望勤奋、自律会一直贯穿我的研究生生涯甚至我的整个人生，衷心的祝愿自己。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS学习笔记]]></title>
    <url>%2F2020%2F06%2F20%2FCSS%2F</url>
    <content type="text"><![CDATA[目录 伪类选择器 单位 移动端适配 媒体查询 省略 雪碧图 CSS盒模型 过渡约束 外边距折叠 轮廓和圆角 浮动 高度塌陷 BFC 清除浮动 外边距折叠的解决 clearfix 定位 层级 居中 垂直居中 水平居中 动画 过渡 弹性盒子 其他 三角形 伪类选择器伪类带一个冒号，伪元素带两个冒号。 常见伪类 li:first-childli:last-childli:nth-child(n) //n从1开始，2n/even选中偶数位，2n+1/odd奇数位 这三个 排序是根据所有的子元素进行的，并不是li中的第几个。 li:first-child{ color: orange; } //第一个li元素并不会变色，因为在子元素中第一个元素是span &lt;span&gt;abc&lt;/span&gt; &lt;li&gt;ff&lt;/li&gt; &lt;li&gt;zz&lt;/li&gt; :first-of-type:last-of-type:nth-of-type() 这几个伪类与上述相似，不过是在同类型元素中选择排序。 :not()否定伪类 ul&gt;li:not(li:nth-of-type(3)) //当前后相同时，也可以写成 ul&gt;li:not(:nth-of-type(3)) 超链接的伪类 :link 用来表示没访问过的链接（正常的链接）:visited 用来表示访问过的链接，由于隐私的原因，该伪类只能改变颜色（所以不常用）上述两个伪类只用于a标签:hover 用来表示鼠标移入的状态:active 用来鼠标点击 顺序:lvha 伪元素 伪元素表示页面中一些特殊的并不真实存在的元素 p::first- letter 表示标签p里的第一个字母::first-line 表示第一行::selection 表示选中的内容div::before 表示div标签内的开始位置div::after 表示div标签内的最后一个位置 before,after添加的文字不可以被选中 单位在前端像素分为两种：css像素和物理像素。编写网页时，所用的像素是CSS像素。浏览器在加载网页时，会将CSS像素转化成物理像素。默认情况在pc端1个css像素=1个物理像素 视口(viewport)就是屏幕中用来网页显示的区域，可以通过html查看。物理像素是设备的宽度。 编写移动端的页面时，通过调整视口大小来调整像素比，meta标签设置，content=&quot;width=device-width&quot;可以将像素比设置为最佳像素比的视口大小。 em是相对于自身元素的字体大小来计算的，1 em = 1 font-sizerem是相对于根元素（html）的字体大小来计算的。行高（line-height）指的是文字占有的实际高度，行高如果是整数，则是该元素字体大小的倍数 移动端不适用px来布局，常常使用vw来布局。vw表示视口的宽度 100vw=1个视口的宽度 常用的vw适配方案 比如当前最佳视口大小375px,设计图宽度750px,100vw = 750px(这个750指的是设计图中的宽度),那么设计图中的 1px = 0.1333 vw。 给font-size设置0.133vw对应的是设计图中的1px，所以设计图中的10px可以写成10rem。 但是一般浏览器对字体的大小有限制，所以会对font-size进行放大比如放大了40倍，那么使用的时候需要缩小40倍。 html{ //100vw/750 = 0.1333vw font-size:100vw/750 * 40 } .box{ width:设计图中该元素的宽度/40 rem } 媒体查询@media(min-width:xxx/max-width:xxx){} @media not (){}//除了 @media(),(){} //两个条件满足一个就可以了 @media()and(){} //两个条件全部满足 样式切换的分界点称为断点，常用断点： 小于768 超小屏幕 max-width=768px大于768 小屏幕 min-width=768ox大于992 中型屏幕 min-width=992px大于1200 大屏幕 min-width=1200px 响应式设计的网站:移动端优先 字体字体框就是字体存在的格子，设置font-size实际上就是在设置字体框的高度。行高会在字体框的上下平均分配。font属性：字体大小/行高 字体族， //可以将服务器中的字体直接提供给用户去使用 //问题：1.加载速度 2.版权 @font-face { //xx为你给该字体起的名 font-family:&quot;xx&quot;; //服务器中字体的路径 src:url(); } 图标字体在使用图标时，可以将图标直接设置为字体，通过font-face的形式来字体进行引用。 //使用iconfont的方式,本地引用icconfont.css //伪元素引用 p::before{ content:&quot;\xxxx&quot;; //字体图标的编码 font-family:&quot;iconfont&quot;; font-size:xxx; } //类名引用 &lt;i class=&quot;iconfont icon-qitalaji&quot;&gt;&lt;/i&gt; text-align文本的水平对齐vertical-align 设置元素垂直对齐 图片默认的基线对齐，但是基线可能和外边框之间有缝隙，所以图片常常设置vertical-align的值来改变对齐方式。 省略 width:xx; white-space:nowrap; //white-space 设置网页如何处理空白 normal 正常 nowrap 不换行 pre 保留原格式 overflow:hidden; text-overflow:ellipsis; 背景 background-clip 背景范围background-origin 背景图片的偏移量计算的源点，默认在内边距开始可选值 border-box 默认值 padding-box，content-box background-size 背景图片的大小 cover 图片比例不变，将元素铺满高度100% contain 图片比例不变，将图片在元素中完整显示，宽度100%background-attachment 背景图片是否跟随元素移动 scroll默认移动，fixed背景会固定在页面中background-image还可以设置渐变的背景色 解决图片闪烁问题（CSS-Sprite）：可以将多个小图片统一保存在一个大图片（雪碧图），通过图片背景定位来解决问题。 隐藏文字 常常使用text-indext:-9999px来隐藏文字,需配合overflow使用。 CSS盒模型CSS将页面中的所有元素都设置为一个矩形的盒子，对页面的布局就变成了将不同的盒子摆放到不同的位置。 盒子 = 内容content + 内边距padding + 边框border + 外边距margin（看不见，其余为可见框） 由width和height决定的是content的大小。 块级元素盒模型控制布局的时候最好对块级元素进行布局，块级元素占一行。 过渡约束水平布局 一个块级元素在其父元素中，水平布局必须满足margin-left + border-left + padding-left + width + padding-right + border-right + margin-right = 其父元素内容的宽度，如果相加结果不相等，则称为过渡约束。这七个值中可以设置为auto：width，margin。如果发生过渡约束，等式会自动调整，宽度优先，左右平分：1.如果7个值无auto的情况，则浏览器会自动调整margin-right2.如果某个值为auto，则会自动调整auto的值是等式成立。3.如果一个宽度和一个外边距设置为auto，则优先把宽度调整到最大。4.如果两个外边距设置为auto，宽度固定，则会将外边距设置为相同的值。利用这个特点实现一个元素在其父元素水平居中。 (width:xx;margin:xx auto） 垂直布局 若父元素没设置高度，则默认父元素的高度被内容撑开。使用overflow属性来设置父元素如何处理溢出的子元素，设置在子元素。 overflow:visible //默认值，子元素会从父元素中溢出 overflow:hidden //溢出内同被裁剪不会显示 overflow:scroll //生成双向滚动条 overflow:auto //根据需要生成滚动条 overflow-x/overflow-y 外边距的折叠相邻的垂直方向外边距会发生重叠方向。兄弟元素间的相邻垂直外边距会取两者之间的绝对值较大值，若一正一负取和。兄弟元素之间的外边距重叠对开发有利，不需要处理。 父子元素的相邻外边距，子元素会传递给父元素(上边距)。 行内元素盒模型行内元素不支持设置宽度和高度，行内元素可以设置padding/border/margin，但是垂直方向padding/border/margin不会影响页面的布局。垂直方向取最大，水平方向取和。 使用display来设置元素的类型，与display:none相似的还有visibility：hidden。区别是前者隐藏后不占据位置，后者仍然占据位置只是不可见。 visibility：hidden //元素隐藏不显示，但是仍然占据位置 visibility：visible //元素可见 display:inline display:block //块元素占一行 display:inline-block //行内块元素，宽高生效但不占一行，尽量不用换行符会解析 display:none //元素不显示 display:table //将元素设置为一个表格 CSS3的盒模型CSS3新增box-sizing属性，该属性设置width与height的作用范围。 box-sizing: border-box //使用ie盒模型 box-sizing: content-box //使用标准盒模型，默认 box-sizing:padding-box //width/height设置的是左右padding+content 标准盒子模型的width/height设置的是content的高度与宽度。IE盒子模型的width/height设置的是content+左右padding+左右border之和。 可以记忆成属性值为什么从哪个地方开始到对应的地方结束 轮廓和圆角outline轮廓outline与border用法相同，轮廓outline不会影响布局，不会撑大盒子。 box-shadowbox-shadow用来设置元素的阴影，前两个值为左侧下侧偏移量，第三个值为模糊程度，第四个值为颜色，不会影响布局。 border-radiusborder-radius用来设置圆角，指定画圆的半径，值为50%则是一个圆。第一个值是x方向半径，第二个值是y方向半径。 浮动通过浮动float可以使一个元素相对于父元素进行向左向右浮动，默认不会从父元素中移动。元素设置浮动以后，水平布局的等式margin-left + border-left + padding-left + width + padding-right + border-right + margin-right = 其父元素内容的宽度失效并且脱离文档流不占用文档流的位置。如果浮动元素上面是在文档流中的，则浮动元素从该位置后面进行排序，而不是上移。浮动元素不会超过它上一个浮动的兄弟元素高度，最多就是一样高。浮动元素不会盖住文字，文字会自动环绕在图片的周围。元素从文档流中脱离，会具有行内块元素的特性。 高度塌陷一般父元素的高度不会写死，高度根据子元素高度决定。当子元素浮动后，完全脱离文档流，子元素将无法撑起父元素的高度，导致父元素的高度丢失。 //style .box1{ border:10px red solid; } .box2{ width:100px; height:100px; background-color:green; float:left } //html &lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;/div&gt; 解决办法：BFCBlock Formatting Context 块级格式化环境，是CSS中的一个隐含的属性，可以为一个元素开启BFC，开启BFC该元素会变成一个独立的布局区域。 元素开启BFC后的特点1.开启BFC的元素不会被浮动元素所覆盖。2.开启BFC的元素子元素和父元素外边距不会重叠。（不会发生子元素设置外边距，父元素跟着动的情况）3.开启BFC的元素可以包含浮动的子元素，使其不会发生高度塌陷。 启动特殊方式开启元素的BFC方法一：设置元素的浮动（不推荐）副作用：会从文档中脱离。方法二：变成行内块元素（不推荐）方法三：将元素的overflow设置为一个非visible的值，一般用hidden（常用方式） 清除浮动给受影响的盒子添加clear属性，clear元素的原理是设置清除浮动以后，浏览器会自动为元素添加上外边距，所以添加了clear的属性不可以手动添加margin-top。 clear:left //清除左侧浮动元素对当前元素的影响 clear:right //清除右侧浮动元素对当前元素的影响 clear:both //清除两侧中最大影响的那侧 高度塌陷的最终解决方案：使用after伪类 在父元素的后面添加一个空标签(行内元素)，清除浮动对其的影响并使其为块元素，浏览器自动改变margin-top使其可以撑开父元素。 因为行内元素【如span】的padding-top,padding-bottom,margin-top,margin-bottom（垂直方向）属性设置无效。 //表示box1(父元素)盒子里面内容的最后 .box1::after{ content:&quot;&quot;; display:block; clear:both } 使用这种思想同时可以解决外边距重叠的问题。 &lt;style&gt; .box1{ width: 200px; height: 200px; background: green; } .box2{ width: 100px; height: 100px; background: orange; margin-top: 100px; } &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 解决办法：让其外边距不相邻 //box1盒子内容的最前面 .box1::before{ content:&quot;&quot;; display:table; } clearfix解决外边距重叠与高度塌陷的问题，谁塌陷这个类名加在谁的身上。 .clearfix::before, .clearfix::aftee{ content:&quot;&quot;; display:table; clear:both; } 定位可以通过定位将元素摆到页面的任意位置（一般使用在微小的地方，大布局使用浮动），当元素开启了定位以后，可以通过偏移量(top bottom left right 仅对开启定位的元素有用)来设置元素的位置。 positon属性的值: static 默认值，元素是静止的没有开启定位 relative 相对定位 sticky 粘滞定位 absolute 绝对定位 fixed 固定定位 relative相对定位 开启绝对定位后，如果不设置偏移量元素不会发生变化relative是参照于开启相对定位的元素在文档流中的位置（元素本身）进行定位的。相对定位会提升元素的层次相对定位不会让元素脱离文档流并且不会改变元素的性质。脱离文档流后，元素会变成行内块元素（不会独占一行，宽高属性生效） absolute绝对定位 开启绝对定位后，如果不设置偏移量元素的位置不会发生变化。元素会从文档流中脱离，绝对定位的元素会提升层级。absolute定位元素是相对与其包含块（块级元素）进行定位正常情况下，包含块就是离当前元素最近的祖先块元素。绝对定位的包含块就是离它最近的开启了定位的祖先元素。 注意：平时使用的width:100%是指的是相对于包含块的长度 absolute定位的特点是父相子绝，使用绝对定位的元素会向上寻找第一个使用相对定位的父元素。 水平布局等式margin-left + border-left + padding-left + width + padding-right + border-right + margin-right = 其父元素内容的宽度 当开启了绝对定位之后的水平布局等式变成了left + margin-left + border-left + padding-left + width + padding-right + border-right + margin-right + right = 包含块的宽度这9个值中可以设置为auto：width，margin，left，right。如果发生过渡约束，等式会自动调整，宽度优先，right/left其次，左右平分：1.如果9个值无auto的情况，则浏览器会自动调整right2.如果某个值为auto，则会自动调整auto的值是等式成立。3.如果一个宽度和一个外边距设置为auto，则优先把宽度调整到最大。4.如果两个外边距设置为auto，宽度固定，则会将外边距设置为相同的值。利用这个特点实现一个元素在其父元素水平居中。 (width:xx;margin:xx auto） 注意left和right的默认值是auto，所以如果不知道left和right，则等式不满足会自动调整这两个值。所以以上4点要在left/right设置的情况下进行。 当我们开启绝对定位后，垂直方向也需要满足垂直方向的等式也需要满足（正常的不会）,其规则类似水平布局。 所以可以利用其特点，进行元素的垂直居中 //垂直居中的元素 width:xxx; height:xxx; position:absolute; //父相子绝,在谁中间就给谁相对定位 margin:auto left:0; right:0; top:0; bottom:0; fixed固定定位 固定定位也是绝对定位的一种，所以固定定位的大部分特点都和绝对定位一样。不同点是固定定位永远参照与浏览器的视口（可视区域，固定不动）进行定位 sticky粘滞定位 粘滞定位和相对定位的特点基本一致，不同的是粘滞定位当元素到达一定高度的时候固定住，常常和top结合。sticky定位的元素元素仅在其父元素内生效且父元素的高度不能低于sticky定位 元素的高度，所以如果滚动到父元素的高度低于sticky定位元素的高度，该定位失效。 层级定位的层级大于浮动的层级 z-index属性可以来指定元素的层级，数越大层级越高。 如果优先级一样，优先显示结构上靠下的元素 祖先元素的层级再高也不会盖住后代元素。 居中垂直居中1.文字的垂直居中 要让文字在父元素中垂直居中，只需将父元素的line-height设置为和父元素的高度一样。 2.利用定位 //垂直居中的元素 width:xxx; height:xxx; position:absolute; //父相子绝,在谁中间就给谁相对定位，也可以实现垂直水平居中，原理是利用布局等式 margin:auto top:0; bottom:0; 3.利用tabel的性质（很少使用） //将元素设置为单元格td display:table-cell; //元素类的子元素垂直居中 vertical-align:middle; 4.利用transform 当元素的大小并不明确的时候，以水平为例子，垂直类似。 .box{ position:absolute; left:50%;//相对与包含块的50% transform:translateX(-50%)//相对于元素自身的50% } 水平居中一个元素在父元素中水平居中,该代码写在该元素的样式中，该代码仅对块级元素有效。 width:xx; margin:xx auto 这种办法的原理是利用水平布局的margin-left + border-left + padding-left + width + padding-right + border-right + margin-right = 其父元素内容的宽度等式。 所有元素也可以通过对父元素设置 text-align：center；的方式来实现居中。而对于块元素来说，对要居中的元素自身进行设置text-align:center也能实现居中，而无需对其父元素进行设置。 动画过渡transition过渡三要素:起始位置 过渡时间 终止位置 transition-property 表示执行过渡的属性transition-duration 指定用于过渡的持续时间transition-timing-function 指定过渡的时序函数transition-delay 指定过渡效果的延迟 在简写中，如果有2个时间，则第一个为持续时间，第二个为延迟时间。 动画animation动画可以自动触发动态效果。设置动画效果，必须先设置一个关键帧，关键帧设置了动画执行每一个步骤。 //定义关键帧 @keyframes name{ //第一种 from{} to{} //第二种 0%{} 5%{} } //使用动画 animation-name... //其余属性同transition animation-iteration-count //迭代次数 animation-direction //动画方向 animation-play-state //设置动画的执行状态 执行或者暂停 animation-fill-mode //动画开始/停止的位置，默认动画执行完毕回到原来的位置 使用图片实现动画的一些小技巧 .box{ background-image:url(&quot;&quot;); //开启平铺 animation:name 1s steps(几个图片就几次) infinite; } @keyframes name{ from{ background-position:0 0; } to{ background-position:-图片的长度 0; } } 变形变形不会影响页面的布局，只会改变元素的形状或位置。 平移 可以与定位结合实现居中的效果。 //百分比是相对于自身计算的，并不是根据包含块 transform:translateX()/translateY()/translateZ() Z轴平移，正常情况就是调整人和元素之间的距离，距离越大，元素离人越近。如果想要看见效果必须要设置网页的视距。一般设置在html，perspective:1000px 表示人眼距离网页的距离 旋转与缩放 通过旋转可以使元素沿轴旋转指定的角度沿X轴转的时候，设置视距可以看见近大远小的效果。转了轴也会跟着转。 transform:rotateZ（45deg）/rotateZ(.5turn) //旋转的背面是否可以看见 backface-visibility:hidden; transform:scaleX() //缩放的是轴 即使设置了视距可以看见近大远小的效果，但是仍然仅仅是2D的效果，如果想看见3D的效果还需要设置transform-style:preserve-3d 弹性盒子flex是CSS3中新增的布局手段，它主要用来代替浮动来完成页面的布局。 弹性容器：要使用弹性盒，必须先将一个容器设置为弹性容器,display:flex设置为块级弹性容器，display:inline-flex设置为行内的弹性容器。 主轴：弹性元素的排列方式为主轴 侧轴：与主轴垂直方向为侧轴 弹性容器的样式 flex-direction 指定容器中弹性元素的排列方式 flex-wrap 指定弹性元素是否在容器中按侧轴换行 flex-flow是上述两个属性的简写属性 justify-content 如果分配主轴的空白空间 align-items 元素在侧轴如何对齐,控制元素间的对齐 align-content 侧轴空白空间的分配 弹性元素：弹性容器的子元素 弹性元素的样式 flex-grow 指定弹性元素的伸展的系数，当父元素有多余空间时，子元素如何分配。 flex-shrink 指定弹性元素的收缩性，当父元素的空间无法容纳所有的子元素时，如何对子元素进行收缩。 align-self 用来覆盖当前弹性元素上的align-items flex-basis 指定元素在主轴上的基础长度，如果主轴是横向的，那么指定的就是元素的宽度 flex 是上述的三个属性的简写，顺序也是上述的顺序 order决定弹性盒子的排列顺序 一个元素可以同时是弹性盒子和弹性元素。 其他三角形border四个方向的边框实际是一个梯形并不是矩形。当内容区域的高度宽度为0时，边框就会变成小三角形。 .box1{ width: 0; height: 0; border: 20px red solid; border-color: border-color: red orange greenyellow yellow; } //常常用伪类添加三角效果 //把不需要的方向颜色换成transparent就可以了。或者为了防止占位，可以添加 border-top:none 等来设计。 .xxx::before{ width: 0; height: 0; content:&quot;&quot;; display:block; border:10px solid transparent; border-top:none; border-bottom-color:white //如果开始不显示设置为display:none } //那么hover的时候可以用下面的写法使其显示 //xxxhover的时候他的伪元素怎么样 .xxx:hover::after{ display:block }]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《图解HTTP》阅读笔记]]></title>
    <url>%2F2020%2F06%2F18%2F%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[给自己定了100天阅读计划，希望每天都可以坚持，让日子过得更有趣一点。 6.18-6.22 HTTP是无状态协议，目的是让服务器更快处理大量事务，确保协议的可伸缩性。 问题1：浏览器输入URL发生了什么 1.浏览器分析目标的URL，向DNS请求解析该URL的IP地址。因为TCP是通过IP地址连接的。2.通过IP地址与该服务器建立TCP连接。3.浏览器发出HTTP请求。4.服务器响应后TCP连接释放。 在请求方法中，这里仅记录平时看见过。 但不太熟悉的方法。HEAD方法同DET方法一样，只是仅仅返回报文首部，用于确定URI的有效性及资源更新的日期时间等。OPTIONS方法用来查询该URL支持的方法 常见的状态码 1xx：接收的请求正在处理，信息性状态码2xx：请求正常处理完毕，成功状态码3xx：需要进行附加操作以完成请求，重定向状态码4xx：服务器无法处理请求，客户端错误状态码5xx：服务器处理请求错误，服务器错误状态码 注意：状态码和状态的情况不一致，不少返回的状态码响应都是错误的，但是用户可能察觉不到这点。比如Web应用程序内部发生错误，状态码依旧返回200 OK。 HTTP1.1中，所有的连接默认都是持久连接。只要任意一端没有明确提出断开连接，则保持连接状态。持久连接的好处是减少了TCP连接重复建立和断开造成的额外开销。持久连接使请求可以管线化，不用等待响应可直接发送下一个请求。（HTTP1.1并没有实现） 问题2：HTTP1.1与1.0的区别在哪里？1.HTTP1.1默认的是持久连接，只要任意一端没有明确提出断开连接，则保持连接状态。而HTTP1.0默认是非持久连接。2.HOST首部字段。在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中必须有HOST首部字段，如果没有Host头域会报告400 Bad Request的错误。3.HTTP1.1增加了更多的状态响应码。4.HTTP1.0中，存在一些浪费的现象，例如：客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1可以分块请求数据以及断点续传。 问题3：HTTP2.0带来的改进是？1.二进制分帧，在应用层和传输中之前增加了一个二进制分成帧层，在此层中HTTP2会将所有传输的信息分割为更小的消息和帧，并采用二进制格式的编码。2.复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，实现了管线化。3.HTTP1.1中服务器不能主动的push，HTTP2.0允许服务器未经请求，主动向客户端发送资源，即服务器推送（server push）。4.HTTP1.1中头部数据太长，HTTP2.0引入头部压缩机制，头信息使用gzip或compress压缩后再发送；客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，不发送同样字段，只发送索引号，提高速度 HTTP不管哪个版本都存在安全性问题： 通信使用明文（未加密的报文），内容可能会被窃听。 不验证通信方的身份，因此有可能遭遇伪装，并且无意义的请求也会接收，无法阻止海量请求下的DoS攻击。 无法证明报文的完整性，所以可能报文被篡改，容易导致中间人攻击。 而SSL（secure socket layer安全套接层）可以将整个通信线路加密处理，还使用证书来确定通信方以及对报文的完整性保护，因此SSL+HTTP协议的结合产生了HTTPS，提高了通信的安全性。 问题5：HTTP与HTTPS的区别是什么？ HTTP + 加密 + 认证 + 完整性保护 = HTTPS 1.http明文传输，HTTPS加密传输更加安全。2.使用的端口不同，一般http协议的端口为80，https的端口为443 问题6：SPDY的优点是什么？SPDY可以说是综合HTTPS与HTTP的传输协议。1.多路复用，在一个连接里可以无限处理多个HTTP请求，降低延迟。2.请求优先级，可以给请求分配优先级顺序。3.压缩HTTP首部。4.SPDY规定通信中使用SSL，提高数据传输的可靠性。5.服务器推送，服务器可以主动向客户端推送数据，例如有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到 问题7：SPDY与HTTP2.0的区别是什么？HTTP2.0可以说是SPDY的升级版（基于SPDY设计的）1.HTTP2.0支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS2.HTTP2.0消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE WebSockt WebSocket是由HTML5开始提供的Web浏览器与Web服务器之间全双工通信的协议，由于建立在HTTP基础上的协议，因此需要进行一次由客户端发起的HTTP连接，一旦确立WebSocket通信连接，即是全双工通信。 WebSocket优点：1.支持由服务器向客户端推送数据。（HTTP/2 只能推送静态资源,无法推送指定的信息）2.WebSocket是持久连接，较少每次连接时的总开销。3.WebSocket的首部信息很小，较少通信量。 总结 SPDY不是可以替代HTTP的协议，而是对HTTP协议的增强，SPDY强制使用HTTPS。HTTP2以SPDY2为基础进行改进，支持HTTP传输。HTTPS是身披SSL外壳的HTTP。 不管所用网络协议是什么版本，什么样的网络协议，最终的目标都应该是消除或减少不必要的网络延迟，将需要传输的数据压缩至最少。 评价 此书的有些语句过于拗口且也歧义，理解真正的意思有困难。其次前6章对于HTTP报文的介绍只是简单的把每个部分的语法代表什么意思说了出来，缺乏整体性的认识，过于枯燥。阅读性不高。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[exports与module.exports的区别]]></title>
    <url>%2F2020%2F05%2F26%2Fexports%2F</url>
    <content type="text"><![CDATA[CommonJS规范CommonJS加载模块是同步 知识点1 Node中，一个js文件就是一个模块 引入：require(路径)，使用相对路径，必须以.或..开头引入模块以后，该函数会返回一个对象，这个对象代表的是引入的模块。 模块分成两大类：核心模块：由node引擎提供的模块，核心模块的标识就是模块的名字文件模块：由用户自己创建的模块，文件模块的标识为路径 知识点2在Node中，每一个js文件中的js代码都是独立运行在一个函数体中。所以如果想要其他文件访问，必须要将数据暴露出来暴露：exports.x = “xxxx” //当node在执行模块中的代码时，它首先在代码的最顶部，添加如下代码 function(exports,require,module,__filename,__dirname){ //里面才是自己写的 name=XX } 形参中 exports：将变量或函数暴露到外部 require：用来引入外部的模块 module：代表当前模块本身 __filename：当前模块的完整路径 __dirname：当前模块所在文件夹的完整路径 exports与module.exports的区别本质上exports就是module的属性，module.exports===exports exports只能用.的方式来向外暴露内部变量，比如：exports.name = XXX module.exports即可以通过.，也可以直接赋值暴露 //可以这样写 module.exports = {} //错误写法 exports = {} 首先无论用module.exports还是exports都是改变的module的exports属性。 本质是exports与module.exports指向的是同一个对象。 //module指向a空间 let module = {}; //在a空间中分配一块空间b给exports module.exports = {}; //引用类型赋值，exports变量指向空间b let exports = module.exports //使用.赋值是ok的，相当于修改b空间里给name分配的c空间 exports.name = &quot;xxx&quot; //使用直接赋值是不行的，因为引用类型在内存中存放的是指向数据的地址指针 //直接赋值相当于修改的指针使其不在指向b，让指针指向别处。 exports = {}]]></content>
      <categories>
        <category>前端</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm包管理]]></title>
    <url>%2F2020%2F05%2F25%2Fnpm%E5%8C%85%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[NPM（Node Package Manager）CommonJS包规范是理论（CommonJS的包规范 = 包结构+包描述文件），NPM是其中一种实践。npm是Node.js的软件包管理，对于Node而言，NPM帮助其完成了第三方模板的发布、安装、依赖等。借助NPM，Node与第三方模块之间形成了很好的一个生态系统。 基本的操作：查看版本：npm -v搜索模块包：npm search 包名安装包：npm install 包名 安装包并添加到依赖 （最好在要安装包的位置创建package.json文件） npm install 包名 -g 全局安装 初始化package.json:npm init (名字不用大写)删除包：npm remove 包名 通过npm下载的包都在node_mudules文件夹中，直接通过包名即可引用。node在使用模块名字来引入模块时，它会首先在当前目录的node_modules中寻找是否含有该模块，如果没有去上一级目录的node_modules中寻找，直到找到磁盘的根目录。 问题1：全局安装与本地安装npm install xxx # 本地安装npm install xxx -g # 全局安装 本地安装 将安装包放在 ./node_modules 下（运行npm时所在的目录） 可以通过 require() 来引入本地安装的包 全局安装 将安装包放在 /usr/local 下 可以直接在命令行里使用 问题2：-d与-s的区别npm install -d 就是npm install –save-devnpm insatll -s 就是npm install –save 我们在使用npm install 安装模块或插件的时候，上述两种命令都可以把他们写入到 package.json 文件里面去。首先dev是develop的简写，-save-dev安装的插件，被写入到 devDependencies 域里面去，而使用 –save 安装的插件，则是被写入到 dependencies区块里面去。devDependencies 里面的插件只用于开发环境，不用于生产环境，而dependencies是需要发布到生产环境的。 例子：比如我们写一个项目要依赖于jQuery，没有这个包的依赖运行就会报错，这时候就把这个依赖写入dependencies ；而我们使用的一些构建工具比如glup、webpack这些只是在开发中使用的包，上线以后就和他们没关系了，所以将它写入devDependencies。 问题3：什么是npxnpm从5.2版本，增加了npx命令。npx主要作用是调用项目内部安装的模块和方法。现在的工具包一般都安装在局部，而不是全局。 //安装在开发环境的webpack-dev-server npm install webpack-dev-server -D //命令行中启动webpack-dev-server npx webpack-dev-server npx的原理是运行的时候会到node_modules/.bin路径和path里面，查看命令是否存在。 注意：Bash内置的命令不在Path中，所以类似cd的Bash命令不可以使用npx。 npx还可以运行一些需要全局安装的依赖（但不安装该依赖），npx将会把该依赖下载到一个临时目录，使用以后再删除，所以可以避免全局安装模块。 –no-install与–ignore-existing参数 –no-install:可以时npx强制使用本地模块，不下载远程模块，所以如果本地不存在该模块，就会报错。–ignore-existing:可以使npx强制安装使用远程模块，忽略本地的同名模块。 -p参数用于指定npx所要安装的模块。 //-p也可以省略 npx -p node@0.12.8 总结 利用npx可以下载模块使用过后再删除的特点，可以在某些场景切换版本。 使用npx可以不需要全局安装依赖，较少使用本机的存储空间。 使用本地已安装的可执行工具，而不需要配置scripts。 可以执行依赖包中的命令，安装完成自动运行。]]></content>
      <categories>
        <category>前端</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unexpected-token< 报错]]></title>
    <url>%2F2020%2F03%2F22%2Funexpected-token%2F</url>
    <content type="text"><![CDATA[因为团队信息的后台返回数据格式发生了变化，前端字段应该做相应变化。改完之后，本地是没有问题的，打包上线到服务器之后发现了报错了Uncaught SyntaxError: Unexpected token &lt; 所以原因要么在服务器，要么就是打包的问题。 首先进行排查的是文档类型，因为报错的三行都是与js相关。点击控制台错误的代码提示，查看network对应的文件加载状态,发现返回的不是js形式。而是doctype html,那么很大概率是服务器把js文件当作html响应，导致解析错误。正常情况返回content-type:applocation/javascript，而现在的错误情况js文档的响应信息，变成了text/html 把上一个版本部署上去，发现没问题。那么排除了服务器的问题，应该是打包的问题。 确定是打包的问题之后查看config/index.js,找到了原因。 默认的是在路径前面添加/,但是此项目的路由设置了所有路径都会跳转到/manage/xx,所以需要在修改assetPublicPath属性。]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>软件超市</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[letcode记录(更新中)]]></title>
    <url>%2F2020%2F03%2F10%2Fletcode%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[第一题：买卖股票的最佳时机时间：2020-03-10题目：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。分析：最终需要比较的量是最大利润，比较的条件是先买入再卖出。如果出现元素比基数还小，那么该元素后面比它大的元素与该元素的差一定大于与基础的差。思路：设置当前基数为prices[0],循环数组当数组元素大于基数时，比较当前利润与之前的利润，大者保存；当元素小于基数时，小的元素作为新的基数。代码： var maxProfit = function(prices) { let price = prices[0],profit=0; for(let i=1;i&lt;prices.length;i++){ if(price&lt;prices[i]){ //当后面的大于前面时计算利润 profit = (prices[i]-price&gt;profit)?(prices[i]-price):profit; }else{ //当后面的价格比当前的价格小时，改变price price = prices[i]; } } return profit; }; 总结改进1：比较大小时了用Math.max，写法更简单。 学习1：看了其他人的解题思路，学习到了dp算法解题结论:由牛顿莱布尼兹的思想可以得出，区间和可以转换成求差问题，求差问题，也可以转换成区间和的问题。最大连续子数组和可以使用动态规划求解，dp[i]表示以i为结尾的最大连续子数组和，递推公式为dp[i]=max(0,dp[i-1]) //dp粗糙版本 var maxProfit = function(prices) { if(prices.length&lt;=1) return 0 let diff = [] //记录数组相邻两元素差值 for (let i = 0; i &lt; prices.length-1; i++) { diff[i] = prices[i+1] -prices[i] } let dp = new Array(prices.length).fill(0) dp[0] = Math.max(0,diff[0]) let max = dp[0] for (let i = 1; i &lt; diff.length; i++) { //转换成区间求和问题 //差值累加，累加的最大值就是两个元素差的最大值 dp[i] = Math.max(0, dp[i-1]+diff[i]) max = Math.max(max,dp[i]) } return max } 解题的思路其实与我想的差不多，就是实现上面把求差问题，转换成了求和问题。 // 方法三：dp优化版 var maxProfit = function(prices) { let last = 0 let max = 0 for (let i = 0; i &lt; prices.length-1; i++) { //累加值为正，说明该元素之前有比他小的 //累加值为负，说明该元素前面暂时没有比他小的 //累加值就是元素之间的差值，累计值最大的就是最大利润。 last = Math.max(0, last + prices[i+1]-prices[i]) max = Math.max(max,last) } return max } 学习2：阅读下面的《一个方法解决6道股票题》，决定重新解题。首先此题，K=1，先套上转移方程 dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i]) dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) = max(dp[i-1][1][1], -prices[i]) k = 0 是 base case，所以 dp[i-1][0][0] = 0。 因为k都是1，不会改变，即K对状态转移已经没有影响了。那么进一步化简去掉k dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], -prices[i]) 写成代码形式: let maxProfit = function(prices) { let n = prices.length; let dp = new Array(n) if(n===0){ return 0; } for(let i=0;i&lt;n;i++){ dp[i] = new Array(2) if (i===0){ dp[i][0] = 0; dp[i][1] = -prices[i]; continue; } dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); dp[i][1] = Math.max(dp[i-1][1], -prices[i]); } return dp[n-1][0] }; 补充一个小知识点：break是跳出循环，continue是跳出当前循环 第一个问题就解决了，但是这样处理base case很麻烦，而且状态转移方程，新状态只和相邻的一个状态有关，所以不需要用整个dp数组，只需要一个变量存储相邻的状态就可以了，这样可以把空间复杂度降到 O(1): var maxProfit = function(prices) { let n = prices.length; // base case: dp[-1][0] = 0, dp[-1][1] = -infinity let dp_i_0 = 0,dp_i_1 = -Infinity for(let i=0;i&lt;n;i++){ //dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); dp_i_0 = Math.max(dp_i_0,dp_i_1 + prices[i]) //dp[i][1] = Math.max(dp[i-1][1], -prices[i]); dp_i_1 = Math.max(dp_i_1, -prices[i]); } return (dp_i_0) }; 阅读笔记《一个方法解决6道股票题》日期：2020-03-11链接：labuladong阅读笔记摘要：穷举框架利用[状态]进行穷举，具体到每一天，再找出每个[状态]对应的[选择]。穷举的目的是根h据对应的[选择]更新状态。这个问题的[状态]有三个，第一个是天数，第二个是允许交易的最大次数（一次买入+一次卖出算一次交易），第三个是当前的持有状态（持有用1，没有持有用0)。每天都有三种[选择]：买入、，卖出、无操作，用buy、sell、rest表示这三种选择。但选择是有条件的，sell必须在buy之后，下一次buy必须在sell之后。那么rest还应该分两种状态:一个是buy之后的rest（持有股票），一种是sell之后的rest（没有持有股票）。且buy只能在交易次数&gt;0的前提进行。所以可以用一个三维数组装下全部组合： dp[i][k][0 or 1] 0&lt;=i&lt;n, 1&lt;=k&lt;=K n为天数，因为数组从0开始，默认从第0天开始 大K为最多交易数 此问题共 n * K * 2 中状态 每一天有三种状态 dp[状态1][状态2][...] = 择优(选择1，选择2...) for 0 &lt;= i &lt; n: for 1&lt;=k&lt;=K: for s in {0,1}: dp[i][k][s] = max(buy sell rest) 如dp[3][2][1]的含义是：今天是第三天、现在持有股票，至今最多进行2次交易。我们想求的最终答案是dp[n-1][k][0]，最后一天，最多允许K次交易，最多获得多少的利润。 状态转移接下来要思考每种[状态]有哪些[选择]，如何更新[状态] 根据这个图，可以写状态转义方程: dp[i][k][0] = max(dp[i-1][k][0],dp[i-1][k][1]+ prices[i]) max( 选择rest ， 选择sell ) 解释：今天我没有持有股票，有两种可能： 要么是我昨天就没有持有，然后今天选择rest，所以我今天还是没有持有 要么是我昨天持有股票，但是我金泰sell，所以我今天没有持有股票了 dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) max( 选择 rest , 选择 buy ) 解释：今天我持有着股票，有两种可能： 要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票； 要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。 最后就是定义base case，最简单的情况。 dp[-1][k][0] = 0 解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。 dp[-1][k][1] = -infinity 解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。 dp[i][0][0] = 0 解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。 dp[i][0][1] = -infinity 解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。 总结一下 base case： dp[-1][k][0] = dp[i][0][0] = 0 dp[-1][k][1] = dp[i][0][1] = -infinity 状态转移方程： dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i] 第二题：买卖股票的最佳时机2日期：2020-03-12题目：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。尽可能地完成个更多交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意不能同时参与多笔交易思路：套上转移方式 dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) K的次数是正无穷，可以看成k-1也为正无穷，所以认为k和k-1是一样的 dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i]) 那么就不需要记录k这个状态了。 dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]) 情况又回到了第一题，不过这里的dp[i][1]里是dp[i-1][0]-prices[i],说明这里也与前一个状态有关系，但是d[i][0]的状态在dp[i][1]之前改变，所以代码也需要一个变量记录前一个dp[i][0] 翻译成代码： let maxProfit = function(prices) { let n = prices.length; let dp_i_0=temp= 0,dp_i_1 = -Infinity for(let i=0;i&lt;n;i++){ temp = dp_i_0; dp_i_0 = Math.max(dp_i_0,dp_i_1 + prices[i]) dp_i_1 = Math.max(dp_i_1, temp-prices[i]); } return (dp_i_0) }; 总结学习1：学习到一种思路更清晰的贪心策略 股票买卖策略： 单独交易日：设今天价格p1，明天价格p2，则今天买入、明天卖出可赚取p2-p1（负值代表亏损） 连续上涨交易日：设此上涨日股票价格分别为p1、p2、p3…pn，则第一天买最后一天卖收益最大，即pn-p1 = （p2-p1）+（p3-p2）+…+(pn-pn-1)。这里的转化思维是最重要的 连续下降交易日：则不买卖收益最大 算法流程 遍历整个股票交易日价格表prices，策略是所有上涨交易日都买卖（赚到所有）,所有下降日都不买 1.设 tmp 为第 i-1 日买入与第 i 日卖出赚取的利润，即 tmp = prices[i] - prices[i-1] ；2.当该天利润为正 tmp &gt; 0，则将利润加入总利润 profit；当利润为 0 或为负，则直接跳过；3.遍历完成后，返回总利润 profit。 代码: let maxProfit = function(prices) { let profit = 0,tmp; for(let i=1 ; i&lt;prices.length+1 ;i++){ tmp = prices[i] - prices[i - 1] if (tmp &gt; 0) profit += tmp } return profit }; 第三题：最佳买卖股票时机含冷冻期日期：2020-03-16题目：给定一个整数数组，其中第i个元素代表了第i天的股票价格。​ 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: - 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 - 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 思路：最初状态转移方程是： dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) 这里的k=Infinity的，所以k-1也可以看成无穷与上一道一样。其次此题有冷冻期为1天，也就是当天持有股票的情况，要么是昨天就持有，要么是前天卖出。所以转移方程为： dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i]) 可以写出代码： let maxProfit = function(prices) { let n = prices.length; let dp = new Array(n) if(n&lt;=1){ return 0; } for(let i=0;i&lt;n;i++){ dp[i] = new Array(2) if (i===0){ dp[i][0] = 0; dp[i][1] = -prices[i]; continue; } if (i===1){ dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); dp[i][1] = Math.max(dp[0][1], dp[0][0] -prices[i] ) continue; } dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); dp[i][1] = Math.max(dp[i-1][1], dp[i-2][0] - prices[i]); } return dp[n-1][0] }; 这样写是很麻烦的，之前是只与相邻的两个状态有关，现在是与相邻的三个状态有关，所以还可以多添加一个变量存储第三个相邻值。 let maxProfit = function(prices) { let n = prices.length; //dp_2_0表示dp[i-2][0] let dp_i_0=dp_2_0=temp= 0,dp_i_1 = -Infinity for(let i=0;i&lt;n;i++){ temp = dp_i_0; dp_i_0 = Math.max(dp_i_0,dp_i_1 + prices[i]) dp_i_1 = Math.max(dp_i_1, dp_2_0-prices[i]); dp_2_0 = temp } return (dp_i_0) };]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XHR的ajax封装(简单版本)]]></title>
    <url>%2F2020%2F03%2F01%2FXHR%E7%9A%84ajax%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[目的:熟练XHR的基本使用 特点1.函数的返回值为promise，成功的结果为response，失败的结果为error2.能处理多种类型的请求：GET/POST/PUT/DELETE3.函数的参数为一个配置对象 { url:&quot;&quot;,//请求地址 method:&quot;&quot;,//请求方式 params:{},//GRT/DELETE请求的query参数 data:{},//POST或DELETE请求的请求体参数 } 4.响应json数据自动解析为js5.response只实现了data，status，statusText6.put请求提交的是请求体参数，delete提交query参数 补充1.query，params，body req.params,req.query是用在get请求当中 query参数 返回值：对数据过滤产生一个新数组 param参数:常用于REST API风格 localhost:3000/posts?id=1 返回值：定位到对应的对象 返回值：定位到对应的对象 localhost:3000/posts/1 req.body是用在post请求中的，body 不是 nodejs 默认提供的，你需要载入 body-parser 中间件才可以使用，req.body此方法通常用来解析 POST 请求中的数据。 2.OPTIONS请求，预检查（get不需要）是否跨域等，没有响应体。 注意:1.axios的params是指定get或者delete请求的query参数（拼接在url后面）2.发送json格式请求体参数，需要设置请求头 function axios({ url, method=&quot;GET&quot;, //设置默认值 parmas={},//默认空对象 data={}//设置默认值 }) { //返回一个Promise对象 return new Promise((resolve, reject) =&gt; { //处理query参数，拼接到url let queryString=&#39;&#39; for (key in params){ queryString+=`${key}=${parmas[key]}&amp;` } if (queryString){ //去掉最后的&amp; queryString = queryString.substring(0,queryString.length-1) //拼接 url += &quot;?&quot;+queryString } //处理method为大写 method = method.toUpperCase() //1.执行异步ajax请求 //创建xhr对象 const request = new XMLHttpRequest(); //初始化请求(异步) request.open(method,url,true) //绑定状态改变的监听,send是异步的，所以绑定监听写在send后面也可以 request.onreadystatechange = function () { //如果请求没有完成，直接结束 if (request.readyState!==4){ return } } switch (method){ case &quot;GET&quot;||&quot;DELETE&quot; : //get的参数通过url传 request.send(); break; case &quot;POST&quot;||&quot;PUT&quot;: //发送请求 // post请求的data不能是对象需要是字符串 //发送JSON格式，需要加请求头 request.setRequestHeader(&quot;Content-Type&quot;,&quot;application/json;charset=utf&quot;)//告诉服务器请求体的格式是json request.send(JSON.stringify(data)) break; } //如果响应状态码在【200，300)之间代表成功，否则失败 const {status,statusText} = request if (status&gt;=200&amp;&amp;status&lt;=299){ //2.1如果请求成功了，调用resolve() //准备结果response对象 const response = { //服务器返回的是JSON数据需要转换成对象 //响应json数据自动解析为js的对象/数组 data:JSON.parse(request.response), status, statusText, } resolve(response) }else { //2.2如果请求失败,调用reject() reject(new Error(`request error status is ${status}`)) } }) }]]></content>
      <categories>
        <category>前端</category>
        <category>库</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios]]></title>
    <url>%2F2020%2F02%2F27%2Faxios%2F</url>
    <content type="text"><![CDATA[HTTP相关交互的基本过程 客户端 ===》（请求行，请求头，请求体）服务器服务器 ===》（状态行，响应头，响应体）客户端 请求报文请求行：method url多个请求头：host主机，cookie，Content-Type(请求体的内容类型)application/json 或者 application/x-www.form.urlencoded请求体（get请求没有）：{“username”:”tom”,”pwd”:123} 或者 username=tom&amp;pwd=123 响应报文状态行：status statusText多个响应头：Content-Type(响应体的内容类型):text/html;charset=uft-8 Set-Cookie:BD_CK_SAM=1;path=/响应体：html 文本/json 文本/js/css/图片… post请求体参数格式Content-Type:application/x-www.form.urlencoded例如：username=tom&amp;pwd=123 Content-Type:application/json例如：{“username”:”tom”,”pwd”:123} Content-Type:multipart/form-data用于文件上传请求 常见的响应状态码200 ok 请求成功，一般用于GET与POST请求201 created 已创建。成功请求并创建了新的资源401 Unauthorized 未到授权/请求要求用户的身份认证404 Not Found 服务器无法根据客户端的请求找资源500 Internal Serve Error 服务器内部错误，无法完成请求 常用请求类型 GET:从服务器端读取数据POST:向服务器端添加新数据PUT:更新服务器端已有数据DELETE:删除服务器端数据 API的分类1.REST API: restful 发送请求进行操作由请求方式决定 同一个请求路径可以进行多个操作（如同一个路径的get、delete） 请求方式会用到GET/POST/PUT/DELETE2.非REST API restless 请求方式不决定请求的操作 一个请求路径只能对用一个操作 一般只有GET/POST json-server工具包可快速搭建REST API XHR的理解和使用XHR对象可以从URL获取数据，而无需让整个页面刷新 一般的http请求与ajax请求1.ajax请求是一种特别的http请求2.对服务端来说，没有任何区别，区别在浏览器端3.浏览器端发请求：只有XHR或fetch发出的才是ajax请求4.浏览器端接收响应： 一般请求：浏览器一般会直接显示响应体数据，也就是我们常说的刷新/跳转页面 ajax请求：浏览器不会对界面进行任何更新操作，只是调用监视的回调函数并传入响应相关数据。 APIXHR对象的属性：XMLHttpRequest():创建XHR对象的构造函数readyState（请求的状态）： 0：初始 1：open()之后 2：send()之后 3：请求中 4：请求完成onreadystatechange：绑定readyState改变的监听responseType:指定响应数据类型，如果是’json’,得到响应后自动解析响应体数据response：响应体数据，类型取决于responseTypeopen(method，url[,async]):初始化一个请求,默认async：truesend(data)：发送请求abort()：中断请求getResponseHeader(name)：获取指定名称的响应头值getAllResponseHeaders():获取所有响应头组成的字符串setResponseHeaders(name,value):设置请求头status：由服务器返回的HTTP状态代码statusText：由服务器返回的HTTP状态文本 ajaxajax技术的核心是XMLHttpRequest对象(简称XHR)， XHR的ajax简单封装 axiosaxios的post请求头默认是application/x-www-form-urlencoded,如果data是对象,默认Json。axios请求的方式可以通过函数axios(config)使用，也可以通过对象axios.get()使用 特点1.基于promise的异步ajax请求库（基于promise的 HTTP 库）2.浏览器端/node端都可以使用3.支持请求/响应拦截器4.支持请求取消5.请求/响应数据转换6.批量发送多个请求 axios.create(config)自定义配置新建一个新的axios实例，新axios只是没有取消请求和批量发请求的方法，其他所有语法都是一致的。 const instance = axios.create({ baseURL:&quot;http://localhost:3000&quot; }) //使用instance发请求 instance({ url:&quot;/posts&quot; //请求端口3000 }) 这个语法的用处： 需求：项目中有部分接口需要的配置与另一部分接口需要的配置不太一样 解决：创建2个新的axios，每个都有自己特有的配置，分别应用到不同要求的接口请求中 axios.default.baseURL = &quot;http://localhost:4000&quot; axios({ url:&quot;/posts&quot; //请求的端口4000 }) const instance = axios.create({ baseURL:&quot;http://localhost:3000&quot; }) //使用instance发请求 instance({ url:&quot;/posts&quot; //请求端口3000 }) axios的处理链流程axios拦截器 请求拦截器axios.interceptor.request.use(callback)响应拦截器axios.interceptor.response.use(callback) axios.interceptors.request.use(config=&gt;{ console.log(&quot;request interceptor1 &quot;); //拦截请求，处理请求之后，必须要返回该配置，若不返回相当于axios请求没有添加配置 return config },error=&gt;{ console.log(&quot;request interceptor1 err&quot;); return Promise.reject(error) }) axios.interceptors.request.use(config=&gt;{ console.log(&quot;request interceptor2 &quot;); return config },error=&gt;{ console.log(&quot;request interceptor2 err&quot;); return Promise.reject(error) }) axios.interceptors.response.use(response=&gt;{ console.log(&quot;response interceptor1 &quot;); return response },error=&gt;{ console.log(&quot;response interceptor1 err&quot;); return Promise.reject(error) }) axios.interceptors.response.use(response=&gt;{ console.log(&quot;response interceptor2 &quot;); //拦截response结果处理之后，要返回结果 return response },error=&gt;{ console.log(&quot;response interceptor2 err&quot;); return Promise.reject(error) }) axios.get(&quot;http://localhost:/posts&quot;).then(response =&gt;{ console.log(&quot;response data&quot;); }).catch(error=&gt;{ console.log(&quot;response error&quot;); }) /* 输出 request interceptor2 request interceptor1 response interceptor1 err response interceptor2 err response error */ 注意点：1.请求拦截器后添加先执行。2.拦截请求，处理请求之后，必须要返回该配置，若不返回相当于axios请求没有添加配置3.拦截response结果处理之后，要返回结果。 取消请求应用场景:如果发送请求2的时候，发现请求1还没有完成则取消请求1 let cancel //保存用于取消请求的函数 function getProducts1(){ if (typeof cancel === &quot;function&quot;){ //需要使用取消请求时调用 //如果请求取消了，则该请求进入请求失败的流程，请求失败的error是Cancel对象类型，Cancel里面有message属性 cancel(&quot;这里可以传消息提示&quot;) } axios.get(&quot;/user&quot;,{ cancelToken:new axios.CancelToken( //执行器回调，同步进行 c =&gt; {//c是用于取消当前请求的函数 cancel = c } ) }).then(response =&gt;{ cancel = null //如果请求完成就不要取消请求了 },error =&gt;{ if (axios.isCancel(error)){ // 取消请求 console.log(&quot;请求取消了&quot;,error.message); } else{ //请求本身出错 cancel = null console.log(error); } }) } function getProducts2(){ if (typeof cancel === &quot;function&quot;){ cancel(&quot;这里可以传消息提示&quot;) } axios.get(&quot;/user/1&quot;,{ cancelToken:new axios.CancelToken( c =&gt; {cancel = c} ) }).then(response =&gt;{ cancel = null },error =&gt;{ if (axios.isCancel(error)){ console.log(&quot;请求取消了&quot;,error.message); } else{ cancel = null console.log(error); } }) } 改进版本 //添加请求拦截器 axios.interceptors.request.use(config=&gt;{ if (typeof cancel === &quot;function&quot;){ cancel(&quot;这里可以传消息提示&quot;) } config.cancelToken =new axios.CancelToken( c =&gt; { cancel = c } ) return config }) //添加响应拦截器 axios.interceptors.response.use( respose=&gt;{ cancel = null return respose }, error =&gt;{ if (axios.isCancel(error)){ console.log(&quot;请求取消了&quot;,error.message); //中断promise链接 return new Promise(()=&gt;{}) } else{ cancel = null //将错误继续向下传递 // throw error return Promise.reject(error) } }) let cancel function getProducts1(){ axios.get(&quot;/user&quot;).then(response =&gt;{ //其他数据响应 },error =&gt;{ //只需要处理请求失败 }) } function getProducts2(){ axios.get(&quot;/user/1&quot;).then(response =&gt;{ //其他数据响应 },error =&gt;{ //只需要处理请求失败 }) }]]></content>
      <categories>
        <category>前端</category>
        <category>库</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js（3.28更新）]]></title>
    <url>%2F2020%2F02%2F25%2Fnode-js%2F</url>
    <content type="text"><![CDATA[综述Node.js是能够在服务器端运行JavaScript的开放源代码、跨平台JavaScript运行环境 Node是对ES标准一个实现，Node也是一个JS引擎 通过Node可以使js代码在服务器端执行 Node仅仅对ES标准进行了实现，所以在Node中不包含DOM和BOM Node中可以使用所有的内建对象（String Number Boolean Math Date RegExp Function Object Array）而BOM（操作浏览器）和DOM（文档对象模型）都不能使用，但是可以用console也可以用定时器 Node可以在后台来编写服务器，Node服务器都是单线程的服务器。 补充：1.node中有一个全局对象global，它的作用和网页中window类似，在全局创建的变量/方法都会作为global的属性/方法保存2.代码风格：建议无论有分号代码或者无分号代码，都建议如果一（、[、\`开头，最好都在前面补上一个分号。 Buffer（缓存区）Buffer的结构和数组很像，操作的方法也和数组类似。数组中不能存储二进制的文件，而Buffer专门用来存储二进制数据(图片/mp3/视频 二进制文件) 使用：buffer不需要引入模块，直接使用即可 常用操作Buffer.from(str[,encoding]) str 需要编码的字符串 encoding 默认’utf8’把字符串转换成二进制,buffer中每个元素的范围从00-ff（8bit）,如果要转换成字符串用toString() Buffer.lengthBuffer占用的内存大小 Buffer.alloc(size[, fill[, encoding]]) size，分配的内存长度 fill，用于预填充新Buffer的值，默认值：0 encoding，如果fill是一个字符串，则这是它的字符编码，默认’utf8’ //创建一个10个字节的buffer let buf = Buffer.alloc(10) //通过索引，来操作buf中的元素 buf[0] = 88 注意：Buffer的大小一旦确定，则不能在修改，因为Buffer是对内存的直接操作 只要数字在控制台或页面中输出一定是10进制 如果要16进制输出，number的toString(进制)里面可以传参。 ``` let buf = Buffer.alloc(10) buf[1]=0xaa; console.log(buf[1].toString(16)); //输出aa ``` Buffer.allocUnsafe(size) 创建一个指定大小的buffer，但是buffer中可能含有敏感数据（分配空间并没有预设默认值0） fs（文件系统）文件系统简单来说就是通过Node来操作系统的文件。服务器的本质就是将本地的文件发送给远程的客户端。fs模块中所有的操作都有同步和异步两种形式选择，同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码，异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回。 使用：使用文件系统，需要先引入fs模块，fs是核心模块，直接用名字引入不需要下载。 同步/异步文件写入同步的文件的写入：1.打开文件 fs.openSync(path[, flags, mode]) - path 打开文件的路径 - flags 打开文件要做的操作的类型 默认&#39;r&#39; - mode 设置文件的操作权限，一般不传 返回值：该方法会返回一个文件的描述符作为结果，我们可以通过该描述符对文件进行各种操作 2.向文件中写入内容 fs.writeSync(fd, buffer[, offset[, length[, position]]]) - fd 文件的描述符，需要传递要写入的文件的描述符 - buffer 要写入的内容 - offset 写入的位置 3.保存并关闭文件 fs.closeSync(fd) let fs = require(&quot;fs&quot;) //打开文件 let fd = fs.openSync(&quot;hello.txt&quot;,&quot;w&quot;) //向文件中写入内容 console.log(fd); fs.writeSync(fd,&quot;hello&quot;) //保存并关闭文件 fs.closeSync(fd) 异步方法(不可能有返回值):1.打开文件 fs.open(path[, flags[, mode]], callback) ，结果是通过回调函数返回的,回调函数路两个参数。 - err 错误对象，如果没有错误则为null（js的设计思想，错误优先） - fd 文件描述符 2.向文件中写入内容 fs.write(fd, buffer[, offset[, length[, position]]], callback）3.关闭文件 fs.close(fd, callback) let fs = require(&quot;fs&quot;) //打开文件 fs.open(&quot;hello.txt&quot;,&quot;w&quot;,function (err,fd) { if (!err) { console.log(&quot;打开成功&quot;); //向文件中写入内容 fs.write(fd,&quot;这是异步写入的内容&quot;,function (err) { if (!err){ console.log(&quot;写入成功&quot;); } //关闭文件 fs.close(fd, function (err) { console.log(&quot;文件关闭&quot;); }) }) } else console.log(err); }) (常用)简单的文件写入fs.writeFile(file, data[, options], callback) file 要操作的文件的路径 data 要写入的数据 options 选项，可以对写入进行一些设置 callback 当写入完成以后执行的函数 const fs = require(&quot;fs&quot;) fs.writeFile(&quot;hello.text&quot;,&quot;这是通过writeFile写入的内容&quot;,function (err) { if (!err){ console.log(&quot;写入成功&quot;); } }) 文件打开常用模式：w：写入文件，如果不存在则创建，文件写入默认从头开始写会覆盖文件。r+:读写文件，写操作时会覆盖，文件不存在则出现异常。w+:读写文件，文件不存在先创建，会覆盖。a: 写入文件，打开文件用于追加，如果不存在则新建。a+：读写文件，文件不存在先建立，追加r：读取文件，文件不存在则出现异常rb/wb：分别与r/w相似，但是用于读写二进制文件 流式文件写入同步、异步、简单文件的写入都不适合大文件的写入（只要写一次），性能较差，容易导致内存溢出。只要流存在，可以分多次写入。 创建一个可写流：fs.createWriteStream(path,[,options]) - path：文件路径 - options 配置的参数 - 有返回值，该方法会返回一个文件的描述符作为结果，我们可以通过该描述符对文件进行各种操作 const fs = require(&quot;fs&quot;) //流失文件写入 //创建一个可写流 let ws = fs.createWriteStream(&quot;hello.txt&quot;) //可以通过监听流的open和close事件来监听流的打开和关闭 ws.once(&quot;open&quot;,function () { //open只会触发一次，on绑定了事件会一直存在，所以用once绑定一次性事件。 console.log(&quot;已经打开流&quot;); }) ws.once(&quot;close&quot;,function () { console.log(&quot;流关闭&quot;); }) ws.write(&quot;写入成功&quot;) ws.write(&quot;哈哈哈哈&quot;) ws.write(&quot;写入成功&quot;) ws.write(&quot;哈哈哈哈&quot;) //关闭流，关闭的接收方， ws.close() 文件的读取操作基本上和文件的写入差不多，具体看API。注意：1.读取到的数据会返回一个Buffer2.如果要读取一个可读流中的数据，必须要为可读流绑定一个data事件，data事件绑定完毕，它会自动开始读取数据，读取完毕后可读流自动关闭 const fs = require(&quot;fs&quot;) //流失文件读取，可以分多次将文件读取到内存中 //创建一个可读流 let rs = fs.createReadStream(&quot;消息提醒.png&quot;) //创建一个可写流 let ws = fs.createWriteStream(&quot;xxx.png&quot;) //可以通过监听流的open和close事件来监听流的打开和关闭 rs.once(&quot;open&quot;,function () { console.log(&quot;已经打开流&quot;); }) rs.once(&quot;close&quot;,function () { console.log(&quot;流关闭&quot;); //读取完毕后可读流自动关闭，所以在这个时候关闭可写流 ws.close() }) //如果要读取一个可读流中的数据，必须要为可读流绑定一个data事件，data事件绑定完毕，它会自动开始读取数据，读取完毕后自动关闭 rs.on(&quot;data&quot;,function (data) { console.log(data); ws.write(data); //ws.close()，可能导致只读了一条数据就关闭 }) pipe()更简单的写法pipe(),rs.pipe(ws)在可读流rs与可写流ws之间架起一个管道，自动将可读流中的内容，直接输出可写流。 fs其他常用方法验证路径是否存在 fs.existsSync(path) 返回值：存在true，不存在false获取文件状态 fs.stat(path,callback)/fs.statSync(path) 返回对象：文件的状态删除文件 fs.unlink(path,callback)/fs.unlinkSync(path)读取一个目录的目录结构 fs.readdir(path[,options],callback)/fs.readdirSync(path[,options]) 返回一个字符串数组，每一个元素就是一个文件夹或文件的名字截断文件 fs.truncate(path,len,callback)/fs.truncateSync(path,len) 将文件修改成指定的len大小（一个汉字3个字节）创建文件夹 fs.mkdir(path[,mode],callbcak)/fs.mkdirSync(path[,mode])删除文件夹 fs.rmdir(path,callbcak)/fs.rmdirSync(path)重命名文件/剪贴文件 fs.rename(oldPath(oldName),newPath,callback)/fs.renameSync(oldPath,newPath)监视文件的修改 fs.watchFile(filename[,options],listener) listener回调函数，当文件发生变化时，回调函数会执行。 ip地址和端口号 ip地址用来定位计算机 端口号用来定位具体的应用程序 一切需要联网通信的软件都会占用一个端口号 端口号的范围从0-65536 在计算中有写一些默认端口号，最好不要去使用。如：http服务的80 httprequest 请求事件处理函数，需要接收两个参数：request，response。 const http = require(&quot;http&quot;) const server = http.createServer() server.on(&quot;request&quot;,function (request,response) { console.log(&quot;请求路径是&quot; + request.url); //在服务端默认发送的数据，其实是utf8编码的内容 //但是浏览器不知道是utf8的内容，在不知道服务器响应内容的编码的情况下会按照当前操作系统默认编码解析 //text/plain;普通文本 //response对象有一个方法：write可以用来给客服端发送响应数据； //write可以使用多次，但最后一定要使用end来结束响应，否则客服端会一致等待 //响应的数据只能是二进制(默认)或字符串 fs.readFile(xxx,function(err,data){ response.setHeader(&#39;Content-type&#39;,&quot;text/html;charset=utf-8&quot;) response.end(data) }) } }) server.listen(3000,function () { console.log(&quot;服务器启动成功&quot;); }) urlurl：统一资源定位符，url核心模块在为我们解析url地址时提供了非常方便的APIurl.parse()方法可以解析一个url地址，通过传第二个参数(true)把包含有查询字符串的query转化成对象 const url = require(&quot;url&quot;) let httpUrl = &quot;https://sale.vmall.com/hwmate.html#abc?cid=10602&quot; let urlObj = url.parse(httpUrl) console.log(urlObj); //Url { // protocol: &#39;https:&#39;, 协议 // slashes: true, // auth: null, // host: &#39;sale.vmall.com&#39;, 主机 // port: null, 端口号 // hostname: &#39;sale.vmall.com&#39;, // hash: &#39;#abc?cid=10602&#39;, // search: &#39;?cid=10602&#39;, 查找的内容 // query: &#39;cid=10602&#39;, query问号后面的内容 // pathname: &#39;/hwmate.html&#39;, 路径的名称 // path: &#39;/hwmate.html?cid=10602&#39;, // href: &#39;https://sale.vmall.com/hwmate.html?cid=10602&#39; } url.resolve()方法合成url，第一个参数基url，第二个参数目标url const url = require(&quot;url&quot;) let targetUrl=&quot;http://www.taobao.com/&quot; let httpUrl = &quot;./xxx.html&quot; console.log(url.resolve(targetUrl, httpUrl)); //自动去掉./ //http://www.taobao.com/xxx.html]]></content>
      <categories>
        <category>前端</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F2020%2F02%2F23%2F%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[ES5时，有个经典的需求：点击某个按钮，提示”点击的是第n个按钮” //html &lt;button&gt;测试1&lt;/button&gt; &lt;button&gt;测试2&lt;/button&gt; &lt;button&gt;测试3&lt;/button&gt; //js var btns = document.getElementsByTagName(&quot;button&quot;); //遍历加监听 for (var i = 0;i&lt;btns.length;i++) { var btn = btns[i]; btn.onclick =function () { alert(i) } 这里有个关于效率的问题,btns是伪数组，for循环中btns.length每次都要计算一遍才能得到结果，这里循环就会计算多次。改进之后的代码: var btns = document.getElementsByTagName(&quot;button&quot;); //遍历加监听 for (var i = 0,length=btns.length;i&lt;length;i++) { var btn = btns[i]; btn.onclick =function () { alert(i) } } 但是点击按钮之后发现每个按钮都打印的3。因为点击之后的函数是回调函数，需要放在宏队列中执行，而for循环已经执行结束(i已经等于3了) ES6之前的解决办法：解决办法1：将btn所对应的下标保存在btn上 var btns = document.getElementsByTagName(&quot;button&quot;); //遍历加监听 for (var i = 0,length=btns.length;i&lt;length;i++) { var btn = btns[i]; btn.index = i btn.onclick =function () { alert(this.index) } } 解决办法2:闭包 var btns = document.getElementsByTagName(&quot;button&quot;); for (var i = 0;i&lt;btns.length;i++) { var btn = btns[i]; (function (i) {//这i是局部的 btn.onclick = function () { alert(i) } })(i)//这个i是全局i } 问题1:如何产生闭包？当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时，就产生了闭包。 问题2：闭包到底是什么?(用chrome调试查看)闭包是嵌套的内部函数注意:闭包存在于嵌套函数的内部函数中 问题3：产生闭包的条件1.函数嵌套2.内部函数引用了外部函数的数据 函数定义时就会产生闭包，调用一次外部函数产生一个新的闭包。做闭包的题的时候仔细分析哪个变量导致闭包且是否有新的闭包产生。 常见的闭包1.将函数作为另一个函数的返回值 function fn1() { var a = 2 function fn2() { a++; console.log(a); }//仅一个闭包 return fn2 } //f指向了fn2的函数对象(局部变量fn2已经不在了，因为fn2不在闭包里面)，这也是闭包一直存在的原因 var f = fn1()//已经产生了闭包，执行完后，a还在 f()//3 f()//4 局部函数调用时存在，调用结束消失。外部函数执行几次，就产生几个闭包。所以此例子只产生了一个闭包。 2.将函数作为实参传递给另一个函数调用 function showDelay(msg,time) { //setTimeout()是在执行这个函数 setTimeout(function () {//闭包是在定义内部函数时生成的 alert(msg)//回调函数是内部函数，且用了外部函数的msg值 },time) } showDelay(&quot;xxx&quot;,2000) //产生了闭包 闭包的作用(又想隐藏，又想使用) 使用函数内部的变量在函数执行完后，仍然存活在内存中(延长了局部变量的生命周期) 让函数外部可以操作(读写)到函数内部的数据 闭包的生命周期产生：在嵌套内部函数定义执行完成时就产生了(不是在调用)死亡：在嵌套的内部函数成为垃圾对象时 function fn1() { var a = 2//此时闭包就已经产生了(函数提升，内部函数对象已经创建了) function fn2() { a++; console.log(a); } return fn2 } var f = fn1() f = null //闭包死亡(包含闭包的函数对象成为垃圾对象) 闭包的应用1.定义JS模块 具有特定功能的JS文件 将所有的数据和功能都封装在函数内部（私有的）//对象的属性外部直接可以见，所以封装在对象里不算私有 只向外暴露一个包含n个方法的对象或函数 //module.js function myModule(){ //私有数据 var msg = &quot;xxx&quot; function doSomething(){ console.log(&quot;doSomething&quot;+msg.toUpperCase()) } function doOtherthing(){ console.log(&quot;doOtherthing&quot;+msg.toLowerCase()) } //向外暴露对象 return{doSomething,doOtherthing} } } //其他界面调用时，需要一个函数来接收 匿名函数自调用 //module2.js (function myModule(window){ //私有数据 var msg = &quot;xxx&quot; function doSomething(){ console.log(&quot;doSomething&quot;+msg.toUpperCase()) } function doOtherthing(){ console.log(&quot;doOtherthing&quot;+msg.toLowerCase()) } //向外暴露对象 window.module2 = {doSomething,doOtherthing} })(window) //其他界面调用时，直接module2.doSomethig 闭包的缺点及解决缺点：函数执行完后，函数内的局部变量没有释放，占用内存时间会变长。(容易造成内存泄漏)解决：能不用闭包就不用，及时释放（让内部函数称为垃圾对象–&gt;回收闭包） 内存溢出一种程序运行出现的错误。当程序运行需要的内存超过了剩余的内存时，就会抛出溢出的错误。 内存泄漏占用的内存没有及时释放就是内存泄露，内存泄漏积累多了就容易导致内存溢出。常见的内存泄漏：意外的全局变量，没有及时清理的计时器（如启动循环定时器后不清理）或回调函数，闭包。 let intervalId = setInterval(function(){//启动循环定时器后不清理 console.log(&quot;---&quot;) },1000) //清除定时器 clearInterval(intervalId) 面试题 var name = &quot;The Window&quot;; var object = { name:&quot;My object&quot;, getNameFunc : function () { return function () { return this.name; } } } console.log(object.getNameFunc()());//The Window var name = &quot;The Window&quot;; var object = { name:&quot;My object&quot;, getNameFunc : function () { var that = this return function () { return that.name; //that等于的this是 调用了getNameFunc的对象 } } } console.log(object.getNameFunc()());//My object]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回调函数]]></title>
    <url>%2F2020%2F02%2F23%2F%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一直都知道回调函数这种说法，但是并不能很准确的回答什么是回调函数？ 这个是知乎常溪玲的答案，非常的通俗易懂 你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。 或者说回调函数的特征:你定义的，你没有调，但它最终执行了。 常见回调函数 dom事件回调函数 定时器回调函数 ajax请求回调函数 生命周期回调函数 document.getElementById(&quot;btn&quot;).onclick=function () {//dome事件回调函数 alert(this.innerHTML) } //定时器 setTimeout(function () { //定时器回调函数 alert(&quot;到点了&quot;) },2000)]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git&GitHub]]></title>
    <url>%2F2020%2F02%2F14%2Fgit-1%2F</url>
    <content type="text"><![CDATA[git介绍结构 工作区（本身文件）：写代码 = git add =&gt; 暂存区：临时存储 = git commit =&gt; 本地库（.git）：存储历史版本 Git和代码托管中心 代码托管中心(如GitHub):帮忙维护远程库 本地库和远程库 团队内部协作 跨团队协作 外团队人员fork该团队远程库A（复制新的远程库B），clone到本地修改后push到B，之后外团队人员pull request =&gt; 该团队人 审核 =&gt; merge 远程库A的内容更新成远程库B的内容。 git命令行操作本地库初始化命令：git init效果：出现隐藏文件.git注意：.git目录中存放的是本地库相关的子目录和文件，不要删除，也不要乱修改 设置签名形式: 用户名：XXX Email地址：XXXXX 作用：区分不同开发人员的身份辨析：这里设置的签名和代码托管中心的账号、密码没有任何关系命令: 项目级别/仓库级别：仅在当前本地库起作用 git config user.name XX git config user.email XX 系统用户级别：登陆当前操作系统的用户范围， git config --global git config --global user.name XX git config --global user.email XX 级别优先级：项目级别优于系统用户级别 基本操作状态检查命令: git status作用：查看工作区、暂存区状态 移除暂存区命令: git rm –cached [filename] 添加到暂存器命令：git add[filename] 添加所有git add . 添加所有修改的git add -A 提交命令：git commit -m”commit message”[filename] 提交所有git commit -m”版本留言描述”作用：将暂存区的内容提交到本地库 查看历史任务命令： 完整形式 git log 若多屏显示控制方式：空格向下翻页 b向上翻页 q退出 以一个漂亮的格式显示 git log –pretty=oneline/git log–oneline(后面的更简洁) git reflog :索引值更简洁，其中HEAD@{移动到当前版本需要多少步} &lt;img src=&quot;/img/git/历史任务.png&quot; /&gt; 前进后退可以配合git reflog使用本质:操作HEAD的指针，默认是指向最近的版本。基于索引值操作（推荐）: git reset –hard [局部索引值] 例（上图）：git reset–hard a6ace91使用^(异或)符号（只能后退）： git reset –hard HEAD^ 注:一个^表示后退一步，n 个表示后退 n 步使用~符号（只能后退）: git reset –hard HEAD~n 注:表示后退 n 步 reset 命令的三个参数对比–soft参数： 仅仅在本地库移动 HEAD 指针 只回退了commit的信息，如果还要提交，直接commit –mixed参数：① 在本地库移动 HEAD 指针 ② 重置暂存区 默认方式 git reset –mixed + git add . = git reset –soft –hard参数：①在本地库移动 HEAD 指针 ② 重置暂存区 ③ 重置工作区 彻底回退到某个版本，本地的源码也会变成上一个版本的内容 删除文件与恢复前提：删除前，文件存在时的状态提交到了本地库。操作：rm [filename]注：rm之后通过 git add [filename] 可把文件再次添加到缓存区 可利用 git reset –hard[指针位置] 回退到之前版本找回文件。 前提：删除的文件在暂存区，但还没有提交到本地库命令: git reset –hard HEAD（刚刚创建时） 比较文件差别命令：git diff[文件名]作用：将工作区中的文件和暂存区进行比较 命令：git diff[本地库中历史版本][文件名]作用：将工作区中的文件和本地库历史记录比较 注意:不带文件名比较多个文件 分支管理优势： 同时并行推进多个功能开发，提高开发效率 各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可 分支操作创建分支命令：git branch[分支名] 查看分支命令：git branch -v 切换分支命令：git checkout[分支名] 合并分支如把hot_fix上的修改合并到master上 第一步：切换到合并的分支上 git checkout[master]第二步：执行 merge 命令 git merge[hot_fix] 解决冲突合并时同时修改同一个文件的同一个地方 第一步:自行修改冲突文件第二步:git add[文件名]第三步:git commit-m”日志信息” 注意：此时 commit 一定不能带具体文件名 GitHub连接远程库命令： git remote-v 查看当前所有远程地址别名 git remote add [别名] [远程地址] (常用别名：origin)作用：下次上传可以直接用别名上传 推送命令：git push [别名][分支名] 克隆命令：git clone 仓库地址作用；完整的把远程库下载到本地；创建origin远程地址别名；初始化本地库。 团队成员邀请 变成团队成员就可以把自己的修改推送进入远程仓库了。 拉取pull命令: git fetch[远程库地址别名][远程分支名] git merge[远程库地址别名/远程分支名] git pull[远程库地址别名][远程分支名]作用: pull=fetch+merge。 fetch 把远程库抓取下来，并没有修改本地文件。 merge 把远程的master合并到本地的master，本地文件修改。 解决冲突要点：如果不是基于GitHub远程库的最新版本所作的修改，不能推送，必须先拉取下来如若pull下来之后进入冲突状态，其余同分支冲突处理办法一样。 跨团队操作外团队人员fork该团队远程库A（复制新的远程库B、外团队人员的仓库），clone到本地修改后push到B，之后外团队人员pull request （GitHub远程库B操作）=&gt; 该团队人（GitHub远程库A） 审核 =&gt; merge 远程库A的内容更新成远程库B的内容。 SSH登陆第一步：生成ssh（在家目录）ssh-keygen ct rsa -C 邮箱账号 //注意C大写注：在主目录下生成的密钥在 /c/Users/用户名/.ssh/id_rsa 里第二步：查看并复制ssh（需在.ssh目录下执行 cd .ssh进入）cat id_rsa.pub第三步：复制密钥内容添加到 github 上 使用ssh协议上传文件到仓库 git initgit add .git commit -m “ “git remote add 别名 git@github.com:…git push -u 别名 master Git工作流在项目开发过程中使用的Git的方式 GitFlow工作流(常用)Gitflow 工作流通过为功能开发、发布准备和维护设立了独立的分支，让发布 迭代过程更流畅。严格的分支模型也为大型项目提供了一些非常必要的结构。]]></content>
      <categories>
        <category>前端</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[富文本tinymce]]></title>
    <url>%2F2020%2F02%2F09%2F%E5%AF%8C%E6%96%87%E6%9C%ACtinymce%2F</url>
    <content type="text"><![CDATA[安装//安装tinymce-vue npm install @tinymce/tinymce-vue -S //安装tinymce,版本为5.X npm install tinymce -S //引入中文语言包 中文下载包 使用在 node_modules中找到 tinymce/skins目录，然后将skins目录拷贝到static目录下的tinymce 初始化引入基本文件 //初始化tinymce import tinymce from &#39;tinymce/tinymce&#39; import Editor from &#39;@tinymce/tinymce-vue&#39; import &#39;tinymce/themes/silver&#39; 注册组件 &lt;Editor&gt;&lt;/Editor&gt; //js components: {Editor} 初始化配置 &lt;Editor :init=&quot;init&quot;&gt;&lt;/Editor&gt; data() { return { init:{ //语言 language_url: &#39;/static/tinymce/zh_CN.js&#39;, language: &#39;zh_CN&#39;, //skin路径 skin_url: &#39;/static/tinymce/skins/ui/oxide&#39;, } } }, mounted () { tinymce.init({}) }, 初始化配置之后最基本的符文就有了，接下来丰富它的功能 数据同步 //子组件 &lt;Editor v-model=&quot;myValue&quot;&gt;&lt;/Editor&gt; data() { return { myValue: this.value } }, props: { value: { default: &#39;&#39;, type: String }, } watch: { value(newValue) { this.myValue = newValue }, myValue(newValue) { this.$emit(&#39;input&#39;, newValue) } }, //父组件 onEditorUploadSuccess为图片上传成功的回调 &lt;editor v-model=&quot;value&quot; @on-upload-success=&quot;onEditorUploadSuccess&quot; &gt;&lt;/editor&gt; 完整代码 &lt;template&gt; &lt;div&gt; &lt;Editor :init=&quot;init&quot; v-model=&quot;myValue&quot;&gt;&lt;/Editor&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; //这个是接口文件 import {ImgUpload} from &#39;@/api/notice&#39; //初始化tinymce import tinymce from &#39;tinymce/tinymce&#39; import Editor from &#39;@tinymce/tinymce-vue&#39; //引入主题 import &#39;tinymce/themes/silver&#39; /* 引入插件 */ import &#39;tinymce/plugins/image&#39; import &#39;tinymce/plugins/table&#39; import &#39;tinymce/plugins/preview&#39; import &#39;tinymce/plugins/fullscreen&#39; import &#39;tinymce/plugins/link&#39; import &#39;tinymce/plugins/code&#39; import &#39;tinymce/plugins/lists&#39; import &#39;tinymce/plugins/hr&#39; import &#39;tinymce/plugins/advlist&#39; import &#39;tinymce/plugins/paste&#39; import &#39;tinymce/plugins/importcss&#39; import &#39;tinymce/plugins/media&#39; export default { data() { return { myValue: this.value, init:{ //语言 language_url: &#39;/static/tinymce/zh_CN.js&#39;, language: &#39;zh_CN&#39;, //设置皮肤 skin_url: &#39;/static/tinymce/skins/ui/oxide&#39;, //高度 height: 400, //菜单栏 menubar: false, //隐藏商标 // branding: false, //工具栏|分类 配置插件 toolbar: `styleselect | fontselect | formatselect | fontsizeselect | forecolor backcolor | bold italic underline strikethrough | image | table | alignleft aligncenter alignright alignjustify | outdent indent | numlist bullist | preview removeformat hr | code link | undo redo | fullscreen `, //自动聚焦 auto_focus: true, //引入插件 plugins: ` paste importcss image code table advlist fullscreen link media lists hr preview`, //图片标题 image_caption: true, //上传本地图片 image_uploadtab:true, // Image imagetools_toolbar: &#39;rotateleft rotateright | flipv fliph | editimage imageoptions&#39;, // 设置Tab // tabfocus_elements: &#39;:prev,:next&#39;, // object_resizing: true, //设置可选段落样式 style_formats: [ { title: &#39;首行缩进&#39;, block: &#39;p&#39;, styles: { &#39;text-indent&#39;: &#39;2em&#39; } }, { title: &#39;行高&#39;, items: [ { title: &#39;1&#39;, styles: { &#39;line-height&#39;: &#39;1&#39; }, inline: &#39;span&#39; }, { title: &#39;1.5&#39;, styles: { &#39;line-height&#39;: &#39;1.5&#39; }, inline: &#39;span&#39; }, { title: &#39;2&#39;, styles: { &#39;line-height&#39;: &#39;2&#39; }, inline: &#39;span&#39; }, { title: &#39;2.5&#39;, styles: { &#39;line-height&#39;: &#39;2.5&#39; }, inline: &#39;span&#39; }, { title: &#39;3&#39;, styles: { &#39;line-height&#39;: &#39;3&#39; }, inline: &#39;span&#39; } ] } ], //字体列表 font_formats: ` 微软雅黑=微软雅黑; 宋体=宋体; 黑体=黑体; 仿宋=仿宋; 楷体=楷体; 隶书=隶书; 幼圆=幼圆; Andale Mono=andale mono,times; Arial=arial, helvetica, sans-serif; Arial Black=arial black, avant garde; Book Antiqua=book antiqua,palatino; Comic Sans MS=comic sans ms,sans-serif; Courier New=courier new,courier; Georgia=georgia,palatino; Helvetica=helvetica; Impact=impact,chicago; Symbol=symbol; Tahoma=tahoma,arial,helvetica,sans-serif; Terminal=terminal,monaco; Times New Roman=times new roman,times; Trebuchet MS=trebuchet ms,geneva; Verdana=verdana,geneva; Webdings=webdings; Wingdings=wingdings,zapf dingbats`, //内容样式, 在最后呈现的页面也要写入这个基本样式保证前后一致 content_style: ` * { padding:0; margin:0; } html, body { height:100%; } img { max-width:100%; display:block;height:auto; } a { text-decoration: none; } iframe { width: 100%; } p { line-height:1.6; margin: 0px; font-family:&quot;宋体&quot;; } table { word-wrap:break-word; word-break:break-all; max-width:100%; border:none; border-color:#999; } .mce-object-iframe { width:100%; box-sizing:border-box; margin:0; padding:0; } ul,ol { list-style-position:inside; } `, insert_button_items: &#39;image link | inserttable&#39;, //回车添加的标签 forced_root_block:&quot;p&quot;, //强制每行添加&lt;p&gt;标签 force_p_newlines: true, importcss_append: true, //字体大小栏选项 fontsize_formats: &#39;10px 11px 12px 14px 16px 18px 20px 24px&#39;, // paste设置 paste_data_images: true,//可以粘贴图片 paste_word_valid_elements: &#39;*[*]&#39;,//word过滤 paste_retain_style_properties:&#39;all&#39;, //允许保留word粘贴过来的格式 paste_convert_word_fake_lists: false,//禁止word的列表内容转换html的ul和ol格式 paste_merge_formats: true,//合并相似格式 nonbreaking_force_tab: false, paste_auto_cleanup_on_paste: false, statusbar: false, // 隐藏编辑器底部的状态栏 images_upload_handler: this.uploadImg//图片上传 }, } }, props: { //图片最大大小 maxSize: { default: 2097152, type: Number }, //图片可接收类型 accept: { default: &#39;image/jpeg, image/png, image/jpg, image/svg, image/gif&#39;, type: String }, //上传地址 url: { default: &#39;&#39;, type: String }, //数据 value: { default: &#39;&#39;, type: String }, }, methods: { //上传图片 uploadImg(blobInfo, success, failure) { const that = this //符合大小 if (blobInfo.blob().size &gt; this.maxSize) { failure(&#39;文件体积过大&#39;); } //符合类型 if (this.accept.indexOf(blobInfo.blob().type) &gt; -1) { let form = new FormData(); form.append(&#39;file&#39;, blobInfo.blob(), blobInfo.filename()); ImgUpload(form).then(res=&gt;{ //给父组件传值 that.$emit(&#39;on-upload-success&#39;, { res, success, failure }) }).catch(err =&gt; { failure(&#39;上传失败: &#39; + err); }) } else failure(&#39;图片格式错误&#39;); }, }, watch: { value(newValue) { this.myValue = newValue }, myValue(newValue) { this.$emit(&#39;input&#39;, newValue) } }, components: {Editor}, mounted () { tinymce.init({}) }, } &lt;/script&gt; &lt;!--scoped 样式仅仅在当前组件使用--&gt; &lt;style scoped&gt; &lt;/style&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>库</category>
      </categories>
      <tags>
        <tag>富文本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件超市项目后台管理界面开发流程3]]></title>
    <url>%2F2020%2F02%2F06%2F%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82%E9%A1%B9%E7%9B%AE%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B3%2F</url>
    <content type="text"><![CDATA[vue全局配置项目有很多重复用到的变量和方法，新建一个global/index.js来存放。具体的实现是通过在Vue的原型上添加方法和属性，也就是使用Vue.prototype，最后要在main.js引入文件`import “./global”; Messsage.vue一级导航用于显示消息通知,里面包含了两个组件，一个用于分页的ProjectPagination，一个是用于消息提醒的MessageRemind。这里实现了流程1提到的:如果有未读消息，进入管理页面后直接显示消息通知，如果没有未读消息，则显示第一个路由。 //登陆之后是先跳转到message，此时的pageEnterStatetrue=true。 if (this.pageEnterState) { //如果没有消息就跳到第一个路由 if (this.msgLen === 0) { const route = this.$store.getters.addRouter; this.$router.push(route[0].path); } else { //如果有消息就显示，tableData就是登陆时传给state的消息 this.data = this.tableData; this.isLoading = false; } this.$store.commit(&quot;SET_PAGE_ENTER_STATE&quot;, false); } else { this.loadData(); } } 分页ProjectPagination结合element-ui的pagination加上一些修改。前一篇博客中提到了父组件向子组件传值的方法，这里同时也用到了子组件向父组件传值的方法 &lt;!-- 分页器 --&gt; &lt;template&gt; &lt;el-pagination class=&quot;x-page&quot; layout=&quot;total,sizes, prev, pager, next, jumper&quot; @current-change=&quot;handleCurrentChange&quot; @size-change=&quot;handleSizeChange&quot; :current-page.sync=&quot;currentPage&quot; :page-sizes=&quot;pageSizes&quot; :page-size=&quot;pageSize&quot; :total=&quot;total&quot;&gt;&lt;/el-pagination&gt; &lt;/template&gt; &lt;script&gt; export default { name: &quot;ProjectPagination&quot;, //接收父组件传来的值 props: { //data为所有数据 data: Array, //filterData做为一个筛选容器 filterData: Array }, data() { return { //当前页数 currentPage: 1, //默认的一页显示条数 pageBase: 10 }; }, computed: { // 数据总数目 total() { return this.data.length; }, // 一页有多少条数据 pageSize() { //如果基础数据大于总数，则显示总数 let size = this.total &gt;= this.pageBase ? this.pageBase : this.total; return size; }, // 提供每页条数的选择，返回值为一个数组 pageSizes() { let count = Math.ceil(this.total / this.pageSize); let sizes = []; for (let i = 1; i &lt;= count; i++) { sizes.push(this.pageSize * i); } return sizes; } }, methods: { //pageSize改变执行，回调参数:每页条数 handleSizeChange(val) { // 获取项目条数 //子组件像父组件传值，更新filterData。 this.$emit(&quot;update:filterData&quot;, this.data.slice(0, val)); }, // 页面页数改变 handleCurrentChange(val) { // 获取下一页数据 this.$emit( &quot;update:filterData&quot;, this.data.slice((val - 1) * this.pageSize, val * this.pageSize) ); } }, created() { //发送一个update:filterData，显示pageSize个数据 this.$emit(&quot;update:filterData&quot;, this.data.slice(0, this.pageSize)); }, watch: { // 监控数据变化时获取数据 data() { this.$emit(&quot;update:filterData&quot;, this.data.slice(0, this.pageSize)); } }, //路由要求刷新 activated() { if (this.$route.meta.isRefresh) { this.currentPage = 1; } } }; &lt;/script&gt; &lt;style scoped&gt; .x-page { margin-top: 10px; float: right; } &lt;/style&gt; $emit(update: prop, “newPropVulue”)$emit(update: prop, “newPropVulue”) 这个模式，使子组件向父组件传达：更新属性，并抛出新的属性值。 从上述代码中可以看出首先更新的值要是从父组件中接收的，也就是props里面的值。其次父组件该值需要写成 &lt;ProjectPagination :data=&quot;data&quot; :filter-data=&quot;filterData&quot; @update:filter-data=&quot;filterData=$event&quot;&gt;&lt;/ProjectPagination&gt; 更简单的写法是.sync修饰符 &lt;ProjectPagination :filter-data=&quot;filterData&quot; :filter-data.sync=&quot;filterData&quot;&gt;&lt;/ProjectPagination&gt; 注意:这里有一个Vue.sync修饰符与$emit(update:xxx)写法的坑使用.sync修饰符 //有效 this.$emit(&quot;update:filterData&quot;, this.data.slice(0, val)); //无效 this.$emit(&quot;update:filter-Data&quot;, this.data.slice(0, val)); 不使用.sync修饰符 //无效 this.$emit(&quot;update:filterData&quot;, this.data.slice(0, val)); //有效 this.$emit(&quot;update:filter-Data&quot;, this.data.slice(0, val)); MessageRemind消息提醒的MessageRemind使用了element-ui的消息提醒，这里最后的实现比较容易，但是在实现的过程中遇到了一个关于路由监控的坑。 路由监听失效：需要在父路由的组件内才可以监听到子路由的信息。 Notice.vue仅管理员拥有的组件。主要有左边的导航和中间显示部分组成。显示公告列表，增删改查等实现比较容易就没有记录下来。 这里记录一个文章显示的css，超出部分滚动，但不显示滚轮 .article{ height: 100%; overflow-x:hidden; overflow-y: scroll; } // -webkit-scrollbar css3新特性 .article::-webkit-scrollbar { display: none; } 框架 &lt;template&gt; &lt;div class=&quot;notice&quot;&gt; &lt;div class=&quot;nav&quot;&gt; &lt;el-menu default-active=&quot;publish&quot; class=&quot;el-menu-vertical-demo&quot; @select=&quot;handleSelect&quot; &gt; &lt;el-menu-item index=&quot;publish&quot; &gt; &lt;i class=&quot;el-icon-edit-outline&quot;&gt;&lt;/i&gt; &lt;span slot=&quot;title&quot;&gt;发布公告&lt;/span&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;allNotice&quot;&gt; &lt;i class=&quot;el-icon-document&quot;&gt;&lt;/i&gt; &lt;span slot=&quot;title&quot;&gt;所有公告&lt;/span&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;dustbin&quot;&gt; &lt;i class=&quot;el-icon-delete&quot;&gt;&lt;/i&gt; &lt;span slot=&quot;title&quot;&gt;回收站&lt;/span&gt; &lt;/el-menu-item&gt; &lt;/el-menu&gt; &lt;/div&gt; &lt;router-view class=&quot;view&quot;&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; handleSelect(key) { let path=&#39;/notice/&#39;+key; this.$router.push({path:path}) } 富文本tinymce默认显示的是发布公告,选用的是tinymce这款富文本。 学习笔记 项目问题1表单规则验证 &lt;el-form-item label=&quot;学/工号&quot; prop=&quot;captainInformation.studentId&quot; &gt; &lt;el-input v-model.number=&quot;form.captainInformation.studentId&quot; &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; data() { return { form:{ teamName:&quot;&quot;, captainInformation:{ name:&quot;&quot;, studentId:&quot;&quot;, }, }, rules: { teamName: [ { required: true, message: &#39;请输入团队名称&#39;, trigger: &#39;blur&#39; }, { min: 3, max: 10, message: &#39;长度在 3 到 10 个字符&#39;, trigger: &#39;blur&#39; } ], //这个位置注意一定要加引号 &quot;captainInformation.studentId&quot;: [ { required: true, message: &#39;请输入学号&#39;, trigger: &#39;blur&#39; }, {type: &#39;integer&#39;, message: &#39;格式错误&#39;, trigger: &#39;blur&#39;} ], } 问题二过滤器 后台传来的数据只有分数，未评分的分数为-1，这里需要将其显示成状态已完成或未评分，并且可以根据状态筛选数据。 &lt;el-table-column prop=&quot;score&quot; sortable label=&quot;状态&quot; :filters=&quot;tags&quot; :filter-method=&quot;filterTag&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-tag disable-transitions style=&quot;font-size:12px&quot; :type=&quot;stateColor(scope.row.score)&quot;&gt;{{scope.row.score| filterState}}&lt;/el-tag&gt; &lt;/template&gt; &lt;/el-table-column&gt; //js //筛选标签 filterTag(value, row) { if (value === -1) { return row.score === -1; } else { return row.score &gt;= value; } }, //过滤器 filters: { filterState(val) { return val === -1 ? &quot;未评分&quot; : &quot;已完成&quot;; } }, 问题三返回刷新问题从详情返回列表，列表不需要刷新，而从其他页面进入列表，列表需要刷新。首先需要了解两个生命周期： // 数据缓存 beforeRouteEnter(to, from, next) { //如果不是从teamDetail来的界面需要刷新 if (![&quot;teamDetail&quot;].includes(from.name)) { to.meta.isRefresh = true; } next() }, activated() { //需要刷新的界面 if (this.$route.meta.isRefresh) { // 先重置 this.$route.meta.isRefresh = false; //重新获取数据 this.isLoading = true; this.getLoadData(); } }, 后面重复的操作比较多，多为增删查改，重复的东西将不在记录了。有关于vue我不熟悉的知识点，会重新学习了解之后更新博客。]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>软件超市</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件超市项目后台管理界面开发流程2]]></title>
    <url>%2F2020%2F01%2F31%2F%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82%E9%A1%B9%E7%9B%AE%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B2%2F</url>
    <content type="text"><![CDATA[设置权限时动态加载路由 路由分为两类，一类是静态路由（不需要登陆验证），一类是动态路由（需要登陆验证） 当用户登陆后，获取用role（权限），将role和路由表每个页面的需要的权限作比较，生成用户可访问的路由表 调用router.addRoutes(store.getters.addRouters)添加用户可访问的路由。 使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。 permission.js首先新建store/permission.js，用来控制生成的路由表。 //是否有权限访问，role为当前权限 function hasPermission(role, route) { if (route.meta &amp;&amp; route.meta.roles) { //如果该路由的meta存在，并且有要求权限 const roles = route.meta.roles; //如果路由要求的权限有当前权限，返回成功 return roles.includes(role); } else { //如果不存在说明不需要权限 return true; } } const permission ={ state: { //默认路由 routers: constantRouterMap, //添加的路由 addRouters: [] }, mutations: { SET_ROUTERS: (state, routers) =&gt; { //往数组中添加符合条件的路由 state.addRouters = routers; //符合权限的路由变成默认路由可访问。 state.routers = constantRouterMap.concat(routers); } }, actions: { //定义产生路由的方法 async GenerateRoutes({ commit }, { role }) { //返回符合权限的异步路由 const accessedRouters = await asyncRouterMap.filter(route =&gt; hasPermission(role, route) ); commit(&quot;SET_ROUTERS&quot;, accessedRouters); return accessedRouters; } } } export default permission; 这里可以把permission.js看成一个模块，因为它拥有自己的state,mutation,action。所以还需要把permission挂载在vuex里。 export default new Vuex.Store({ modules:{ permission }, state, actions, mutations, getters }); 问题一addRoutes在哪里调用登录后，获取用户的权限信息，然后筛选有权限访问的路由，再调用addRoutes添加路由。这个方法是可行的。但是不可能每次进入应用都需要登录，用户刷新浏览器又要登陆一次。所以addRoutes还是要在全局路由守卫里进行调用。 if(token){ //已经登陆了 if (to.path ===&quot;/login&quot;) next({path:&quot;/&quot;}) // else{ if (!store.getters.role){ //如果没有当前权限信息,role仅getUserInfor后可以获得 //用户登陆之后，根据缓存获取登陆信息 store.dispatch(&quot;getUserInfor&quot;).then(role=&gt;{ //产生符合权限路由的方法 store.dispatch(&quot;GenerateRoutes&quot;, { role }) .then( data =&gt; { // 生成可访问的路由表 router.addRoutes(data); next({ ...to, replace: true }); }) ..... } } } 问题一 next()的使用 首先调用next()时会直接进入to路由，不会再调用beforeEach(),所以刷新页面可能会进入无限循环，调用next(‘xxx’)后会拦截路由使得路由重定向xxx，并再次调用beforeEach()。 如果把replace设置为true，那么导航不会留下history记录，点击浏览器回退按钮不会再回到这个路由。router.addRoutes之后的next()可能会失效，因为可能next()的时候路由并没有完全add完成，next({…to}) 的时候重新指定以下刷新前的路径。 问题二 404页面404路由写在动态路由中，否则可能会有闪屏和路由为空时加载的404页面。原因是：当页面刷新，会导致vue重新实例化，路由也恢复了初始路,addRoutes 还没有添加上路由就开始跳转， 所以找不到路由就跳转到404页面了。 Layout页面Layout作为整个后台管理页面的框架，主要有Header、根据权限生成的Sidebar和中间的显示界面组成。 框架//Layout组件 &lt;div id=&quot;manage&quot;&gt; &lt;Header&gt;&lt;/Header&gt; &lt;div class=&quot;container&quot;&gt; &lt;Sidebar&gt;&lt;/Sidebar&gt; &lt;router-view class=&quot;content&quot; &gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; 通过把一级路由与二级路由的path设置成同一个，来同时加载Header组件、Sidebar组件和中间对应的显示界面 //仅用其中一个举列子 const project ={ path: { path: &quot;/projectManage&quot;, name: &quot;projectManage&quot;, component: Layout }, check: [ { path: &quot;check&quot;, name: &quot;projectCheck&quot;, component: () =&gt; import( /* webpackChunkName: &quot;ProjectCheck&quot; */ &quot;../views/projectManage/components/ProjectCheck&quot; ) }, ], } export const asyncRouterMap = [ { ...project.path, children: [ { path: project.path.path, redirect: &quot;/projectManage/check&quot;, component: () =&gt; import(/* webpackChunkName: &quot;ProjectDeveloper&quot; */ &quot;../views/projectManage/ProjectDeveloper&quot;), children: [...project.check] },] } ] 注意:这里有个简单的重定向问题我晕了好久QAQ 首先是path加/和不加/有什么区别。/xx就是根路径。下面代码去到children是/#/child而不是/#/fa/child。而不以斜杠开头的，都会被当成普通的字符串拼到当前路径的后面。 path: /fa children: { path: /child } 然后这里重新定向之后projectManage/check路由到底算几级路由？通过把redirect注释之后终于弄懂了。这里是因为children控制的是第几个router-view,第一个children控制的是第二个router-view，即使它重定向/projectManage/check,第二个router-view显示的还是ProjectDeveloper组件。 Siderbar导航图标上显示未读消息数量 主要实现是使用element-ui里面的badge组件+父子间传值实现的。这里以导航图标上显示未读消息数量为例子，后续类似操作将不做记录。 新建一个MessageNue.vue记录未处理的消息数量，作为子组件，接收父组件传来的值。这里接收两个值：customClass样式，因为这个组件会重复使用，并且不同消息显示的位置可能不同，所以关于定位的信息要单独接收。menu接收的是显示的哪一个消息。 &lt;template&gt; &lt;span class=&quot;badgebox&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;el-badge :value=&quot;getMsgN(menu)&quot; :style=&quot;customClass&quot; class=&quot;item&quot; :max=&quot;99&quot; :hidden=&quot;!getMsgN(menu)&quot;&gt;&lt;/el-badge&gt; &lt;/span&gt; &lt;/template&gt; &lt;script&gt; export default { name: &quot;MessageNum&quot;, props: { menu: Object, customClass: String }, methods: { getMsgN(menu) { return this.count[menu.path]; } }, computed: { count() { return this.$store.state.msgNum; } } }; &lt;/script&gt; //state.js //需要显示的消息数量 msgNum: { publishExamine: 0, delayExamine: 0, alterExamine: 0, undertakeExamine: 0, projectExamine: 0, porjectRun: 0, projectCheck: 0, projectFinish: 0, projectManage: 0 }, Sidebar.vue 作为父组件，把组件挂载好之后。menu值是传的动态值所以用v-bind:绑定，而customClass是一个静态值所以直接传值就行。 这里有一个命名的坑:props属性支持驼峰命名,不支持连接线命名。HTML特性是不区分大小写的，所以在HTML之中的驼峰写法要变成连接线写法。 &lt;message-num :menu=&quot;{path:router.name}&quot; custom-class=&quot;top:-12px;right:-12px&quot;&gt; &lt;i class=&quot;iconfont&quot; :class=&quot;&#39;icon-&#39;+router.meta.icon&quot;&gt;&lt;/i&gt; &lt;/message-num&gt; Header.vue主要功能有： 1.显示用户名，可退出2.如果身份是开发团队的队长，且同时有几个团队，显示当前团队，并可切换其他团队。3.点击logo的时候，可以操作侧边栏展开 ①下拉框用的是Element-ui的el-dropdown组件,下拉的时候出现退出键。 // @command=&quot;handleCommand&quot;为绑定下拉框点击事件，command为值 &lt;el-dropdown class=&quot;exit&quot; @command=&quot;handleCommand&quot; trigger=&quot;click&quot;&gt; &lt;span class=&quot;el-dropdown-link&quot;&gt; {{ username }} &lt;i class=&quot;el-icon-arrow-down el-icon--right&quot;&gt;&lt;/i&gt; &lt;/span&gt; &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt; &lt;el-dropdown-item command=&quot;exit&quot;&gt;退出&lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/el-dropdown&gt; // 退出登录或者切换用户管理界面 handleCommand(command) { console.log(command); if (command === &quot;exit&quot;) { //退出之后清除 this.exit(); }， exit() { // 退出清除缓存和登录 //登录成功之后重定向到登录页 this.$store.dispatch(&quot;Logout&quot;); } ②做第二个功能的时候，首先团队名称是通过axios获取的，并且刷新的时候还要在。所以应该把数据存在session中，同时要解决数据渲染的问题,采用了在state里面设置get和set的方法。 //state.js get teams() { let vlaue = sessionStorage.getItem(&quot;teams&quot;); return typeof vlaue === &quot;string&quot; ? JSON.parse(vlaue) : []; }, set teams(vlaue) { sessionStorage.setItem(&quot;teams&quot;, JSON.stringify(vlaue)); }, get teamId() { return sessionStorage.getItem(&quot;teamId&quot;); }, set teamId(vlaue) { sessionStorage.setItem(&quot;teamId&quot;, vlaue); }, 这里切换团队之后页面刷新用了上一篇博客提到的provide/inject组合刷新的办法。 ③第三个功能是兄弟Header和Sidebar组件的通讯，因为做这个项目主要是学习为主，所以选择了借助中央事件总线：在外部新建一个utils/eventBus.js文件。 //eventBus.js import Vue from &#39;vue&#39; export default new Vue(); //Header.vue import eventBus from &quot;../../utils/eventBus.js&quot;; extendNav() { //通过eventBus中央事件总线用$emit发送一个showNav事件 eventBus.$emit(&quot;showNav&quot;); } //Sidebar.vue mounted() { //通过eventBus中央事件总线用$on监听组件1中发送的showNav事件，第二个参数为回调函数。 eventBus.$on(&quot;showNav&quot;, this.change); }, 上述是最开始的做法，后面发现更简便的方法。主要是省略了外部的js文件，把总线放在main.js里的vue实例中 new Vue({ data:{ eventBus:new Vue() } }) 兄弟组件调用的时候,用this.$root.eventBus.$on代替eventBus.$on]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>软件超市</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件超市项目后台管理界面开发流程1]]></title>
    <url>%2F2020%2F01%2F29%2F%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82%E9%A1%B9%E7%9B%AE%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[3.3 组件编写3.3.1 Manage.vue 存放目录：src/views/Manage.vue 作用：作为Layout容器 详情：包含了Header组件与Sidebar组件 3.3.2 Login.vue 存放目录：src/views/login/Login 作用：登陆界面 详情：通过前台展示界面进入，进入时选择身份，ID的不同身份权限不一样。 具体实现 需要根据前台显示的页面获取信息： getStudentIdByRequest get请求获取登陆的学号ID getUserId?studentId= 通过登陆的studentId获取userId getRole?userId= 通过userId获取角色权限，通过不用的权限生成不同的导航栏。 getMessageByUserGet?userGet=userId 通过userId获取消息，如果有未读消息，进入管理页面后直接显示消息通知，如果没有未读消息，则显示第一个路由。 权限、登陆时效等相关（重要） 问题一：跨域问题由于vue-cli脚手架工具开发时，由于项目本身启动本地服务是需要占用一个端口的，所以必然会有跨域问题。解决办法：config/index（webpack构建下），更改开发环境下(在dev里配置)的proxyTable。将请求代理到目标域名 proxyTable: { &quot;/v1&quot;:{ target:&quot;http://software.sicau.edu.cn:8080&quot;, changeOrigin: true//是否开启代理 } }, 问题二：axios的cookie问题由于用的是学校的统一认证平台，采用的是cookie，在使用axios的时候，发现http响应头中少了Set-Cookie属性（axios隐藏了这部分）。解决办法：axios.defaults.withCredentials = true。withCredentials属性主要功能是指定跨域的请求是否应该使用证书（如cookie或授权头header） 问题三：vue组件刷新问题。（这个方法在添加删除之中比较好用，最后虽然没有采用但还是把记录下来）用vue-router重新路由到当前页面，页面是不进行刷新的。采用window.reload,或者router.go(0)刷新时，整个浏览器进行了重新加载，闪烁，体验感不好。解决办法：provide/inject组合provide：选项应该是一个对象或返回一个对象的函数。该对象包含可传递其子孙的属性。inject：一个字符串数组，或一个对象，对象的 key 是本地的绑定名 app.vue 中通过provide将父组件中的数据传给子组件 &lt;router-view v-if=&quot;isRouterAlive&quot;&gt;&lt;/router-view&gt; &lt;script&gt; export default { name: &quot;App&quot;, provide() { return { reload: this.reload } }, data() { return { isRouterAlive: true } }, methods: { reload() { this.isRouterAlive = false this.$nextTick( ()=&gt; this.isRouterAlive = true ) } } }; &lt;/script&gt; 在要使用的组件中inject:[‘reload’],调用this.reload()既可实现刷新。 问题4：错误捕获问题由于前端要根据返回的不同错误类型，进行不同的处理，在抛出问题时，不知道用async/await的错误如何捕获。解决办法：try catch只能捕获同步代码，不能捕获异步代码，在async函数内，使用await可以捕获异步代码，这里实际上是异步代码变成了同步代码。 在 async 函数内部使用 try catch 捕获异步错误 promise 内部使用 .catch 方法来捕获 promise 内部代码错误 async getRequest({commit,dispatch}){ try{ let resGetStudentIdByRequest = await getStudentIdByRequest(); if (resGetStudentIdByRequest.status==0){ ... } else throw resGetStudentIdByRequest.msg; }catch(err){ throw {err, msg: &quot;无效登录&quot;, code: 1 } } }, 问题5：token验证 ——————————————————待补充 之前的项目用的是session，偶然见看见一篇关于token的文章。https://blog.csdn.net/mydistance/article/details/84545768 点击进入管理界面时，先根据选择的不同身份，设置不同的不同的角色信息，在进加密。 进行路由拦截 //main.js router.beforeEach((to, from, next) =&gt; { let token = sessionStorage.getItem(&quot;token&quot;); if(token){...} else{ //如果没有token ,如果to.path在白名单中,则免登陆。如果不在白名单中，定向去登陆页面 (whiteList.includes(to.path)) == true ? next(): next(&quot;/login&quot;) } } 登陆时设置token //action.js //设置角色 async setRole({commit,dispatch},roleId){ //给身份加密 setRole(roleId); //设置token setToken(); }, //auth.js const verify = 45416289438485; //给角色权限加密 export const setRole = roleId =&gt; { let token = verify * roleId; sessionStorage.setItem(&quot;xxx&quot;, token); }; //设置登陆token export const setToken = () =&gt; { let token = randomString(32); sessionStorage.setItem(&quot;token&quot;, token); }; //产生随机数 function randomString(len) { len = len || 32; /****默认去掉了容易混淆的字符oOLl,9gq,Vv,Uu,I1****/ const $chars = &quot;ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678&quot;; const maxPos= $chars.length; let pwd = &quot;&quot;; for (let i = 0; i &lt; len; i++) { pwd += $chars.charAt(Math.floor(Math.random() * maxPos)); } return pwd; } 然后为了防止用户直接手动按f5刷新页面，这个时候会重新构建vue实例，而又没有重新登录，所以vuex里面的东西会清空，所以将登录后的数据存放在sessionStroage中，在刷新页面，重新构建vue实例的时候，会有判断。 问题6：button按钮添加回车事件最开始的写法，发现login方法根本没有执行，开始以为是@keyup.enter.native的问题，但是写在封装好的组件中的时候加.native才能监听原生的事件。后面发现是输入框事件，在button上面不起效果。 &lt;el-button @click=&quot;login&quot; @keyup.enter.native=&quot;login&quot; class=&quot;btn&quot; :loading=&quot;btnLoading&quot;&gt;进入管理页面&lt;/el-button&gt; 修改后，用了自定义指令的办法。 &lt;el-button @click=&quot;login&quot; v-enter=&quot;this&quot; class=&quot;btn&quot; :loading=&quot;btnLoading&quot;&gt;进入管理页面&lt;/el-button&gt; directives: { // 按enter键登录 enter(el, { value }) { document.onkeydown = e =&gt; { e = e || window.event; if (e.keyCode === 13) { value.login(); } }; } }, 问题7：封装好外部链接通过新建一个元素a，调用函数时点击a来实现外部跳转 const HOME_URL = &quot;主页&quot;; const LOGIN_URL = &quot;统一认证界面&quot;; //新建a export const goto = url =&gt; { const link = document.createElement(&quot;a&quot;); link.href = url; link.click(); }; goto.home = () =&gt; goto(HOME_URL); goto.login = () =&gt; goto(LOGIN_URL);]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>软件超市</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie、LocalStorage、sessionStorage的区别]]></title>
    <url>%2F2020%2F01%2F29%2FCookie%E3%80%81LocalStorage%E3%80%81sessionStorage%2F</url>
    <content type="text"><![CDATA[主要区别 方法 localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等 setItem存储value sessionStorage.setItem(&quot;key&quot;, &quot;value&quot;); localStorage.setItem(&quot;key&quot;, &quot;value&quot;); getItem获取value let value = sessionStorage.getItem(&quot;key&quot;); let key = localStorage.getItem(&quot;key&quot;); removeItem删除key sessionStorage.removeItem(&quot;key&quot;); localStorage.removeItem(&quot;key&quot;); clear清除所有的key/value sessionStorage.clear(); localStorage.clear(); localStorage和sessionStorage的key和length属性实现遍历 let storage = window.localStorage; for(var i=0, len=storage.length; i&lt;len;i++){ var key = storage.key(i); var value = storage.getItem(key); console.log(key + &quot;=&quot; + value); }]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB学习笔记]]></title>
    <url>%2F2019%2F08%2F01%2FMongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[MongoDB是非关系型数据库文档数据库，存的类似JSON的结构。 启动服务器，db存放数据库，我创建在D盘的。 mongod --dbpath D:\mongoDB\data\db /*-----默认端口号27017-----*/ mongod --dbpath D:\mongoDB\data\db --port XXX 注意两个概念： 数据库的服务器。服务器用来保存数据，mongod启动服务器 数据库的客户端。客户端用来操作服务器，对数据惊醒增删改查的操作，mongo启动 基本概念数据库：存放集合。集合：类似数组，在集合中存放文档。文档：文档是数据库中的最小单位，存储和操作内容都是文档。 基本操作use 数据库名 //进入数据库 增加插入一个放对象db..insert({数据})//db..insertOne()插入多个放数组db..insert([{},{}]) //db ..insertMang() //插入多条可以配合使用for循环 var arr =[]; for (var i=1;i&lt;=20000;i++){ arr.push({num:i}); } db.numbers.insert(arr) 查询db..find({条件})，为空查询所有。 /*----名字为张三并且年龄为28的文档,返回的是一个数组--*/ db.stus.find({name:&quot;张三&quot;,age:28}) /*----查询符合条件的第一个集合，返回的是一个对象--*/ db.stus.findOne({age:28}) /*-----返回符合条件的文档数量----*/ db.&lt;collection&gt;.find().count() MongoDB支持通过内嵌文档的属性进行查询，通过点（.）连接。但是此属性名必须是用引号。 hobby:{movies:[111,222],XXX} //查找的是hobby里面的moovies里面的值有111 db.users.find(‘hobby.movies’:&#39;111&#39;) 修改db..update(查询条件，新对象,{修改的配置选项，可选})。update默认会使用新对象来替换旧对象。所以不常用。默认情况下只会修改一个 ，实际上既可修改单个，也可修改多个。db..updateMany()。 修改多条db..updateOne()。 修改单条db.collection.replaceOne()。替换单条 常与$set结合使用来修改文档中的指定属性，没有的属性名会自动创建。unset可以删除响应属性。 db.stus.update({name:&quot;李四&quot;},{$set:{gender:&quot;女&quot;}，{add:&quot;哈哈哈&quot;}}) //若值为一个数组,$push往数组中添加。不考虑是否重复 //$addToSet 向数组中添加一个新元素。 重复的就不会添加。 db.stus.update({name:&quot;李四&quot;},{$push:{hobby.movies’:&#39;333&#39;}}) 删除db.collection.remove() 删除符合条件的所有文档，第二个参数可选：删除配置（比如只删除一个）。必须传参，但如果传递空对象，则所有文档都删除（清空集合，性能太差）db.collection.deleteMany()db.collection.deleteOne()db.collection.drop() 删除集合db.dropDatabase()删除数据库 一般数据是不会删除的，而是在数据中添加一个字段，表示是否删除]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[keep-alive]]></title>
    <url>%2F2019%2F06%2F29%2Fkeep-alive%2F</url>
    <content type="text"><![CDATA[&lt;keep-alive&gt;能在组件切换的过程中将状态保留在内存中，防止重复渲染DOM。 设置了keepAlive缓存的组件： 第一次进入：beforeRouterEnter -&gt;created-&gt;…-&gt;activated-&gt;…-&gt;deactivated 后续进入时：beforeRouterEnter -&gt;activated-&gt;deactivated activated和deactivated仅在keepAlive缓存的组件里被激活只有第一次进入该组件时，才会走created钩子，而需要缓存的组件中activated是每次都会走的钩子函数。 prop: include: 字符串或正则表达式。只有匹配的组件会被缓存。 exclude: 字符串或正则表达式。任何匹配的组件都不会被缓存。 在2.1.0版本Vue中 常见用法： // 组件 export default { name: &#39;test-keep-alive&#39;, data () { return { includedComponents: &quot;test-keep-alive&quot; } } } &lt;keep-alive include=&quot;test-keep-alive&quot;&gt; &lt;!-- 将缓存name为test-keep-alive的组件 --&gt; &lt;component&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;keep-alive include=&quot;a,b&quot;&gt; &lt;!-- 将缓存name为a或者b的组件，结合动态组件使用 --&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;!-- 使用正则表达式，需使用v-bind --&gt; &lt;keep-alive :include=&quot;/a|b/&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;!-- 动态判断 --&gt; &lt;keep-alive :include=&quot;includedComponents&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;keep-alive exclude=&quot;test-keep-alive&quot;&gt; &lt;!-- 将不缓存name为test-keep-alive的组件 --&gt; &lt;component&gt;&lt;/component&gt; &lt;/keep-alive&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件超市-返回刷新问题]]></title>
    <url>%2F2019%2F06%2F28%2F%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82-%E8%BF%94%E5%9B%9E%2F</url>
    <content type="text"><![CDATA[在对项目进行优化的时候，发现返回上一页的函数很多组件都会使用，于是打算把这个函数抽离出来。 在此之前需要先解决首页进入列表页面刷新，而详情页返回列表页面不刷新的问题的问题 方法一：keep-alive与vue-router配合使用实现在定义了两个字段 keepAlive:true 标识是否使用keep-alive组件字段,ifDoFresh:false标识是否刷新数据字符 /*------router/index-----*/ { path: &#39;/project&#39;, name:&#39;项目列表&#39; component:resolve =&gt; require([&quot;@/pages/Project/Project&quot;],resolve), meta: { keepAlive:true, ifDoFresh:false, showNav: true } }, 在根组件中根据keepAlive 字符判断是否使用keep-alive组件 /*------app.vue----*/ &lt;div class=&quot;main&quot;&gt; &lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;/&gt; &lt;/keep-alive&gt; &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;/&gt; &lt;/div&gt; 在目标列表页的beforeRouteEnter判断从哪个页面进入的，根据需求更改ifDoFresh变量。这里与activated联合用。 beforeRouteEnter(to,from,next){ //需要刷新的页面 if (from.name!=&quot;团队详情&quot;) { to.meta.ifDoFresh = true; } next() }, activated(){ if (this.$route.meta.ifDoFresh){ // 先重置 this.selected=0 this.$route.meta.ifDoFresh=false this.$store.dispatch(&#39;getTeam&#39;,{teamId:0}) } } 按逻辑来说这样就可以了，但是有个的问题出现了！！！！ 返回只显示一个团队了！！好气啊，不断调试中发现我团队详情的团队信息居然和我列表的团队信息存储在同一个变量里！！！！所以点进详情页后，改变了team，而keep-alive缓存的是team里的数据。我是白痴吗？？？？ 还有一个问题就是从列表到首页，在从首页到列表页，分页的缓存仍然存在。 解决办法：在分页器组件内提前判断（因为使用分页器组件时并没有传当前页码） activated(){ if (this.$route.meta.ifDoFresh) { this.currentPage = 1 } }, 方法二：keep-alive标签内部添加 keep-alive的总结]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>软件超市</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件超市-改变v-html内容的图片样式]]></title>
    <url>%2F2019%2F06%2F26%2F%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82-%E9%97%AE%E9%A2%98v-if%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在通过v-html把后台传过来的内容渲染到页面之后，发现后台传来的图片是限制了宽和高的。 通过查资料发现，这里解析是把v-html传来的数据作为了一个新的组件，所以在scoped下的style里面设置样式不起作用。那么根据原理，或许可以把scoped直接去掉，但是为了防止组件之间的样式污染，使用了其他办法。 方法一 &gt;&gt;&gt;(深度作用选择器) 或者 有些sass类的预处理器无法正确解析可以使用 /deep/ /*----html----*/ &lt;div class=&quot;announcement_img&quot; v-html=&quot;announcement.content&quot;&gt;&lt;/div&gt; /*----style----*/ .announcement_img&gt;&gt;&gt;img{ width: 100%; display: block; height: auto; } 方法二 updated周期函数中，js动态配置样式。 首先需要清楚updated周期函数在什么时候起作用，①data里面需要有该数据变量如arr ②在页面重新渲染arr完成后才进入updated。更深入的会在以后学习。 updated:function(){ console.log(&quot;1==我会先执行&quot;); this.$nextTick(function(){ //在下次 DOM 更新循环结束之后执行这个回调。在修改数据之后立即使用这个方法，获取更新后的DOM. console.log(&quot;3==我只能等页面渲染完了才会立即执行&quot;); }) console.log(&quot;2==我虽然在最后但会比$nextTick先执行&quot;) } 如果后期发现更好的或者更多的办法会重新更新。]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>软件超市</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown]]></title>
    <url>%2F2019%2F05%2F15%2Fmarkdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[写博客的时候有些不常用的语法会有遗漏，今天重新学习markdown常用语法并把记录下来。 综述 兼容HTML。不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。 用于瞄点测试 基本语法标题方法一： ``` # 第一级标题 `&lt;h1&gt;` ## 第二级标题 `&lt;h2&gt;` ### 第三级标题 `&lt;h3&gt;` #### 第二四级标题 `&lt;h4&gt;` ##### 第五级标题 `&lt;h5&gt;` ###### 第六级标题 `&lt;h6&gt;` ``` 方法二： 任何数量的 = 和 - 都可以有效果。 ``` 一级标题 = 二级标题 - ``` 字体如果* 和 _ 两边都有空白的话，它们就只会被当成普通的符号如果要在文字前后直接插入普通的星号或底线，可以用反斜线。 斜体 *内容*或者_内容_ （em）加粗 **内容**或者__内容__ （strong）倾斜加粗 ***内容***删除线 ~~内容~~ 链接行内式 ``` [我的博客](https://biubiuins.github.io/) 自动生成连接 &lt;https://biubiuins.github.io/&gt; ``` 效果：我的博客自动生成连接 https://biubiuins.github.io/ 添加图片形式和链接类似。 ``` 格式：![图片描述](url) ![GitHub set up](http://zh.mweb.im/asset/img/set-up-git.gif) ``` 效果： 分割线可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。 代码块 只要简单地缩进 4 个空格或是 1 个制表符就可以。 需要和普通段落之间存在空行！ `内容` 多行代码块与语法高亮：在需要高亮的代码块的前一行及后一行使用三个单反引号`包裹，就可以了。 代码块中包含html代码。在代码区块里面， &amp; 、&lt; 和 > 会自动转成 HTML 实体 引用 在被引用的文本前加上&gt;符号，以及一个空格就可以了，如果只输入了一个&gt;符号会产生一个空白的引用。 引用可以嵌套 引用的区块内也可以使用其他的Markdown 语法 列表符号后面一定要有一个空格，起到缩进的作用。还需要注意的是在使用列表时，只要是数字后面加上英文的点，就会无意间产生列表，比如2017.12.30 这时候想表达的是日期，有些软件把它被误认为是列表。解决方式：在每个点前面加上\就可以了。 无序列表使用 *，+，- 表示无序列表。 有序列表使用数字和一个英文句点表示有序列表。 表格姓名|分数 -|- 张三|50 李四|80 效果： 姓名 分数 张三 50 李四 80 表格对齐方式：我们可以指定表格单元格的对齐方式，冒号在左边表示左对齐，右边表示有对齐，两边都有表示居中。 姓名|分数 :-|-: 张三|50 李四|80 效果： 姓名 分数 张三 50 李四 80 反斜杠Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号 常用技巧换行方法1: 连续两个以上空格+回车方法2：使用html语言换行标签 其他特殊字符unicode字符编码 内容目录在段落中填写 [TOC] 以显示全文内容的目录结构，需要独占一行才能生效。 字体样式Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3。 &lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt; &lt;font color=gray size=5&gt;color=gray&lt;/font&gt; &lt;font color=#0099ff size=5 face=&quot;黑体&quot;&gt;color=#0099ff size=5 face=&quot;黑体&quot;&lt;/font&gt; 背景色需要借助 table, tr, td 等表格标签的 bgcolor 属性来实现背景色的功能。 &lt;table&gt;&lt;tr&gt;&lt;td bgcolor=pink&gt;背景色是：pink&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 效果： 背景色是：pink 瞄点自定义瞄点 标签形式的锚点目标的id特性值中是不能含有中文字符； //建立一个跳转链接 [说明文字](#jump) //需要跳转到的位置 &lt;span id = &quot;jump&quot;&gt;跳转到的位置&lt;/span&gt; 效果：瞄点 Markdown会自动给每一个h1~h6标题生成一个锚，其id就是标题内容。如表格]]></content>
      <categories>
        <category>前端</category>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[element-ui总结]]></title>
    <url>%2F2019%2F04%2F19%2Felement-ui%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在一次项目中用到了element-ui框架，对在使用过程中遇见的问题进行总结（持续更新）。 表单1.数据为二级对象时数据为二级对象时，验证的数据要用字符串形式。 rules:{ &quot;captainInformation.name&quot;: [ { required: true, message: &#39;请输入姓名&#39;, trigger: &#39;blur&#39; }, ], } 2.动态添加的数据动态添加的输入框或表单绑定数据时注意 :prop=&quot;&#39;v-for绑定的数组.&#39; + index + &#39;.v-model绑定的变量&#39;&quot; 我是直接把验证写在标签里面的 &lt;el-form-item label=&quot;姓名&quot; :prop=&quot;&#39;memberInformation.&#39;+index+&#39;.name&#39;&quot; :rules=&quot;[ { required: true, message: &#39;请输入姓名&#39;, trigger: &#39;blur&#39; }]&quot;&gt; 增加与减少成员 //增加成员 addmember() { let newmember = { name: &quot;&quot;, studentId: &quot;&quot;, } this.form.memberInformation.push(newmember) }, //减少成员 reducemember(index) { this.form.memberInformation.splice(index, 1) }, 这个是我在项目中用到的办法，在阅读时发现了另一种情况的解决办法：https://blog.csdn.net/weixin_41041379/article/details/81908788 3.普通输入验证```js rules:{ data1:[ //必填，trigger是触发类型 { required: true, message: &#39;请输入学号&#39;, trigger: &#39;blur&#39; }, //数字类型 &#39;number&#39;, 整数: &#39;integer&#39;, 浮点数: &#39;float&#39; //使用整数的时候，首先要保证数据类型为数字，可以v-model.number绑定数据 {type: &#39;integer&#39;, message: &#39;格式错误&#39;, trigger: &#39;blur&#39;}, //长度限制 { min: 2, max: 4, message: &#39;长度在 2 到 4 个字符&#39;, trigger: &#39;blur&#39; } ] } ``` 4.手动验证 第一种是直接写在rules的里面 rules:{ data1:[ { validator:(rule,value,callback)=&gt;{ if(/^\d+$/.test(value) == false){ callback(new Error(&quot;只能输入数字&quot;)); }else{ callback(); } }, trigger: &#39;blur&#39; } } ] 第二种写法是抽离出来 //注意书写位置 data(){ let checkAge = (rule, value, callback) =&gt; { if (!value) { return callback(new Error(&#39;年龄不能为空&#39;)); } if (!Number.isInteger(value)) { callback(new Error(&#39;请输入数字值&#39;)); } else { if (value &lt; 18) { callback(new Error(&#39;必须年满18岁&#39;)); } else { callback(); } } } return { rules:{ age: [ { trigger: &#39;blur&#39;, validator: checkAge } ] } } 5.手动上传文件```html //html &lt;el-upload action ref=&quot;upload&quot; //覆盖默认的上传行为，自定义上传的实现 :http-request=&quot;finish&quot; //取消自动上传 :auto-upload=&quot;false&quot; &gt; &lt;el-button slot=&quot;trigger&quot; size=&quot;small&quot; type=&quot;primary&quot;&gt;选取文件&lt;/el-button&gt; &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;请上传您的项目功能清单&lt;/div&gt; &lt;/el-upload&gt; //js finish() { this.$refs.form.validate(valid =&gt; { // 验证成功 if (valid) { //这里的需求是必须上传文件 const file = this.$refs.upload.uploadFiles[0]; if (!file) { this.$message({ type: &quot;warning&quot;, message: &quot;请选择文件&quot; }); return; } //数据处理 let formData = new FormData(); formData.append(&quot;projectId&quot;, this.runId); formData.append(&quot;timeNode&quot;,JSON.stringify(this.form.timeNode)); formData.append(&quot;teamId&quot;, 1); formData.append(&quot;functionFile&quot;,file.raw ); //....中间的弹框确定等省略 submitApply(formData) } } } ``` 6.动态获取选项+模糊查询]]></content>
      <categories>
        <category>前端</category>
        <category>库</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex流程总结]]></title>
    <url>%2F2018%2F12%2F09%2Fvuex%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[对如何异步显示数据效果的编码流程进行了总结 ajaxajax请求函数，抛出接口 vuex store里面新建index完成基本配置 /* vuex最核心的管理对象store 组装模块并导出 store 的地方 */ // 首先引入Vue及Vuex import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; // 引入四个基本模块 import state from &#39;./state&#39; import mutations from &#39;./mutations&#39; import actions from &#39;./actions&#39; import getters from &#39;./getters&#39; // 一定要声明使用插件 Vue.use(Vuex) // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件 export default new Vuex.Store({ state, mutations, actions, getters }) - 现在Vue对象里面挂载store ``` import store from &#39;./store&#39; new Vue({ el: &#39;#app&#39;, components: { App }, template: &#39;&lt;App/&gt;&#39;, store //所有的组件都多了一个$store }) ``` - 在store下新建state.js state：用于存储状态对象 ``` export default { user:{} } ``` - 在store下新建mutation-types.js mutation是操作state状态的，mutation-types是存放操作state的方法名 ``` export const RECEIVE_USER_INFO = &#39;receive_user_info&#39; // 接收用户信息 ``` - 在store下新建actions.js action是通过操作mutation间接更新state的多个方法的对象 起连接作用。 异步获取数据。(注意需要引入api接口函数)把数据传给mutation。(因为mutation的方法名是放在mutation-types里面，所以注意要引入mutation-types里面对应的方法名) ``` import { reqUserInfo, } from &#39;../api&#39; import { RECEIVE_USER_INFO, } from &#39;./mutation-types&#39; // 异步获取用户信息 async getUserInfo ({commit}) { const result = await reqUserInfo() //如果请求成功，返回code=0 if (result.code === 0) { const userInfo = result.data //提交mutation //把结果{userInfo}提交给RECEIVE_USER_INFO方法 commit(RECEIVE_USER_INFO, {userInfo}) } }, ``` 参数除了commit以外，还可以有state`{commit,state}` - 在store里面新建mutations.js mutations直接对state进行操作，`[方法名](state,{param}){}` 默认第一个参数state，所以需要引入vue与方法名 ``` import Vue from &#39;vue&#39; import { RECEIVE_USER_INFO, } from &#39;./mutation-types&#39; export default { [RECEIVE_USER_INFO] (state, {userInfo}) { state.userInfo = userInfo } } ``` 使用数据 一般放在computed中进行接收，有利于state的值发生改变的时候及时响应给子组件。 mapState辅助函数 mapState返回的是一个对象 其实就是返回值:{return this.$store.XXXX} 当一个组件需要获取多个状态时候，用mapState辅助函数更为方便 ``` import { mapState } from &#39;vuex&#39; export default { computed:mapState({ //方法一：箭头函数 count: state =&gt; state.count; //方法二：传字符串参数&#39;count&#39;等同于‘state=&gt;state.count’ count:&#39;count&#39;; //方法三，使用this获取局部状态，必须使用常规函数 count(state){ return this.count } }) } ``` 当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。 ``` computed:mapState([ &quot;count&quot;]) ``` …mapState() ...mapState是state的语法糖，使用时需要从vuex中引入 ``` computed:{ ...mapState({}) } ``` mapGetters 辅助函数 mapGetters辅助函数仅仅是将store中的getter映射到局部属性 import { mapGetters } from &#39;vuex&#39; export default { // ... computed: { // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters([ &#39;doneTodosCount&#39;, &#39;anotherGetter&#39;, // ... ]) } } mapActions 类似mapState getter计算属性 ``` computed: { doneTodosCount () { return this.$store.state.todos.filter(todo =&gt; todo.done).length } } ``` 如果有多个组件需要用到这个属性，可以在store里面定义‘getter’，可以说是store的计算属性，像计算属性一样，getter的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算 const store = new Vuex.Store({ state: { todos: [ { id: 1, text: &#39;...&#39;, done: true }, { id: 2, text: &#39;...&#39;, done: false } ] }, getters: { //state作为第一个参数 doneTodos: state =&gt; { return state.todos.filter(todo =&gt; todo.done) } //可以接收其他getter作为第二个参数 doneTodosCount: (state, getters) =&gt; { return getters.doneTodos.length } //可以通过让getter返回一个函数，来实现给getter传参,对store里的数组进行查询时非常有作用 getTodoById: (state) =&gt; (id) =&gt; { return state.todos.find(todo =&gt; todo.id === id) } // store.getters.getTodoById(2) // -&gt; { id: 2, text: &#39;...&#39;, done: false } } }) //在组件中使用，同计算属性的调用，不用加括号 this.$store.getters.doneTodosCount dispatch方法 dispatch(actionName,data)分发调用action，第一个参数是方法名，第二个是数据 触发store里面的action对应方法名的函数 this.$store.dispatch(&quot;&quot;)]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex]]></title>
    <url>%2F2018%2F11%2F11%2Fvuex%2F</url>
    <content type="text"><![CDATA[vuex主要是状态管理，将数据统一管理(state) 模块 状态对象 stat 操作state 直接更新state的多个方法对象 mutations 操作mutations 间接更新state的多个方法对象 actions 包含多个基于state的getter计算属性的对象 getters 包含n个mutations的type名称常量 mutations-type 引入import Vuex from &#39;vuex&#39; Vue.use(Vuex) 使用共享的数据 const state={}; 建立统一数据容器，唯一的容器 let store = new Vuex.Store({ state }) store(容器)注册到实例上，main.js里面，所有的组件都会有一个属性this.$store new Vue({ store, }) 在组件中使用，加不加this都一样 {{this.$store.state.XXX}} state(单向数据流) 注意,在组件中最好不要直接更改共享的数据，共享的数据仅仅给组件染 mutation 通过mutation(管理员)来更改状态，可以在store里面设置成严格模式 strict：true，mutation不支持异步 告诉mutations需要更改,mutations相当于methodsconst mutations={ add(state,count){ //state是自动放入的，默认指的就是当前的state //操作state的属性 state.XXX +=count } } let store = new Vuex.Store({ state， mutations, strict：true }) 组件通过mutations提交,第一个参数是与mutatioons里面的方法绑定，第二个参数是自定义参数this.$store.commit(&#39;add&#39;,2) 插件打印日志 import logger from &#39;vuex/dist/logger&#39; const store = new Vuex.store({ plugins:[logger()] }) 整理src下面创建一个store文件\index.js import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; Vue.use(Vuex) import logger from &#39;vuex/dist/logger&#39; const state={}; import mutations from &#39;./mutations&#39; export default new Vuex.Store({ state， mutations, strict：true, plugins:[logger()] }) store下面再创建一个mutations.js,里面存放mutations的相关 import * as Types from &#39;mutations.types.js&#39; const mutations = { // [方法名](state,{param}){} [Types.INCREMENT](state){ state.count+=1 }, [Types.DECREMENT](state){ state.count-=1 } }; export default mutations; 宏(一般大写)store下面再创建一个mutations.types.js里面存放mutations的方法的名字，方便查找 //增加 export const INCREMENT=&#39;INCREMENT&#39; //减少 export const DECREMENT=&#39;DECREMENT&#39; 组件中引入同mutations.js中引入一样,只不过不加中括号import * as Types from ‘mutations.types.js’ Types.INCREMENTTypes.DECREMENT getters相当于computed,如果数据多了可以模仿mutations的抽离 const getters={ val(state){ state.count%2?&#39;奇数&#39;:&#39;偶数&#39; } }; export default new Vuex.store({ getters, }) //引用时 {{$store.getters.val}} actions 和后台交互的异步action，后台数据也需要修改 Action 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 引入api以及mutation-types 异步获取数据 异步获取地址 发送异步ajax请求 提交一个mutation //async 方法名({commit,参数可选}{}) // 异步获取地址 async getAddress ({commit, state}) { // 从state状态中获取到经纬度用来设置reqAddress的参数（看接口文档） const geohash = state.latitude + &#39;,&#39; + state.longitude // 1. 发送异步ajax请求 const result = await reqAddress(geohash) // 2. 根据结果提交一个mutation commit(RECEIVE_ADDRESS, {address: result.data}) },]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
</search>
