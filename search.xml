<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2F2018%2F10%2F12%2Fgit%2F</url>
    <content type="text"><![CDATA[git的基本操作 初次配置第一步需要配置用户名和邮箱地址，因为git为每一次提交记录名字和邮箱地址12$ git config --global user.name &apos;runoob&apos;$ git config --global user.email test@runoob.com ssh key 生成一对shh key（id_rsa私钥，id_rsa.pub公钥） 1ssh-keygen 注：在主目录下生成的密钥在 /c/Users/用户名/.ssh/id_rsa 里 查看公钥内容（需在.ssh目录下执行） 1cat id_rsa.pub 复制密钥内容添加到 github 上 使用ssh协议上传文件到仓库 12345git initgit add .git commit -m &quot; &quot;git remote add origin git@github.com:...git push -u origin master 注：若在创建新仓库时有readme.md 文件会上传失败 新建版本库 git里面先进入新建库的文件夹下 初始化库初始化目录，目录下回出现一个.git的目录，该目录包含了资源的所有元数据 12git initgit init 目录名 添加文件到暂存区将当前目录下几个文件纳入版本控制，需要先用git add 命令告诉git开始对这些文件进行跟踪 123git add .//添加当前项目的所有文件git add README //添加名为README的文件git add -A 所有修改的内容添加到缓存区 增加到版本库中使用 git add 命令将想要快照的内容写入缓存区， 而执行 git commit -m将缓存区内容添加到仓库中。 12git commit -a 跳过这一步git commit -m&quot;版本留言描述&quot; 连接远程仓库（现在GitHub上面新建仓库） 1git remote add origin 仓库地址 讲本地仓库推送到远程库上 12git pushgit push -u origin master //首次执行，说明上传到仓库的master分支上 问题：![rejected] master -&gt; master (fetch first)解决办法：1. 先执行git pull 2. 然后再执行`git push --force origin master`替换原先的 `git push -u origin master` 从远程库克隆先把别人的fork进自己的库里面 克隆仓库到指定目录 123//自己在本地进入需要克隆进的文件夹下执行下面第一条指令git clone 仓库地址git clone 仓库地址 本地目录 add commit push 删除文件 本地删除文件 123//或者直接在文件管理器中把没用的文件删了//需要git进入文件夹下$ rm test.txt Git知道你删除了文件，这个时候只是本地删除了文件，而版本库里面还有文件，所以可以恢复文件 1$ git checkout -- test.txt 远程库删除文件 1git rm test.txt 记得还需要commit 我的石墨文档：https://shimo.im/docs/2Eg0gszciPEQBPxG/]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[express学习笔记]]></title>
    <url>%2F2018%2F10%2F12%2Fexpress%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[express 学习笔记 搭建简单服务器1234567891011//express() 是一个由 express 模块导出的入口（top-level）函数let express = require('express');//创建一个express应用实例名applet app = express();// 设置端口号：3000//process.env.PORT：读取当前目录下环境变量port的值let port = process.env.PORT || 3000 ;//在端口号上开启服务app.listen(port,function () &#123; console.log("server start"+port);&#125;); app.listen(port, [hostname], [backlog], [callback])类似于node中的http.Server.listen()1234567// 设置端口号：3000//process.env.PORT：读取当前目录下环境变量port的值let port = process.env.PORT || 3000 ;//在端口号上开启服务app.listen(port,function () &#123; console.log("server start"+port);&#125;); 服务器启动时候，默认端口3000：node app.js设置端口8080：PORT=8080 node app.js app.set(name,value)123456789//设置 views 文件夹为存放视图文件的目录, 即存放模板文件的地方,__dirname 为全局变量,存储当前正在执行的脚本所在的目录。app.set('views', path.join(__dirname, 'views'));app.set("views","./views");//设置使用的模板引擎app.set('view engine', 'ejs’)app.set("view engine","jade")npm install --save express-art-template//设置art模板引擎，后缀为artapp.engine('art', require('express-art-template')); app.get(name)返回name的value值1234567891011//实例一app.get('title');// =&gt; undefinedapp.set('title', 'My Site');app.get('title');// =&gt; "My Site"//实例二app.set('port', process.env.PORT || 3000);var server = app.listen(app.get('port'), function() &#123; console.log("server start"+port);&#125;); app.get(path, callback [, callback …])app.all(path, callback [, callback …])这种方法就像标准的app.METHOD()方法, 除了它匹配所有HTTP动词。访问path路径的所有方法执行的回调函数.12345//* 表示匹配所有的路径app.all('*', function(req, res)&#123; res.end(req.method + 'user')&#125;//一般放在最后面防止前面的被覆盖 请求与响应123456//Express 应用使用回调函数的参数： request 和 response 对象来处理请求和响应的数据。app.get('/', function(req, res)&#123; res.send('hello world'); res.status(404).send(错误请求)//访问这个路径是设定状态码为404 //通过res.send（）接口向客户端发送hello world，send只能响应一次，意思是只能出现一个send&#125;) res.send（）只能出现一次如果要响应多次，用node原生的write和end，但是如果只有write会处于一个挂起状态1234app.get('/', function(req, res)&#123; res.write('hello world'); res.write('hello world');&#125;) res.send有结束响应的作用 res.write没有结束响应的作用，需要res.end结束中间件挂起response下表中响应对象（res）的方法向客户端返回响应，终结请求响应的循环。如果在路由句柄中一个方法也不调用，来自客户端的请求会一直挂起。res.render()12345//设置 views 文件夹为存放视图文件的目录, 即存放模板文件的地方,__dirname 为全局变量,存储当前正在执行的脚本所在的目录。app.set('views', path.join(__dirname, 'views'));app.set("views","./views");//第一个是渲染的views文件夹下面的index，第二个是传递的数据,注意需要设置模板引擎res.render("index",&#123;&#125;,function()&#123;&#125;) res.setHeader()12//Content-Type的作用 该实体头的作用是让服务器告诉浏览器它发送的数据属于什么文件类型。res.setHeader(&quot;Content-Type&quot;,&apos;text/html;charset=utf-8&apos;) res.redirect()调用redirect()方法后，其后的代码都不会被执行。而使用redirect()设置的状态码不是301或302也不会发生跳转12res.redirect([status,] path)//重定义到path所指定的URL，重定向时可以同时指定HTTP状态码，不指定状态码默认为302 res.location()location()方法本质上是调用了ServerResponse对象的setHeader()方法，但并没有设置状态码。使用location()设置头信息，而不设置状态码或状态码不是301或302，并不会发生重定向1res.location(path) request req.query处理 get 请求，获取 get 请求参数12345678910// GET /search?q=tobi+ferretreq.query.q// =&gt; "tobi ferret"// GET /shoes?order=desc&amp;shoe[color]=blue&amp;shoe[type]=conversereq.query.order// =&gt; "desc"req.query.shoe.color// =&gt; "blue"req.query.shoe.type// =&gt; "converse" req.body处理 post 请求，获取 post 请求体12345678// POST user[name]=tobi&amp;user[email]=tobi@learnboost.comreq.body.user.name// =&gt; "tobi"req.body.user.email// =&gt; "tobi@learnboost.com"// POST &#123; "name": "tobi" &#125;req.body.name// =&gt; "tobi" req.params处理 /:xxx 形式的 get 或 post 请求，获取请求参数123456// GET /user/tjreq.params.name// =&gt; "tj"// GET /file/javascripts/jquery.jsreq.params[0]// =&gt; "javascripts/jquery.js" req.param(name)处理 get 和 post 请求，但查找优先级由高到低为 req.params→req.body→req.query123456789// ?name=tobireq.param('name')// =&gt; "tobi"// POST name=tobireq.param('name')// =&gt; "tobi"// /user/tobi for /user/:namereq.param('name')// =&gt; "tobi" 中间件用于客户端与服务器路由匹配之前的中间操作，正常中间件放在路由上面，中间件通过next()往下走。 app.use（[path],function）利用express托管静态文件node.js不能通过目录来引入文件，而express可以，public为静态目录1234//设置public文件夹为存放静态文件的目录。let path=require("path")//ex4里面唯一的内置中间件app.use(express.static(path.join(__dirname, 'public'))); 一个中间件处理器，请求来了，让那些中间件先处理一遍 没有挂载路径的中间件，应用的每个请求都会执行该中间件 挂载至 /path 的中间件，任何指向 /path 的请求都会执行它1234567app.use(&quot;/name&quot;,function(req,res,next)&#123;res.setHeader(&quot;Content-Type&quot;,&apos;text/html;charset=utf-8&apos;)next();&#125;)app.get(&quot;/name/n&quot;,function(req,res)&#123;&#125;)//也可以匹配到，在执行get请求/name/n时先执行上面的中间件 错误中间件错误处理中间件和其他中间件定义类似，只是必须要使用 4 个参数(err, req, res, next)。即使不需要 next 对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。遇见错误之后直接执行错误中间件。错误处理中间件应当在在其他 app.use() 和路由调用之后才能加载，一般放在路由的最底部，比如：123456789var bodyParser = require('body-parser');var methodOverride = require('method-override');app.use(bodyParser());app.use(methodOverride());app.use(function(err, req, res, next) &#123; // 业务逻辑 console.error(err.stack); res.status(500).send('Something broke!');&#125;); 应用生成器12345678910//安装$ npm install express-generator -g//view=XXX 使用引擎名字 myapp项目名称$ express --view=pug myapp//安装所有依赖$ cd myapp$ npm install//启动myapp项目$ set DEBUG=myapp:* &amp; npm start 我的石墨文档链接：https://shimo.im/docs/TXeewzaE8Jsdgn0I/练习的简易聊天室连接：https://github.com/biubiuins/demo_chat]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[project_email]]></title>
    <url>%2F2018%2F10%2F11%2Fproject-email%2F</url>
    <content type="text"><![CDATA[邮件收发项目大二上开始学html，css，js之后做的暑假做的前端页面，很感谢老师可以给一个练手的机会，在做的过程中发现了很多问题，以及项目完成之后的收获。&nbsp;&nbsp;&nbsp;&nbsp;虽然是一个很简单的界面，但是之前学习的时候不太仔细，也没有demo练习，还是做的磕磕绊绊，还好最后做的差不多了。TAT&nbsp;&nbsp;针对过程中的问题，阅读了很多关于语法规范的文章，js，jq又重新学习了一遍（练习了很多），大二下期基本在学习之中度过的。希望在以后的项目中可以有所进步，彻底的实现前后端分离！！！ 项目相关 完成时间：大二上期寒假 2018-3月左右 bootsrap框架，layui框架，jquery 项目不足 语法不规范，复用性不强，后面修改过一次感觉修改起来很复杂 js不熟练，项目之后大二下期又重新开始学习了一遍js，并写了总结 (https://biubiuins.github.io/2018/10/11/summary-2018-9/) 技术不足，没有实现前后端分离 主要功能 首页 http://mailroom.sicau.edu.cn/email/public/ bootsrap做了响应式，用了ajax请求数据 管理页面（需要登陆仅提供图片） 实现全选与批量删除 点击已取之后，重新获取数据（保证筛选邮件之后点击已取仍显示的是筛选之后的邮件) 邮件类型默认显示上一次选择的类型，可输入筛选的下拉框 超级管理员界面实现了原生js模态框，并做了根据屏幕居中]]></content>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[summary-2018.9]]></title>
    <url>%2F2018%2F10%2F11%2Fsummary-2018-9%2F</url>
    <content type="text"><![CDATA[summary-2018-9 这是在学会搭建博客之后的第一篇博客，以前学习的时候也有记笔记，所以把之前学习笔记上面整理的常见的功能、封装以及遇到的问题写出来，这篇仅限于js，jq。现在正在学习vue，希望在过段时间，自己也能写出关于vue学习的总结。在此之前还需要了解markdown的语法TAT 原来的笔记记录在石墨文档，https://shimo.im/docs/c8YrJy4obNICaWiS/ ID处理1234/** 获取id */function $(id) &#123; return typeof id === "string" ? document.getElementById(id) : null;&#125; 动画匀速动画1234567891011121314151617181920//元素，目标，步数function constant(obj, target, speed) &#123; // 1. 清除定时器 clearInterval(obj.timer); //2.判断方向 //如果现在的距离小于目标值,则往右，否则向左 let dir =obj.offsetLeft&lt;target?speed:-speed; //3. 设置定时器 obj.timer = setInterval(function () &#123; obj.style.left = obj.offsetLeft + dir + "px"; //若超出目标值或者不到目标值 //最后相减的值取绝对值后，总是小于步数的 //Math.abs(dir)||speed if(Math.abs(target-obj.offsetLeft)&lt;Math.abs(dir))&#123; clearInterval(obj.timer); //根据目标值板正 obj.style.left =target+'px'; &#125; &#125;, 20);&#125; 缓动动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function buffer(obj, json, fn) &#123; // 1. 清除定时器 clearInterval(obj.timer); var begin = 0, end = 0; // 2. 设置定时器 obj.timer = setInterval(function () &#123; // 2.0 旗帜, 决定动画是否结束 let flag = true; // 2.1 遍历 for(let k in json)&#123; // 2.2.-1 求出起始值 和 结束值 if(k === 'opacity')&#123; // 透明度 begin = parseInt( parseFloat(getCssAttr(obj, k)) * 100); end = parseInt(parseFloat(json[k]) * 100); &#125;else if(k === 'scrollTop')&#123; // 滚动到头部 begin = obj.scrollTop; end = parseInt(json[k]); &#125;else &#123; // 正常情况 begin = parseInt(getCssAttr(obj, k)); end = parseInt(json[k]); &#125; // 2.2.0 求出步长 //步长公式 let step = (end - begin) * 0.2; step = step &gt;=0 ? Math.ceil(step) : Math.floor(step); // 2.2.1 计算起始位置 if(k === 'opacity')&#123; obj.style.opacity = (begin + step) / 100; obj.style.filter = 'alpha(opacity=' + (begin + end)+')'; // 针对IE &#125;else if(k === 'scrollTop')&#123; obj.scrollTop = begin + step; &#125;else if(k === 'zIndex')&#123; obj.style[k] = json[k]; &#125;else &#123; obj.style[k] = begin + step + 'px'; &#125; // 2.2.2 判断 if(begin !== end)&#123; flag = false; &#125; &#125; // 3.0 结束动画 if(flag)&#123; clearInterval(obj.timer); // 开启动画组中的下一组动画 if(fn)&#123; // 判断有没有这个函数 fn(); &#125; &#125; &#125;, 60);&#125; js获取CSS利用 [] 访问属性 元素.style[“属性”];1234567891011121314//这种语法的好处就是可以动态的传递参数作为属性//只能获取行类标签 var h = 'height'; box.style[h] = 300 + 'px';//获取外部css或页内的cssfunction getStyleAttr(obj, attr) &#123; if(obj.currentStyle)&#123; // IE 和 opera return obj.currentStyle[attr]; &#125;else &#123; //window.getComputedStyle("元素", "伪类") （ 注意：两个选项是必须的，没有伪类 用 null 替代 ） //也可以点选，但是为了传递参数作为属性 return window.getComputedStyle(obj, null)[attr]; &#125;&#125; 定时器 在定时器事件前，先设置接收定时器的变量指向null 在定时器事件里，先要清除定时器再设置定时器，先清除是防止定时器累加轮播第一种这种不适合多图1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162function slider (sliderid,olStyleClassName,imgWidth,speed,second) &#123; //高级排他 //lastIndex 选中的小圆点样式 currentIndex 小圆点索引 picIndex 图片索引 let lastIndex=0,currentIndex=0,picIndex=0; // 1. 获取需要的标签 let ul=$(sliderid).children[0]; let ol=$(sliderid).children[1]; let list=ul.children; let olList= ol.children; // 2.克隆最后一个li标签 ul.appendChild(list[0].cloneNode(true)); // 3.动态创建小圆点 for(let i= 0;i&lt;list.length-1;i++)&#123; let li =document.createElement("li"); ol.appendChild(li); &#125; //4.第一个小圆点选中 olList[0].className=olStyleClassName; //5.监听每个li的进入事件 for(let i= 0;i&lt;olList.length;i++)&#123; //5.1 每一个li绑定自己的事件 olList[i].onmouseover=function () &#123; //先清除之前的选中状态，在把当前选中的索引给lastIndex lastIndex=currentIndex; olList[lastIndex].className=""; this.className=olStyleClassName; lastIndex=i; //5.2图片动起来 constant(ul,-(i * imgWidth),speed); currentIndex=picIndex=i; &#125;; &#125; //6.定时器 let timer; timer = setInterval(autoPlay, second); // 7. 清除和设置定时器 $(sliderid).onmouseover = function () &#123; clearInterval(timer); &#125;; $(sliderid).onmouseout = function () &#123; timer = setInterval(autoPlay, second); &#125;; function autoPlay()&#123; picIndex++; currentIndex++; //如果图片到了最后一张 if (picIndex &gt; list.length - 1) &#123; ul.style.left = 0; //从第二张图片开始 picIndex = 1; &#125; constant(ul, -(picIndex * imgWidth), speed); //小原点的选中 if (currentIndex &gt; olList.length - 1) &#123; currentIndex = 0; &#125; for (let i=0;i&lt;olList.length;i++)&#123; olList[i].className=""; &#125; olList[currentIndex].className=olStyleClassName; &#125;&#125; 第二种两个图片宽度的位置，第一个位置显示（当前），第二位置隐藏 第三种改变透明度，循环一遍让所有的opacity动画为0，然后当前为opacity动画为1，索引++、12345678910111213141516171819function opacityAutoPlay(ulid,speed) &#123; // 1. 获取所有的li标签 var lis = $(ulid).getElementsByTagName("li"); var index = 0; // 2. 开始定时器 setInterval(function () &#123; // 2.1 改变透明度 for(let i=0; i&lt;lis.length; i++)&#123; let singerLi = lis[i]; buffer(singerLi, &#123;opacity: 0&#125;, null); &#125; buffer(lis[index], &#123;opacity: 1&#125;, null); // 2.2 索引++ index++; if(index === lis.length)&#123; index = 0; &#125; &#125;, speed);&#125; 瀑布流 父盒子居中 Math.floor(屏幕宽度/子盒子宽度)=cols 子盒子的宽度*cols=父盒子的宽度 margin:0 auto; 子盒子定位第一行不变，其他子盒子接在第一行最矮的盒子的后面（反复） 拿到所有盒子的高度。把第一行的盒子的高度放在一个数组里面（i&lt;cols,heightArr[]) 在剩下的盒子里面(i&gt;=cols),找出第一行最矮的盒子的高度（Math.min(…heightArr)||Math.min.apply(this.height)）2.1 找出最矮盒子的索引(遍历heightArr[],找出和第二步盒子高度一样的i返回)2.2 剩下盒子定位（left=第2.1步的索引*子盒子宽度，top=最矮的盒子高度）2.3 更新最矮盒子的高度 （heightArr[最矮盒子的高度]+=当前盒子的高度） 滚动加载图片 监听窗口的滚动，滚动到你需要的位置加载 js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 window.onload = function () &#123; // 1. 实现瀑布流布局 waterFull("main", "box"); // 2. 动态加载图片 window.onscroll = function () &#123; if(checkWillLoadImage())&#123; // 2.1 造数据 var dataArr = [ &#123;"src": "img04.jpg"&#125;, &#123;"src": "img06.jpg"&#125;, &#123;"src": "img08.jpg"&#125;, &#123;"src": "img09.jpg"&#125;, &#123;"src": "img10.jpg"&#125;, &#123;"src": "img12.jpg"&#125;, &#123;"src": "img14.jpg"&#125;, &#123;"src": "img16.jpg"&#125;, &#123;"src": "img18.jpg"&#125; ]; // 2.2 创建元素 for(var i=0; i&lt;dataArr.length; i++)&#123; var newBox = document.createElement("div"); newBox.className = "box"; $("main").appendChild(newBox); var newPic = document.createElement("div"); newPic.className = "pic"; newBox.appendChild(newPic); var newImg = document.createElement("img"); newImg.src = "images/" + dataArr[i].src; newPic.appendChild(newImg); &#125; // 2.3 重新布局 waterFull("main", "box"); &#125; &#125;&#125;;/** * 实现瀑布流布局 */function waterFull(parent, child) &#123; // 1. 父盒子居中 // 1.1 获取所有的盒子 var allBox = $(parent).getElementsByClassName(child); // 1.2 获取子盒子的宽度 var boxWidth = allBox[0].offsetWidth; // 1.3 获取屏幕的宽度 var screenW = document.documentElement.clientWidth; // 1.4 求出列数 var cols = parseInt(screenW / boxWidth); // 1.5 父盒子居中 $(parent).style.width = cols * boxWidth + 'px'; $(parent).style.margin = "0 // 2. 子盒子的定位 // 2.1 定义高度数组 var heightArr = [], boxHeight = 0, minBoxHeight = 0, minBoxIndex = 0; // 2.2 遍历子盒子 for (var i = 0; i &lt; allBox.length; i++) &#123; // 2.2.1 求出每一个子盒子的高度 boxHeight = allBox[i].offsetHeight; // 2.2.2 取出第一行盒子的高度放入高度数组 if (i &lt; cols) &#123; // 第一行 heightArr.push(boxHeight); &#125; else &#123; // 剩余行 // 1. 取出最矮的盒子高度 // minBoxHeight = _.min(heightArr); minBoxHeight=Math.min(...heightArr); // 2. 求出最矮盒子对应的索引 minBoxIndex = getMinBoxIndex(heightArr, minBoxHeight); // 3. 子盒子定位 allBox[i].style.position = "absolute"; allBox[i].style.left = minBoxIndex * boxWidth + 'px'; allBox[i].style.top = minBoxHeight + 'px'; // 4. 更新数组中的高度 heightArr[minBoxIndex] += boxHeight; &#125; &#125; console.log(heightArr, minBoxHeight, minBoxIndex);&#125;/** * 获取数组中最矮盒子高度的索引 * @param arr * @param val * @returns &#123;number&#125; */function getMinBoxIndex(arr, val) &#123; for(var i=0; i&lt;arr.length; i++)&#123; if(arr[i] === val)&#123; return i; &#125; &#125;&#125;/** * 判断是否具备加载图片的条件 */function checkWillLoadImage() &#123; // 1. 获取最后一个盒子 var allBox = document.getElementsByClassName("box"); var lastBox = allBox[allBox.length - 1]; // 2. 求出最后一个盒子自身高度的一半 + offsetTop var lastBoxDis = lastBox.offsetHeight * 0.5 + lastBox.offsetTop; // 3. 求出屏幕的高度 var screenW = document.body.clientHeight || document.documentElement.clientHeight; // 4. 求出页面偏离浏览器的高度 var scrollTop = scroll().top; return lastBoxDis &lt;= screenW + scrollTop;&#125; jq123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//当页面加载完毕$(window).on('load',function () &#123;//1.实现瀑布流布局waterFall();//2.滚动加载$(window).on('scroll',function () &#123;//判断是否加载if (checkWillLoad())&#123;////创造假数据var data = &#123;'dataImg':[&#123;'img':'23.jpg'&#125;,&#123;'img':'24.jpg'&#125;,&#123;'img':'25.jpg'&#125;,&#123;'img':'26.jpg'&#125;,&#123;'img':'27.jpg'&#125;,&#123;'img':'28.jpg'&#125;]&#125;;//遍历创建盒子$.each(data.dataImg,function (index,value)&#123;//创建一个div标签 设置它的类为'box' 添加到'main'里面去var newBox = $('&lt;div&gt;').addClass('box').appendTo($('#main')); var newPic = $('&lt;div&gt;').addClass('pic').appendTo($(newBox)); //创建img 取出遍历的对象value的img属性对应的值 $('&lt;img&gt;').attr('src','images/'+$(value).attr('img')).appendTo($(newPic)); &#125;) //1.实现瀑布流布局 waterFall(); &#125; &#125;); &#125;); //实现瀑布流布局 function waterFall () &#123; //拿到所有的盒子 var allBox = $('#main &gt; .box'); //取出其中一个盒子的宽度 var boxWidth = $(allBox).eq(0).outerWidth(); //取出屏幕的高度 var screenWidth = $(window).width(); //求出列数 //取整函数取整 var cols = Math.floor( screenWidth/boxWidth); //父标签居中 $('#main').css(&#123; 'width':cols * boxWidth + 'px', 'margin':'0 auto' &#125;); //对子盒子定位 var heightArr = []; //遍历 $.each(allBox,function (index,value) &#123; //取出单独盒子的高度 var boxHeight = $(value).outerHeight(); //判断是否第一行 if(index &lt; cols) &#123; heightArr[index] = boxHeight; &#125; else //剩余的盒子要瀑布流布局 &#123; //求出最矮的盒子高度 var minBoxHeight = Math.min.apply(null,heightArr); //取出最矮高度对应的索引 封装了js的这个方法 var minBoxIndex = $.inArray(minBoxHeight,heightArr); //定位 $(value).css(&#123; 'position':'absolute', 'top':minBoxHeight + 'px', 'left':minBoxIndex * boxWidth + 'px' &#125;); //更新数组中最矮的高度 heightArr[minBoxIndex] += boxHeight; &#125; &#125;) &#125; //判断是否符合加载条件 function checkWillLoad() &#123; //直接取出最后一个盒子 var lastBox = $('#main &gt; div').last(); //取出最后一个盒子高度的一半 + 头部偏离的位置 var lastBoxDis = $(lastBox).outerHeight() + $(lastBox).offset().top; //求出浏览器的高度 var clientHeight = $(window).height(); //求出页面偏离浏览器高度 var scrollTopHeight = $(window).scrollTop(); //比较返回 return lastBoxDis &lt;= clientHeight + scrollTopHeight; &#125; margin:0 auto 块级元素 给定要居中的块级元素的宽度。 所有元素也可以通过对父元素设置text-align：center；的方式来实现居中。而对于块元素来说，对要居中的元素自身进行设置text-align:center也能实现居中 margin:0 auto;可以使盒子居中，text-align:center;可以使文本居中，节流onresize举列子窗口大小一变化就执行，太过灵敏，所以需要阻止1234567891011121314151617//使用定时器var timer = null;window.onresize = function () &#123; clearTimeout(timer); // 节流 timer = setTimeout(function () &#123; waterFull('main', 'box'); &#125;, 200);&#125;//封装之后的function throttle(fn, delay) &#123; var timer = null; return function () &#123; clearTimeout(timer); timer = setTimeout(fn, delay); &#125;&#125; apply/call这个面试中常考到，现在只做初步了解(https://www.cnblogs.com/gaowx/p/4837687.html ) 改变函数的this指向 apply可以改变传递给函数参数的形式Date123456789101112131415161718192021222324function newDate()&#123; //声明日期对象，里面可以设置参数表示其他时间 let date =new Date(); //获取时间里面的年 date.getFullYear() //月0-11 date.getMonth()+1 //日1-31 date.getDate() //获取星期0-6 data.Day //设置某一天 date.setDate（day） //时0-23 date.getHours() //分0-59 date.getMinutes() //秒0-59 date.getSeconds() //获取毫秒 date.getMilliSeconds() //时间戳 date.getTime()&#125; ms转化时间 cookie封装封装成插件，引入该文件后，$.addCookie(key,value,day,path,domain)来引用1234567891011121314151617181920212223242526272829303132333435363738394041;(function ($,window) &#123; $.extend(&#123; addCookie: function addCookie(key,value,day,path,domain)&#123; //1.处理默认保存的路径 var index=window.location.pathname.lastIndexOf('/'); var currentPath=window.location.pathname.slice(0,index) path=path||currentPath //2.处理默认domain domain=domain||document.domain //3.处理默认的过期时间 if(!day)&#123; document.cookie=key+"="+value+";path="+path+";domain="+domain+';' &#125; else&#123; var date =new Date(); date.setDate(date.getDate()+day) document.cookie=key+"="+value+";expires="+date.toGMTString()+";path="+path+";domain="+domain+';' &#125; &#125;, getCookie: function getCookie(key)&#123; var res=document.cookie.split(';') for(var i=0;i&lt;res.length;i++)&#123; //把key和value切割 var temp=res[i].split('=') //前后可能有空格，把空格删除 if(temp[0].trim()===key)&#123; return temp[1] &#125; &#125; &#125;, delCookie: function delCookie(key, path) &#123; //默认情况下只能删除默认路径中保存的cookie，如果要删除指定路径保存的cookie，要把路径值传出去 //设置过期时间为-1 addCookie(key, getCookie(key), -1, path) &#125; &#125;);&#125;)(jQuery,window); 动态添加的元素绑定事件 delegate 123$(&apos;ul&apos;).delegate(&apos;li&apos;,&apos;click&apos;,function()&#123;//操作的还是li&#125;) onclick事件在动态添加数据的时候，就给元素绑定onclick事件 on（）常用 12345//把动态添加的元素写在on里面，如果调用的函数是外部定义好的，则在调用的时候不加（）//不然会跳过点击事件直接执行函数$(&quot;父元素或祖辈元素&quot;).on(&quot;click&quot;,&quot;动态添加的元素&quot;,function()&#123;$(this).css(&quot;border&quot;,&quot;5px solid #000&quot;);&#125; 其他清除默认样式http://yui.yahooapis.com/3.18.1/build/cssreset/cssreset-min.css 下拉框1234567891011121314151617181920//拿到select对象：var myselect=document.getElementById("select");//拿到选中项的索引var index=myselect.selectedIndex ; // selectedIndex代表的是你所选中项的index//拿到选中项options的value：myselect.options[index].value;//拿到选中项options的text：myselect.options[index].text;//拿到选中项的其他值，比如这里的url： myselect.options[index].getAttribute('url');//jqueryvar options=$(“#select option:selected”); //获取选中的项alert(options.val()); //拿到选中项的值alert(options.text()); //拿到选中项的文本alert(options.attr('url')); //拿到选中项的url值//设置//设置value为pxx的项选中$(".selector").val("pxx")//设置text为pxx的项选中$(".selector").find("option[text='pxx']").attr("selected",true) H5 datalistdatalist 只是列表赋值取值还是通过input.样式等都在input上操作https://www.zhangxinxu.com/wordpress/2013/03/html5-datalist-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8-%E5%8F%AF%E8%A1%8C%E6%80%A7/ 邮箱的自动补全HTML代码：123456789邮箱：&lt;input type=&quot;email&quot; id=&quot;email&quot; list=&quot;emailList&quot; name=&quot;off_autocomplete&quot; /&gt;&lt;datalist id=&quot;emailList&quot;&gt;//其中*为占位符，当文本框输入内容的时候，*替换成邮箱地址的前半部分，于是，动态邮件地址提示的效果就实现了 &lt;option value=&quot;*@qq.com&quot;&gt; &lt;option value=&quot;*@163.com&quot;&gt; &lt;option value=&quot;*@gmail.com&quot;&gt; &lt;option value=&quot;*@yahoo.com.cn&quot;&gt; &lt;option value=&quot;*@126.com&quot;&gt;&lt;/datalist&gt; JS代码：12345678910111213141516171819202122232425262728var eleList = document.getElementById("emailList") , eleMail = document.getElementById("email") , htmlListInit = '', arrEmailList = [];if (eleMail &amp;&amp; eleList &amp;&amp; (htmlListInit = eleList.innerHTML) !== '') &#123; // 得到类似["qq.com", "163.com", "gmail.com", ...]的数据 arrEmailList = [].slice.call(eleList.getElementsByTagName("option")).map(function(option) &#123; return option.value.replace("*@", ""); &#125;); eleMail.fnListReplace = function() &#123; var arrValue = this.value.trim().split("@"); // 修复FireFox浏览器下无限input问题 // 如果值不完全匹配某option值，执行动态替换 if (arrValue.length !== 2 || arrEmailList.indexOf(arrValue[1]) === -1) &#123; eleList.innerHTML = htmlListInit.replace(/\*/g, arrValue[0]); &#125; return this; &#125;; // 绑定输入事件侦听 eleMail.addEventListener("input", function() &#123; this.fnListReplace.call(this); &#125;, false); // 载入即匹配 eleMail.fnListReplace.call(eleMail).focus();&#125; else &#123; eleList = document.createElement("datalist"); eleList.innerHTML = '&lt;p class=sorry&gt;抱歉，当前浏览器不支持HTML5 datalist.&lt;/p&gt;'; eleMail.parentNode.appendChild(eleList);&#125; jquery.editable-select控件引入jquery.editable-select.cssjquery.editable-select.js调用方法123456789101112$('#editable-select').editableSelect(&#123; bg_iframe: true, //是否加iframe case_sensitive: false, items_then_scroll: 10 ,//设置下拉选项的数目 isFilter:false/true, //是否根据条件过滤下拉选项 onCreate:, //当输入时触发 onShow：, //当下拉时触发 onHide：, //当下拉框隐藏时触发 onSelect：, //当下拉框中的选项被选中时触发 effects:default/slide/fade， //动画效果 duration： //动画效果的时间&#125;);]]></content>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
</search>
