<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[软件超市新项目后台管理界面开发流程3]]></title>
    <url>%2F2020%2F02%2F06%2F%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B3%2F</url>
    <content type="text"><![CDATA[vue全局配置项目有很多重复用到的变量和方法，新建一个global/index.js来存放。具体的实现是通过在Vue的原型上添加方法和属性，也就是使用Vue.prototype，最后要在main.js引入文件`import “./global”; Messsage.vue一级导航用于显示消息通知,里面包含了两个组件，一个用于分页的ProjectPagination，一个是用于消息提醒的MessageRemind 分页ProjectPagination结合element-ui的pagination加上一些修改。前一篇博客中提到了父组件向子组件传值的方法，这里同时也用到了子组件向父组件传值的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!-- 分页器 --&gt;&lt;template&gt; &lt;el-pagination class=&quot;x-page&quot; layout=&quot;total,sizes, prev, pager, next, jumper&quot; @current-change=&quot;handleCurrentChange&quot; @size-change=&quot;handleSizeChange&quot; :current-page.sync=&quot;currentPage&quot; :page-sizes=&quot;pageSizes&quot; :page-size=&quot;pageSize&quot; :total=&quot;total&quot;&gt;&lt;/el-pagination&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;ProjectPagination&quot;, //接收父组件传来的值 props: &#123; //data为所有数据 data: Array, //filterData做为一个筛选容器 filterData: Array &#125;, data() &#123; return &#123; //当前页数 currentPage: 1, //默认的一页显示条数 pageBase: 10 &#125;; &#125;, computed: &#123; // 数据总数目 total() &#123; return this.data.length; &#125;, // 一页有多少条数据 pageSize() &#123; //如果基础数据大于总数，则显示总数 let size = this.total &gt;= this.pageBase ? this.pageBase : this.total; return size; &#125;, // 提供每页条数的选择，返回值为一个数组 pageSizes() &#123; let count = Math.ceil(this.total / this.pageSize); let sizes = []; for (let i = 1; i &lt;= count; i++) &#123; sizes.push(this.pageSize * i); &#125; return sizes; &#125; &#125;, methods: &#123; //pageSize改变执行，回调参数:每页条数 handleSizeChange(val) &#123; // 获取项目条数 //子组件像父组件传值，更新filterData。 this.$emit(&quot;update:filterData&quot;, this.data.slice(0, val)); &#125;, // 页面页数改变 handleCurrentChange(val) &#123; // 获取下一页数据 this.$emit( &quot;update:filterData&quot;, this.data.slice((val - 1) * this.pageSize, val * this.pageSize) ); &#125; &#125;, created() &#123; //发送一个update:filterData，显示pageSize个数据 this.$emit(&quot;update:filterData&quot;, this.data.slice(0, this.pageSize)); &#125;, watch: &#123; // 监控数据变化时获取数据 data() &#123; this.$emit(&quot;update:filterData&quot;, this.data.slice(0, this.pageSize)); &#125; &#125;, //路由要求刷新 activated() &#123; if (this.$route.meta.isRefresh) &#123; this.currentPage = 1; &#125; &#125;&#125;;&lt;/script&gt;&lt;style scoped&gt;.x-page &#123; margin-top: 10px; float: right;&#125;&lt;/style&gt; $emit(update: prop, “newPropVulue”)$emit(update: prop, “newPropVulue”) 这个模式，使子组件向父组件传达：更新属性，并抛出新的属性值。 从上述代码中可以看出首先更新的值要是从父组件中接收的，也就是props里面的值。其次父组件该值需要写成 1&lt;ProjectPagination :data=&quot;data&quot; :filter-data=&quot;filterData&quot; @update:filter-data=&quot;filterData=$event&quot;&gt;&lt;/ProjectPagination&gt; 更简单的写法是.sync修饰符 1&lt;ProjectPagination :data=&quot;data&quot; :filter-data.sync=&quot;filterData&quot;&gt;&lt;/ProjectPagination&gt; 注意这里有一个Vue.sync修饰符与$emit(update:xxx)写法的坑使用.sync修饰符1234//有效this.$emit(&quot;update:filterData&quot;, this.data.slice(0, val));//无效this.$emit(&quot;update:filter-Data&quot;, this.data.slice(0, val)); 不使用.sync修饰符1234//无效this.$emit(&quot;update:filterData&quot;, this.data.slice(0, val));//有效this.$emit(&quot;update:filter-Data&quot;, this.data.slice(0, val));]]></content>
      <tags>
        <tag>project</tag>
        <tag>软件超市</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件超市项目后台管理界面开发流程2]]></title>
    <url>%2F2020%2F01%2F31%2F%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82%E9%A1%B9%E7%9B%AE%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B2%2F</url>
    <content type="text"><![CDATA[设置权限时动态加载路由 路由分为两类，一类是静态路由（不需要登陆验证），一类是动态路由（需要登陆验证） 当用户登陆后，获取用role（权限），将role和路由表每个页面的需要的权限作比较，生成用户可访问的路由表 调用router.addRoutes(store.getters.addRouters)添加用户可访问的路由。 使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。 permission.js首先新建store/permission.js，用来控制生成的路由表。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//是否有权限访问，role为当前权限function hasPermission(role, route) &#123; if (route.meta &amp;&amp; route.meta.roles) &#123; //如果该路由的meta存在，并且有要求权限 const roles = route.meta.roles; //如果路由要求的权限有当前权限，返回成功 return roles.includes(role); &#125; else &#123; //如果不存在说明不需要权限 return true; &#125;&#125;const permission =&#123; state: &#123; //默认路由 routers: constantRouterMap, //添加的路由 addRouters: [] &#125;, mutations: &#123; SET_ROUTERS: (state, routers) =&gt; &#123; //往数组中添加符合条件的路由 state.addRouters = routers; //符合权限的路由变成默认路由可访问。 state.routers = constantRouterMap.concat(routers); &#125; &#125;, actions: &#123; //定义产生路由的方法 async GenerateRoutes(&#123; commit &#125;, &#123; role &#125;) &#123; console.log(role); //返回符合权限的异步路由 const accessedRouters = await asyncRouterMap.filter(route =&gt; hasPermission(role, route) ); console.log(accessedRouters); commit(&quot;SET_ROUTERS&quot;, accessedRouters); return accessedRouters; &#125; &#125;&#125;export default permission; 这里可以把permission.js看成一个模块，因为它拥有自己的state,mutation,action。所以还需要把permission挂载在vuex里。 123456789export default new Vuex.Store(&#123; modules:&#123; permission &#125;, state, actions, mutations, getters&#125;); 问题一addRoutes在哪里调用登录后，获取用户的权限信息，然后筛选有权限访问的路由，再调用addRoutes添加路由。这个方法是可行的。但是不可能每次进入应用都需要登录，用户刷新浏览器又要登陆一次。所以addRoutes还是要在全局路由守卫里进行调用。 12345678910111213141516171819202122if(token)&#123;//已经登陆了if (to.path ==="/login") next(&#123;path:"/"&#125;)//else&#123;if (!store.getters.role)&#123; //如果没有当前权限信息,role仅getUserInfor后可以获得//用户登陆之后，根据缓存获取登陆信息 store.dispatch("getUserInfor").then(role=&gt;&#123; //产生符合权限路由的方法 store.dispatch("GenerateRoutes", &#123; role &#125;) .then( data =&gt; &#123; // 生成可访问的路由表 router.addRoutes(data); next(&#123; ...to, replace: true &#125;); &#125;).....&#125;&#125;&#125; 问题一 next()的使用 首先调用next()时会直接进入to路由，不会再调用beforeEach(),所以刷新页面可能会进入无限循环，调用next(‘xxx’)后会拦截路由使得路由重定向xxx，并再次调用beforeEach()。 如果把replace设置为true，那么导航不会留下history记录，点击浏览器回退按钮不会再回到这个路由。router.addRoutes之后的next()可能会失效，因为可能next()的时候路由并没有完全add完成，next({…to}) 的时候重新指定以下刷新前的路径。 问题二 404页面404路由写在动态路由中，否则可能会有闪屏和路由为空时加载的404页面。原因是：当页面刷新，会导致vue重新实例化，路由也恢复了初始路,addRoutes 还没有添加上路由就开始跳转， 所以找不到路由就跳转到404页面了。 Layout页面Layout作为整个后台管理页面的框架，主要有Header、根据权限生成的Sidebar和中间的显示界面组成。 框架12345678//Layout组件 &lt;div id="manage"&gt; &lt;Header&gt;&lt;/Header&gt; &lt;div class="container"&gt; &lt;Sidebar&gt;&lt;/Sidebar&gt; &lt;router-view class="content" &gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; 通过把一级路由与二级路由的path设置成同一个，来同时加载Header组件、Sidebar组件和中间对应的显示界面 12345678910111213141516171819202122232425262728293031//仅用其中一个举列子const project =&#123; path: &#123; path: "/projectManage", name: "projectManage", component: Layout &#125;, check: [ &#123; path: "check", name: "projectCheck", component: () =&gt; import( /* webpackChunkName: "ProjectCheck" */ "../views/projectManage/components/ProjectCheck" ) &#125;, ], &#125;export const asyncRouterMap = [&#123; ...project.path, children: [ &#123; path: project.path.path, redirect: "/projectManage/check", component: () =&gt; import(/* webpackChunkName: "ProjectDeveloper" */ "../views/projectManage/ProjectDeveloper"), children: [...project.check] &#125;,]&#125;] 注意这里有个简单的重定向问题我晕了好久QAQ 首先是path加/和不加/有什么区别。/xx就是根路径。下面代码去到children是/#/child而不是/#/fa/child。而不以斜杠开头的，都会被当成普通的字符串拼到当前路径的后面。 1234path: /fachildren: &#123; path: /child&#125; 然后这里重新定向之后projectManage/check路由到底算几级路由？通过把redirect注释之后终于弄懂了。这里是因为children控制的是第几个router-view,第一个children控制的是第二个router-view，即使它重定向/projectManage/check,第二个router-view显示的还是ProjectDeveloper组件。 Siderbar导航图标上显示未读消息数量 主要实现是使用element-ui里面的badge组件+父子间传值实现的。这里以导航图标上显示未读消息数量为例子，后续类似操作将不做记录。 新建一个MessageNue.vue记录未处理的消息数量，作为子组件，接收父组件传来的值。这里接收两个值：customClass样式，因为这个组件会重复使用，并且不同消息显示的位置可能不同，所以关于定位的信息要单独接收。menu接收的是显示的哪一个消息。 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;span class="badgebox"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;el-badge :value="getMsgN(menu)" :style="customClass" class="item" :max="99" :hidden="!getMsgN(menu)"&gt;&lt;/el-badge&gt; &lt;/span&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: "MessageNum", props: &#123; menu: Object, customClass: String &#125;, methods: &#123; getMsgN(menu) &#123; return this.count[menu.path]; &#125; &#125;, computed: &#123; count() &#123; return this.$store.state.msgNum; &#125; &#125;&#125;;&lt;/script&gt;//state.js //需要显示的消息数量 msgNum: &#123; publishExamine: 0, delayExamine: 0, alterExamine: 0, undertakeExamine: 0, projectExamine: 0, porjectRun: 0, projectCheck: 0, projectFinish: 0, projectManage: 0 &#125;, Sidebar.vue 作为父组件，把组件挂载好之后。menu值是传的动态值所以用v-bind:绑定，而customClass是一个静态值所以直接传值就行。 这里有一个命名的坑:props属性支持驼峰命名,不支持连接线命名。HTML特性是不区分大小写的，所以在HTML之中的驼峰写法要变成连接线写法。 123&lt;message-num :menu=&quot;&#123;path:router.name&#125;&quot; custom-class=&quot;top:-12px;right:-12px&quot;&gt; &lt;i class=&quot;iconfont&quot; :class=&quot;&apos;icon-&apos;+router.meta.icon&quot;&gt;&lt;/i&gt;&lt;/message-num&gt; Header.vue主要功能有： 1.显示用户名，可退出2.如果身份是开发团队的队长，且同时有几个团队，显示当前团队，并可切换其他团队。3.点击logo的时候，可以操作侧边栏展开 ①下拉框用的是Element-ui的el-dropdown组件,下拉的时候出现退出键。 1234567891011121314151617181920212223// @command="handleCommand"为绑定下拉框点击事件，command为值 &lt;el-dropdown class="exit" @command="handleCommand" trigger="click"&gt; &lt;span class="el-dropdown-link"&gt; &#123;&#123; username &#125;&#125; &lt;i class="el-icon-arrow-down el-icon--right"&gt;&lt;/i&gt; &lt;/span&gt; &lt;el-dropdown-menu slot="dropdown"&gt; &lt;el-dropdown-item command="exit"&gt;退出&lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/el-dropdown&gt; // 退出登录或者切换用户管理界面 handleCommand(command) &#123; console.log(command); if (command === "exit") &#123; //退出之后清除 this.exit(); &#125;， exit() &#123; // 退出清除缓存和登录 //登录成功之后重定向到登录页 this.$store.dispatch("Logout"); &#125; ②做第二个功能的时候，首先团队名称是通过axios获取的，并且刷新的时候还要在。所以应该把数据存在session中，同时要解决数据渲染的问题,采用了在state里面设置get和set的方法。 1234567891011121314//state.js get teams() &#123; let vlaue = sessionStorage.getItem("teams"); return typeof vlaue === "string" ? JSON.parse(vlaue) : []; &#125;, set teams(vlaue) &#123; sessionStorage.setItem("teams", JSON.stringify(vlaue)); &#125;, get teamId() &#123; return sessionStorage.getItem("teamId"); &#125;, set teamId(vlaue) &#123; sessionStorage.setItem("teamId", vlaue); &#125;, 这里切换团队之后页面刷新用了上一篇博客提到的provide/inject组合刷新的办法。 ③第三个功能是兄弟Header和Sidebar组件的通讯，因为做这个项目主要是学习为主，所以选择了借助中央事件总线：在外部新建一个utils/eventBus.js文件。 12345678910111213141516//eventBus.jsimport Vue from 'vue'export default new Vue();//Header.vueimport eventBus from "../../utils/eventBus.js";extendNav() &#123;//通过eventBus中央事件总线用$emit发送一个showNav事件eventBus.$emit("showNav"); &#125; //Sidebar.vuemounted() &#123;//通过eventBus中央事件总线用$on监听组件1中发送的showNav事件，第二个参数为回调函数。 eventBus.$on("showNav", this.change);&#125;, 上述是最开始的做法，后面发现更简便的方法。主要是省略了外部的js文件，把总线放在main.js里的vue实例中 12345new Vue(&#123;data:&#123;eventBus:new Vue()&#125;&#125;) 兄弟组件调用的时候,用this.$root.eventBus.$on代替eventBus.$on]]></content>
      <tags>
        <tag>project</tag>
        <tag>软件超市</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件超市项目后台管理界面开发流程1]]></title>
    <url>%2F2020%2F01%2F29%2F%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82%E9%A1%B9%E7%9B%AE%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[3.3 组件编写3.3.1 Manage.vue 存放目录：src/views/Manage.vue 作用：作为Layout容器 详情：包含了Header组件与Sidebar组件 3.3.2 Login.vue 存放目录：src/views/login/Login 作用：登陆界面 详情：通过前台展示界面进入，进入时选择身份，ID的不同身份权限不一样。 具体实现 需要根据前台显示的页面获取信息： getStudentIdByRequest get请求获取登陆的学号ID getUserId?studentId= 通过登陆的studentId获取userId getRole?userId= 通过userId获取角色权限，通过不用的权限生成不同的导航栏。 getMessageByUserGet?userGet=userId 通过userId获取消息，如果有未读消息，进入管理页面后直接显示消息通知，如果没有未读消息，则显示团队管理。 权限、登陆时效等相关（重要） 问题一：跨域问题由于vue-cli脚手架工具开发时，由于项目本身启动本地服务是需要占用一个端口的，所以必然会有跨域问题。解决办法：config/index（webpack构建下），更改开发环境下(在dev里配置)的proxyTable。将请求代理到目标域名123456proxyTable: &#123; &quot;/v1&quot;:&#123; target:&quot;http://software.sicau.edu.cn:8080&quot;, changeOrigin: true//是否开启代理 &#125;&#125;, 问题二：axios的cookie问题由于用的是学校的统一认证平台，采用的是cookie，在使用axios的时候，发现http响应头中少了Set-Cookie属性（axios隐藏了这部分）。解决办法：axios.defaults.withCredentials = true。withCredentials属性主要功能是指定跨域的请求是否应该使用证书（如cookie或授权头header） 问题三：vue组件刷新问题。（这个方法在添加删除之中比较好用，最后虽然没有采用但还是把记录下来）用vue-router重新路由到当前页面，页面是不进行刷新的。采用window.reload,或者router.go(0)刷新时，整个浏览器进行了重新加载，闪烁，体验感不好。解决办法：provide/inject组合provide：选项应该是一个对象或返回一个对象的函数。该对象包含可传递其子孙的属性。inject：一个字符串数组，或一个对象，对象的 key 是本地的绑定名 app.vue 中通过provide将父组件中的数据传给子组件 1234567891011121314151617181920212223242526&lt;router-view v-if="isRouterAlive"&gt;&lt;/router-view&gt;&lt;script&gt;export default &#123; name: "App", provide() &#123; return &#123; reload: this.reload &#125; &#125;, data() &#123; return &#123; isRouterAlive: true &#125; &#125;, methods: &#123; reload() &#123; this.isRouterAlive = false this.$nextTick( ()=&gt; this.isRouterAlive = true ) &#125; &#125;&#125;;&lt;/script&gt; 在要使用的组件中inject:[‘reload’],调用this.reload()既可实现刷新。 问题4：错误捕获问题由于前端要根据返回的不同错误类型，进行不同的处理，在抛出问题时，不知道用async/await的错误如何捕获。解决办法：try catch只能捕获同步代码，不能捕获异步代码，在async函数内，使用await可以捕获异步代码，这里实际上是异步代码变成了同步代码。 在 async 函数内部使用 try catch 捕获异步错误 promise 内部使用 .catch 方法来捕获 promise 内部代码错误 1234567891011async getRequest(&#123;commit,dispatch&#125;)&#123; try&#123; let resGetStudentIdByRequest = await getStudentIdByRequest(); if (resGetStudentIdByRequest.status==0)&#123; ... &#125; else throw resGetStudentIdByRequest.msg; &#125;catch(err)&#123; throw &#123;err, msg: &quot;无效登录&quot;, code: 1 &#125; &#125;&#125;, 问题5：token验证 ——————————————————待补充 之前的项目用的是session，偶然见看见一篇关于token的文章。https://blog.csdn.net/mydistance/article/details/84545768 点击进入管理界面时，先根据选择的不同身份，设置不同的不同的角色信息，在进加密。 进行路由拦截 123456789//main.jsrouter.beforeEach((to, from, next) =&gt; &#123;let token = sessionStorage.getItem("token");if(token)&#123;...&#125;else&#123; //如果没有token ,如果to.path在白名单中,则免登陆。如果不在白名单中，定向去登陆页面 (whiteList.includes(to.path)) == true ? next(): next("/login")&#125;&#125; 登陆时设置token 123456789101112131415161718192021222324252627282930313233//action.js//设置角色async setRole(&#123;commit,dispatch&#125;,roleId)&#123; //给身份加密 setRole(roleId); //设置token setToken();&#125;,//auth.jsconst verify = 45416289438485;//给角色权限加密export const setRole = roleId =&gt; &#123; let token = verify * roleId; sessionStorage.setItem("xxx", token);&#125;;//设置登陆tokenexport const setToken = () =&gt; &#123; let token = randomString(32); sessionStorage.setItem("token", token);&#125;;//产生随机数function randomString(len) &#123; len = len || 32; /****默认去掉了容易混淆的字符oOLl,9gq,Vv,Uu,I1****/ const $chars = "ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678"; const maxPos= $chars.length; let pwd = ""; for (let i = 0; i &lt; len; i++) &#123; pwd += $chars.charAt(Math.floor(Math.random() * maxPos)); &#125; return pwd;&#125; 如果已经有token(已经登陆过一次了) 然后为了防止用户直接手动按f5刷新页面，这个时候会重新构建vue实例，而又没有重新登录，所以vuex里面的东西会清空，所以将登录后的数据存放在sessionStroage中，在刷新页面，重新构建vue实例的时候，会有判断 问题6：button按钮添加回车事件最开始的写法，发现login方法根本没有执行，开始以为是@keyup.enter.native的问题，但是写在封装好的组件中的时候加.native才能监听原生的事件。后面发现是输入框事件，在button上面不起效果。 1&lt;el-button @click="login" @keyup.enter.native="login" class="btn" :loading="btnLoading"&gt;进入管理页面&lt;/el-button&gt; 修改后，用了自定义指令的办法。 123456789101112&lt;el-button @click=&quot;login&quot; v-enter=&quot;this&quot; class=&quot;btn&quot; :loading=&quot;btnLoading&quot;&gt;进入管理页面&lt;/el-button&gt; directives: &#123; // 按enter键登录 enter(el, &#123; value &#125;) &#123; document.onkeydown = e =&gt; &#123; e = e || window.event; if (e.keyCode === 13) &#123; value.login(); &#125; &#125;; &#125; &#125;, 问题7：封装好外部链接通过新建一个元素a，调用函数时点击a来实现外部跳转 1234567891011const HOME_URL = "主页";const LOGIN_URL = "统一认证界面";//新建aexport const goto = url =&gt; &#123; const link = document.createElement("a"); link.href = url; link.click();&#125;;goto.home = () =&gt; goto(HOME_URL);goto.login = () =&gt; goto(LOGIN_URL);]]></content>
      <tags>
        <tag>project</tag>
        <tag>软件超市</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie、LocalStorage、sessionStorage]]></title>
    <url>%2F2020%2F01%2F29%2FCookie%E3%80%81LocalStorage%E3%80%81sessionStorage%2F</url>
    <content type="text"><![CDATA[主要区别 方法 localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等 setItem存储value 12sessionStorage.setItem("key", "value");localStorage.setItem("key", "value"); getItem获取value 12let value = sessionStorage.getItem("key");let key = localStorage.getItem("key"); removeItem删除key 12sessionStorage.removeItem("key");localStorage.removeItem("key"); clear清除所有的key/value 12sessionStorage.clear();localStorage.clear(); localStorage和sessionStorage的key和length属性实现遍历 123456let storage = window.localStorage;for(var i=0, len=storage.length; i&lt;len;i++)&#123; var key = storage.key(i); var value = storage.getItem(key); console.log(key + "=" + value);&#125;]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise]]></title>
    <url>%2F2020%2F01%2F08%2Fpromise%2F</url>
    <content type="text"><![CDATA[这里记录了学习promise的笔记，如果有更深刻的理解会不断更新。 Promise预备知识1.函数对象与实例对象函数对象：将函数作为对象使用实例对象：new函数产生的对象 括号左边是函数，点左边是对象 1234function Fn()&#123; //Fn函数&#125;const fn = new Fn() //这里的Fn是构造函数，fn是实例对象（new返回的，简称对象）Fn.prototype //Fn本身是个函数，但是使用了XX.XXX(使用了.)，把该函数作为对象来使用，所以这里的Fn是函数对象 2.两种类型的回调函数1234567891011121314151617/*-----------同步回调函数--------------*/const arr = [1,3,5]arr.forEach(item =&gt;&#123; //遍历回调，同步回调函数，一上来就执行，不会放入队列 console.log(item)&#125;)//forEach是一个函数，回调函数也是一个函数。说明该回调函数是同步回调函数，等完全执行完毕之后才执行最后一个打印语句console.log("forEach()执行完毕之后")//输出//1，3，5 forEach()执行完毕之后/*-----------异步回调函数--------------*/setTimeout(()=&gt;&#123;//异步回调函数，会放入队列中将来执行 console.log("timeout callback()")&#125;,0)console.log("setTimeout()之后")//输出//setTimeout()之后 timeout callback() 同步回调 理解：立即执行，完全执行完了才结束，不会放入回调队列中例子：数组遍历相关的回调函数 /promise的excutor函数 异步回调 理解：不会立即执行，会放入回调队列中来执行例子：定时器回调 /ajax回调 /promise的成功与失败的回调 3.error处理错误类型 Error:所有错误的父类型子类型(常见的)：ReferenceError: 引入错误，引用的变量不存在TypeError: 数据类型不正确的错误RangeError：数据值不在其所允许的范围内。SyntaxError：语法错误 错误处理 若没有捕获error，后续的代码是不会执行的捕获错误:try{}catch(error){}抛出错误:throw error() 1234567891011121314151617//抛出错误，自己定义错误function something()&#123;if(Date.now()%2 ===1)&#123; console.log("当前时间为奇数,可以执行任务")&#125;else&#123;//自己定义时间为偶数时为错误, 抛出的错误由调用来处理比如：打印，显示消息框等// throw new Error(里面为传出的message) 固定格式 throw new Error('当前时间为偶数，无法执行任务')&#125;try&#123; something&#123;&#125;&#125; catch(error)&#123;//error下面两个属性message与stackconsole.log(error.message)//错误相关信息console.log(error.stack)//函数调用栈记录信息&#125;&#125; Promise的理解和使用Promise是JS中进行异步编程的新的解决方案（旧的是纯回调的方式）从语法来说：Promise是一个构造函数从功能上说：Promise对象用来封装一个异步操作并可以获取其结果 Promise的状态 pending变为resolved（成功） pending变为rejected (失败) 说明：只有这两种变化，且一个Promise对象只能改变一次。无论是成功还是失败，都会有一个结果数据。成功的结果数据一般称为value，失败的结果数据一般称为reason 12345678910111213141516171819202122232425//1.创建一个新的promise对象,里面传一个回调函数const p = new Promise((resolve,reject)=&gt;&#123; //执行器函数 同步回调//2.执行异步操作setTimeout(()=&gt;&#123;const time = Date.now() //如果当前时间是偶数代表成功，否则代表失败if(time%2 ==0)&#123;//3.1 如果成功了，调用resolve(value) resolve("成功的数据,time="+time)&#125;else&#123;//3.2 如果失败了，调用reject（reason） reject("成功的数据,time="+time)&#125;&#125;,1000);&#125;)p.then( value =&gt;&#123; //接收得到成功的value数据 onResolved console.log("成功的回调",value) &#125;, reason =&gt; &#123; //接收得到失败的reason数据 onRejected console.log("失败的回调",reason) &#125;)//输出 成功的回调 成功的数据,time=XXXX 优势 指令回调函数的方式更加灵活：旧的，必须在启动异步任务前指定;promise：启动异步任务 =&gt; 返回peomise对象 =&gt; 给promise对象绑定回调函数(甚至可以在异步执行之后才指定他的回调函数) 支持链式调用，可以解决回调地狱问题（回调函数嵌套调用，不便于阅读/不便于异常）。 简便写法，Promise还有一些对象方法，这里就不进行记录了。 12345const p1 = new Promise((resolve,reject)=&gt;&#123; resolve(1)&#125;)const p2 = Promise.reject(2)p2.catch(reason=&gt;&#123;console.log(reason)&#125;) 几个关键问题 1.如何改变promise的状态？（1）resolve(value):如果当前是pending就会变为resolved（2）reject（reason）：如果当前是pending就会变为rejected（3）抛出异常：如果当前是pending就会被成rejected throw new Error(&quot;出错了&quot;) reason值是你抛出的东西 2.一个promise指定多个成功/失败的回调函数，都会调用吗？当promise改变为对应状态时会调用 3.改变promise状态和指定回调函数谁先执行。 1234567891011121314new Promise((resolve,reject)=&gt;&#123; setTimeout(()&gt;&#123; resolve(1)//后改变的状态，同时指定数据，异步执行回调函数 &#125;,1000);&#125;).then(//先指定回调函数，保存当前指定的回调函数value=&gt;&#123;&#125;,reason=&gt;&#123;&#125;)/*---------先改状态后指定回调函数------------*/new Promise((resolve,reject)=&gt;&#123; //同步回调 resolve(1)//先改变的状态，同时指定数据);&#125;).then(//异步回调value=&gt;&#123;&#125;,reason=&gt;&#123;&#125;//后指定回调函数，异步执行回调函数) 4.promise.then()返回的新的promise的结果状态由什么决定 123456789101112131415161718192021222324252627new Promise((resolve,reject)=&gt;&#123; //1.resolve(1) //2.reject(1));&#125;).then(value=&gt;&#123; console.log('onResolved1()',value) //3.return 2 //4.return Promise.resolve(3) //5.return Promise.reject(4) //6 throw 5&#125;,reason=&gt;&#123; console.log('onRejected1()',reason)&#125;).then(value=&gt;&#123; console.log('onResolved2()',value)&#125;,reason=&gt;&#123; console.log('onRejected2()',reason)&#125;)//1.输出onResolved1() 1 onResolved2() undefined//2.输出onRejected1() 1 onResolved2() undefined （ 其余情况结合1.3 1.4 1.5 1.6 ）//1.3 输出onResolved1() 1 onResolved2() 2//1.4 输出onResolved1() 1 onResolved2() 3//1.5 输出onResolved1() 1 onRejected2() 4//1.6 输出onResolved1() 1 onRejected2() 5 promise异常传透和中止 当使用promise的then链式调用时，可以在最后指定失败的回调，因为没有处理异常相当于 reason =&gt; {throw reason}。会一层一层往下寻找异常处理（知道找到）。 当使用promise的then链式调用时，若想中断promise链，可一返回new Promise(()=&gt;{})返回一个处于pending的promise。 自定义promise链接：https://github.com/biubiuins/promise-/tree/master async与await1.async 函数async是’异步’的简写，用于申明这个函数是异步的。函数的返回值为Promise对象，promise对象的结果由async函数执行的返回值决定。 2.await 表达式await相当于then的语法糖。当await后面的表达式为promise，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，得到的结果就是promise成功的value。如果右侧表达不是promise，得到的结果就是它本身。 注意： await必须放在async函数里面 await只能得到成功的结果，失败的结果需用try-catch try catch只能捕获同步代码，不能捕获异步代码，在async函数内，使用await可以捕获异步代码，这里实际上是异步代码变成了同步代码。]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB学习笔记]]></title>
    <url>%2F2019%2F08%2F01%2FMongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[MongoDB是非关系型数据库文档数据库，存的类似JSON的结构。 启动服务器，db存放数据库，我创建在D盘的。 123mongod --dbpath D:\mongoDB\data\db/*-----默认端口号27017-----*/mongod --dbpath D:\mongoDB\data\db --port XXX 注意两个概念： 数据库的服务器。服务器用来保存数据，mongod启动服务器 数据库的客户端。客户端用来操作服务器，对数据惊醒增删改查的操作，mongo启动 基本概念数据库：存放集合。集合：类似数组，在集合中存放文档。文档：文档是数据库中的最小单位，存储和操作内容都是文档。 基本操作use 数据库名 //进入数据库 增加插入一个放对象db..insert({数据})//db..insertOne()插入多个放数组db..insert([{},{}]) //db ..insertMang() //插入多条可以配合使用for循环 12345var arr =[];for (var i=1;i&lt;=20000;i++)&#123;arr.push(&#123;num:i&#125;);&#125;db.numbers.insert(arr) 查询db..find({条件})，为空查询所有。 123456/*----名字为张三并且年龄为28的文档,返回的是一个数组--*/db.stus.find(&#123;name:&quot;张三&quot;,age:28&#125;)/*----查询符合条件的第一个集合，返回的是一个对象--*/db.stus.findOne(&#123;age:28&#125;)/*-----返回符合条件的文档数量----*/db.&lt;collection&gt;.find().count() MongoDB支持通过内嵌文档的属性进行查询，通过点（.）连接。但是此属性名必须是用引号。 1234hobby:&#123;movies:[111,222],XXX&#125;//查找的是hobby里面的moovies里面的值有111db.users.find(‘hobby.movies’:&apos;111&apos;) 修改db..update(查询条件，新对象,{修改的配置选项，可选})。update默认会使用新对象来替换旧对象。所以不常用。默认情况下只会修改一个 ，实际上既可修改单个，也可修改多个。db..updateMany()。 修改多条db..updateOne()。 修改单条db.collection.replaceOne()。替换单条 常与$set结合使用来修改文档中的指定属性，没有的属性名会自动创建。unset可以删除响应属性。 1234db.stus.update(&#123;name:&quot;李四&quot;&#125;,&#123;$set:&#123;gender:&quot;女&quot;&#125;，&#123;add:&quot;哈哈哈&quot;&#125;&#125;)//若值为一个数组,$push往数组中添加。不考虑是否重复//$addToSet 向数组中添加一个新元素。 重复的就不会添加。db.stus.update(&#123;name:&quot;李四&quot;&#125;,&#123;$push:&#123;hobby.movies’:&apos;333&apos;&#125;&#125;) 删除db.collection.remove() 删除符合条件的所有文档，第二个参数可选：删除配置（比如只删除一个）。必须传参，但如果传递空对象，则所有文档都删除（清空集合，性能太差）db.collection.deleteMany()db.collection.deleteOne()db.collection.drop() 删除集合db.dropDatabase()删除数据库 一般数据是不会删除的，而是在数据中添加一个字段，表示是否删除]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js常用字符串操作方法总结]]></title>
    <url>%2F2019%2F07%2F16%2Fjs%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[终于忙完期末了，考研复习也慢慢走上正轨，要抽出更多的时间把以前学的东西总结下来，再在项目中实践，重新学习更深的内容。24小时完全不够用QAQ。 substring(star,stop)/slice（star,stop）最常用的就是对后台传过来的字符串进行截取处理 语法：stringObject.substring(start,stop) start 必须，并且非负整数 stop 可选，并且非负整数。如果省略，一直截取到字符串的结尾 返回一个新的字符串，包含了start处的字符，但不包括stop处的字符 语法：stringObject.slice(start,end) start 截取的片段的起始下标，如果为负数，从后往前截取（-1 指字符串的最后一个字符） end 截取的结尾的下标 返回一个新的字符串，包含了start处的字符，但不包括end处的字符 arrayObject.slice(start,end)与stringObject.slice(start,end)相似用法。注意array.splice与slice的区别在于splice方法会改变原数组并且可以向原数组中添加元素，如果有删除元素则返回是含有删除的元素的数组。 String.split()/Array.join()语法: stringObject.split(separator,howmany) 把一个字符串分割成字符串数组 separator 必须。字符或正则表达式，从该从该参数指定的地方分割 stringObject。 howmany 可选。该参数可指定返回的数组的最大长度。 返回一个字符串数组，不包括separator自身 语法： arrayObject.join(separator) 数组中的所有元素放入一个字符串。 separator 数组中的元素形成字符串时连接的符号，默认逗号。 如果把空字符串 (“”) 用作 separator，那么 stringObject 中的每个字符之间都会被分割 返回一个字符串数组 String.concat()/Array.concat()字符串的concat方法其实并不常用，连接两个字符串的时候我们常常用+来代替。这里主要是记录几个数组的连接方法。 语法:arrayObject.concat(arrayX,arrayX,……,arrayX) 添加的是数组的元素不是添加一个数组 返回一个新数组，不改变原数组 string.replace(regexp/substr,replacement) 第一个参数可以使RegExp对象或者一个字符串，第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个字符串。如果想替换所有的字符串，则必须使用正则表达式。 默认只进行第一次匹配操作的替换，想要全局替换，需要置上正则全局标识g ‘\s”是转移符号用以匹配任何空白字符，包括空格、制表符、换页符等等， string.search(regexp)/string.indexOf(searchvalue,fromindex)语法 string.indexOf(searchvalue,fromindex) searchvalue，规定检索的字符串值 fromindex 可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。 返回的检索的字符串第一次出现的位置，如果没有出现，返回-1 语法 string.search(regexp) regexp 该参数可以是需要在 stringObject 中检索的子串，也可以是需要检索的 RegExp 对象。 要执行忽略大小写的检索，追加标志 i。 返回值：stringObject 中第一个与 regexp 相匹配的子串的起始位置。 search() 方法不执行全局匹配，它将忽略标志 g。它同时忽略 regexp 的 lastIndex 属性， 语法 stringObject.match(searchvalue) stringObject.match(regexp) 返回指定的值 非全局下返回的数组包含index，input，全局模式下只返回匹配结果，没有index，input等，只有结果。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F07%2F15%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[基本语法修饰符 修饰符 描述 i 执行对大小写不敏感的匹配。 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 m 执行多行匹配。 元字符 方括号 量词 js里面的正则只有前瞻，头部的（后），尾部的（前），所以前瞻就是后面紧跟着的 匹配有贪婪模式（尽可能多的匹配），非贪婪模式（尽可能少的匹配），默认为贪婪模式，非贪婪模式需要在量词后面加？ 常用正则表达]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js遍历方法总结]]></title>
    <url>%2F2019%2F07%2F04%2Fjs%E7%9A%84%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[复习之余，把常用的遍历方法总结，方便使用的时候查看。 数组的遍历语法中有thisValue参数的，可以接收第二个参数，用来绑定回调函数内部的this变量，将回调函数内部的this对象，指向第二个参数，间接操作这个参数（一般是数组）。以map为例子 123456var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];[1, 2].map(function (e) &#123; return this[e];&#125;, arr) // [&apos;b&apos;, &apos;c&apos;] forEach()语法: array.forEach(function(currentValue, index, arr), thisValue) 调用数组的每个元素，并将元素传递给回调函数。 没有返回一个新数组。不能中断，对空数组是不会执行回调函数。 map()语法: array.map(function(currentValue,index,arr), thisValue) 按照原始数组元素顺序依次处理元素，结果放在一个新数组里返回。返回一个新数组，不会改变原始数组 1234567/*------从接口得到数据------*/const users=res.items.map(item =&gt; (&#123; url: item.html_url, img: item.avatar_url, name: item.login, &#125;)); filter()语法：array.filter(function(currentValue,index,arr), thisValue) 创建一个新的数组，指定数组中符合条件的放入新数组。返回一个新数组，按照约定条件筛选数组元素时比较常用 1234/*-----去重问题----*/var arr = [1, 2, 2, 3, 4, 5, 5, 6, 7, 7,8,8,0,8,6,3,4,56,2];var arr2 = arr.filter((x, index,self)=&gt;self.indexOf(x)===index)console.log(arr2); //[1, 2, 3, 4, 5, 6, 7, 8, 0, 56] every()/some()语法: array.every(function(currentValue,index,arr), thisValue) 对整个数组进行检查，如有一个元素满足，整个表达式返回false，且其余元素不检查。否则返回true。 不会改变原数组 语法:array.some(function(currentValue,index,arr),thisValue) 对整个数组进行检查，如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。反之返回false。 不会改变原数组 这两个方法在实际开发中，大有可用之处。比如在判定用户是否勾选了不可操作的数据，或者是否勾选了一条可以操作的数据可以使用这两个方法遍历循环数组。 reduce()/reduceRight()语法:arr.reduce(callback,[initialValue]) callback （执行数组中每个值的函数，包含四个参数） previousValue 必选。上一次调用回调返回的值，或者是提供的初始值（initialValue） currentValue 必选。数组中当前被处理的元素 index 可选。当前元素在数组中的索引。 arr 可选。当前元素所属的数组对象。 initialValue （作为第一次调用 callback 的第一个参数。） 将数组元素做“叠加”处理， 返回一个值。 reduce方向从左向右，reduceRight方向从右向左 1234567891011var arr = [1, 2, 3, 4];var sum = arr.reduce(function(prev, cur, index, arr) &#123; console.log(prev, cur, index); return prev + cur;&#125;)console.log(arr, sum);/*-----打印结果---*/1 2 13 3 26 4 3[1, 2, 3, 4] 10 index是从1开始的，第一次的prev的值是数组的第一个值。数组长度是4，但是reduce函数循环3次。 123456789101112var arr = [1, 2, 3, 4];var sum = arr.reduce(function(prev, cur, index, arr) &#123; console.log(prev, cur, index); return prev + cur;&#125;，0) //注意这里设置了初始值console.log(arr, sum);/*----打印结果----*/0 1 01 2 13 3 26 4 3[1, 2, 3, 4] 10 这个例子index是从0开始的，第一次的prev的值是我们设置的初始值0，数组长度是4，reduce函数循环4次。 如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始 对空数组来说，不设置初始值会报错，设置了初始值不会报错，所以一般来说我们提供初始值通常更安全。 使用场景也很多，具体可以看 参考文档 对象 Object.keys() 返回一个由一个给定对象的自身可枚举属性组成的数组 Object.getOwnPropertyNames() 返回一个数组,包含对象自身的所有属性(不含Symbol属性,但是包括不可枚举属性). for in 循环遍历对象自身的和继承的可枚举属性(不含Symbol属性). for of 主要来遍历可迭代的对象（包括Array, Map, Set, arguments等），它主要用来获取对象的属性值，而for..in主要获取对象的属性名。 总结: for in遍历数组的下标类型不一样 ：for in为String，for为Number for in不适合遍历数组 对不存在项的处理：for in不存在的项不被枚举出来；for全部枚举出 遍历对象可通过hasOwnProperty()过滤掉原型里面的属性 for of输出数组中包括不存在的值在内的所有值]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[keep-alive]]></title>
    <url>%2F2019%2F06%2F29%2Fkeep-alive%2F</url>
    <content type="text"><![CDATA[&lt;keep-alive&gt;能在组件切换的过程中将状态保留在内存中，防止重复渲染DOM。 设置了keepAlive缓存的组件： 第一次进入：beforeRouterEnter -&gt;created-&gt;…-&gt;activated-&gt;…-&gt;deactivated 后续进入时：beforeRouterEnter -&gt;activated-&gt;deactivated activated和deactivated仅在keepAlive缓存的组件里被激活只有第一次进入该组件时，才会走created钩子，而需要缓存的组件中activated是每次都会走的钩子函数。 prop: include: 字符串或正则表达式。只有匹配的组件会被缓存。 exclude: 字符串或正则表达式。任何匹配的组件都不会被缓存。 在2.1.0版本Vue中 常见用法：123456789101112131415161718192021222324252627282930313233// 组件export default &#123; name: &apos;test-keep-alive&apos;, data () &#123; return &#123; includedComponents: &quot;test-keep-alive&quot; &#125; &#125;&#125;&lt;keep-alive include=&quot;test-keep-alive&quot;&gt; &lt;!-- 将缓存name为test-keep-alive的组件 --&gt; &lt;component&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;keep-alive include=&quot;a,b&quot;&gt; &lt;!-- 将缓存name为a或者b的组件，结合动态组件使用 --&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 使用正则表达式，需使用v-bind --&gt;&lt;keep-alive :include=&quot;/a|b/&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 动态判断 --&gt;&lt;keep-alive :include=&quot;includedComponents&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;&lt;keep-alive exclude=&quot;test-keep-alive&quot;&gt; &lt;!-- 将不缓存name为test-keep-alive的组件 --&gt; &lt;component&gt;&lt;/component&gt;&lt;/keep-alive&gt;]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件超市-返回刷新问题]]></title>
    <url>%2F2019%2F06%2F28%2F%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82-%E8%BF%94%E5%9B%9E%2F</url>
    <content type="text"><![CDATA[在对项目进行优化的时候，发现返回上一页的函数很多组件都会使用，于是打算把这个函数抽离出来。 在此之前需要先解决首页进入列表页面刷新，而详情页返回列表页面不刷新的问题的问题 方法一：keep-alive与vue-router配合使用实现在定义了两个字段 keepAlive:true 标识是否使用keep-alive组件字段,ifDoFresh:false标识是否刷新数据字符 1234567891011/*------router/index-----*/ &#123; path: '/project', name:'项目列表' component:resolve =&gt; require(["@/pages/Project/Project"],resolve), meta: &#123; keepAlive:true, ifDoFresh:false, showNav: true &#125; &#125;, 在根组件中根据keepAlive 字符判断是否使用keep-alive组件 1234567/*------app.vue----*/&lt;div class="main"&gt; &lt;keep-alive&gt; &lt;router-view v-if="$route.meta.keepAlive"/&gt; &lt;/keep-alive&gt; &lt;router-view v-if="!$route.meta.keepAlive"/&gt;&lt;/div&gt; 在目标列表页的beforeRouteEnter判断从哪个页面进入的，根据需求更改ifDoFresh变量。这里与activated联合用。 12345678910111213141516beforeRouteEnter(to,from,next)&#123; //需要刷新的页面 if (from.name!="团队详情") &#123; to.meta.ifDoFresh = true; &#125; next() &#125;,activated()&#123; if (this.$route.meta.ifDoFresh)&#123; // 先重置 this.selected=0 this.$route.meta.ifDoFresh=false this.$store.dispatch('getTeam',&#123;teamId:0&#125;) &#125; &#125; 按逻辑来说这样就可以了，但是有个的问题出现了！！！！ 返回只显示一个团队了！！好气啊，不断调试中发现我团队详情的团队信息居然和我列表的团队信息存储在同一个变量里！！！！所以点进详情页后，改变了team，而keep-alive缓存的是team里的数据。我是白痴吗？？？？ 还有一个问题就是从列表到首页，在从首页到列表页，分页的缓存仍然存在。 解决办法：在分页器组件内提前判断（因为使用分页器组件时并没有传当前页码）12345activated()&#123; if (this.$route.meta.ifDoFresh) &#123; this.currentPage = 1 &#125;&#125;, 方法二：keep-alive标签内部添加 keep-alive的总结]]></content>
      <tags>
        <tag>project</tag>
        <tag>软件超市</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件超市-改变v-html内容的图片样式]]></title>
    <url>%2F2019%2F06%2F26%2F%E8%BD%AF%E4%BB%B6%E8%B6%85%E5%B8%82-%E9%97%AE%E9%A2%98v-if%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在通过v-html把后台传过来的内容渲染到页面之后，发现后台传来的图片是限制了宽和高的。 通过查资料发现，这里解析是把v-html传来的数据作为了一个新的组件，所以在scoped下的style里面设置样式不起作用。那么根据原理，或许可以把scoped直接去掉，但是为了防止组件之间的样式污染，使用了其他办法。 方法一 &gt;&gt;&gt;(深度作用选择器) 或者 有些sass类的预处理器无法正确解析可以使用 /deep/ 12345678/*----html----*/&lt;div class="announcement_img" v-html="announcement.content"&gt;&lt;/div&gt;/*----style----*/.announcement_img&gt;&gt;&gt;img&#123;width: 100%;display: block;height: auto;&#125; 方法二 updated周期函数中，js动态配置样式。 首先需要清楚updated周期函数在什么时候起作用，①data里面需要有该数据变量如arr ②在页面重新渲染arr完成后才进入updated。更深入的会在以后学习。 12345678updated:function()&#123;console.log(&quot;1==我会先执行&quot;);this.$nextTick(function()&#123;//在下次 DOM 更新循环结束之后执行这个回调。在修改数据之后立即使用这个方法，获取更新后的DOM.console.log(&quot;3==我只能等页面渲染完了才会立即执行&quot;);&#125;)console.log(&quot;2==我虽然在最后但会比$nextTick先执行&quot;)&#125; 如果后期发现更好的或者更多的办法会重新更新。]]></content>
      <tags>
        <tag>project</tag>
        <tag>软件超市</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css总结]]></title>
    <url>%2F2019%2F05%2F18%2Fcss%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在学习的过程中，对css有了更深一步的了解，把遇见过的问题、经常使用到的样式做一个总结。 清除默认样式http://yui.yahooapis.com/3.18.1/build/cssreset/cssreset-min.css 清除浮动 方法一 给受影响的盒子添加clear属性，添加了clear的属性不可以添加margin-top 方法二 12345678910浮动元素::after&#123; content:&quot;&quot;; display:block; height:0; visibility:hidden; clear:both&#125;浮动元素&#123; *zoom:1;//兼容IE6&#125; 盒子的问题 在默认布局的垂直方向上，外边距有合并现象(BFC块级，水平方向也可以，但是块级都是占一行的，而浮动成水平的 BFC的区域不会与float box重叠) 嵌套盒子时，里面的盒子设置margin-top时，父盒子一起被顶下来。 解决办法：父盒子添加border，或者overflow：hidden 图片的问题 自适应图片 123max-width:100%;height:auto;display:block 设置图片img的width和height的时候，指定其中一个另外一个自动算出来 当图片宽度大于父元素宽度时，居中：父元素text-align：center,子元素：margin：0，-100% 居中浮动之后的高宽不设定则有内容撑开 居中元素有宽度 12345 .center &#123;width: 960px;margin-left: auto;margin-right: auto; &#125; margin:0 auto 使用场景块级元素：给定要居中的块级元素的宽度行内元素： ①设置display:block。 ②给定要居中的行内元素的宽度。（行内元素设置成块级元素后可以对其宽高进行设置） 所有元素也可以通过对父元素设置 text-align：center；的方式来实现居中。(而对于块元素来说，对要居中的元素自身进行设置text-align:center也能实现居中——而无需对其父元素进行设置) 。 浮动、绝对定位、固定定位的盒子失效。 脱离文档流元素的水平垂直 margin:auto或者按圆点定位定在正中间，margin设置成负的宽高的一般 法二： 1234567891011121314div&#123; width: 300px; height: 300px; position: relative; border: 1px solid #465468; &#125; img&#123; position: absolute; margin: auto; top: 0; left: 0; right: 0; bottom: 0; &#125; 指定宽高元素水平居中 还可以定位到50% 50% 改变margin-left/margin-top为元素的一半定位（元素加padding，可以结合box-sizing） 12345678910#test&#123;position:absolute;left:0;right:0;bottom:0;top:0margin:auto;width:100pxheight:100px&#125; 图片的垂直居中 12345678910111213//img的外部包含元素 如divdiv&#123; text-align:center;&#125; div:after&#123; content:&quot;&quot;; display:inline-block; height:100% vertical-align:middle;&#125;img&#123; vertical-align:middle&#125; 其余 超出省略号 盒子不可以仅由内容撑开的时候 123white-space:nowrap //不换行overflow：hidden//超出部分截掉text-overflow:ellipsis //省略号 禁止滚动条 1234html,body&#123;height:100%overflow:hidden&#125;]]></content>
      <tags>
        <tag>css</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown学习笔记]]></title>
    <url>%2F2019%2F05%2F15%2Fmarkdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[写博客的时候有些不常用的语法会有遗漏，今天重新学习markdown常用语法并把记录下来。 综述 兼容HTML。不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。 用于瞄点测试 基本语法标题方法一： 123456# 第一级标题 `&lt;h1&gt;`## 第二级标题 `&lt;h2&gt;`### 第三级标题 `&lt;h3&gt;`#### 第二四级标题 `&lt;h4&gt;`##### 第五级标题 `&lt;h5&gt;`###### 第六级标题 `&lt;h6&gt;` 方法二： 任何数量的 = 和 - 都可以有效果。 1234一级标题=二级标题- 字体如果* 和 _ 两边都有空白的话，它们就只会被当成普通的符号如果要在文字前后直接插入普通的星号或底线，可以用反斜线。 斜体 *内容*或者_内容_ （em）加粗 **内容**或者__内容__ （strong）倾斜加粗 ***内容***删除线 ~~内容~~ 链接行内式 12[我的博客](https://biubiuins.github.io/)自动生成连接 &lt;https://biubiuins.github.io/&gt; 效果：我的博客自动生成连接 https://biubiuins.github.io/ 添加图片形式和链接类似。 12格式：![图片描述](url)![GitHub set up](http://zh.mweb.im/asset/img/set-up-git.gif) 效果： 分割线可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。 代码块 只要简单地缩进 4 个空格或是 1 个制表符就可以。 需要和普通段落之间存在空行！ `内容` 多行代码块与语法高亮：在需要高亮的代码块的前一行及后一行使用三个单反引号`包裹，就可以了。 代码块中包含html代码。在代码区块里面， &amp; 、&lt; 和 > 会自动转成 HTML 实体 引用 在被引用的文本前加上&gt;符号，以及一个空格就可以了，如果只输入了一个&gt;符号会产生一个空白的引用。 引用可以嵌套 引用的区块内也可以使用其他的Markdown 语法 列表符号后面一定要有一个空格，起到缩进的作用。还需要注意的是在使用列表时，只要是数字后面加上英文的点，就会无意间产生列表，比如2017.12.30 这时候想表达的是日期，有些软件把它被误认为是列表。解决方式：在每个点前面加上\就可以了。 无序列表使用 *，+，- 表示无序列表。 有序列表使用数字和一个英文句点表示有序列表。 表格1234姓名|分数-|-张三|50李四|80 效果： 姓名 分数 张三 50 李四 80 表格对齐方式：我们可以指定表格单元格的对齐方式，冒号在左边表示左对齐，右边表示有对齐，两边都有表示居中。 1234姓名|分数:-|-:张三|50李四|80 效果： 姓名 分数 张三 50 李四 80 反斜杠Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： 123456789101112\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 常用技巧换行方法1: 连续两个以上空格+回车方法2：使用html语言换行标签 其他特殊字符unicode字符编码 内容目录在段落中填写 [TOC] 以显示全文内容的目录结构，需要独占一行才能生效。 字体样式Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3。 123&lt;font face="STCAIYUN"&gt;我是华文彩云&lt;/font&gt;&lt;font color=gray size=5&gt;color=gray&lt;/font&gt;&lt;font color=#0099ff size=5 face="黑体"&gt;color=#0099ff size=5 face="黑体"&lt;/font&gt; 背景色需要借助 table, tr, td 等表格标签的 bgcolor 属性来实现背景色的功能。 1&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=pink&gt;背景色是：pink&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 效果： 背景色是：pink 瞄点自定义瞄点 标签形式的锚点目标的id特性值中是不能含有中文字符； 1234//建立一个跳转链接[说明文字](#jump)//需要跳转到的位置&lt;span id = &quot;jump&quot;&gt;跳转到的位置&lt;/span&gt; 效果：瞄点 Markdown会自动给每一个h1~h6标题生成一个锚，其id就是标题内容。如表格]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[less学习笔记]]></title>
    <url>%2F2019%2F05%2F13%2Fless%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[less 参考文章:https://segmentfault.com/a/1190000012360995 less属于css的一种预处理器（处理在浏览器运行前）,作为css的扩展，是一种动态样式语言。 注释 //开头的注释，不会被编译到css文件中，以/ /注释的内容会被编译到css文件 变量 以@开头定义变量，使用是直接 @定义的名称 变量名必须使用大括号包裹 声明变量（类比于写好的css引用）类似于混合方法 结构: @name: { 属性: 值 ;}; 使用：@name(); 使用@来申明一个变量: @pink:pink //不要添加引号 作为普通属性值只是来使用：直接使用@pink 作为选择器和属性名: @{selector的值}的形式（不常用） 作为URL：@{url} （@images:’../img’ 注意要加引号） 变量的延迟加载（一个块级域解析完再加载变量） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* Less */@color: #999;@bgColor: skyblue;//不要添加引号@width: 50%;#wrap &#123; color: @color; width: @width;&#125;/* 选择器变量 */ @mySelector: #wrap; @Wrap: wrap; @&#123;mySelector&#125;&#123; //变量名 必须使用大括号包裹 color: #999; width: 50%; &#125; .@&#123;Wrap&#125;&#123; color:#ccc; &#125; #@&#123;Wrap&#125;&#123; color:#666; &#125; /* url 变量*/ @images: &quot;../img&quot;;//需要加引号 body &#123; background: url(&quot;@&#123;images&#125;/dog.png&quot;);//变量名 必须使用大括号包裹 &#125;/* 声明变量 */ @background: &#123;background:red;&#125;; #main&#123; @background(); &#125; @Rules:&#123; width: 200px; height: 200px; border: solid 1px red; &#125;; #con&#123; @Rules(); &#125; /* 生成的 CSS */ #main&#123; background:red; &#125; #con&#123; width: 200px; height: 200px; border: solid 1px red; &#125; 变量的运算注意点： 加减法时，以第一个数据的单位为基准 乘除法时，注意单位一定要统一 less嵌套规则和html结构相似，层层嵌套&amp;代表的上一层选择器的名字 12345678910111213141516171819202122/* Less */#header&#123; &amp;:after&#123; content:&quot;Less is more!&quot;; &#125; .title&#123; font-weight:bold; &#125; &amp;_content&#123;//理解方式：直接把 &amp; 替换成 #header margin:20px; &#125;&#125;/* 生成的 CSS */#header::after&#123; content:&quot;Less is more!&quot;;&#125;#header .title&#123; //嵌套了 font-weight:bold;&#125;#header_content&#123;//没有嵌套！ margin:20px;&#125; less中的混合 混合：将一系列的规则集引入另一个规则集中 普通混合(编译到原生css中) 不带输出的混合(加括号) 混合使用.或 #的形式来定义；声明变量使用的是@来定义，@变量名（）来使用 普通混合 最好写成后面带（）的形式 12345678910/* Less */ .card &#123; // 等价于 .card() background: #f6f6f6; -webkit-box-shadow: 0 1px 2px rgba(151, 151, 151, .58); box-shadow: 0 1px 2px rgba(151, 151, 151, .58); &#125; #wrap&#123; .card;//等价于.card(); &#125; //其中 .card 与 .card() 是等价的。 带参数的混合注意点： Less 可以使用默认参数，如果 没有传参数，那么将使用默认参数。冒号后面的是默认值2. @arguments代表全部参数，实参列表 传的参数中必须带单位 1234567891011121314151617181920212223242526272829303132/* Less */ .border(@a:10px,@b:50px,@c:30px,@color:#000)&#123; border:solid 1px @color; box-shadow: @arguments;//指代的是 全部参数 &#125; #main&#123; .border(0px,5px,30px,red);//必须带着单位 &#125; #wrap&#123; .border(0px); &#125; /* 命名参数 */ #wrap&#123; .border(@color:black); &#125; #content&#123; .border;//等价于 .border() &#125; /* 生成的 CSS */ #main&#123; border:solid 1px red; box-shadow:0px,5px,30px,red; &#125; #wrap&#123; border:solid 1px #000; box-shadow: 0px 50px 30px #000; &#125; #content&#123; border:solid 1px #000; box-shadow: 10px 50px 30px #000; &#125; 匹配模式注意点： 第一个参数 left 要会找到方法中匹配程度最高的，如果匹配程度相同，将全部选择，并存在着样式覆盖替换。 如果匹配的参数 是变量， @_表示的会被调用任意标志的 。 123456789101112131415161718192021222324252627/* Less */ .triangle(top,@width:20px,@color:#000)&#123; border-color:transparent transparent @color transparent ; &#125; .triangle(right,@width:20px,@color:#000)&#123; border-color:transparent @color transparent transparent ; &#125; .triangle(bottom,@width:20px,@color:#000)&#123; border-color:@color transparent transparent transparent ; &#125; .triangle(left,@width:20px,@color:#000)&#123; border-color:transparent transparent transparent @color; &#125; .triangle(@_,@width:20px,@color:#000)&#123; border-style: solid; border-width: @width; &#125; #main&#123; .triangle(left, 50px, #999) &#125; /* 生成的 CSS */ #main&#123; border-color:transparent transparent transparent #999; border-style: solid; border-width: 50px; &#125; 方法的命名规范注意点： 在 CSS 中&gt; 选择器，选择的是 儿子元素，就是 必须与父元素 有直接血源的元素。 在引入命令空间时，如使用 &gt; 选择器，父元素不能加 括号。 不得单独使用命名空间的方法 必须先引入命名空间，才能使用 其中方法。 子方法 可以使用上一层传进来的方法 123456789101112131415161718192021222324252627282930313233343536/* Less */#card()&#123; background: #723232; .d(@w:300px)&#123; width: @w; #a(@h:300px)&#123; height: @h;//可以使用上一层传进来的方法 width: @w; &#125; &#125;&#125;#wrap&#123; #card &gt; .d &gt; #a(100px); // 父元素不能加 括号&#125;#main&#123; #card .d();&#125;#con&#123; //不得单独使用命名空间的方法 //.d() 如果前面没有引入命名空间 #card ，将会报错 #card; // 等价于 #card(); .d(20px); //必须先引入 #card&#125;/* 生成的 CSS */#wrap&#123; height:100px; width:300px;&#125;#main&#123; width:300px;&#125;#con&#123; width:20px;&#125; less的继承extend 是 Less 的一个伪类。它可继承 所匹配声明中的全部样式。extend（这里放规则）是一个函数 12345678910111213141516171819202122/* Less *///规则的定义，没有参数.animation&#123; transition: all .3s ease-out; .hide&#123; transform:scale(0); &#125;&#125;#main&#123; &amp;:extend(.animation);&#125;#con&#123; &amp;:extend(.animation .hide);&#125;/* 生成后的 CSS */.animation,#main&#123; transition: all .3s ease-out;&#125;.animation .hide , #con&#123; transform:scale(0);&#125; all全局搜索替换使用选择器匹配到的 全部声明。 123456789101112131415161718/* Less */#main&#123; width: 200px;&#125;#main &#123; &amp;:after &#123; content:&quot;Less is good!&quot;; &#125;&#125;#wrap:extend(#main all) &#123;&#125;/* 生成的 CSS */#main,#wrap&#123; width: 200px;&#125;#main:after, #wrap:after &#123; content: &quot;Less is good!&quot;;&#125; 从表面 看来，extend 与 方法 最大的差别，就是 extend 是同个选择器共用同一个声明，而 方法 是使用自己的声明。 ~”XXXXX” less之中避免编译，让浏览器编译]]></content>
      <tags>
        <tag>css</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[element-ui总结]]></title>
    <url>%2F2019%2F04%2F19%2Felement-ui%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在一次项目中用到了element-ui框架，对在使用过程中遇见的问题进行总结（持续更新）。 表单1.数据为二级对象时数据为二级对象时，验证的数据要用字符串形式。 12345rules:&#123; "captainInformation.name": [ &#123; required: true, message: '请输入姓名', trigger: 'blur' &#125;, ], &#125; 2.动态添加的数据动态添加的输入框或表单绑定数据时注意 :prop=&quot;&#39;v-for绑定的数组.&#39; + index + &#39;.v-model绑定的变量&#39;&quot; 我是直接把验证写在标签里面的 1&lt;el-form-item label=&quot;姓名&quot; :prop=&quot;&apos;memberInformation.&apos;+index+&apos;.name&apos;&quot; :rules=&quot;[ &#123; required: true, message: &apos;请输入姓名&apos;, trigger: &apos;blur&apos; &#125;]&quot;&gt; 增加与减少成员 123456789101112//增加成员 addmember() &#123; let newmember = &#123; name: &quot;&quot;, studentId: &quot;&quot;, &#125; this.form.memberInformation.push(newmember) &#125;, //减少成员 reducemember(index) &#123; this.form.memberInformation.splice(index, 1) &#125;, 这个是我在项目中用到的办法，在阅读时发现了另一种情况的解决办法：https://blog.csdn.net/weixin_41041379/article/details/81908788 3.普通输入验证1234567891011rules:&#123;data1:[//必填，trigger是触发类型&#123; required: true, message: '请输入学号', trigger: 'blur' &#125;,//数字类型 'number', 整数: 'integer', 浮点数: 'float'//使用整数的时候，首先要保证数据类型为数字，可以v-model.number绑定数据&#123;type: 'integer', message: '格式错误', trigger: 'blur'&#125;,//长度限制&#123; min: 2, max: 4, message: '长度在 2 到 4 个字符', trigger: 'blur' &#125;]&#125; 4.手动验证 第一种是直接写在rules的里面 1234567891011rules:&#123;data1:[ &#123; validator:(rule,value,callback)=&gt;&#123; if(/^\d+$/.test(value) == false)&#123; callback(new Error(&quot;只能输入数字&quot;)); &#125;else&#123; callback(); &#125; &#125;, trigger: &apos;blur&apos; &#125;&#125;] 第二种写法是抽离出来 1234567891011121314151617181920212223//注意书写位置 data()&#123; let checkAge = (rule, value, callback) =&gt; &#123; if (!value) &#123; return callback(new Error(&apos;年龄不能为空&apos;)); &#125; if (!Number.isInteger(value)) &#123; callback(new Error(&apos;请输入数字值&apos;)); &#125; else &#123; if (value &lt; 18) &#123; callback(new Error(&apos;必须年满18岁&apos;)); &#125; else &#123; callback(); &#125; &#125; &#125; return &#123; rules:&#123; age: [ &#123; trigger: &apos;blur&apos;, validator: checkAge &#125; ] &#125; &#125; 5.手动上传文件12345678910111213141516171819202122232425262728293031323334353637//html &lt;el-upload action ref="upload" //覆盖默认的上传行为，自定义上传的实现 :http-request="finish" //取消自动上传 :auto-upload="false" &gt; &lt;el-button slot="trigger" size="small" type="primary"&gt;选取文件&lt;/el-button&gt; &lt;div slot="tip" class="el-upload__tip"&gt;请上传您的项目功能清单&lt;/div&gt; &lt;/el-upload&gt;//js finish() &#123; this.$refs.form.validate(valid =&gt; &#123; // 验证成功 if (valid) &#123; //这里的需求是必须上传文件 const file = this.$refs.upload.uploadFiles[0]; if (!file) &#123; this.$message(&#123; type: "warning", message: "请选择文件" &#125;); return; &#125; //数据处理 let formData = new FormData(); formData.append("projectId", this.runId); formData.append("timeNode",JSON.stringify(this.form.timeNode)); formData.append("teamId", 1); formData.append("functionFile",file.raw ); //....中间的弹框确定等省略 submitApply(formData) &#125; &#125; &#125; 6.动态获取选项+模糊查询]]></content>
      <tags>
        <tag>总结</tag>
        <tag>vue</tag>
        <tag>库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js页面属性]]></title>
    <url>%2F2018%2F12%2F18%2Fjs%E9%A1%B5%E9%9D%A2%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[页面属性 offsetWidth /offsetHeight 12345//js对元素操作，只能获取不可以改变//获取对象自身的宽度和高度 ，包括内容、边框和内边距，即：offsetWidth = width + border + paddingbox.offsetWidth//注意：和 div.style.width 的区别，其只能获取到行内的数值div.style.width offsetLeft 和 offsetTop 距离第一个有定位的父级盒子左边和上边的距离，注意：父级盒子必须要有定位，如果没有，则最终以body为准！offsetLeft和offsetTop从从父标签的padding开始计算，不包括border。即：从子盒子边框到定位父盒子边框的距离。 offsetParent 返回当前对象的父级（带有定位）盒子，若爷爷也有则选择进近的 clientWidth/clientHeight 网页可见区域宽和高 clientLeft，clientTop 返回的是元素边框的borderWidth，如果不指定一个边框或者不定位改元素，其值就为0 document.body.scrollWidth; document.body.scrollHeight; 网页正文全文宽网页正文全文高 document.body.scrollTop; 网页被卷去的高 document.body.scrollLeft; 网页被卷去的左 区别 left和top分析： clientLeft: 左边边框的宽度；clientTop: 上边边框的宽度 offsetLeft: 当前元素距离有定位的父盒子左边的距离；offsetTop: 当前元素距离有定位的父盒子上边的距离 scrollLeft: 左边滚动的长度; scrollTop: 上边滚动的长度; width和height分析 clientWidth\/Height: 内容 + 内边距 offsetWidth\/Height: 内容 + 内边距 + 边框 scrollWidth\/Height: 滚动内容的宽度和高度]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex流程总结]]></title>
    <url>%2F2018%2F12%2F09%2Fvuex%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[对如何异步显示数据效果的编码流程进行了总结 ajaxajax请求函数，抛出接口 vuex store里面新建index完成基本配置 123456789101112131415161718192021222324/*vuex最核心的管理对象store组装模块并导出 store 的地方 */// 首先引入Vue及Vueximport Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;// 引入四个基本模块import state from &apos;./state&apos;import mutations from &apos;./mutations&apos;import actions from &apos;./actions&apos;import getters from &apos;./getters&apos;// 一定要声明使用插件Vue.use(Vuex)// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件export default new Vuex.Store(&#123; state, mutations, actions, getters&#125;) 现在Vue对象里面挂载store 1234567import store from &apos;./store&apos;new Vue(&#123; el: &apos;#app&apos;, components: &#123; App &#125;, template: &apos;&lt;App/&gt;&apos;, store //所有的组件都多了一个$store&#125;) 在store下新建state.js state：用于存储状态对象 123export default &#123;user:&#123;&#125;&#125; 在store下新建mutation-types.js mutation是操作state状态的，mutation-types是存放操作state的方法名 1export const RECEIVE_USER_INFO = &apos;receive_user_info&apos; // 接收用户信息 在store下新建actions.js action是通过操作mutation间接更新state的多个方法的对象 起连接作用。 异步获取数据。(注意需要引入api接口函数)把数据传给mutation。(因为mutation的方法名是放在mutation-types里面，所以注意要引入mutation-types里面对应的方法名) 123456789101112131415161718import &#123;reqUserInfo,&#125; from &apos;../api&apos;import &#123; RECEIVE_USER_INFO,&#125; from &apos;./mutation-types&apos; // 异步获取用户信息 async getUserInfo (&#123;commit&#125;) &#123; const result = await reqUserInfo() //如果请求成功，返回code=0 if (result.code === 0) &#123; const userInfo = result.data //提交mutation //把结果&#123;userInfo&#125;提交给RECEIVE_USER_INFO方法 commit(RECEIVE_USER_INFO, &#123;userInfo&#125;) &#125; &#125;, 参数除了commit以外，还可以有state{commit,state} 在store里面新建mutations.js mutations直接对state进行操作，[方法名](state,{param}){} 默认第一个参数state，所以需要引入vue与方法名 123456789import Vue from &apos;vue&apos;import &#123; RECEIVE_USER_INFO, &#125; from &apos;./mutation-types&apos;export default &#123; [RECEIVE_USER_INFO] (state, &#123;userInfo&#125;) &#123; state.userInfo = userInfo &#125; &#125; 使用数据 一般放在computed中进行接收，有利于state的值发生改变的时候及时响应给子组件。 mapState辅助函数mapState返回的是一个对象 其实就是返回值:{return this.$store.XXXX} 当一个组件需要获取多个状态时候，用mapState辅助函数更为方便 1234567891011121314import &#123; mapState &#125; from &apos;vuex&apos;export default &#123;computed:mapState(&#123;//方法一：箭头函数count: state =&gt; state.count;//方法二：传字符串参数&apos;count&apos;等同于‘state=&gt;state.count’count:&apos;count&apos;;//方法三，使用this获取局部状态，必须使用常规函数count(state)&#123; return this.count&#125;&#125;)&#125; 当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。 1computed:mapState([ &quot;count&quot;]) …mapState() ...mapState是state的语法糖，使用时需要从vuex中引入 123computed:&#123;...mapState(&#123;&#125;)&#125; mapGetters 辅助函数 mapGetters辅助函数仅仅是将store中的getter映射到局部属性 12345678910111213import &#123; mapGetters &#125; from &apos;vuex&apos;export default &#123; // ... computed: &#123; // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters([ &apos;doneTodosCount&apos;, &apos;anotherGetter&apos;, // ... ]) &#125;&#125; mapActions 类似mapState getter计算属性 12345computed: &#123; doneTodosCount () &#123; return this.$store.state.todos.filter(todo =&gt; todo.done).length &#125; &#125; 如果有多个组件需要用到这个属性，可以在store里面定义‘getter’，可以说是store的计算属性，像计算属性一样，getter的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算 1234567891011121314151617181920212223242526272829 const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: &apos;...&apos;, done: true &#125;, &#123; id: 2, text: &apos;...&apos;, done: false &#125; ] &#125;, getters: &#123; //state作为第一个参数 doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; //可以接收其他getter作为第二个参数 doneTodosCount: (state, getters) =&gt; &#123; return getters.doneTodos.length &#125; //可以通过让getter返回一个函数，来实现给getter传参,对store里的数组进行查询时非常有作用 getTodoById: (state) =&gt; (id) =&gt; &#123; return state.todos.find(todo =&gt; todo.id === id) &#125; //store.getters.getTodoById(2) // -&gt; &#123; id: 2, text: &apos;...&apos;, done: false &#125; &#125; &#125;) //在组件中使用，同计算属性的调用，不用加括号 this.$store.getters.doneTodosCount dispatch方法 dispatch(actionName,data)分发调用action，第一个参数是方法名，第二个是数据 触发store里面的action对应方法名的函数 1this.$store.dispatch(&quot;&quot;)]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[summary_js]]></title>
    <url>%2F2018%2F11%2F24%2Fsummary_js%2F</url>
    <content type="text"><![CDATA[enter回车 持续更新 在修改项目的过程中，学习到了关于表单enter键提交是否可以触发 如果type是submit，一个文本或者多个文本都会提交 如果是button，仅一个文本的时候提交 type为image的按钮，等同于type为submit的效果 用button时，fx和IE有不同的表现。radio和checkbox在FX下也会触发提交表单，在IE下不会 事件代理，事件委托利用的是冒泡原理，与事件源。还可以用来给动态添加的元素绑定事件 事件源 兼容 12let e = e || window.event;var target = e.target || e.srcElement; 属性 12345678console.log(e.target);console.log(e.target.id);console.log(e.target.tagName);console.log(e.target.nodeName); console.log(e.target.classList);console.log(e.target.className);console.log(e.target.innerHTML);console.log(e.target.innerText); es6 箭头函数 回调函数为匿名函数时，回调函数的this会指向window，需要对回调函数bind(this)。回调函数为箭头函数时，回调函数的this会指向他的直接上层，本例中指向obj,objx。回调函数就是一个参数，将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数。这个过程就叫做回调。 不绑定this箭头函数的this其实就是在定义的时候就确定好的，以后不管怎么调用这个箭头函数，箭头函数的this始终为定义时的this 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。所以说在箭头函数中的this指向是固定的 最好不要用箭头函数作为对象的方法。 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 箭头函数还有一个比较有特点的地方就是其不绑定arguments,或者用rest参数代替 但是如果在箭头函数需要参数时，可以使用剩余参数来取代arguments 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。123var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;; 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 12345// 报错let getTempItem = id =&gt; &#123; id: id, name: &quot;Temp&quot; &#125;;// 不报错let getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;); es6 module模块通过export抛出，import引入 export 抛出一个变量 12345//写法一export let firstName = 'Michael';//写法二let firstName = 'Michael';export &#123;firstName&#125;; as关键字重命名 1234function v1() &#123; ... &#125;export &#123; v1 as streamV1,&#125;; 抛出默认 1export default xxx import 接收一个变量 1import &#123;firstName&#125; from &apos;./profile.js&apos;; as关键字重命名 1import &#123; firstName as surname &#125; from &apos;./profile.js&apos;; import命令输入的变量都是只读的，因为它的本质是输入接口，不可以修改 整体加载 1import * as XXX from &apos;./profile.js&apos;; 引入默认抛出的接口，可以自己随便命名 js跳转https://www.cnblogs.com/Renyi-Fan/p/9130325.html js对打开的页面ULR进行跳转， location的href属性 open 方法 histoty的三个方法 location的assign方法 常规的js页面跳转 在原来的窗口中直接跳转 1window.location.href=&quot;你所要跳转的页面&quot;; 在新窗口中打开页面用 12window.open(&apos;你所要跳转的页面&apos;);//open属性的参数 &apos;page.html&apos; 弹出窗口的文件名；&apos;newwindow&apos; 弹出窗口的名字（不是文件名），非必须，可用空&apos;代替；height=100 窗口高度；width=500 窗口宽度；top=0 窗口距离屏幕上方的象素值；left=0 窗口距离屏幕左侧的象素值。 ##[object Object] 这个不是两个对象的意思，是对象的字符串形式，是隐式调用了Object对象的toString()方法，形式是”[object Object]”.[object objcet] 自定义的对象 没有覆盖toString方法，返回默认[object] window对象 覆盖了toString方法，显式调用返回[object Object]123 字条串 覆盖了toString方法，显式调用返回[object String] 在我做项目的时候遇见了一个问题，把对象放进cookie之后，cookie存储的格式变成了object Object,解决办法是转化成字符串之后存入,使用时再解析成json对象 JSON.parse()【从一个字符串中解析出json对象】 123456//定义一个字符串var data=&apos;&#123;&quot;name&quot;:&quot;goatling&quot;&#125;&apos;//解析对象​​JSON.parse(data)结果是：​name:&quot;goatling&quot; JSON.stringify()【从一个对象中解析出字符串】 1234var data=&#123;name:&apos;goatling&apos;&#125;JSON.stringify(data)结果是：&apos;&#123;&quot;name&quot;:&quot;goatling&quot;&#125;&apos;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rem]]></title>
    <url>%2F2018%2F11%2F18%2Frem%2F</url>
    <content type="text"><![CDATA[rem rem是相对于根元素的字体大小相对单位 类似与em，不过rem是依赖根元素计算的，em是依赖父元素计算的 rem能等比例适配所有屏幕 这里有个插件flexible.js就是用rem实现的 这个button按钮的宽度为120px，高度为60px 123456789101112131415html&#123; font-size:20px;&#125;.btn &#123; width: 6rem; height: 3rem; line-height: 3rem; font-size: 1.2rem; display: inline-block; background: #06c; color: #fff; border-radius: .5rem; text-decoration: none; text-align: center;&#125; 如果是不同分辨率下的font-size的值，应该如何计算计算之后可以用媒体查询设置html的font-size值 移动端页面自适应解决方案 不需要手动设置viewport了 原理是根据设备屏幕的DPR(设备像素比，比如dpr=2时，表示1个CSS像素由4个物理像素点组成） 动态设置 html 的font-size, 同时根据设备DPR调整页面的缩放值，进而达到高清效果。) 绝不是每个地方都要用rem，rem只适合与固定宽度 此方案也是默认1rem=100px 比如你在效果图上量取的某个按钮元素长 55px, 宽37px 1234.myBtn &#123; width: 0.55rem; height: 0.37rem;&#125;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex]]></title>
    <url>%2F2018%2F11%2F11%2Fvuex%2F</url>
    <content type="text"><![CDATA[vuex主要是状态管理，将数据统一管理(state) 模块 状态对象 stat 操作state 直接更新state的多个方法对象 mutations 操作mutations 间接更新state的多个方法对象 actions 包含多个基于state的getter计算属性的对象 getters 包含n个mutations的type名称常量 mutations-type 引入12import Vuex from 'vuex'Vue.use(Vuex) 使用共享的数据1const state=&#123;&#125;; 建立统一数据容器，唯一的容器123let store = new Vuex.Store(&#123; state&#125;) store(容器)注册到实例上，main.js里面，所有的组件都会有一个属性this.$store123new Vue(&#123;store,&#125;) 在组件中使用，加不加this都一样1&#123;&#123;this.$store.state.XXX&#125;&#125; state(单向数据流) 注意,在组件中最好不要直接更改共享的数据，共享的数据仅仅给组件染 mutation 通过mutation(管理员)来更改状态，可以在store里面设置成严格模式 strict：true，mutation不支持异步 告诉mutations需要更改,mutations相当于methods 123456789101112const mutations=&#123; add(state,count)&#123; //state是自动放入的，默认指的就是当前的state //操作state的属性 state.XXX +=count &#125;&#125;let store = new Vuex.Store(&#123;state，mutations,strict：true&#125;) 组件通过mutations提交,第一个参数是与mutatioons里面的方法绑定，第二个参数是自定义参数 1this.$store.commit(&apos;add&apos;,2) 插件打印日志1234import logger from &apos;vuex/dist/logger&apos;const store = new Vuex.store(&#123; plugins:[logger()]&#125;) 整理src下面创建一个store文件\index.js 123456789101112import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)import logger from 'vuex/dist/logger'const state=&#123;&#125;;import mutations from './mutations'export default new Vuex.Store(&#123; state， mutations, strict：true, plugins:[logger()] &#125;) store下面再创建一个mutations.js,里面存放mutations的相关123456789101112import * as Types from &apos;mutations.types.js&apos;const mutations = &#123; // [方法名](state,&#123;param&#125;)&#123;&#125;[Types.INCREMENT](state)&#123; state.count+=1&#125;,[Types.DECREMENT](state)&#123; state.count-=1&#125;&#125;;export default mutations; 宏(一般大写)store下面再创建一个mutations.types.js里面存放mutations的方法的名字，方便查找1234//增加export const INCREMENT=&apos;INCREMENT&apos;//减少export const DECREMENT=&apos;DECREMENT&apos; 组件中引入同mutations.js中引入一样,只不过不加中括号import * as Types from ‘mutations.types.js’ Types.INCREMENTTypes.DECREMENT getters相当于computed,如果数据多了可以模仿mutations的抽离12345678910const getters=&#123; val(state)&#123; state.count%2?&apos;奇数&apos;:&apos;偶数&apos; &#125;&#125;;export default new Vuex.store(&#123;getters,&#125;)//引用时&#123;&#123;$store.getters.val&#125;&#125; actions 和后台交互的异步action，后台数据也需要修改 Action 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 引入api以及mutation-types 异步获取数据 异步获取地址 发送异步ajax请求 提交一个mutation 12345678910 //async 方法名(&#123;commit,参数可选&#125;&#123;&#125;)// 异步获取地址 async getAddress (&#123;commit, state&#125;) &#123; // 从state状态中获取到经纬度用来设置reqAddress的参数（看接口文档） const geohash = state.latitude + &apos;,&apos; + state.longitude // 1. 发送异步ajax请求 const result = await reqAddress(geohash) // 2. 根据结果提交一个mutation commit(RECEIVE_ADDRESS, &#123;address: result.data&#125;) &#125;,]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stylus]]></title>
    <url>%2F2018%2F10%2F29%2Fstylus%2F</url>
    <content type="text"><![CDATA[stylus学习笔记 冒号可选，分号可选，逗号可选，括号可选 缩进与空格很重要 12body color white 父级引用 &amp; 1234567891011121314textareainput color #A7A7A7 &amp;:hover color #000//等于textarea, input &#123; color: #a7a7a7; &#125; textarea:hover, input:hover &#123; color: #000; &#125; 变量 属性查找 @ 12345678#logo position: absolute top: 50% left: 50% width: 150px height: 80px margin-left: -(@width / 2) margin-top: -(@height / 2) 运算符 范围 .. 包含界限 …包含开头不包含结尾 存在操作符in 实例检查 is a 条件赋值：?= := 变量定义：is defined 混合书写 方法]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[demo_vue-book]]></title>
    <url>%2F2018%2F10%2F27%2Fvue-book%2F</url>
    <content type="text"><![CDATA[vue-book 接下来会学习vuex，在学习一门预处理语言，之后用我学过的所有东西做一个练习的项目vue学习之后，用vue-cli做的一个练习。这是学习vue的过程中走通了一遍流程，但还有很多功能没有实现 上拉下拉刷新 图片的懒加载 打包之后如何上线 vuex的学习 如何连接数据库等 github:https://github.com/biubiuins/vue-book 安装依赖 npm install vue npm install -g webpack npm install -g vue-cli npm install less less-loader axios vuex bootstrap 目录 build 打包后的脚本文件 src 源码文件 mock后台代码，模拟数据 src/api 代表的是所有的接口,获取数据给前端调用 src/base 基础组件 src/components 页面组件实现路由根据页面划分了5个页面组件 首页 Home.vue 列表 List.vue 收藏 Collect.vue 添加 Add.vue 详情 Detail.vue 配置路由，配置路由映射表并new个实例,挂载在根组件上，router-view显示在App.vuerouter/index.js Vue.use()是用来安装Vue插件123import Vue from 'vue'import Router from 'vue-router'Vue.use(Router); 这里用了模板，将会另外写一篇，关于前端的模板与node的 导航base/Tab.vuescoped 表示是当前组件的样式，并不是全局的1&lt;style scoped lang=&quot;less&quot;&gt; less预处理语言，学习之后会写一篇博客 点击导航之后会通过to跳转页面，并且样式改变这里需要注意/home 确切激活，仅仅这个路径有效。router-link-exact-active/home /home/a 都可以。router-link-active123&lt;router-link to=&quot;/add&quot;&gt;&lt;i class=&quot;iconfont icon-add&quot;&gt;&lt;/i&gt;&lt;span&gt;添加&lt;/span&gt;&lt;/router-link&gt; 基础组件Tab挂载在App.vue上（导航很多页面都需要），并在App.vue上写全局的样式，清除默认样式。新学习到的清除输入框和按钮的默认样式1input，button&#123;appearance:none;&#125; App.vue的组件中有name: &#39;App&#39;，这里name: &#39;app&#39; 相当于一个全局 ID。可以不写，写了可以提供更好的调试信息。页面渲染也是在App.vue中实现的 图标http://www.iconfont.cn/home/index?spm=a313x.7781069.1998910419.2图标打包好了之后在index.html中引入\iconfont是必须类名表明是个icon，后面根据页面选择1&lt;i class=&quot;iconfont icon-shouye&quot;&gt;&lt;/i&gt;&lt;span&gt;首页&lt;/span&gt; 头部base/Mheader.vue头部的标题不是全部一样的，并且比如首页是没有返回键的，所以这里用到的插槽和父组件给子组件传值这里用Home.vue-Mheader.vue为例 在父组件上挂载Mheader.vue &lt;Mheader.vue&gt;首页，首页需要显示出来，需要在子组件Mheader.vue中放个匿名插槽接收 父组件需要传递一个值告诉子组件是否显示返回键。子组件接收back，不需要验证的时候用数组，需要验证的时候用对象。 12345 &lt;i class=&quot;iconfont icon-fanhui&quot; v-if=&quot;back&quot;&gt;&lt;/i&gt;...props:&#123; back:&#123;type:Boolean,default:false&#125; &#125; 点击返回键，返回上一个操作 1this.$router.go(-1); 扩展一下,back也可以返回。this.$router.back() 强制跳转页面，在后面追加，点返回还可以回去。this.$router.push(‘/XXX’) 路由替换，将原来的替换。this.$router.replace(‘/XXX’)轮播图base/Swiper.vue安装依赖1npm install vue-awesome-swiper --save-dev 在main.js中引入vue-awesome-swiper插件123import VueAwesomeSwiper from &apos;vue-awesome-swiper&apos;import &apos;swiper/dist/css/swiper.css&apos;Vue.use(VueAwesomeSwiper) 后台获取图片信息mock/sliders.js 存放图片连接mock/server.js 配置服务器url.parse()可以将一个完整的URL地址，分为很多部分，常用的有：host、port、pathname、path、query。12345678let sliders = require(&apos;./sliders&apos;)http.createServer((req,res)=&gt;&#123;let&#123;pathname,query&#125; = url.parse(req.url); if (pathname === &apos;/sliders&apos;)&#123; res.setHeader(&apos;Content-Type&apos;,&apos;application/json;charset=utf-8&apos;) res.end(JSON.stringify(sliders)) &#125;&#125; 但是当前段发起ajax请求的时候，是8080端口请求3000端口的数据，所以有跨域的问题，这里需要在服务器中加入跨域头12345res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,Content-Length, Authorization, Accept,X-Requested-With&quot;);res.setHeader(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;);res.setHeader(&quot;X-Powered-By&quot;,&apos; 3.2.1&apos;)if(req.method==&quot;OPTIONS&quot;) return res.end();/*让options请求快速返回*/ 轮播图的api12345678import axios from 'axios';//设置基本的默认请求路径axios.defaults.baseURL ='http://localhost:3000';//获取轮播图数据export let getSliders=()=&gt;&#123; //因为设置了了efaults.baseURL，所以它请求的路径其实是http://localhost:3000/sliders,返回的是一个promise对象 return axios.get('/sliders')&#125; axios 笔记待整理 前端获取数据获取的数据父子组件传值，传给子组件，子组件渲染出图片如果给接收到的data一个新的名字 slider {data：slider}1234async created()&#123; let &#123;data&#125; = await getSliders().then() this.sliders=data&#125;, async/await 已整理 热门图书/删除图书 先写服务端，确保数据能正常返回 增加api方法，实现调取数据的功能 在哪个组件中应用这个api，如果是一个基础组件需要这些数据，在使用这个组件的父级中调用这个方法，将数据传递给基础组件 详情页面如果用对象作为to的属性，并且使用了参数，必须给路由起个名字，通过名字跳转router/index.js1&#123;path:&apos;/detail/:bid&apos;,component:Detail,name:&apos;detail&apos;&#125; component/List.vue需要配置路径参数，点击哪个li跳转哪个详情这是跳转用到router-link，把之前的li改为router-link， params是路径参数 循环组件，需要加上key router-link是a标签，这里需要的是li，在taf里面修改1&lt;router-link v-for=&quot;(book,index) in books&quot; :to=&quot;&#123;name:&apos;detail&apos;,params:&#123;bid:book.bookId&#125;&#125;&quot; :key=&quot;index&quot; tag=&quot;li&quot; &gt; 因为点击li跳转，删除按钮也在li里面，所以这个应该阻止删除按钮冒泡1&lt;button @click.stop=&quot;remove(book.bookId)&quot;&gt;删除&lt;/button&gt; component/Detail.vue12//获取通过传过来的参数$route.params.XXX 获取当前id的图书信息渲染到界面。 问题一: 当修改的时候，价格原本是数字，修改之后会变成字符串,加上数字的修饰符 1&lt;input type=&quot;text&quot; v-model.number=&quot;book.bookPrice&quot; id=&quot;bookPrice&quot;&gt; 问题二修改url的时候，页面没有刷新，因为模板已经渲染出来了，不会在走created办法。所以，需要监控url的变化，路径参数发生变化，通过监控参数的变化来发送ajax 123456watch:&#123;//路径参数发生变化，通过监控参数的变化来发送ajax$route()&#123; this.getData() ; &#125;&#125; 问题三如果没有找到对应id的书，那返回的是空对象，如果是空，需要跳转回列表页Object.keys()，该方法返回一个数组,里面是对象的所有属性。如果是空对象那么返回一个空数组。 1Object.keys(this.book).length&gt;0?void 0:this.$ruoter.push(&apos;/List&apos;) 处理一下url,server.js查询book的条件变一下 1if (!isNaN(id)) 数据改变之后，需要用put更新数据PUT：参数1：url:/book?id=3参数2：请求体发送server.js获取put/post请求体中的数据使用这两个事件就可以获取来自服务器端的响应内容。 data，数据传递时触发， end，没有更多数据提供时触发1234567let str = &quot;&quot;; res.on(&apos;data&apos;,(chunk)=&gt;&#123; str += chunk; &#125;); res.on(&apos;end&apos;,()=&gt;&#123; console.log(str); &#125;); 添加页面同详情页面 优化与其他功能loading轮播图和热门图书是分开获取的，这里改成一起获取api/index1return axios.all([getSliders(),getHotBook()]) 数据返回的是一个数组，里面是两个promise对象。 新建base/Loading.vue,挂载在Home.vuehttps://www.cnblogs.com/lhb25/p/loading-spinners-animated-with-css3.html 实现页面缓存分页面缓存，路由元信息。在配置路由映射的时候有meta(备注)属性,这条对象可以通过this.$route获取1&#123;path:&apos;/home&apos;,component:Home,meta:&#123;keepAlive:true&#125;&#125;, 修改APP.vue,写两个router-view，一个用于，显示缓存的，一个用于显示一般的123456789&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; &lt;Tab&gt;&lt;/Tab&gt; &lt;/div&gt;&lt;/template&gt; 实现路由动画给router-view外面包裹一个标签,注意点：一个只能包裹一个标签写css样式12345678910.fadeIn-enter&#123; opacity: 0;&#125;.fadeIn-enter-active&#123; transition:all 0.3s;&#125;.fadeIn-leave-active&#123; transition: all 0.3s; opacity: 0;&#125; 下拉加载更多打包上线history路由在路由中改变mode:’history’ 标题router/indexmeta:{title:XXX}main.js全局钩子，在进入路由之前每一次都会执行此方法。有拦截的作用router.beforeEach(function(from.to,next){ document.title = to.meta.title; next();});]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2F2018%2F10%2F12%2Fgit%2F</url>
    <content type="text"><![CDATA[git的基本操作 初次配置第一步需要配置用户名和邮箱地址，因为git为每一次提交记录名字和邮箱地址12$ git config --global user.name &apos;runoob&apos;$ git config --global user.email test@runoob.com ssh key 生成一对shh key（id_rsa私钥，id_rsa.pub公钥） 1ssh-keygen 注：在主目录下生成的密钥在 /c/Users/用户名/.ssh/id_rsa 里 查看公钥内容（需在.ssh目录下执行） 1cat id_rsa.pub 复制密钥内容添加到 github 上 使用ssh协议上传文件到仓库 12345git initgit add .git commit -m &quot; &quot;git remote add origin git@github.com:...git push -u origin master 注：若在创建新仓库时有readme.md 文件会上传失败 新建版本库 git里面先进入新建库的文件夹下 初始化库初始化目录，目录下回出现一个.git的目录，该目录包含了资源的所有元数据 12git initgit init 目录名 添加文件到暂存区将当前目录下几个文件纳入版本控制，需要先用git add 命令告诉git开始对这些文件进行跟踪 123git add .//添加当前项目的所有文件git add README //添加名为README的文件git add -A 所有修改的内容添加到缓存区 增加到版本库中使用 git add 命令将想要快照的内容写入缓存区， 而执行 git commit -m将缓存区内容添加到仓库中。 12git commit -a 跳过这一步git commit -m&quot;版本留言描述&quot; 连接远程仓库（现在GitHub上面新建仓库） 1git remote add origin 仓库地址 讲本地仓库推送到远程库上 12git pushgit push -u origin master //首次执行，说明上传到仓库的master分支上 问题：![rejected] master -&gt; master (fetch first)解决办法：1. 先执行git pull.然后再执行git push –force origin master替换原先的 git push -u origin master 从远程库克隆先把别人的fork进自己的库里面 克隆仓库到指定目录 123//自己在本地进入需要克隆进的文件夹下执行下面第一条指令git clone 仓库地址git clone 仓库地址 本地目录 add commit push 删除文件 本地删除文件 123//或者直接在文件管理器中把没用的文件删了//需要git进入文件夹下$ rm test.txt Git知道你删除了文件，这个时候只是本地删除了文件，而版本库里面还有文件，所以可以恢复文件 1$ git checkout -- test.txt 远程库删除文件 1git rm test.txt 记得还需要commit 我的石墨文档：https://shimo.im/docs/2Eg0gszciPEQBPxG/]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[express学习笔记]]></title>
    <url>%2F2018%2F10%2F12%2Fexpress%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[express 学习笔记 搭建简单服务器1234567891011//express() 是一个由 express 模块导出的入口（top-level）函数let express = require('express');//创建一个express应用实例名applet app = express();// 设置端口号：3000//process.env.PORT：读取当前目录下环境变量port的值let port = process.env.PORT || 3000 ;//在端口号上开启服务app.listen(port,function () &#123; console.log("server start"+port);&#125;); app.listen(port, [hostname], [backlog], [callback])类似于node中的http.Server.listen()1234567// 设置端口号：3000//process.env.PORT：读取当前目录下环境变量port的值let port = process.env.PORT || 3000 ;//在端口号上开启服务app.listen(port,function () &#123; console.log("server start"+port);&#125;); 服务器启动时候，默认端口3000：node app.js设置端口8080：PORT=8080 node app.js app.set(name,value)123456789//设置 views 文件夹为存放视图文件的目录, 即存放模板文件的地方,__dirname 为全局变量,存储当前正在执行的脚本所在的目录。app.set('views', path.join(__dirname, 'views'));app.set("views","./views");//设置使用的模板引擎app.set('view engine', 'ejs’)app.set("view engine","jade")npm install --save express-art-template//设置art模板引擎，后缀为artapp.engine('art', require('express-art-template')); app.get(name)返回name的value值1234567891011//实例一app.get('title');// =&gt; undefinedapp.set('title', 'My Site');app.get('title');// =&gt; "My Site"//实例二app.set('port', process.env.PORT || 3000);var server = app.listen(app.get('port'), function() &#123; console.log("server start"+port);&#125;); app.get(path, callback [, callback …])app.all(path, callback [, callback …])这种方法就像标准的app.METHOD()方法, 除了它匹配所有HTTP动词。访问path路径的所有方法执行的回调函数.12345//* 表示匹配所有的路径app.all('*', function(req, res)&#123; res.end(req.method + 'user')&#125;//一般放在最后面防止前面的被覆盖 请求与响应123456//Express 应用使用回调函数的参数： request 和 response 对象来处理请求和响应的数据。app.get('/', function(req, res)&#123; res.send('hello world'); res.status(404).send(错误请求)//访问这个路径是设定状态码为404 //通过res.send（）接口向客户端发送hello world，send只能响应一次，意思是只能出现一个send&#125;) res.send（）只能出现一次如果要响应多次，用node原生的write和end，但是如果只有write会处于一个挂起状态1234app.get('/', function(req, res)&#123; res.write('hello world'); res.write('hello world');&#125;) res.send有结束响应的作用 res.write没有结束响应的作用，需要res.end结束中间件挂起response下表中响应对象（res）的方法向客户端返回响应，终结请求响应的循环。如果在路由句柄中一个方法也不调用，来自客户端的请求会一直挂起。res.render()12345//设置 views 文件夹为存放视图文件的目录, 即存放模板文件的地方,__dirname 为全局变量,存储当前正在执行的脚本所在的目录。app.set('views', path.join(__dirname, 'views'));app.set("views","./views");//第一个是渲染的views文件夹下面的index，第二个是传递的数据,注意需要设置模板引擎res.render("index",&#123;&#125;,function()&#123;&#125;) res.setHeader()12//Content-Type的作用 该实体头的作用是让服务器告诉浏览器它发送的数据属于什么文件类型。res.setHeader(&quot;Content-Type&quot;,&apos;text/html;charset=utf-8&apos;) res.redirect()调用redirect()方法后，其后的代码都不会被执行。而使用redirect()设置的状态码不是301或302也不会发生跳转12res.redirect([status,] path)//重定义到path所指定的URL，重定向时可以同时指定HTTP状态码，不指定状态码默认为302 res.location()location()方法本质上是调用了ServerResponse对象的setHeader()方法，但并没有设置状态码。使用location()设置头信息，而不设置状态码或状态码不是301或302，并不会发生重定向1res.location(path) request req.query处理 get 请求，获取 get 请求参数12345678910// GET /search?q=tobi+ferretreq.query.q// =&gt; "tobi ferret"// GET /shoes?order=desc&amp;shoe[color]=blue&amp;shoe[type]=conversereq.query.order// =&gt; "desc"req.query.shoe.color// =&gt; "blue"req.query.shoe.type// =&gt; "converse" req.body处理 post 请求，获取 post 请求体12345678// POST user[name]=tobi&amp;user[email]=tobi@learnboost.comreq.body.user.name// =&gt; "tobi"req.body.user.email// =&gt; "tobi@learnboost.com"// POST &#123; "name": "tobi" &#125;req.body.name// =&gt; "tobi" req.params处理 /:xxx 形式的 get 或 post 请求，获取请求参数123456// GET /user/tjreq.params.name// =&gt; "tj"// GET /file/javascripts/jquery.jsreq.params[0]// =&gt; "javascripts/jquery.js" req.param(name)处理 get 和 post 请求，但查找优先级由高到低为 req.params→req.body→req.query123456789// ?name=tobireq.param('name')// =&gt; "tobi"// POST name=tobireq.param('name')// =&gt; "tobi"// /user/tobi for /user/:namereq.param('name')// =&gt; "tobi" 中间件用于客户端与服务器路由匹配之前的中间操作，正常中间件放在路由上面，中间件通过next()往下走。 app.use（[path],function）利用express托管静态文件node.js不能通过目录来引入文件，而express可以，public为静态目录1234//设置public文件夹为存放静态文件的目录。let path=require("path")//ex4里面唯一的内置中间件app.use(express.static(path.join(__dirname, 'public'))); 一个中间件处理器，请求来了，让那些中间件先处理一遍 没有挂载路径的中间件，应用的每个请求都会执行该中间件 挂载至 /path 的中间件，任何指向 /path 的请求都会执行它1234567app.use(&quot;/name&quot;,function(req,res,next)&#123;res.setHeader(&quot;Content-Type&quot;,&apos;text/html;charset=utf-8&apos;)next();&#125;)app.get(&quot;/name/n&quot;,function(req,res)&#123;&#125;)//也可以匹配到，在执行get请求/name/n时先执行上面的中间件 错误中间件错误处理中间件和其他中间件定义类似，只是必须要使用 4 个参数(err, req, res, next)。即使不需要 next 对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。遇见错误之后直接执行错误中间件。错误处理中间件应当在在其他 app.use() 和路由调用之后才能加载，一般放在路由的最底部，比如：123456789var bodyParser = require('body-parser');var methodOverride = require('method-override');app.use(bodyParser());app.use(methodOverride());app.use(function(err, req, res, next) &#123; // 业务逻辑 console.error(err.stack); res.status(500).send('Something broke!');&#125;); 应用生成器12345678910//安装$ npm install express-generator -g//view=XXX 使用引擎名字 myapp项目名称$ express --view=pug myapp//安装所有依赖$ cd myapp$ npm install//启动myapp项目$ set DEBUG=myapp:* &amp; npm start 我的石墨文档链接：https://shimo.im/docs/TXeewzaE8Jsdgn0I/练习的简易聊天室连接：https://github.com/biubiuins/demo_chat]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[project_email]]></title>
    <url>%2F2018%2F10%2F11%2Fproject-email%2F</url>
    <content type="text"><![CDATA[邮件收发项目大二上开始学html，css，js之后做的暑假做的前端页面，很感谢老师可以给一个练手的机会，在做的过程中发现了很多问题，以及项目完成之后的收获。&nbsp;&nbsp;&nbsp;&nbsp;虽然是一个很简单的界面，但是之前学习的时候不太仔细，也没有demo练习，还是做的磕磕绊绊，还好最后做的差不多了。TAT&nbsp;&nbsp;针对过程中的问题，阅读了很多关于语法规范的文章，js，jq又重新学习了一遍（练习了很多），大二下期基本在学习之中度过的。希望在以后的项目中可以有所进步，彻底的实现前后端分离！！！ 项目相关 完成时间：大二上期寒假 2018-3月左右 bootsrap框架，layui框架，jquery 项目不足 语法不规范，复用性不强，后面修改过一次感觉修改起来很复杂 js不熟练，项目之后大二下期又重新开始学习了一遍js，并写了总结 (https://biubiuins.github.io/2018/10/11/summary-2018-9/) 技术不足，没有实现前后端分离 主要功能 首页 http://mailroom.sicau.edu.cn/email/public/ bootsrap做了响应式，用了ajax请求数据 管理页面（需要登陆仅提供图片） 实现全选与批量删除 点击已取之后，重新获取数据（保证筛选邮件之后点击已取仍显示的是筛选之后的邮件) 邮件类型默认显示上一次选择的类型，可输入筛选的下拉框 超级管理员界面实现了原生js模态框，并做了根据屏幕居中]]></content>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[summary-2018.9]]></title>
    <url>%2F2018%2F10%2F11%2Fsummary-2018-9%2F</url>
    <content type="text"><![CDATA[summary-2018-9 这是在学会搭建博客之后的第一篇博客，以前学习的时候也有记笔记，所以把之前学习笔记上面整理的常见的功能、封装以及遇到的问题写出来，这篇仅限于js，jq。现在正在学习vue，希望在过段时间，自己也能写出关于vue学习的总结。在此之前还需要了解markdown的语法TAT 原来的笔记记录在石墨文档，https://shimo.im/docs/c8YrJy4obNICaWiS/ ID处理1234/** 获取id */function $(id) &#123; return typeof id === "string" ? document.getElementById(id) : null;&#125; 动画匀速动画1234567891011121314151617181920//元素，目标，步数function constant(obj, target, speed) &#123; // 1. 清除定时器 clearInterval(obj.timer); //2.判断方向 //如果现在的距离小于目标值,则往右，否则向左 let dir =obj.offsetLeft&lt;target?speed:-speed; //3. 设置定时器 obj.timer = setInterval(function () &#123; obj.style.left = obj.offsetLeft + dir + "px"; //若超出目标值或者不到目标值 //最后相减的值取绝对值后，总是小于步数的 //Math.abs(dir)||speed if(Math.abs(target-obj.offsetLeft)&lt;Math.abs(dir))&#123; clearInterval(obj.timer); //根据目标值板正 obj.style.left =target+'px'; &#125; &#125;, 20);&#125; 缓动动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function buffer(obj, json, fn) &#123; // 1. 清除定时器 clearInterval(obj.timer); var begin = 0, end = 0; // 2. 设置定时器 obj.timer = setInterval(function () &#123; // 2.0 旗帜, 决定动画是否结束 let flag = true; // 2.1 遍历 for(let k in json)&#123; // 2.2.-1 求出起始值 和 结束值 if(k === 'opacity')&#123; // 透明度 begin = parseInt( parseFloat(getCssAttr(obj, k)) * 100); end = parseInt(parseFloat(json[k]) * 100); &#125;else if(k === 'scrollTop')&#123; // 滚动到头部 begin = obj.scrollTop; end = parseInt(json[k]); &#125;else &#123; // 正常情况 begin = parseInt(getCssAttr(obj, k)); end = parseInt(json[k]); &#125; // 2.2.0 求出步长 //步长公式 let step = (end - begin) * 0.2; step = step &gt;=0 ? Math.ceil(step) : Math.floor(step); // 2.2.1 计算起始位置 if(k === 'opacity')&#123; obj.style.opacity = (begin + step) / 100; obj.style.filter = 'alpha(opacity=' + (begin + end)+')'; // 针对IE &#125;else if(k === 'scrollTop')&#123; obj.scrollTop = begin + step; &#125;else if(k === 'zIndex')&#123; obj.style[k] = json[k]; &#125;else &#123; obj.style[k] = begin + step + 'px'; &#125; // 2.2.2 判断 if(begin !== end)&#123; flag = false; &#125; &#125; // 3.0 结束动画 if(flag)&#123; clearInterval(obj.timer); // 开启动画组中的下一组动画 if(fn)&#123; // 判断有没有这个函数 fn(); &#125; &#125; &#125;, 60);&#125; js获取CSS利用 [] 访问属性 元素.style[“属性”];1234567891011121314//这种语法的好处就是可以动态的传递参数作为属性//只能获取行类标签 var h = 'height'; box.style[h] = 300 + 'px';//获取外部css或页内的cssfunction getStyleAttr(obj, attr) &#123; if(obj.currentStyle)&#123; // IE 和 opera return obj.currentStyle[attr]; &#125;else &#123; //window.getComputedStyle("元素", "伪类") （ 注意：两个选项是必须的，没有伪类 用 null 替代 ） //也可以点选，但是为了传递参数作为属性 return window.getComputedStyle(obj, null)[attr]; &#125;&#125; 定时器 在定时器事件前，先设置接收定时器的变量指向null 在定时器事件里，先要清除定时器再设置定时器，先清除是防止定时器累加轮播第一种这种不适合多图1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162function slider (sliderid,olStyleClassName,imgWidth,speed,second) &#123; //高级排他 //lastIndex 选中的小圆点样式 currentIndex 小圆点索引 picIndex 图片索引 let lastIndex=0,currentIndex=0,picIndex=0; // 1. 获取需要的标签 let ul=$(sliderid).children[0]; let ol=$(sliderid).children[1]; let list=ul.children; let olList= ol.children; // 2.克隆最后一个li标签 ul.appendChild(list[0].cloneNode(true)); // 3.动态创建小圆点 for(let i= 0;i&lt;list.length-1;i++)&#123; let li =document.createElement("li"); ol.appendChild(li); &#125; //4.第一个小圆点选中 olList[0].className=olStyleClassName; //5.监听每个li的进入事件 for(let i= 0;i&lt;olList.length;i++)&#123; //5.1 每一个li绑定自己的事件 olList[i].onmouseover=function () &#123; //先清除之前的选中状态，在把当前选中的索引给lastIndex lastIndex=currentIndex; olList[lastIndex].className=""; this.className=olStyleClassName; lastIndex=i; //5.2图片动起来 constant(ul,-(i * imgWidth),speed); currentIndex=picIndex=i; &#125;; &#125; //6.定时器 let timer; timer = setInterval(autoPlay, second); // 7. 清除和设置定时器 $(sliderid).onmouseover = function () &#123; clearInterval(timer); &#125;; $(sliderid).onmouseout = function () &#123; timer = setInterval(autoPlay, second); &#125;; function autoPlay()&#123; picIndex++; currentIndex++; //如果图片到了最后一张 if (picIndex &gt; list.length - 1) &#123; ul.style.left = 0; //从第二张图片开始 picIndex = 1; &#125; constant(ul, -(picIndex * imgWidth), speed); //小原点的选中 if (currentIndex &gt; olList.length - 1) &#123; currentIndex = 0; &#125; for (let i=0;i&lt;olList.length;i++)&#123; olList[i].className=""; &#125; olList[currentIndex].className=olStyleClassName; &#125;&#125; 第二种两个图片宽度的位置，第一个位置显示（当前），第二位置隐藏 第三种改变透明度，循环一遍让所有的opacity动画为0，然后当前为opacity动画为1，索引++、12345678910111213141516171819function opacityAutoPlay(ulid,speed) &#123; // 1. 获取所有的li标签 var lis = $(ulid).getElementsByTagName("li"); var index = 0; // 2. 开始定时器 setInterval(function () &#123; // 2.1 改变透明度 for(let i=0; i&lt;lis.length; i++)&#123; let singerLi = lis[i]; buffer(singerLi, &#123;opacity: 0&#125;, null); &#125; buffer(lis[index], &#123;opacity: 1&#125;, null); // 2.2 索引++ index++; if(index === lis.length)&#123; index = 0; &#125; &#125;, speed);&#125; 瀑布流 父盒子居中 Math.floor(屏幕宽度/子盒子宽度)=cols 子盒子的宽度*cols=父盒子的宽度 margin:0 auto; 子盒子定位第一行不变，其他子盒子接在第一行最矮的盒子的后面（反复） 拿到所有盒子的高度。把第一行的盒子的高度放在一个数组里面（i&lt;cols,heightArr[]) 在剩下的盒子里面(i&gt;=cols),找出第一行最矮的盒子的高度（Math.min(…heightArr)||Math.min.apply(this.height)）2.1 找出最矮盒子的索引(遍历heightArr[],找出和第二步盒子高度一样的i返回)2.2 剩下盒子定位（left=第2.1步的索引*子盒子宽度，top=最矮的盒子高度）2.3 更新最矮盒子的高度 （heightArr[最矮盒子的高度]+=当前盒子的高度） 滚动加载图片 监听窗口的滚动，滚动到你需要的位置加载 js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 window.onload = function () &#123; // 1. 实现瀑布流布局 waterFull("main", "box"); // 2. 动态加载图片 window.onscroll = function () &#123; if(checkWillLoadImage())&#123; // 2.1 造数据 var dataArr = [ &#123;"src": "img04.jpg"&#125;, &#123;"src": "img06.jpg"&#125;, &#123;"src": "img08.jpg"&#125;, &#123;"src": "img09.jpg"&#125;, &#123;"src": "img10.jpg"&#125;, &#123;"src": "img12.jpg"&#125;, &#123;"src": "img14.jpg"&#125;, &#123;"src": "img16.jpg"&#125;, &#123;"src": "img18.jpg"&#125; ]; // 2.2 创建元素 for(var i=0; i&lt;dataArr.length; i++)&#123; var newBox = document.createElement("div"); newBox.className = "box"; $("main").appendChild(newBox); var newPic = document.createElement("div"); newPic.className = "pic"; newBox.appendChild(newPic); var newImg = document.createElement("img"); newImg.src = "images/" + dataArr[i].src; newPic.appendChild(newImg); &#125; // 2.3 重新布局 waterFull("main", "box"); &#125; &#125;&#125;;/** * 实现瀑布流布局 */function waterFull(parent, child) &#123; // 1. 父盒子居中 // 1.1 获取所有的盒子 var allBox = $(parent).getElementsByClassName(child); // 1.2 获取子盒子的宽度 var boxWidth = allBox[0].offsetWidth; // 1.3 获取屏幕的宽度 var screenW = document.documentElement.clientWidth; // 1.4 求出列数 var cols = parseInt(screenW / boxWidth); // 1.5 父盒子居中 $(parent).style.width = cols * boxWidth + 'px'; $(parent).style.margin = "0 // 2. 子盒子的定位 // 2.1 定义高度数组 var heightArr = [], boxHeight = 0, minBoxHeight = 0, minBoxIndex = 0; // 2.2 遍历子盒子 for (var i = 0; i &lt; allBox.length; i++) &#123; // 2.2.1 求出每一个子盒子的高度 boxHeight = allBox[i].offsetHeight; // 2.2.2 取出第一行盒子的高度放入高度数组 if (i &lt; cols) &#123; // 第一行 heightArr.push(boxHeight); &#125; else &#123; // 剩余行 // 1. 取出最矮的盒子高度 // minBoxHeight = _.min(heightArr); minBoxHeight=Math.min(...heightArr); // 2. 求出最矮盒子对应的索引 minBoxIndex = getMinBoxIndex(heightArr, minBoxHeight); // 3. 子盒子定位 allBox[i].style.position = "absolute"; allBox[i].style.left = minBoxIndex * boxWidth + 'px'; allBox[i].style.top = minBoxHeight + 'px'; // 4. 更新数组中的高度 heightArr[minBoxIndex] += boxHeight; &#125; &#125; console.log(heightArr, minBoxHeight, minBoxIndex);&#125;/** * 获取数组中最矮盒子高度的索引 * @param arr * @param val * @returns &#123;number&#125; */function getMinBoxIndex(arr, val) &#123; for(var i=0; i&lt;arr.length; i++)&#123; if(arr[i] === val)&#123; return i; &#125; &#125;&#125;/** * 判断是否具备加载图片的条件 */function checkWillLoadImage() &#123; // 1. 获取最后一个盒子 var allBox = document.getElementsByClassName("box"); var lastBox = allBox[allBox.length - 1]; // 2. 求出最后一个盒子自身高度的一半 + offsetTop var lastBoxDis = lastBox.offsetHeight * 0.5 + lastBox.offsetTop; // 3. 求出屏幕的高度 var screenW = document.body.clientHeight || document.documentElement.clientHeight; // 4. 求出页面偏离浏览器的高度 var scrollTop = scroll().top; return lastBoxDis &lt;= screenW + scrollTop;&#125; jq123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//当页面加载完毕$(window).on('load',function () &#123;//1.实现瀑布流布局waterFall();//2.滚动加载$(window).on('scroll',function () &#123;//判断是否加载if (checkWillLoad())&#123;////创造假数据var data = &#123;'dataImg':[&#123;'img':'23.jpg'&#125;,&#123;'img':'24.jpg'&#125;,&#123;'img':'25.jpg'&#125;,&#123;'img':'26.jpg'&#125;,&#123;'img':'27.jpg'&#125;,&#123;'img':'28.jpg'&#125;]&#125;;//遍历创建盒子$.each(data.dataImg,function (index,value)&#123;//创建一个div标签 设置它的类为'box' 添加到'main'里面去var newBox = $('&lt;div&gt;').addClass('box').appendTo($('#main')); var newPic = $('&lt;div&gt;').addClass('pic').appendTo($(newBox)); //创建img 取出遍历的对象value的img属性对应的值 $('&lt;img&gt;').attr('src','images/'+$(value).attr('img')).appendTo($(newPic)); &#125;) //1.实现瀑布流布局 waterFall(); &#125; &#125;); &#125;); //实现瀑布流布局 function waterFall () &#123; //拿到所有的盒子 var allBox = $('#main &gt; .box'); //取出其中一个盒子的宽度 var boxWidth = $(allBox).eq(0).outerWidth(); //取出屏幕的高度 var screenWidth = $(window).width(); //求出列数 //取整函数取整 var cols = Math.floor( screenWidth/boxWidth); //父标签居中 $('#main').css(&#123; 'width':cols * boxWidth + 'px', 'margin':'0 auto' &#125;); //对子盒子定位 var heightArr = []; //遍历 $.each(allBox,function (index,value) &#123; //取出单独盒子的高度 var boxHeight = $(value).outerHeight(); //判断是否第一行 if(index &lt; cols) &#123; heightArr[index] = boxHeight; &#125; else //剩余的盒子要瀑布流布局 &#123; //求出最矮的盒子高度 var minBoxHeight = Math.min.apply(null,heightArr); //取出最矮高度对应的索引 封装了js的这个方法 var minBoxIndex = $.inArray(minBoxHeight,heightArr); //定位 $(value).css(&#123; 'position':'absolute', 'top':minBoxHeight + 'px', 'left':minBoxIndex * boxWidth + 'px' &#125;); //更新数组中最矮的高度 heightArr[minBoxIndex] += boxHeight; &#125; &#125;) &#125; //判断是否符合加载条件 function checkWillLoad() &#123; //直接取出最后一个盒子 var lastBox = $('#main &gt; div').last(); //取出最后一个盒子高度的一半 + 头部偏离的位置 var lastBoxDis = $(lastBox).outerHeight() + $(lastBox).offset().top; //求出浏览器的高度 var clientHeight = $(window).height(); //求出页面偏离浏览器高度 var scrollTopHeight = $(window).scrollTop(); //比较返回 return lastBoxDis &lt;= clientHeight + scrollTopHeight; &#125; margin:0 auto 块级元素 给定要居中的块级元素的宽度。 所有元素也可以通过对父元素设置text-align：center；的方式来实现居中。而对于块元素来说，对要居中的元素自身进行设置text-align:center也能实现居中 margin:0 auto;可以使盒子居中，text-align:center;可以使文本居中，节流onresize举列子窗口大小一变化就执行，太过灵敏，所以需要阻止1234567891011121314151617//使用定时器var timer = null;window.onresize = function () &#123; clearTimeout(timer); // 节流 timer = setTimeout(function () &#123; waterFull('main', 'box'); &#125;, 200);&#125;//封装之后的function throttle(fn, delay) &#123; var timer = null; return function () &#123; clearTimeout(timer); timer = setTimeout(fn, delay); &#125;&#125; apply/call这个面试中常考到，现在只做初步了解(https://www.cnblogs.com/gaowx/p/4837687.html ) 改变函数的this指向 apply可以改变传递给函数参数的形式Date123456789101112131415161718192021222324function newDate()&#123; //声明日期对象，里面可以设置参数表示其他时间 let date =new Date(); //获取时间里面的年 date.getFullYear() //月0-11 date.getMonth()+1 //日1-31 date.getDate() //获取星期0-6 data.Day //设置某一天 date.setDate（day） //时0-23 date.getHours() //分0-59 date.getMinutes() //秒0-59 date.getSeconds() //获取毫秒 date.getMilliSeconds() //时间戳 date.getTime()&#125; ms转化时间 cookie封装封装成插件，引入该文件后，$.addCookie(key,value,day,path,domain)来引用1234567891011121314151617181920212223242526272829303132333435363738394041;(function ($,window) &#123; $.extend(&#123; addCookie: function addCookie(key,value,day,path,domain)&#123; //1.处理默认保存的路径 var index=window.location.pathname.lastIndexOf('/'); var currentPath=window.location.pathname.slice(0,index) path=path||currentPath //2.处理默认domain domain=domain||document.domain //3.处理默认的过期时间 if(!day)&#123; document.cookie=key+"="+value+";path="+path+";domain="+domain+';' &#125; else&#123; var date =new Date(); date.setDate(date.getDate()+day) document.cookie=key+"="+value+";expires="+date.toGMTString()+";path="+path+";domain="+domain+';' &#125; &#125;, getCookie: function getCookie(key)&#123; var res=document.cookie.split(';') for(var i=0;i&lt;res.length;i++)&#123; //把key和value切割 var temp=res[i].split('=') //前后可能有空格，把空格删除 if(temp[0].trim()===key)&#123; return temp[1] &#125; &#125; &#125;, delCookie: function delCookie(key, path) &#123; //默认情况下只能删除默认路径中保存的cookie，如果要删除指定路径保存的cookie，要把路径值传出去 //设置过期时间为-1 addCookie(key, getCookie(key), -1, path) &#125; &#125;);&#125;)(jQuery,window); 动态添加的元素绑定事件 delegate 123$(&apos;ul&apos;).delegate(&apos;li&apos;,&apos;click&apos;,function()&#123;//操作的还是li&#125;) onclick事件在动态添加数据的时候，就给元素绑定onclick事件 on（）常用 12345//把动态添加的元素写在on里面，如果调用的函数是外部定义好的，则在调用的时候不加（）//不然会跳过点击事件直接执行函数$(&quot;父元素或祖辈元素&quot;).on(&quot;click&quot;,&quot;动态添加的元素&quot;,function()&#123;$(this).css(&quot;border&quot;,&quot;5px solid #000&quot;);&#125; 其他清除默认样式http://yui.yahooapis.com/3.18.1/build/cssreset/cssreset-min.css 下拉框1234567891011121314151617181920//拿到select对象：var myselect=document.getElementById("select");//拿到选中项的索引var index=myselect.selectedIndex ; // selectedIndex代表的是你所选中项的index//拿到选中项options的value：myselect.options[index].value;//拿到选中项options的text：myselect.options[index].text;//拿到选中项的其他值，比如这里的url： myselect.options[index].getAttribute('url');//jqueryvar options=$(“#select option:selected”); //获取选中的项alert(options.val()); //拿到选中项的值alert(options.text()); //拿到选中项的文本alert(options.attr('url')); //拿到选中项的url值//设置//设置value为pxx的项选中$(".selector").val("pxx")//设置text为pxx的项选中$(".selector").find("option[text='pxx']").attr("selected",true) H5 datalistdatalist 只是列表赋值取值还是通过input.样式等都在input上操作https://www.zhangxinxu.com/wordpress/2013/03/html5-datalist-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8-%E5%8F%AF%E8%A1%8C%E6%80%A7/ 邮箱的自动补全HTML代码：123456789邮箱：&lt;input type=&quot;email&quot; id=&quot;email&quot; list=&quot;emailList&quot; name=&quot;off_autocomplete&quot; /&gt;&lt;datalist id=&quot;emailList&quot;&gt;//其中*为占位符，当文本框输入内容的时候，*替换成邮箱地址的前半部分，于是，动态邮件地址提示的效果就实现了 &lt;option value=&quot;*@qq.com&quot;&gt; &lt;option value=&quot;*@163.com&quot;&gt; &lt;option value=&quot;*@gmail.com&quot;&gt; &lt;option value=&quot;*@yahoo.com.cn&quot;&gt; &lt;option value=&quot;*@126.com&quot;&gt;&lt;/datalist&gt; JS代码：12345678910111213141516171819202122232425262728var eleList = document.getElementById("emailList") , eleMail = document.getElementById("email") , htmlListInit = '', arrEmailList = [];if (eleMail &amp;&amp; eleList &amp;&amp; (htmlListInit = eleList.innerHTML) !== '') &#123; // 得到类似["qq.com", "163.com", "gmail.com", ...]的数据 arrEmailList = [].slice.call(eleList.getElementsByTagName("option")).map(function(option) &#123; return option.value.replace("*@", ""); &#125;); eleMail.fnListReplace = function() &#123; var arrValue = this.value.trim().split("@"); // 修复FireFox浏览器下无限input问题 // 如果值不完全匹配某option值，执行动态替换 if (arrValue.length !== 2 || arrEmailList.indexOf(arrValue[1]) === -1) &#123; eleList.innerHTML = htmlListInit.replace(/\*/g, arrValue[0]); &#125; return this; &#125;; // 绑定输入事件侦听 eleMail.addEventListener("input", function() &#123; this.fnListReplace.call(this); &#125;, false); // 载入即匹配 eleMail.fnListReplace.call(eleMail).focus();&#125; else &#123; eleList = document.createElement("datalist"); eleList.innerHTML = '&lt;p class=sorry&gt;抱歉，当前浏览器不支持HTML5 datalist.&lt;/p&gt;'; eleMail.parentNode.appendChild(eleList);&#125; jquery.editable-select控件引入jquery.editable-select.cssjquery.editable-select.js调用方法123456789101112$('#editable-select').editableSelect(&#123; bg_iframe: true, //是否加iframe case_sensitive: false, items_then_scroll: 10 ,//设置下拉选项的数目 isFilter:false/true, //是否根据条件过滤下拉选项 onCreate:, //当输入时触发 onShow：, //当下拉时触发 onHide：, //当下拉框隐藏时触发 onSelect：, //当下拉框中的选项被选中时触发 effects:default/slide/fade， //动画效果 duration： //动画效果的时间&#125;);]]></content>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
</search>
