<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[demo_vue-book2]]></title>
    <url>%2F2018%2F11%2F11%2Fvue-shop2%2F</url>
    <content type="text"><![CDATA[vue实战项目外卖2ajax请求问题分析： 目前为止运行的所有页面都是静态页面 接下来先测试使用封装的ajax接口请求函数来异步获取数据 123456789101112// 先在App.vue中引入封装的接口函数import &#123;reqCategorys&#125; from './api'// 然后再调用接口，测试打印数据export default &#123; async mounted () &#123; const result = await reqCategorys() console.log(result) &#125;, components: &#123; FooterGuide &#125;&#125; 报错了，跨域问题。8080的端口在请求4000端口的数据，然后在api文件夹下的index.js中修改测试 1234// 定义BASE_URLconst BASE_URL = 'http://local:4000'// 然后修改请求接口的urlexport const reqCategorys = () =&gt; ajax(BASE_URL + '/index_category') 跨域是浏览器的限制。解决办法：1.服务器告诉浏览器允许跨域 2.蒙蔽浏览器的双眼 配置代理并测试接口： 除了设置让服务器允许跨域的方法之外，还可以通过配置代理实现跨域请求 在项目config文件夹下的index.js文件里设置代理配置表 12345678910111213141516171819 // Paths // 静态资源文件夹 assetsSubDirectory: 'static', // 发布路径assetsPublicPath: '/',// 代理配置表，在这里可以配置特定的请求代理到对应的API接口// 例如将'localhost:8080/api/xxx'代理到'www.example.com/api/xxx'proxyTable: &#123; '/api': &#123; // 匹配所有以 '/api'开头的请求路径 target: 'http://localhost:4000', // 代理目标的基础路径 // secure: false, // 如果是https接口，需要配置这个参数 changeOrigin: true, // 支持跨域 pathRewrite: &#123; // 重写路径: 去掉路径中开头的'/api' '^/api': '' &#125; &#125; &#125;, 修改api文件夹index.js里接口函数的请求路径 123456// const BASE_URL = 'http://local:4000'const BASE_URL = '/api'export const reqAddress = geohash =&gt; ajax(`$&#123;BASE_URL&#125;/position/$&#123;geohash&#125;`)export const reqCategorys = () =&gt; ajax(BASE_URL + '/index_category')// 下面修改后的接口省略... 因为修改了项目的config文件，所以需要重启项目npm run dev 此时可以在控制台看到跨域请求到的数据{code: 0, data: Array(16)} vuex管理状态 安装Vuexnpm install vuex --save用来管理从后台获取的状态数据 以下代码以首页Msite为例 11.1 创建Store(核心仓库) 在项目的store文件夹下新建index.js 1234567891011121314151617181920/*vuex最核心的管理对象store*/// 首先引入Vue及Vueximport Vue from 'vue'import Vuex from 'vuex'// 引入四个基本模块import state from './state'import mutations from './mutations'import actions from './actions'import getters from './getters'// 一定要声明使用插件Vue.use(Vuex)// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件export default new Vuex.Store(&#123;state,mutations,actions,getters&#125;) 模块对象 状态对象 state 操作state 直接更新state的多个方法对象 mutations 操作mutations 间接更新state的多个方法对象 actions 包含多个基于state的getter计算属性的对象 getters 包含n个mutations的type名称常量 mutations-type State 分析整理出项目首页Msite中有哪些状态需要管理，然后写入state.js 在之前应该定位，这里直接保存当前状态 12345678910/*状态对象 state*/export default &#123; latitude: 40.10038, // 纬度 longitude: 116.36867, // 经度 address: &#123;&#125;, // 地址相关信息对象 categorys: [], // 食品分类数组 shops: [] // 商家数组&#125; Mutation 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation 每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler) 我们可以使用常量替代 Mutation 事件类型，新建mutations-types文件 123456/*包含n个mutation的type名称常量 */export const RECEIVE_ADDRESS = 'receive_address' // 接收地址信息export const RECEIVE_CATEGORYS = 'receive_categorys' // 接收分类数组export const RECEIVE_SHOPS = 'receive_shops' // 接收商家数组 然后在mutations.js文件内引入使用 (注意书写格式[ ]) 1234567891011121314151617 /* vuex 的 mutations 模块 */ import &#123;RECEIVE_ADDRESS,RECEIVE_CATEGORYS,RECEIVE_SHOPS&#125; from './mutation-types' // [方法名](state,&#123;param&#125;)&#123;&#125; export default &#123; [RECEIVE_ADDRESS](state, &#123;address&#125;) &#123; state.address = address&#125;,[RECEIVE_CATEGORYS](state, &#123;categorys&#125;) &#123; state.categorys = categorys&#125;,[RECEIVE_SHOPS](state, &#123;shops&#125;) &#123; state.shops = shops&#125; &#125; 而回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数 Action 和后台交互的异步action， Action 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 12345678910111213141516171819202122232425262728293031 // Action:通过操作mutation间接更新state的多个方法的对象 // 注意要引入api接口函数 import &#123;reqAddress, reqCategorys, reqShops&#125; from '../api' import &#123;RECEIVE_ADDRESS, RECEIVE_CATEGORYS, RECEIVE_SHOPS&#125; from './mutation-types' export default &#123; // 异步获取地址 async getAddress (&#123;commit, state&#125;) &#123; // 从state状态中获取到经纬度用来设置reqAddress的参数（看接口文档） const geohash = state.latitude + ',' + state.longitude // 1. 发送异步ajax请求 const result = await reqAddress(geohash) // 2. 根据结果提交一个mutation //因为mutation.js里面的函数接收的参数是&#123;address&#125; commit(RECEIVE_ADDRESS, &#123;address: result.data&#125;)&#125;,// 异步获取分类列表async getCategorys (&#123;commit&#125;) &#123; const result = await reqCategorys() commit(RECEIVE_CATEGORYS, &#123;categorys: result.data&#125;)&#125;,// 异步获取商家列表async getShops (&#123;commit, state&#125;) &#123; // 对象的解构赋值 const &#123;latitude, longitude&#125; = state // 注意参数的顺序 const result = aowait reqShops(&#123;latitude, longitude&#125;) commit(RECEIVE_SHOPS, &#123;shops: result.data&#125;)&#125; &#125; 至此已经完成了首页状态数据的vuex设置 异步获取并显示数据 在项目中注册store 123456//项目的main.js文件import store from './store'new Vue(&#123; store&#125;) 测试异步获取当前地址数据 123456// 地址信息要尽早的获取，所以请求可以写在App.vue中// 首先删除之前测试使用封装的ajax接口的代码async mounted () &#123; // 通过this.$store.dispatch 方法触发调用Action this.$store.dispatch('getAddress')&#125; 运行项目，在浏览器控制台里打开vue开发工具，切换到vuex，可以看到通过vuex异步获取的状态数据 除了这种方法调用action，还可以使用mapActions语法糖 12345678import &#123;mapActions&#125; from 'vuex'async mounted () &#123; this.getAddress()&#125;methods: &#123; ...mapActions(['getAddress'])&#125; 读取并显示获取到的当前地址数据 首页Msite组件中显示地址信息 123456// 利用mapState语法糖去读取state对象import &#123;mapState&#125; from 'vuex'computed: &#123; ...mapState(['address'])&#125; 123&lt;HeaderTop :title="address.name"&gt;// 将静态地址信息换成异步获取的地址数据 注意:title为绑定数据&lt;/HeaderTop&gt; 完成Msite页面异步显示食品分类轮播列表 上面已经完成了首页当前地址信息的获取与显示，接下来是完成Msite.vue中的食品分类的轮播图 mounted方法中通过this.$store.dispatch调用Action来获取异步数据 12345// 忘记Actuon里对应的方法名时查看Action.jsmounted () &#123; this.$store.dispatch('getCategorys') ...&#125; 通过mapState语法糖来读取获取到的异步数据 1234// 忘记state名时查看State.jscomputed: &#123; ...mapState(['address', 'categorys'])&#125; 分析template结构并处理categorys数据 轮播图应该在数组数据显示之后才能显示 业务分析： 此时获取到的categorys是所有食品类别的一维数组，而如果要完成轮播图，需要将其变成这种[[page1], [page2], [page3]]二维数组categorysArr。 比如本项目中有两页轮播图，一页为8个数据。应该把categorys数组处理成[[data1 - 8], [data1 - 8]]这种数据格式 123456//template&lt;div class="swiper-slide" v-for="(pages,index) in categorysArr" :key="index"&gt; &lt;a href="javascript:" class="(data,index) in pages" :key="index"&gt; ...... &lt;/a&gt;&lt;/div&gt; 利用计算属性将categorys处理成期望的数据结构categorysArr 1234567891011121314151617181920212223242526272829computed () &#123; ...mapState(['address', 'categorys']), /* 根据categorys一维数组生成一个2维数组 小数组中的元素个数最大是8 */ categorysArr () &#123; // 1.先从当前组件中得到所有食品分类的一维数组 const &#123;categorys&#125; = this // 2.准备一个空的二维数组--categorysArr const arr = [] // 3.准备一个小数组--pages(最大长度为8) let minArr = [] // 4.遍历categorys得到处理后的二维数组catagorysArr categorys.forEach(data =&gt; &#123; // 如果当前小数组(pages)已经满了, 创建一个新的 if (minArr.length === 8) &#123; minArr = [] &#125; // 如果minArr是空的, 将小数组(pages)保存到大数组(categorysArr)中 if (minArr.length === 0) &#123; arr.push(minArr) &#125; // 将当前分类信息保存到小数组(pages)中 minArr.push(data) &#125;) return arr &#125;&#125; 注意第4步forEach里的逻辑顺序 1.为什么当minArr数组的长度为0时就将它与大数组关联起来，不是等它存满(8个)？ 因为有可能categorys里的数据个数不为8的倍数，最后一个minArr内的数据不足8个。 2.为什么先判断minArr的长度为8的情况再判断等于0的情况？ 因为先判断minArr的长度为0，将其放入大数组中与大数组关联起来，那么等到当前这个minArr填充完成之后新建的小数组则无法与大数组关联起来。 所以先判断长度为8的情况，再判断数组长度为0的情况。就可以确保之前的minArr填充完成后，新建的minArr都可以被放到大数组里与大数组关联起来。 除了上面的方式处理categorys，也可以采用分割数组的方法。 12345678categorysArr () &#123; const &#123;categorys&#125; = this const arr = [] for (let i = 0,len = categorys.length;i &lt; len; i += 8)&#123; arr.push(categorys.slice(i, i + 8)) &#125; return arr&#125; 将数据显示到页面上 123456// 因为食品分类的图片信息都有一个baseImageUrl所以在data里定义data () &#123; return &#123; baseImageUrl: 'https://fuss10.elemecdn.com' &#125;&#125;, 123456789&lt;!--通过v-for循环渲染data的信息 注意src为绑定数据--&gt;&lt;div class="swiper-slide" v-for="(pages,index) in categorysArr" :key="index"&gt; &lt;a href="javascript:" class="link_to_food" v-for="(data,index) in pages" :key="index"&gt; &lt;div class="food_container"&gt; &lt;img :src="baseImageUrl+data.image_url"&gt; &lt;/div&gt; &lt;span&gt;&#123;&#123;data.title&#125;&#125;&lt;/span&gt; &lt;/a&gt;&lt;/div&gt; 使用watch与$nextTick解决轮播的Bug 分页器Swiper其实应该是在轮播列表显示(即categorys数组有了数据)以后才初始化。 最开始categorys为空数组，有了数据才会显示轮播列表，而要监视categorys的数据变化，就要用到watch。 123456789101112131415// 新建watch 监听categoryswatch: &#123; categorys (value) &#123; // categorys数组中有数据了 // 但界面还没有异步更新 new Swiper('.swiper-container', &#123; autoplay: true, // 如果需要分页器 pagination: &#123; el: '.swiper-pagination', clickable: true &#125; &#125;) &#125;&#125;// 删除mounted中的new Swiper...代码 但其实state里的状态数据改变（categorys接收数据）与异步更新界面（显示轮播列表）是两个步骤。所以需要等一等，界面完成异步更新后才可以进行Swiper的初始化。 123456789101112// 使用setTimeout可以实现效果, 但是时机不准确setTimeout(() =&gt; &#123; // 创建一个Swiper实例对象, 来实现轮播 new Swiper('.swiper-container', &#123; autoplay: true, // 如果需要分页器 pagination: &#123; el: '.swiper-pagination', clickable: true &#125; &#125;)&#125;, 100) 利用vm.$nextTick( [callback] )来实现等待界面完成异步更新就立即创建Swiper对象 nextTick将回调延迟到下次DOM更新循环之后执行 在修改数据之后立即使用它，然后等待DOM更新 12345678910// 在修改数据之后立即使用它，然后等待 DOM 更新。this.$nextTick(() =&gt; &#123; // 一旦完成界面更新, 立即执行回调 new Swiper('.swiper-container', &#123; autoplay: true, pagination: &#123; el: '.swiper-pagination', clickable: true &#125;&#125;) 异步显示商家列表 在Msite的mounted中获取异步数据 1this.$store.dispatch('getShops') 在ShopList.vue中引入mapState，在computed中读取状态数据 123456 import &#123;mapState&#125; from 'vuex' export default &#123; computed: &#123; ...mapState(['shops'])&#125; &#125; 修改template并添加data 12345 data () &#123;return &#123; baseImgUrl: 'http://owoccema2.bkt.clouddn.com/show/MintShop/' &#125; &#125; 12345678910111213141516171819 &lt;li class="shop_li border-1px" v-for="(shop,index) in shops" :key="index"&gt;&lt;a&gt; &lt;div class="shop_left"&gt; &lt;img class="shop_img" :src="baseImgUrl + shop.image_path"&gt; &lt;/div&gt; &lt;div class="shop_right"&gt; &lt;section class="shop_detail_header"&gt; &lt;h4 class="shop_title ellipsis"&gt;&#123;&#123;shop.name&#125;&#125;&lt;/h4&gt; &lt;ul class="shop_detail_ul"&gt; ... &lt;/ul&gt; &lt;/section&gt; &lt;section class="shop_rating_order"&gt; &lt;section class="shop_rating_order_left"&gt; ... &lt;/section&gt; &lt;/div&gt;&lt;/a&gt; &lt;/li&gt; 开发评分Star组件 不仅在首页的商家列表中有五颗星星的评分部分，商家信息的评价区域也有star评分，所以可以把它抽取成一个可复用的一般组件。 在components文件夹下新建Star文件夹，然后将原本在ShopList文件夹下的images文件夹里的stars移动到新建的Star文件夹里并重命名为images 在Star文件夹里新建Star.vue并将ShopList.vue中评分部分的模版和样式剪切进去，注意修改图片路径 1234567&lt;div class="star star-24"&gt; &lt;span class="star-item on"&gt;&lt;/span&gt; &lt;span class="star-item on"&gt;&lt;/span&gt; &lt;span class="star-item on"&gt;&lt;/span&gt; &lt;span class="star-item half"&gt;&lt;/span&gt; &lt;span class="star-item off"&gt;&lt;/span&gt;&lt;/div&gt; 根据类名为组件设置属性props和计算属性 1234567891011121314151617181920212223242526272829303132333435// 类名常量const CLASS_ON = 'on'const CLASS_HALF = 'half'const CLASS_OFF = 'off'export default &#123; props: &#123; score: Number, size: Number &#125;, computed: &#123; /* 3.2: 3 + 0 + 2 4.7: 4 + 1 + 0 */ // 该方法产生一个数组starArr来表示on half off类名的span数量（总长度为5） starClasses () &#123; const &#123;score&#125; = this const starArr = [] // 向starArr中添加n个CLASS_ON const scoreInteger = Math.floor(score) for (let i = 0; i &lt; scoreInteger; i++) &#123; starArr.push(CLASS_ON) &#125; // 向starArr中添加0/1个CLASS_HALF if(score*10-scoreInteger*10&gt;=5) &#123; starArr.push(CLASS_HALF) &#125; // 向starArr中添加n个CLASS_OFF while(starArr.length&lt;5) &#123; starArr.push(CLASS_OFF) &#125; return starArr &#125; &#125;&#125; 修改template模版 123&lt;div class="star" :class="'star-'+size"&gt; &lt;span class="star-item" v-for="(sc, index) in starClasses" :class="sc" :key="index"&gt;&lt;/span&gt;&lt;/div&gt; 在ShopList中import引入并注册使用 1&lt;Star :score="shop.rating" :size="24"&gt;&lt;/Star&gt; 使用svg显示页面加载中提示界面 目前首页的内容数据已经可以异步获取并显示，但在数据还未加载完成时，为了优化用户体验，应该给出页面加载中的提示界面。 首先将svg资源图片放入相应的Msite和ShopList的images文件夹里 然后修改模版的显示条件 123456&lt;!--Msite--&gt;&lt;div class="swiper-container" v-if="categorys.length"&gt; ...&lt;/div&gt;//没有数据的时候显示图片&lt;img src="./images/msite_back.svg" alt="back" v-else&gt; 12345678910&lt;!--ShopList--&gt;&lt;ul class="shop_list" v-if="shops.length"&gt; ...&lt;/ul&gt;&lt;!-- 循环显示6个svg图片 --&gt;&lt;ul v-else&gt; &lt;li v-for="item in 6" :key="item"&gt; &lt;img src="./images/shop_back.svg" alt="back"&gt; &lt;/li&gt;&lt;/ul&gt;]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex]]></title>
    <url>%2F2018%2F11%2F11%2Fvuex%2F</url>
    <content type="text"><![CDATA[vuex主要是状态管理，将数据统一管理(state) 模块 状态对象 stat 操作state 直接更新state的多个方法对象 mutations 操作mutations 间接更新state的多个方法对象 actions 包含多个基于state的getter计算属性的对象 getters 包含n个mutations的type名称常量 mutations-type 引入12import Vuex from 'vuex'Vue.use(Vuex) 使用共享的数据1const state=&#123;&#125;; 建立统一数据容器，唯一的容器123let store = new Vuex.Store(&#123; state&#125;) store(容器)注册到实例上，main.js里面，所有的组件都会有一个属性this.$store123new Vue(&#123;store,&#125;) 在组件中使用，加不加this都一样1&#123;&#123;this.$store.state.XXX&#125;&#125; state(单向数据流) 注意,在组件中最好不要直接更改共享的数据，共享的数据仅仅给组件染 mutation 通过mutation(管理员)来更改状态，可以在store里面设置成严格模式 strict：true，mutation不支持异步 告诉mutations需要更改,mutations相当于methods 123456789101112const mutations=&#123; add(state,count)&#123; //state是自动放入的，默认指的就是当前的state //操作state的属性 state.XXX +=count &#125;&#125;let store = new Vuex.Store(&#123;state，mutations,strict：true&#125;) 组件通过mutations提交,第一个参数是与mutatioons里面的方法绑定，第二个参数是自定义参数 1this.$store.commit(&apos;add&apos;,2) 插件打印日志1234import logger from &apos;vuex/dist/logger&apos;const store = new Vuex.store(&#123; plugins:[logger()]&#125;) 整理src下面创建一个store文件\index.js 123456789101112import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)import logger from 'vuex/dist/logger'const state=&#123;&#125;;import mutations from './mutations'export default new Vuex.Store(&#123; state， mutations, strict：true, plugins:[logger()] &#125;) store下面再创建一个mutations.js,里面存放mutations的相关123456789101112import * as Types from &apos;mutations.types.js&apos;const mutations = &#123; // [方法名](state,&#123;param&#125;)&#123;&#125;[Types.INCREMENT](state)&#123; state.count+=1&#125;,[Types.DECREMENT](state)&#123; state.count-=1&#125;&#125;;export default mutations; 宏(一般大写)store下面再创建一个mutations.types.js里面存放mutations的方法的名字，方便查找1234//增加export const INCREMENT=&apos;INCREMENT&apos;//减少export const DECREMENT=&apos;DECREMENT&apos; 组件中引入同mutations.js中引入一样,只不过不加中括号import * as Types from ‘mutations.types.js’ Types.INCREMENTTypes.DECREMENT getters相当于computed,如果数据多了可以模仿mutations的抽离12345678910const getters=&#123; val(state)&#123; state.count%2?&apos;奇数&apos;:&apos;偶数&apos; &#125;&#125;;export default new Vuex.store(&#123;getters,&#125;)//引用时&#123;&#123;$store.getters.val&#125;&#125; actions 和后台交互的异步action，后台数据也需要修改 Action 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 引入api以及mutation-types 异步获取数据 异步获取地址 发送异步ajax请求 提交一个mutation 12345678910 //async 方法名(&#123;commit,参数可选&#125;&#123;&#125;)// 异步获取地址 async getAddress (&#123;commit, state&#125;) &#123; // 从state状态中获取到经纬度用来设置reqAddress的参数（看接口文档） const geohash = state.latitude + &apos;,&apos; + state.longitude // 1. 发送异步ajax请求 const result = await reqAddress(geohash) // 2. 根据结果提交一个mutation commit(RECEIVE_ADDRESS, &#123;address: result.data&#125;) &#125;,]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[demo_vue-shop1]]></title>
    <url>%2F2018%2F10%2F30%2Fvue-shop1%2F</url>
    <content type="text"><![CDATA[vue实战项目外卖1技术栈前段数据处理/交互/组件化 vue全家桶/技术栈 vue vue-router vuex mint-ui vue-lazyload vue-scroller 滑动库 vue-scroller better-scroll swiper 日期处理 moment date-fns 前后台交互 mock数据：mockjs 接口测试：postman ajax请求 axios 模块化 ES6 babel 项目构建/工程化 webpack vue-cli css预编译器 stylus 后台 node express mongodb 前端路由一级路由 首页 /miste Miste.vue 搜索 /search Search.vue 订单 /order Order.vue 个人 /profile Profile.vue 登陆 /login Login.vue(不适用底部导航) 商家 /shop Shop.vue(不适用底部导航) 二级导航 商家商品 /goods ShopGoods.vue 商家评价 /ratings ShopRatings.vue 商家信息 /info ShopInfo.vue 搭建项目1vue init webpack my-project 结构分析 |– build : webpack 相关的配置文件夹(基本不需要修改) |– config: webpack 相关的配置文件夹(基本不需要修改) index.js: 指定的后台服务的端口号和静态资源文件夹 |– node_modules |– src : 源码文件夹 |– main.js: 应用入口 js （初始化vue实例并使用需要的插件 ） |– static: 静态资源文件夹 |– .babelrc: babel 的配置文件 |– .editorconfig: 通过编辑器的编码/格式进行一定的配置 |– .eslintignore: eslint 检查忽略的配置 |– .eslintrc.js: eslint 检查的配置 |– .gitignore: git 版本管理忽略的配置 |– index.html: 默认的主渲染页面文件 |– package.json: 应用包配置文件 |– README.md: 应用描述说明的 readme 文件 编码测试与打包发布项目 编码测试npm run dev访问: http://localhost:8080编码, 自动编译打包(HMR), 查看效果 打包发布npm run build//服务器管理npm install -g serveserve dist访问: http://localhost:5000 字体图标准备使用阿里的图标库http://www.iconfont.cn/home/index?spm=a313x.7781069.1998910419.2生成的资源:http://at.alicdn.com/t/font_726904_68moeoeirj3.css 项目目录 src api 与后台交互模板文件夹 common 通用资源文件夹，如fonts/img/stylus components 非路由组件文件夹 filters 自定义过滤器模块文件夹 mock 模拟数据接口文件夹 pages 路由组件文件夹 router 路由器文件夹 store vuex相关模块文件夹 App.vue 应用组件，根组件 main.js 入口js stylus安装1npm install stylus stylus-loader --save-dev 使用12&lt;style lang=&apos;stylus&apos; rel=&apos;stylesheet/stylus&apos;&gt;&lt;/style&gt; 在common文件夹下新建stylus文件夹 在stylus文件加下面新建mixins.styl文件 分析整个项目的 vue 组件结构 |– components————非路由组件文件夹 |– FooterGuide—————底部组件文件夹 |– FooterGuide.vue——–底部组件 vue |– pages—————–路由组件文件夹 |– Msite—————首页组件文件夹 |– Msite.vue——–首页组件 vue |– Search—————-搜索组件文件夹 |– Search.vue———搜索组件 vue |– Order————–订单组件文件夹 |– Order.vue——-订单组件 vue |– Profile————–个人组件文件夹 |– Profile.vue——-个人组件 vue |– App.vue—————应用根组件 vue |– main.js—————应用入口 js 页面底部的FooterGuide组件只是用来放pages里的组件的容器，所以它不是路由组件 页面最上面的标题栏在我们的项目中属于路由组件的组成部分（与中间内容部分在一起） 但每个路由组件中都有最顶部的组件且相似度很高，所以可以将其抽取成为一个单独的组件 编写网页样式重置在项目主目录下的static文件夹内新建css文件夹 在css文件夹内新建重置样式文件reset.css 在index.html 中引入 1&lt;link rel="stylesheet" href="/static/css/reset.css"&gt; 移动端 meta 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no&quot;&gt; Fastclick 当用户一次点击屏幕之后，浏览器并不能立刻判断用户是要进行双击缩放，还是想要进行单击操作。因此，iOS Safari 就等待 300 毫秒，以判断用户是否再次点击了屏幕。 于是，300 毫秒延迟就这么诞生了。 安装fastclick库 解决点击响应延时 0.3s 问题 1npm install fastclick --save 在main.js中引入，并绑定到body 12import FastClick from 'fastclick'FastClick.attach(document.body); 路由引入组件普通引入1import Msite from '../pages/Msite/Msite.vue' 动态引入1&#123;path:'/msite',component:()=&gt; import('.../pages/Msite/Msite.vue')&#125; 在App.vue里使用router-view引入底部导航FooterFuide，映射成标签，渲染到页面上1234567891011121314//1.import FooterGuide from './components/FooterGuide/FooterGuide.vue'//2export default &#123; name: 'App', templates:&#123;FooterGuide&#125;&#125;//3&lt;template&gt; &lt;div id="app"&gt; &lt;router-view&gt; &lt;/router-view&gt; &lt;FooterGuide&gt;&lt;/FooterGuide&gt; &lt;/div&gt;&lt;/template&gt; FooterGuide.vueHeaderTop.vue因为基本每个组件的头部样式都类似，只有内容有区别，所以把它抽离出来。页面分析 中间有一个固定的标题栏，只是用在不同的路由组件中显示的内容不同 标题栏两侧可能有搜索框之类的部分（Msite）也可能没有 此组件为非路由组件的公用组件（所以在Components文件夹内）实现 标题栏两侧是否有其他部分，要用到slot插槽进行组件间通信 slot 通信是标签, 而不是单纯的数据 中间标题栏接收的文本可以用props 代码：123456789&lt;template&gt; &lt;header class=&quot;header&quot;&gt; &lt;slot name=&quot;left&quot;&gt;&lt;/slot&gt; &lt;span class=&quot;header_title&quot;&gt; &lt;span class=&quot;header_title_text ellipsis&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/span&gt; &lt;/span&gt; &lt;slot name=&quot;right&quot;&gt;&lt;/slot&gt; &lt;/header&gt;&lt;/template&gt; props 传递数据 父组件传值 1&lt;HeaderTop title="四川农业大学(雅安市雨城区)"&gt;&lt;/HeaderTop&gt; 子组件接收 123props:&#123; title:String &#125; 插槽 传递标签插槽用于显示父组件使用子组件时，中间内容的显示命名插槽 子组件插槽命名 1&lt;slot name=&quot;left&quot;&gt;&lt;/slot&gt; 父组件匹配插槽 1&lt;span slot=&quot;left&quot;&gt; Msite.vueSwiper 轮播文档: Swiper官方文档安装1npm install --save swiper 引入12import Swiper from &apos;swiper&apos;import &apos;swiper/dist/css/swiper.min.css&apos; ShopList.vue抽离出一个组件 Login.vue 利用@click=&quot;$router.back()&quot;实现点击页面的箭头返回上一级路由/Profile的功能 已确定底部的四个路由组件需要显示Footer部分 而Login组件为一级路由组件，且不需要显示底部的FooterGuide导航组件 所以为路由组件添加meta元数据来标识是否显示Footer,v-show=&quot;$route.meta.showFooter&quot;·来判断是否显示 123456&#123; path: '/msite', component: Msite, meta: &#123; showFooter: true &#125; 后台应用 整个项目为前后端分离的项目：mintshop-client 与 mintshop-server 后台应用负责处理前台应用提交的请求, 并给前台应用返回 json 数据 前台应用负责展现数据, 与用户交互, 与后台应用交互数据库 确保启动 mongodb 服务 进入mintshop-server文件夹，启动服务器应用: npm start 封装ajax请求函数新建两个文件api/ajax.jsapi/index.js 为了实现统一向后端发送请求数据，所以需要封装一个ajax请求函数 引入axios,axios返回的是一个promise对象1import axios from 'axios' 之前调用请求函数，返回的是response,现在想实现请求函数之后直接返回response.data 12345678910111213141516171819202122232425262728293031323334353637/** * 向外部暴漏一个函数 ajax * @param &#123;*&#125; url 请求路径，默认为空 * @param &#123;*&#125; data 请求参数，默认为空对象 * @param &#123;*&#125; type 请求方法，默认为GET */export default function ajax (url = '', data = &#123;&#125;, type = 'GET') &#123; // 返回值 Promise对象 （异步返回的数据是response.data，而不是response） return new Promise(function (resolve, reject) &#123; // （利用axios）异步执行ajax请求 let promise // 这个内部的promise用来保存axios的返回值(promise对象) if (type === 'GET') &#123; // 准备 url query 参数数据 let dataStr = '' // 数据拼接字符串，将data连接到url Object.keys(data).forEach(key =&gt; &#123; dataStr += key + '=' + data[key] + '&amp;' &#125;) if (dataStr !== '') &#123; dataStr = dataStr.substring(0, dataStr.lastIndexOf('&amp;')) url = url + '?' + dataStr &#125; // 发送 get 请求 promise = axios.get(url) &#125; else &#123; // 发送 post 请求 promise = axios.post(url, data) &#125; promise.then(response =&gt; &#123; // 成功回调resolve() resolve(response.data) &#125;) .catch(error =&gt; &#123; // 失败回调reject() reject(error) &#125;) &#125;)&#125; 封装接口请求函数 有了发送请求数据的ajax函数，还需要封装一些与后台交互的接口函数 根据接口文档来定义接口请求函数 这个接口函数返回的仍然是promise 在路径里面的是路径参数，通过第二个参数传过去的query参数]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reset.css]]></title>
    <url>%2F2018%2F10%2F29%2Freset-css%2F</url>
    <content type="text"><![CDATA[浏览器的样式重置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** * Eric Meyer&apos;s Reset CSS v2.0 (http://meyerweb.com/eric/tools/css/reset/) * http://cssreset.com */html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,b, u, i, center,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td,article, aside, canvas, details, embed,figure, figcaption, footer, header,menu, nav, output, ruby, section, summary,time, mark, audio, video, input &#123; margin: 0; padding: 0; border: 0; font-size: 100%; font-weight: normal; vertical-align: baseline;&#125;/* HTML5 display-role reset for older browsers */article, aside, details, figcaption, figure,footer, header, menu, nav, section &#123; display: block;&#125;body &#123; line-height: 1;&#125;blockquote, q &#123; quotes: none;&#125;blockquote:before, blockquote:after,q:before, q:after &#123; content: none;&#125;table &#123; border-collapse: collapse; border-spacing: 0;&#125;/* custom */a &#123; color: #7e8c8d; text-decoration: none; -webkit-backface-visibility: hidden;&#125;li &#123; list-style: none;&#125;::-webkit-scrollbar &#123; width: 5px; height: 5px;&#125;::-webkit-scrollbar-track-piece &#123; background-color: rgba(0, 0, 0, 0.2); -webkit-border-radius: 6px;&#125;::-webkit-scrollbar-thumb:vertical &#123; height: 5px; background-color: rgba(125, 125, 125, 0.7); -webkit-border-radius: 6px;&#125;::-webkit-scrollbar-thumb:horizontal &#123; width: 5px; background-color: rgba(125, 125, 125, 0.7); -webkit-border-radius: 6px;&#125;html, body &#123; width: 100%; height: 100%;&#125;body &#123; -webkit-text-size-adjust: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0);&#125;/*显示省略号*/.ellipsis&#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stylus]]></title>
    <url>%2F2018%2F10%2F29%2Fstylus%2F</url>
    <content type="text"><![CDATA[stylus学习笔记 冒号可选，分号可选，逗号可选，括号可选 缩进与空格很重要 12body color white 父级引用 &amp; 1234567891011121314textareainput color #A7A7A7 &amp;:hover color #000//等于textarea, input &#123; color: #a7a7a7; &#125; textarea:hover, input:hover &#123; color: #000; &#125; 变量 属性查找 @ 12345678#logo position: absolute top: 50% left: 50% width: 150px height: 80px margin-left: -(@width / 2) margin-top: -(@height / 2) 运算符 范围 .. 包含界限 …包含开头不包含结尾 存在操作符in 实例检查 is a 条件赋值：?= := 变量定义：is defined 混合书写 方法]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[summary_js]]></title>
    <url>%2F2018%2F10%2F28%2Fsummary_js%2F</url>
    <content type="text"><![CDATA[enter回车 持续更新 在修改项目的过程中，学习到了关于表单enter键提交是否可以触发 如果type是submit，一个文本或者多个文本都会提交 如果是button，仅一个文本的时候提交 type为image的按钮，等同于type为submit的效果 用button时，fx和IE有不同的表现。radio和checkbox在FX下也会触发提交表单，在IE下不会]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[demo_vue-book]]></title>
    <url>%2F2018%2F10%2F27%2Fvue-book%2F</url>
    <content type="text"><![CDATA[vue-book 接下来会学习vuex，在学习一门预处理语言，之后用我学过的所有东西做一个练习的项目vue学习之后，用vue-cli做的一个练习。这是学习vue的过程中走通了一遍流程，但还有很多功能没有实现 上拉下拉刷新 图片的懒加载 打包之后如何上线 vuex的学习 如何连接数据库等 github:https://github.com/biubiuins/vue-book 安装依赖 npm install vue npm install -g webpack npm install -g vue-cli npm install less less-loader axios vuex bootstrap 目录 build 打包后的脚本文件 src 源码文件 mock后台代码，模拟数据 src/api 代表的是所有的接口,获取数据给前端调用 src/base 基础组件 src/components 页面组件实现路由根据页面划分了5个页面组件 首页 Home.vue 列表 List.vue 收藏 Collect.vue 添加 Add.vue 详情 Detail.vue 配置路由，配置路由映射表并new个实例,挂载在根组件上，router-view显示在App.vuerouter/index.js Vue.use()是用来安装Vue插件123import Vue from 'vue'import Router from 'vue-router'Vue.use(Router); 这里用了模板，将会另外写一篇，关于前端的模板与node的 导航base/Tab.vuescoped 表示是当前组件的样式，并不是全局的1&lt;style scoped lang=&quot;less&quot;&gt; less预处理语言，学习之后会写一篇博客 点击导航之后会通过to跳转页面，并且样式改变这里需要注意/home 确切激活，仅仅这个路径有效。router-link-exact-active/home /home/a 都可以。router-link-active123&lt;router-link to=&quot;/add&quot;&gt;&lt;i class=&quot;iconfont icon-add&quot;&gt;&lt;/i&gt;&lt;span&gt;添加&lt;/span&gt;&lt;/router-link&gt; 基础组件Tab挂载在App.vue上（导航很多页面都需要），并在App.vue上写全局的样式，清除默认样式。新学习到的清除输入框和按钮的默认样式1input，button&#123;appearance:none;&#125; App.vue的组件中有name: &#39;App&#39;，这里name: &#39;app&#39; 相当于一个全局 ID。可以不写，写了可以提供更好的调试信息。页面渲染也是在App.vue中实现的 图标http://www.iconfont.cn/home/index?spm=a313x.7781069.1998910419.2图标打包好了之后在index.html中引入\iconfont是必须类名表明是个icon，后面根据页面选择1&lt;i class=&quot;iconfont icon-shouye&quot;&gt;&lt;/i&gt;&lt;span&gt;首页&lt;/span&gt; 头部base/Mheader.vue头部的标题不是全部一样的，并且比如首页是没有返回键的，所以这里用到的插槽和父组件给子组件传值这里用Home.vue-Mheader.vue为例 在父组件上挂载Mheader.vue &lt;Mheader.vue&gt;首页，首页需要显示出来，需要在子组件Mheader.vue中放个匿名插槽接收 父组件需要传递一个值告诉子组件是否显示返回键。子组件接收back，不需要验证的时候用数组，需要验证的时候用对象。 12345 &lt;i class=&quot;iconfont icon-fanhui&quot; v-if=&quot;back&quot;&gt;&lt;/i&gt;...props:&#123; back:&#123;type:Boolean,default:false&#125; &#125; 点击返回键，返回上一个操作 1this.$router.go(-1); 扩展一下,back也可以返回。this.$router.back() 强制跳转页面，在后面追加，点返回还可以回去。this.$router.push(‘/XXX’) 路由替换，将原来的替换。this.$router.replace(‘/XXX’)轮播图base/Swiper.vue安装依赖1npm install vue-awesome-swiper --save-dev 在main.js中引入vue-awesome-swiper插件123import VueAwesomeSwiper from &apos;vue-awesome-swiper&apos;import &apos;swiper/dist/css/swiper.css&apos;Vue.use(VueAwesomeSwiper) 后台获取图片信息mock/sliders.js 存放图片连接mock/server.js 配置服务器url.parse()可以将一个完整的URL地址，分为很多部分，常用的有：host、port、pathname、path、query。12345678let sliders = require(&apos;./sliders&apos;)http.createServer((req,res)=&gt;&#123;let&#123;pathname,query&#125; = url.parse(req.url); if (pathname === &apos;/sliders&apos;)&#123; res.setHeader(&apos;Content-Type&apos;,&apos;application/json;charset=utf-8&apos;) res.end(JSON.stringify(sliders)) &#125;&#125; 但是当前段发起ajax请求的时候，是8080端口请求3000端口的数据，所以有跨域的问题，这里需要在服务器中加入跨域头12345res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,Content-Length, Authorization, Accept,X-Requested-With&quot;);res.setHeader(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;);res.setHeader(&quot;X-Powered-By&quot;,&apos; 3.2.1&apos;)if(req.method==&quot;OPTIONS&quot;) return res.end();/*让options请求快速返回*/ 轮播图的api12345678import axios from 'axios';//设置基本的默认请求路径axios.defaults.baseURL ='http://localhost:3000';//获取轮播图数据export let getSliders=()=&gt;&#123; //因为设置了了efaults.baseURL，所以它请求的路径其实是http://localhost:3000/sliders,返回的是一个promise对象 return axios.get('/sliders')&#125; axios 笔记待整理 前端获取数据获取的数据父子组件传值，传给子组件，子组件渲染出图片如果给接收到的data一个新的名字 slider {data：slider}1234async created()&#123; let &#123;data&#125; = await getSliders().then() this.sliders=data&#125;, async/await 已整理 热门图书/删除图书 先写服务端，确保数据能正常返回 增加api方法，实现调取数据的功能 在哪个组件中应用这个api，如果是一个基础组件需要这些数据，在使用这个组件的父级中调用这个方法，将数据传递给基础组件 详情页面如果用对象作为to的属性，并且使用了参数，必须给路由起个名字，通过名字跳转router/index.js1&#123;path:&apos;/detail/:bid&apos;,component:Detail,name:&apos;detail&apos;&#125; component/List.vue需要配置路径参数，点击哪个li跳转哪个详情这是跳转用到router-link，把之前的li改为router-link， params是路径参数 循环组件，需要加上key router-link是a标签，这里需要的是li，在taf里面修改1&lt;router-link v-for=&quot;(book,index) in books&quot; :to=&quot;&#123;name:&apos;detail&apos;,params:&#123;bid:book.bookId&#125;&#125;&quot; :key=&quot;index&quot; tag=&quot;li&quot; &gt; 因为点击li跳转，删除按钮也在li里面，所以这个应该阻止删除按钮冒泡1&lt;button @click.stop=&quot;remove(book.bookId)&quot;&gt;删除&lt;/button&gt; component/Detail.vue12//获取通过传过来的参数$route.params.XXX 获取当前id的图书信息渲染到界面。 问题一: 当修改的时候，价格原本是数字，修改之后会变成字符串,加上数字的修饰符 1&lt;input type=&quot;text&quot; v-model.number=&quot;book.bookPrice&quot; id=&quot;bookPrice&quot;&gt; 问题二修改url的时候，页面没有刷新，因为模板已经渲染出来了，不会在走created办法。所以，需要监控url的变化，路径参数发生变化，通过监控参数的变化来发送ajax 123456watch:&#123;//路径参数发生变化，通过监控参数的变化来发送ajax$route()&#123; this.getData() ; &#125;&#125; 问题三如果没有找到对应id的书，那返回的是空对象，如果是空，需要跳转回列表页Object.keys()，该方法返回一个数组,里面是对象的所有属性。如果是空对象那么返回一个空数组。 1Object.keys(this.book).length&gt;0?void 0:this.$ruoter.push(&apos;/List&apos;) 处理一下url,server.js查询book的条件变一下 1if (!isNaN(id)) 数据改变之后，需要用put更新数据PUT：参数1：url:/book?id=3参数2：请求体发送server.js获取put/post请求体中的数据使用这两个事件就可以获取来自服务器端的响应内容。 data，数据传递时触发， end，没有更多数据提供时触发1234567let str = &quot;&quot;; res.on(&apos;data&apos;,(chunk)=&gt;&#123; str += chunk; &#125;); res.on(&apos;end&apos;,()=&gt;&#123; console.log(str); &#125;); 添加页面同详情页面 优化与其他功能loading轮播图和热门图书是分开获取的，这里改成一起获取api/index1return axios.all([getSliders(),getHotBook()]) 数据返回的是一个数组，里面是两个promise对象。 新建base/Loading.vue,挂载在Home.vuehttps://www.cnblogs.com/lhb25/p/loading-spinners-animated-with-css3.html 实现页面缓存分页面缓存，路由元信息。在配置路由映射的时候有meta(备注)属性,这条对象可以通过this.$route获取1&#123;path:&apos;/home&apos;,component:Home,meta:&#123;keepAlive:true&#125;&#125;, 修改APP.vue,写两个router-view，一个用于，显示缓存的，一个用于显示一般的123456789&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; &lt;Tab&gt;&lt;/Tab&gt; &lt;/div&gt;&lt;/template&gt; 实现路由动画给router-view外面包裹一个标签,注意点：一个只能包裹一个标签写css样式12345678910.fadeIn-enter&#123; opacity: 0;&#125;.fadeIn-enter-active&#123; transition:all 0.3s;&#125;.fadeIn-leave-active&#123; transition: all 0.3s; opacity: 0;&#125; 下拉加载更多打包上线history路由在路由中改变mode:’history’ 标题router/indexmeta:{title:XXX}main.js全局钩子，在进入路由之前每一次都会执行此方法。有拦截的作用router.beforeEach(function(from.to,next){ document.title = to.meta.title; next();});]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP 简括]]></title>
    <url>%2F2018%2F10%2F24%2Fhttp%E7%AE%80%E6%8B%AC%2F</url>
    <content type="text"><![CDATA[http一次完整的HTTP请求需要7个步骤 建立TCP连接 Web浏览器向Web服务器发送请求命令 一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。 Web浏览器发送请求头信息 浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。 Web服务器应答 客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码 Web服务器发送应答头信息 正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。 Web服务器向浏览器发送数据 Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。 Web服务器关闭TCP连接一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：Connection:keep-alive，TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。 http协议的特点①通信流程：断开式（无状态） 断开式：http协议每次响应完成后，会断开与客户端的连接 无状态：由于服务器断开了之前的连接，就无法知晓连接间的关系。 ②内容格式：消息头和消息体 HTTP请求方法 OPTIONS返回服务器针对特定资源所支持的HTML请求方法 或web服务器发送*测试服务器功能。询问支持的方法。 HEAD 类似get，但只返回响应头。 常用于查看某个页面的状态 GET 获取资源 GET方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。 使用GET方法时，请求参数和对应的值附加在URL后面，利用一个问号（“?”）代表URL的结尾与请求参数的开始 POST 向指定资源提交数据进行处理请求（提交表单、上传文件） 将请求参数封装在HTTP请求数据中，以名称/值的形式出现 PUT向指定资源位置上上传其最新内容 DELETE请求服务器删除 TRACE 回显服务器收到的请求，用于测试和诊断 CONNECTHTTP/1.1协议中能够将连接改为管道方式的代理服务器 get 和 post区别get请求无消息体，只能携带少量数据post请求有消息体，可以携带大量数据get请求将数据放在url地址中post请求将数据放在消息体中 HTTP状态码 1xx：相关信息 2xx：操作成功 3xx：重定向 4xx：客户端错误 5xx：服务器错误GET安全且幂等获取表示变更时获取表示（缓存） 200（OK） - 表示已在响应中发出 204（无内容） - 资源有空表示 301（Moved Permanently） - 资源的URI已被更新 303（See Other） - 其他（如，负载均衡） 304（not modified）- 资源未更改（缓存） 400 （bad request）- 指代坏请求（如，参数错误） 404 （not found）- 资源不存在 406 （not acceptable）- 服务端不支持所需表示 500 （internal server error）- 通用错误响应 503 （Service Unavailable）- 服务端当前无法处理请求POST创建子资源部分更新资源 如果没有被修改，则不过更新资源（乐观锁） 200（OK）- 如果现有资源已被更改 201（created）- 如果新资源被创建 202（accepted）- 已接受处理请求但尚未完成（异步处理） 301（Moved Permanently）- 资源的URI被更新 303（See Other）- 其他（如，负载均衡） 400（bad request）- 指代坏请求 404 （not found）- 资源不存在 406 （not acceptable）- 服务端不支持所需表示 409 （conflict）- 通用冲突 412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突） 415 （unsupported media type）- 接受到的表示不受支持 500 （internal server error）- 通用错误响应 503 （Service Unavailable）- 服务当前无法处理请求 PUT通过替换的方式更新资源 200 （OK）- 如果已存在资源被更改 201 （created）- 如果新资源被创建 301（Moved Permanently）- 资源的URI已更改 303 （See Other）- 其他（如，负载均衡） 400 （bad request）- 指代坏请求 404 （not found）- 资源不存在 406 （not acceptable）- 服务端不支持所需表示 409 （conflict）- 通用冲突 412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突） 415 （unsupported media type）- 接受到的表示不受支持 500 （internal server error）- 通用错误响应 503 （Service Unavailable）- 服务当前无法处理请求 DELETE不安全但幂等删除资源 200 （OK）- 资源已被删除 301 （Moved Permanently）- 资源的URI已更改 303 （See Other）- 其他，如负载均衡 400 （bad request）- 指代坏请求 404 （not found）- 资源不存在 409 （conflict）- 通用冲突 500 （internal server error）- 通用错误响应 503 （Service Unavailable）- 服务端当前无法处理请求 http的请求部分 请求方法（GET/POST）、URI、协议/版本 请求头(Request Header) 空行 请求正文 https://blog.csdn.net/chen1403876161/article/details/51546653| 请求头 | 说明 | 实列|| —— | —— |——|| Accept |这个头信息指定浏览器或其他客户端可以处理的 MIME 类型|Accept:application/json, text/plain, /||Accept-Encoding|浏览器能够进行解码的数据编码方式|Accept-Encoding:gzip, deflate, br||Accept-Language| 这个头信息指定客户端的首选语言，在这种情况下，Servlet 会产生多种语言的结果|Accept-Language:zh-CN,zh;q=0.8||Accept-Charset|浏览器可接受的字符集|||Connection|这个头信息指示客户端是否可以处理持久 HTTP 连接。持久连接允许客户端或其他浏览器通过单个请求来检索多个文件|Connection:keep-alive||Host|指定请求资源的Intenet主机和端口号（服务器，向谁请求）|Host:localhost:3000||Referer|这个头信息指示所指向的 Web 页的 URL。例如，如果您在网页 1，点击一个链接到网页 2，当浏览器请求网页 2 时，网页 1 的 URL 就会包含在 Referer 头信息中。||User-Agent|这个头信息识别发出请求的浏览器或其他客户端，并可以向不同类型的浏览器返回不同的内容。||Content-Length|这个头信息只适用于 POST 请求，并给出 POST 数据的大小（以字节为单位）。|Content-Length:60||Content-Type|用于post请求|Content-Type：application/json;charset=UTF-8||Authorization|授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中|| HTTP content-type application/x-www-form-urlencoded 这应该是最常见的 POST 提交数据的方式了。中默认的encType，form表单数据被编码为 key/value格式发送到服务器（表单默认的提交数据的格式） multipart/form-data 需要在表单中进行文件上传时，就需要使用该格式 application/jsonJSON数据格式 HTTP响应头信息 状态行 响应头(Response Header) 空行 响应正文 其他一般的在上面的连接中可以看到，这里整理了平时遇到的跨域问题 跨域的响应头123456res.setHeader("Access-Control-Allow-Origin", "*"); res.setHeader("Access-Control-Allow-Headers", "Content-Type,Content-Length, Authorization, Accept,X-Requested-With"); res.setHeader("Access-Control-Allow-Methods","PUT,POST,GET,DELETE,OPTIONS"); res.setHeader("X-Powered-By",' 3.2.1') res.setHeader("Content-Type", "application/json;charset=utf-8"); if(req.method=="OPTIONS") return res.end();/*让options请求快速返回*/]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise/axios/async/await]]></title>
    <url>%2F2018%2F10%2F22%2Fpromise-axios%2F</url>
    <content type="text"><![CDATA[axios/promise/async/await这里整理axios时，把牵扯到的基础promise学习了，更深一步的以后再深入。axios跨域的问题等之后再整理，这篇仅仅是一些简单的基础 promise用法：可以将异步操作以同步操作的流程表达处理，避免层层嵌套回调函数promise对象有三种状态，对象的状态不受外界影响 pending 进行中 fulfilled 已成功 rejected 已失败 并且一旦状态改变，就不会再变，任何时候都可以得到这个结果,这时称为resolved(已定型)。状态改变只有两种可能 pending到fulfilled pending到rejected Promise实例生成以后，then方法有2个参数，第一个函数接收resolved状态的执行，第二个参数接收reject状态的执行。且then的执行结果也会返回一个Promise对象。12345promise.then(function(value) &#123; // success,resolved时调用&#125;, function(error) &#123; // failure rejected时调用&#125;); axios基于promise用于浏览器和node.js的http客户端 特点 支持浏览器和node.js 支持promise 能拦截请求和响应 能转换请求和响应数据 能取消请求 自动转换JSON数据 浏览器端支持防止CSRF(跨站请求伪造) 使用1import axios from &apos;axios&apos;; 请求get请求123axios.get(url).then(res=&gt;&#123;&#125;).catch(error=&gt;&#123;&#125;) .then访问成功12345//打印的是object对象//data，status，statusText，headers，comfigXXXX.then(res=&gt;&#123;console.log(res)&#125;)//打印的是promise对象XXXX.then() .catch捕获错误 传参1axios.get(url,&#123;params:&#123;&#125;&#125;) 常用配置全局默认路径1axios.defaults.baseURL =&apos;http://localhost:3000&apos;; 拦截器在请求或者返回被then或者catch处理之前对它们进行拦截12345678910111213141516// 添加请求拦截器axios.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 return config; &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;);// 添加响应拦截器axios.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 return response; &#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error); &#125;); async/awaitES7 提出的async 函数，终于让 JavaScript 对于异步操作有了终极解决方案。async作为一个关键字放到函数前面，表示函数是一个异步函数，异步函数也就意味着该函数的执行不会阻塞后面代码的执行。 内置执行器。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，调用方式跟普通函数的调用一样 返回值是 Promise。async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用 写异步代码就像写同步代码一样了，不用不断的回调了。 语法async 函数返回一个 Promise 对象async 函数内部 return 返回的值是个Promise 对象。当调用该函数时，内部会调用Promise.solve() 方法把它转化成一个promise 对象作为返回12345678async function timeout() &#123; return &apos;hello world&apos;&#125;console.log(timeout());console.log(&apos;虽然在后面，但是我先执行&apos;);//输出//Promise&#123;&#125;//虽然在后面，但是我先执行 async 函数内部 return 返回的值。会成为 then 方法回调函数的参数。只有当 async 函数内部的异步操作都执行完，才会执行 then 方法的回调。12345678910 async function timeout() &#123; return &apos;hello world&apos; &#125; timeout().then(result =&gt; &#123; console.log(result); &#125;) console.log(&apos;虽然在后面，但是我先执行&apos;); //输出 //虽然在后面，但是我先执行 //hello world 如果 async 函数内部抛出异常，则会导致返回的 Promise 对象状态变为 reject 状态。抛出的错误而会被 catch 方法回调函数接收到。12345async function e()&#123; throw new Error(&apos;error&apos;);&#125;e().then(v =&gt; console.log(v)).catch( e =&gt; console.log(e)); await await 后面放置的就是返回promise对象的一个表达式。await 表示等一下，先执行await后面的代码，等后面的promise对象执行完毕，再继续像下执行。 正常情况下，await 命令后面跟着的是 Promise，如果不是的话，也会被转换成一个 立即 resolve 的 Promise1234 async function f() &#123; return await 1&#125;;f().then( (v) =&gt; console.log(v)) // 1]]></content>
      <tags>
        <tag>vue</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[demo_todoList]]></title>
    <url>%2F2018%2F10%2F13%2Ftodolist%2F</url>
    <content type="text"><![CDATA[demo_todoList 功能 将数据循坏到页面 敲回车时添加新数据（需要添加isSelected属性） 删除功能 计算当前没有被选中的，选中的有删除样式 双击任务可以修改任务,已经完成的不可以 自定义输入框聚焦 回车或者失去焦点的时候修改成功 计算属性 根据hash展示todolist 数据永久化，hash单页刷新 收获watch 监控todos的变化,当变化时更新数据 watch:todos(){} 只能监控一层的数据变化（删减） watch:todos:handler(){},deep:true 深度监控directivess 自定义指令，指令是操作的dom XXX(el,bindings){} 名字需要和v-XXX的相同，el指代的是当前的dom，bindings参数 github: https://github.com/biubiuins/demo_todolist]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2F2018%2F10%2F12%2Fgit%2F</url>
    <content type="text"><![CDATA[git的基本操作 初次配置第一步需要配置用户名和邮箱地址，因为git为每一次提交记录名字和邮箱地址12$ git config --global user.name &apos;runoob&apos;$ git config --global user.email test@runoob.com ssh key 生成一对shh key（id_rsa私钥，id_rsa.pub公钥） 1ssh-keygen 注：在主目录下生成的密钥在 /c/Users/用户名/.ssh/id_rsa 里 查看公钥内容（需在.ssh目录下执行） 1cat id_rsa.pub 复制密钥内容添加到 github 上 使用ssh协议上传文件到仓库 12345git initgit add .git commit -m &quot; &quot;git remote add origin git@github.com:...git push -u origin master 注：若在创建新仓库时有readme.md 文件会上传失败 新建版本库 git里面先进入新建库的文件夹下 初始化库初始化目录，目录下回出现一个.git的目录，该目录包含了资源的所有元数据 12git initgit init 目录名 添加文件到暂存区将当前目录下几个文件纳入版本控制，需要先用git add 命令告诉git开始对这些文件进行跟踪 123git add .//添加当前项目的所有文件git add README //添加名为README的文件git add -A 所有修改的内容添加到缓存区 增加到版本库中使用 git add 命令将想要快照的内容写入缓存区， 而执行 git commit -m将缓存区内容添加到仓库中。 12git commit -a 跳过这一步git commit -m&quot;版本留言描述&quot; 连接远程仓库（现在GitHub上面新建仓库） 1git remote add origin 仓库地址 讲本地仓库推送到远程库上 12git pushgit push -u origin master //首次执行，说明上传到仓库的master分支上 问题：![rejected] master -&gt; master (fetch first)解决办法：1. 先执行git pull.然后再执行git push –force origin master替换原先的 git push -u origin master 从远程库克隆先把别人的fork进自己的库里面 克隆仓库到指定目录 123//自己在本地进入需要克隆进的文件夹下执行下面第一条指令git clone 仓库地址git clone 仓库地址 本地目录 add commit push 删除文件 本地删除文件 123//或者直接在文件管理器中把没用的文件删了//需要git进入文件夹下$ rm test.txt Git知道你删除了文件，这个时候只是本地删除了文件，而版本库里面还有文件，所以可以恢复文件 1$ git checkout -- test.txt 远程库删除文件 1git rm test.txt 记得还需要commit 我的石墨文档：https://shimo.im/docs/2Eg0gszciPEQBPxG/]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[express学习笔记]]></title>
    <url>%2F2018%2F10%2F12%2Fexpress%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[express 学习笔记 搭建简单服务器1234567891011//express() 是一个由 express 模块导出的入口（top-level）函数let express = require('express');//创建一个express应用实例名applet app = express();// 设置端口号：3000//process.env.PORT：读取当前目录下环境变量port的值let port = process.env.PORT || 3000 ;//在端口号上开启服务app.listen(port,function () &#123; console.log("server start"+port);&#125;); app.listen(port, [hostname], [backlog], [callback])类似于node中的http.Server.listen()1234567// 设置端口号：3000//process.env.PORT：读取当前目录下环境变量port的值let port = process.env.PORT || 3000 ;//在端口号上开启服务app.listen(port,function () &#123; console.log("server start"+port);&#125;); 服务器启动时候，默认端口3000：node app.js设置端口8080：PORT=8080 node app.js app.set(name,value)123456789//设置 views 文件夹为存放视图文件的目录, 即存放模板文件的地方,__dirname 为全局变量,存储当前正在执行的脚本所在的目录。app.set('views', path.join(__dirname, 'views'));app.set("views","./views");//设置使用的模板引擎app.set('view engine', 'ejs’)app.set("view engine","jade")npm install --save express-art-template//设置art模板引擎，后缀为artapp.engine('art', require('express-art-template')); app.get(name)返回name的value值1234567891011//实例一app.get('title');// =&gt; undefinedapp.set('title', 'My Site');app.get('title');// =&gt; "My Site"//实例二app.set('port', process.env.PORT || 3000);var server = app.listen(app.get('port'), function() &#123; console.log("server start"+port);&#125;); app.get(path, callback [, callback …])app.all(path, callback [, callback …])这种方法就像标准的app.METHOD()方法, 除了它匹配所有HTTP动词。访问path路径的所有方法执行的回调函数.12345//* 表示匹配所有的路径app.all('*', function(req, res)&#123; res.end(req.method + 'user')&#125;//一般放在最后面防止前面的被覆盖 请求与响应123456//Express 应用使用回调函数的参数： request 和 response 对象来处理请求和响应的数据。app.get('/', function(req, res)&#123; res.send('hello world'); res.status(404).send(错误请求)//访问这个路径是设定状态码为404 //通过res.send（）接口向客户端发送hello world，send只能响应一次，意思是只能出现一个send&#125;) res.send（）只能出现一次如果要响应多次，用node原生的write和end，但是如果只有write会处于一个挂起状态1234app.get('/', function(req, res)&#123; res.write('hello world'); res.write('hello world');&#125;) res.send有结束响应的作用 res.write没有结束响应的作用，需要res.end结束中间件挂起response下表中响应对象（res）的方法向客户端返回响应，终结请求响应的循环。如果在路由句柄中一个方法也不调用，来自客户端的请求会一直挂起。res.render()12345//设置 views 文件夹为存放视图文件的目录, 即存放模板文件的地方,__dirname 为全局变量,存储当前正在执行的脚本所在的目录。app.set('views', path.join(__dirname, 'views'));app.set("views","./views");//第一个是渲染的views文件夹下面的index，第二个是传递的数据,注意需要设置模板引擎res.render("index",&#123;&#125;,function()&#123;&#125;) res.setHeader()12//Content-Type的作用 该实体头的作用是让服务器告诉浏览器它发送的数据属于什么文件类型。res.setHeader(&quot;Content-Type&quot;,&apos;text/html;charset=utf-8&apos;) res.redirect()调用redirect()方法后，其后的代码都不会被执行。而使用redirect()设置的状态码不是301或302也不会发生跳转12res.redirect([status,] path)//重定义到path所指定的URL，重定向时可以同时指定HTTP状态码，不指定状态码默认为302 res.location()location()方法本质上是调用了ServerResponse对象的setHeader()方法，但并没有设置状态码。使用location()设置头信息，而不设置状态码或状态码不是301或302，并不会发生重定向1res.location(path) request req.query处理 get 请求，获取 get 请求参数12345678910// GET /search?q=tobi+ferretreq.query.q// =&gt; "tobi ferret"// GET /shoes?order=desc&amp;shoe[color]=blue&amp;shoe[type]=conversereq.query.order// =&gt; "desc"req.query.shoe.color// =&gt; "blue"req.query.shoe.type// =&gt; "converse" req.body处理 post 请求，获取 post 请求体12345678// POST user[name]=tobi&amp;user[email]=tobi@learnboost.comreq.body.user.name// =&gt; "tobi"req.body.user.email// =&gt; "tobi@learnboost.com"// POST &#123; "name": "tobi" &#125;req.body.name// =&gt; "tobi" req.params处理 /:xxx 形式的 get 或 post 请求，获取请求参数123456// GET /user/tjreq.params.name// =&gt; "tj"// GET /file/javascripts/jquery.jsreq.params[0]// =&gt; "javascripts/jquery.js" req.param(name)处理 get 和 post 请求，但查找优先级由高到低为 req.params→req.body→req.query123456789// ?name=tobireq.param('name')// =&gt; "tobi"// POST name=tobireq.param('name')// =&gt; "tobi"// /user/tobi for /user/:namereq.param('name')// =&gt; "tobi" 中间件用于客户端与服务器路由匹配之前的中间操作，正常中间件放在路由上面，中间件通过next()往下走。 app.use（[path],function）利用express托管静态文件node.js不能通过目录来引入文件，而express可以，public为静态目录1234//设置public文件夹为存放静态文件的目录。let path=require("path")//ex4里面唯一的内置中间件app.use(express.static(path.join(__dirname, 'public'))); 一个中间件处理器，请求来了，让那些中间件先处理一遍 没有挂载路径的中间件，应用的每个请求都会执行该中间件 挂载至 /path 的中间件，任何指向 /path 的请求都会执行它1234567app.use(&quot;/name&quot;,function(req,res,next)&#123;res.setHeader(&quot;Content-Type&quot;,&apos;text/html;charset=utf-8&apos;)next();&#125;)app.get(&quot;/name/n&quot;,function(req,res)&#123;&#125;)//也可以匹配到，在执行get请求/name/n时先执行上面的中间件 错误中间件错误处理中间件和其他中间件定义类似，只是必须要使用 4 个参数(err, req, res, next)。即使不需要 next 对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。遇见错误之后直接执行错误中间件。错误处理中间件应当在在其他 app.use() 和路由调用之后才能加载，一般放在路由的最底部，比如：123456789var bodyParser = require('body-parser');var methodOverride = require('method-override');app.use(bodyParser());app.use(methodOverride());app.use(function(err, req, res, next) &#123; // 业务逻辑 console.error(err.stack); res.status(500).send('Something broke!');&#125;); 应用生成器12345678910//安装$ npm install express-generator -g//view=XXX 使用引擎名字 myapp项目名称$ express --view=pug myapp//安装所有依赖$ cd myapp$ npm install//启动myapp项目$ set DEBUG=myapp:* &amp; npm start 我的石墨文档链接：https://shimo.im/docs/TXeewzaE8Jsdgn0I/练习的简易聊天室连接：https://github.com/biubiuins/demo_chat]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[project_email]]></title>
    <url>%2F2018%2F10%2F11%2Fproject-email%2F</url>
    <content type="text"><![CDATA[邮件收发项目大二上开始学html，css，js之后做的暑假做的前端页面，很感谢老师可以给一个练手的机会，在做的过程中发现了很多问题，以及项目完成之后的收获。&nbsp;&nbsp;&nbsp;&nbsp;虽然是一个很简单的界面，但是之前学习的时候不太仔细，也没有demo练习，还是做的磕磕绊绊，还好最后做的差不多了。TAT&nbsp;&nbsp;针对过程中的问题，阅读了很多关于语法规范的文章，js，jq又重新学习了一遍（练习了很多），大二下期基本在学习之中度过的。希望在以后的项目中可以有所进步，彻底的实现前后端分离！！！ 项目相关 完成时间：大二上期寒假 2018-3月左右 bootsrap框架，layui框架，jquery 项目不足 语法不规范，复用性不强，后面修改过一次感觉修改起来很复杂 js不熟练，项目之后大二下期又重新开始学习了一遍js，并写了总结 (https://biubiuins.github.io/2018/10/11/summary-2018-9/) 技术不足，没有实现前后端分离 主要功能 首页 http://mailroom.sicau.edu.cn/email/public/ bootsrap做了响应式，用了ajax请求数据 管理页面（需要登陆仅提供图片） 实现全选与批量删除 点击已取之后，重新获取数据（保证筛选邮件之后点击已取仍显示的是筛选之后的邮件) 邮件类型默认显示上一次选择的类型，可输入筛选的下拉框 超级管理员界面实现了原生js模态框，并做了根据屏幕居中]]></content>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[summary-2018.9]]></title>
    <url>%2F2018%2F10%2F11%2Fsummary-2018-9%2F</url>
    <content type="text"><![CDATA[summary-2018-9 这是在学会搭建博客之后的第一篇博客，以前学习的时候也有记笔记，所以把之前学习笔记上面整理的常见的功能、封装以及遇到的问题写出来，这篇仅限于js，jq。现在正在学习vue，希望在过段时间，自己也能写出关于vue学习的总结。在此之前还需要了解markdown的语法TAT 原来的笔记记录在石墨文档，https://shimo.im/docs/c8YrJy4obNICaWiS/ ID处理1234/** 获取id */function $(id) &#123; return typeof id === "string" ? document.getElementById(id) : null;&#125; 动画匀速动画1234567891011121314151617181920//元素，目标，步数function constant(obj, target, speed) &#123; // 1. 清除定时器 clearInterval(obj.timer); //2.判断方向 //如果现在的距离小于目标值,则往右，否则向左 let dir =obj.offsetLeft&lt;target?speed:-speed; //3. 设置定时器 obj.timer = setInterval(function () &#123; obj.style.left = obj.offsetLeft + dir + "px"; //若超出目标值或者不到目标值 //最后相减的值取绝对值后，总是小于步数的 //Math.abs(dir)||speed if(Math.abs(target-obj.offsetLeft)&lt;Math.abs(dir))&#123; clearInterval(obj.timer); //根据目标值板正 obj.style.left =target+'px'; &#125; &#125;, 20);&#125; 缓动动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function buffer(obj, json, fn) &#123; // 1. 清除定时器 clearInterval(obj.timer); var begin = 0, end = 0; // 2. 设置定时器 obj.timer = setInterval(function () &#123; // 2.0 旗帜, 决定动画是否结束 let flag = true; // 2.1 遍历 for(let k in json)&#123; // 2.2.-1 求出起始值 和 结束值 if(k === 'opacity')&#123; // 透明度 begin = parseInt( parseFloat(getCssAttr(obj, k)) * 100); end = parseInt(parseFloat(json[k]) * 100); &#125;else if(k === 'scrollTop')&#123; // 滚动到头部 begin = obj.scrollTop; end = parseInt(json[k]); &#125;else &#123; // 正常情况 begin = parseInt(getCssAttr(obj, k)); end = parseInt(json[k]); &#125; // 2.2.0 求出步长 //步长公式 let step = (end - begin) * 0.2; step = step &gt;=0 ? Math.ceil(step) : Math.floor(step); // 2.2.1 计算起始位置 if(k === 'opacity')&#123; obj.style.opacity = (begin + step) / 100; obj.style.filter = 'alpha(opacity=' + (begin + end)+')'; // 针对IE &#125;else if(k === 'scrollTop')&#123; obj.scrollTop = begin + step; &#125;else if(k === 'zIndex')&#123; obj.style[k] = json[k]; &#125;else &#123; obj.style[k] = begin + step + 'px'; &#125; // 2.2.2 判断 if(begin !== end)&#123; flag = false; &#125; &#125; // 3.0 结束动画 if(flag)&#123; clearInterval(obj.timer); // 开启动画组中的下一组动画 if(fn)&#123; // 判断有没有这个函数 fn(); &#125; &#125; &#125;, 60);&#125; js获取CSS利用 [] 访问属性 元素.style[“属性”];1234567891011121314//这种语法的好处就是可以动态的传递参数作为属性//只能获取行类标签 var h = 'height'; box.style[h] = 300 + 'px';//获取外部css或页内的cssfunction getStyleAttr(obj, attr) &#123; if(obj.currentStyle)&#123; // IE 和 opera return obj.currentStyle[attr]; &#125;else &#123; //window.getComputedStyle("元素", "伪类") （ 注意：两个选项是必须的，没有伪类 用 null 替代 ） //也可以点选，但是为了传递参数作为属性 return window.getComputedStyle(obj, null)[attr]; &#125;&#125; 定时器 在定时器事件前，先设置接收定时器的变量指向null 在定时器事件里，先要清除定时器再设置定时器，先清除是防止定时器累加轮播第一种这种不适合多图1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162function slider (sliderid,olStyleClassName,imgWidth,speed,second) &#123; //高级排他 //lastIndex 选中的小圆点样式 currentIndex 小圆点索引 picIndex 图片索引 let lastIndex=0,currentIndex=0,picIndex=0; // 1. 获取需要的标签 let ul=$(sliderid).children[0]; let ol=$(sliderid).children[1]; let list=ul.children; let olList= ol.children; // 2.克隆最后一个li标签 ul.appendChild(list[0].cloneNode(true)); // 3.动态创建小圆点 for(let i= 0;i&lt;list.length-1;i++)&#123; let li =document.createElement("li"); ol.appendChild(li); &#125; //4.第一个小圆点选中 olList[0].className=olStyleClassName; //5.监听每个li的进入事件 for(let i= 0;i&lt;olList.length;i++)&#123; //5.1 每一个li绑定自己的事件 olList[i].onmouseover=function () &#123; //先清除之前的选中状态，在把当前选中的索引给lastIndex lastIndex=currentIndex; olList[lastIndex].className=""; this.className=olStyleClassName; lastIndex=i; //5.2图片动起来 constant(ul,-(i * imgWidth),speed); currentIndex=picIndex=i; &#125;; &#125; //6.定时器 let timer; timer = setInterval(autoPlay, second); // 7. 清除和设置定时器 $(sliderid).onmouseover = function () &#123; clearInterval(timer); &#125;; $(sliderid).onmouseout = function () &#123; timer = setInterval(autoPlay, second); &#125;; function autoPlay()&#123; picIndex++; currentIndex++; //如果图片到了最后一张 if (picIndex &gt; list.length - 1) &#123; ul.style.left = 0; //从第二张图片开始 picIndex = 1; &#125; constant(ul, -(picIndex * imgWidth), speed); //小原点的选中 if (currentIndex &gt; olList.length - 1) &#123; currentIndex = 0; &#125; for (let i=0;i&lt;olList.length;i++)&#123; olList[i].className=""; &#125; olList[currentIndex].className=olStyleClassName; &#125;&#125; 第二种两个图片宽度的位置，第一个位置显示（当前），第二位置隐藏 第三种改变透明度，循环一遍让所有的opacity动画为0，然后当前为opacity动画为1，索引++、12345678910111213141516171819function opacityAutoPlay(ulid,speed) &#123; // 1. 获取所有的li标签 var lis = $(ulid).getElementsByTagName("li"); var index = 0; // 2. 开始定时器 setInterval(function () &#123; // 2.1 改变透明度 for(let i=0; i&lt;lis.length; i++)&#123; let singerLi = lis[i]; buffer(singerLi, &#123;opacity: 0&#125;, null); &#125; buffer(lis[index], &#123;opacity: 1&#125;, null); // 2.2 索引++ index++; if(index === lis.length)&#123; index = 0; &#125; &#125;, speed);&#125; 瀑布流 父盒子居中 Math.floor(屏幕宽度/子盒子宽度)=cols 子盒子的宽度*cols=父盒子的宽度 margin:0 auto; 子盒子定位第一行不变，其他子盒子接在第一行最矮的盒子的后面（反复） 拿到所有盒子的高度。把第一行的盒子的高度放在一个数组里面（i&lt;cols,heightArr[]) 在剩下的盒子里面(i&gt;=cols),找出第一行最矮的盒子的高度（Math.min(…heightArr)||Math.min.apply(this.height)）2.1 找出最矮盒子的索引(遍历heightArr[],找出和第二步盒子高度一样的i返回)2.2 剩下盒子定位（left=第2.1步的索引*子盒子宽度，top=最矮的盒子高度）2.3 更新最矮盒子的高度 （heightArr[最矮盒子的高度]+=当前盒子的高度） 滚动加载图片 监听窗口的滚动，滚动到你需要的位置加载 js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 window.onload = function () &#123; // 1. 实现瀑布流布局 waterFull("main", "box"); // 2. 动态加载图片 window.onscroll = function () &#123; if(checkWillLoadImage())&#123; // 2.1 造数据 var dataArr = [ &#123;"src": "img04.jpg"&#125;, &#123;"src": "img06.jpg"&#125;, &#123;"src": "img08.jpg"&#125;, &#123;"src": "img09.jpg"&#125;, &#123;"src": "img10.jpg"&#125;, &#123;"src": "img12.jpg"&#125;, &#123;"src": "img14.jpg"&#125;, &#123;"src": "img16.jpg"&#125;, &#123;"src": "img18.jpg"&#125; ]; // 2.2 创建元素 for(var i=0; i&lt;dataArr.length; i++)&#123; var newBox = document.createElement("div"); newBox.className = "box"; $("main").appendChild(newBox); var newPic = document.createElement("div"); newPic.className = "pic"; newBox.appendChild(newPic); var newImg = document.createElement("img"); newImg.src = "images/" + dataArr[i].src; newPic.appendChild(newImg); &#125; // 2.3 重新布局 waterFull("main", "box"); &#125; &#125;&#125;;/** * 实现瀑布流布局 */function waterFull(parent, child) &#123; // 1. 父盒子居中 // 1.1 获取所有的盒子 var allBox = $(parent).getElementsByClassName(child); // 1.2 获取子盒子的宽度 var boxWidth = allBox[0].offsetWidth; // 1.3 获取屏幕的宽度 var screenW = document.documentElement.clientWidth; // 1.4 求出列数 var cols = parseInt(screenW / boxWidth); // 1.5 父盒子居中 $(parent).style.width = cols * boxWidth + 'px'; $(parent).style.margin = "0 // 2. 子盒子的定位 // 2.1 定义高度数组 var heightArr = [], boxHeight = 0, minBoxHeight = 0, minBoxIndex = 0; // 2.2 遍历子盒子 for (var i = 0; i &lt; allBox.length; i++) &#123; // 2.2.1 求出每一个子盒子的高度 boxHeight = allBox[i].offsetHeight; // 2.2.2 取出第一行盒子的高度放入高度数组 if (i &lt; cols) &#123; // 第一行 heightArr.push(boxHeight); &#125; else &#123; // 剩余行 // 1. 取出最矮的盒子高度 // minBoxHeight = _.min(heightArr); minBoxHeight=Math.min(...heightArr); // 2. 求出最矮盒子对应的索引 minBoxIndex = getMinBoxIndex(heightArr, minBoxHeight); // 3. 子盒子定位 allBox[i].style.position = "absolute"; allBox[i].style.left = minBoxIndex * boxWidth + 'px'; allBox[i].style.top = minBoxHeight + 'px'; // 4. 更新数组中的高度 heightArr[minBoxIndex] += boxHeight; &#125; &#125; console.log(heightArr, minBoxHeight, minBoxIndex);&#125;/** * 获取数组中最矮盒子高度的索引 * @param arr * @param val * @returns &#123;number&#125; */function getMinBoxIndex(arr, val) &#123; for(var i=0; i&lt;arr.length; i++)&#123; if(arr[i] === val)&#123; return i; &#125; &#125;&#125;/** * 判断是否具备加载图片的条件 */function checkWillLoadImage() &#123; // 1. 获取最后一个盒子 var allBox = document.getElementsByClassName("box"); var lastBox = allBox[allBox.length - 1]; // 2. 求出最后一个盒子自身高度的一半 + offsetTop var lastBoxDis = lastBox.offsetHeight * 0.5 + lastBox.offsetTop; // 3. 求出屏幕的高度 var screenW = document.body.clientHeight || document.documentElement.clientHeight; // 4. 求出页面偏离浏览器的高度 var scrollTop = scroll().top; return lastBoxDis &lt;= screenW + scrollTop;&#125; jq123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//当页面加载完毕$(window).on('load',function () &#123;//1.实现瀑布流布局waterFall();//2.滚动加载$(window).on('scroll',function () &#123;//判断是否加载if (checkWillLoad())&#123;////创造假数据var data = &#123;'dataImg':[&#123;'img':'23.jpg'&#125;,&#123;'img':'24.jpg'&#125;,&#123;'img':'25.jpg'&#125;,&#123;'img':'26.jpg'&#125;,&#123;'img':'27.jpg'&#125;,&#123;'img':'28.jpg'&#125;]&#125;;//遍历创建盒子$.each(data.dataImg,function (index,value)&#123;//创建一个div标签 设置它的类为'box' 添加到'main'里面去var newBox = $('&lt;div&gt;').addClass('box').appendTo($('#main')); var newPic = $('&lt;div&gt;').addClass('pic').appendTo($(newBox)); //创建img 取出遍历的对象value的img属性对应的值 $('&lt;img&gt;').attr('src','images/'+$(value).attr('img')).appendTo($(newPic)); &#125;) //1.实现瀑布流布局 waterFall(); &#125; &#125;); &#125;); //实现瀑布流布局 function waterFall () &#123; //拿到所有的盒子 var allBox = $('#main &gt; .box'); //取出其中一个盒子的宽度 var boxWidth = $(allBox).eq(0).outerWidth(); //取出屏幕的高度 var screenWidth = $(window).width(); //求出列数 //取整函数取整 var cols = Math.floor( screenWidth/boxWidth); //父标签居中 $('#main').css(&#123; 'width':cols * boxWidth + 'px', 'margin':'0 auto' &#125;); //对子盒子定位 var heightArr = []; //遍历 $.each(allBox,function (index,value) &#123; //取出单独盒子的高度 var boxHeight = $(value).outerHeight(); //判断是否第一行 if(index &lt; cols) &#123; heightArr[index] = boxHeight; &#125; else //剩余的盒子要瀑布流布局 &#123; //求出最矮的盒子高度 var minBoxHeight = Math.min.apply(null,heightArr); //取出最矮高度对应的索引 封装了js的这个方法 var minBoxIndex = $.inArray(minBoxHeight,heightArr); //定位 $(value).css(&#123; 'position':'absolute', 'top':minBoxHeight + 'px', 'left':minBoxIndex * boxWidth + 'px' &#125;); //更新数组中最矮的高度 heightArr[minBoxIndex] += boxHeight; &#125; &#125;) &#125; //判断是否符合加载条件 function checkWillLoad() &#123; //直接取出最后一个盒子 var lastBox = $('#main &gt; div').last(); //取出最后一个盒子高度的一半 + 头部偏离的位置 var lastBoxDis = $(lastBox).outerHeight() + $(lastBox).offset().top; //求出浏览器的高度 var clientHeight = $(window).height(); //求出页面偏离浏览器高度 var scrollTopHeight = $(window).scrollTop(); //比较返回 return lastBoxDis &lt;= clientHeight + scrollTopHeight; &#125; margin:0 auto 块级元素 给定要居中的块级元素的宽度。 所有元素也可以通过对父元素设置text-align：center；的方式来实现居中。而对于块元素来说，对要居中的元素自身进行设置text-align:center也能实现居中 margin:0 auto;可以使盒子居中，text-align:center;可以使文本居中，节流onresize举列子窗口大小一变化就执行，太过灵敏，所以需要阻止1234567891011121314151617//使用定时器var timer = null;window.onresize = function () &#123; clearTimeout(timer); // 节流 timer = setTimeout(function () &#123; waterFull('main', 'box'); &#125;, 200);&#125;//封装之后的function throttle(fn, delay) &#123; var timer = null; return function () &#123; clearTimeout(timer); timer = setTimeout(fn, delay); &#125;&#125; apply/call这个面试中常考到，现在只做初步了解(https://www.cnblogs.com/gaowx/p/4837687.html ) 改变函数的this指向 apply可以改变传递给函数参数的形式Date123456789101112131415161718192021222324function newDate()&#123; //声明日期对象，里面可以设置参数表示其他时间 let date =new Date(); //获取时间里面的年 date.getFullYear() //月0-11 date.getMonth()+1 //日1-31 date.getDate() //获取星期0-6 data.Day //设置某一天 date.setDate（day） //时0-23 date.getHours() //分0-59 date.getMinutes() //秒0-59 date.getSeconds() //获取毫秒 date.getMilliSeconds() //时间戳 date.getTime()&#125; ms转化时间 cookie封装封装成插件，引入该文件后，$.addCookie(key,value,day,path,domain)来引用1234567891011121314151617181920212223242526272829303132333435363738394041;(function ($,window) &#123; $.extend(&#123; addCookie: function addCookie(key,value,day,path,domain)&#123; //1.处理默认保存的路径 var index=window.location.pathname.lastIndexOf('/'); var currentPath=window.location.pathname.slice(0,index) path=path||currentPath //2.处理默认domain domain=domain||document.domain //3.处理默认的过期时间 if(!day)&#123; document.cookie=key+"="+value+";path="+path+";domain="+domain+';' &#125; else&#123; var date =new Date(); date.setDate(date.getDate()+day) document.cookie=key+"="+value+";expires="+date.toGMTString()+";path="+path+";domain="+domain+';' &#125; &#125;, getCookie: function getCookie(key)&#123; var res=document.cookie.split(';') for(var i=0;i&lt;res.length;i++)&#123; //把key和value切割 var temp=res[i].split('=') //前后可能有空格，把空格删除 if(temp[0].trim()===key)&#123; return temp[1] &#125; &#125; &#125;, delCookie: function delCookie(key, path) &#123; //默认情况下只能删除默认路径中保存的cookie，如果要删除指定路径保存的cookie，要把路径值传出去 //设置过期时间为-1 addCookie(key, getCookie(key), -1, path) &#125; &#125;);&#125;)(jQuery,window); 动态添加的元素绑定事件 delegate 123$(&apos;ul&apos;).delegate(&apos;li&apos;,&apos;click&apos;,function()&#123;//操作的还是li&#125;) onclick事件在动态添加数据的时候，就给元素绑定onclick事件 on（）常用 12345//把动态添加的元素写在on里面，如果调用的函数是外部定义好的，则在调用的时候不加（）//不然会跳过点击事件直接执行函数$(&quot;父元素或祖辈元素&quot;).on(&quot;click&quot;,&quot;动态添加的元素&quot;,function()&#123;$(this).css(&quot;border&quot;,&quot;5px solid #000&quot;);&#125; 其他清除默认样式http://yui.yahooapis.com/3.18.1/build/cssreset/cssreset-min.css 下拉框1234567891011121314151617181920//拿到select对象：var myselect=document.getElementById("select");//拿到选中项的索引var index=myselect.selectedIndex ; // selectedIndex代表的是你所选中项的index//拿到选中项options的value：myselect.options[index].value;//拿到选中项options的text：myselect.options[index].text;//拿到选中项的其他值，比如这里的url： myselect.options[index].getAttribute('url');//jqueryvar options=$(“#select option:selected”); //获取选中的项alert(options.val()); //拿到选中项的值alert(options.text()); //拿到选中项的文本alert(options.attr('url')); //拿到选中项的url值//设置//设置value为pxx的项选中$(".selector").val("pxx")//设置text为pxx的项选中$(".selector").find("option[text='pxx']").attr("selected",true) H5 datalistdatalist 只是列表赋值取值还是通过input.样式等都在input上操作https://www.zhangxinxu.com/wordpress/2013/03/html5-datalist-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8-%E5%8F%AF%E8%A1%8C%E6%80%A7/ 邮箱的自动补全HTML代码：123456789邮箱：&lt;input type=&quot;email&quot; id=&quot;email&quot; list=&quot;emailList&quot; name=&quot;off_autocomplete&quot; /&gt;&lt;datalist id=&quot;emailList&quot;&gt;//其中*为占位符，当文本框输入内容的时候，*替换成邮箱地址的前半部分，于是，动态邮件地址提示的效果就实现了 &lt;option value=&quot;*@qq.com&quot;&gt; &lt;option value=&quot;*@163.com&quot;&gt; &lt;option value=&quot;*@gmail.com&quot;&gt; &lt;option value=&quot;*@yahoo.com.cn&quot;&gt; &lt;option value=&quot;*@126.com&quot;&gt;&lt;/datalist&gt; JS代码：12345678910111213141516171819202122232425262728var eleList = document.getElementById("emailList") , eleMail = document.getElementById("email") , htmlListInit = '', arrEmailList = [];if (eleMail &amp;&amp; eleList &amp;&amp; (htmlListInit = eleList.innerHTML) !== '') &#123; // 得到类似["qq.com", "163.com", "gmail.com", ...]的数据 arrEmailList = [].slice.call(eleList.getElementsByTagName("option")).map(function(option) &#123; return option.value.replace("*@", ""); &#125;); eleMail.fnListReplace = function() &#123; var arrValue = this.value.trim().split("@"); // 修复FireFox浏览器下无限input问题 // 如果值不完全匹配某option值，执行动态替换 if (arrValue.length !== 2 || arrEmailList.indexOf(arrValue[1]) === -1) &#123; eleList.innerHTML = htmlListInit.replace(/\*/g, arrValue[0]); &#125; return this; &#125;; // 绑定输入事件侦听 eleMail.addEventListener("input", function() &#123; this.fnListReplace.call(this); &#125;, false); // 载入即匹配 eleMail.fnListReplace.call(eleMail).focus();&#125; else &#123; eleList = document.createElement("datalist"); eleList.innerHTML = '&lt;p class=sorry&gt;抱歉，当前浏览器不支持HTML5 datalist.&lt;/p&gt;'; eleMail.parentNode.appendChild(eleList);&#125; jquery.editable-select控件引入jquery.editable-select.cssjquery.editable-select.js调用方法123456789101112$('#editable-select').editableSelect(&#123; bg_iframe: true, //是否加iframe case_sensitive: false, items_then_scroll: 10 ,//设置下拉选项的数目 isFilter:false/true, //是否根据条件过滤下拉选项 onCreate:, //当输入时触发 onShow：, //当下拉时触发 onHide：, //当下拉框隐藏时触发 onSelect：, //当下拉框中的选项被选中时触发 effects:default/slide/fade， //动画效果 duration： //动画效果的时间&#125;);]]></content>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
</search>
